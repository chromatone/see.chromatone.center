import { useMousePressed as Ue, reactive as d, onMounted as ge, useMouseInElement as Je, watch as V, onBeforeUnmount as Fe, ref as P, ColorHash as K, gunAvatar as Ye, computed as g, ms as Q, refDebounced as Ee, slugify as ie, SEA as O, useStorage as _, buffer as Ze, Gun as ee, urlRegex as qe, Fuse as te, YAML as xe, markdown as We, lib as He, JSZip as Re, watchEffect as Z, exports as Xe, base32 as me, useNow as Ve, computedAsync as Qe, index_umd as Ce, browser as _e, useElementBounding as et, useClamp as tt, getArrow as nt, useCycleList as at, toReactive as ot, markRaw as st, createDrauu as rt, nextTick as it, useDebounceFn as ct } from "./vendor.es.js";
import { SEA as Sa, gunAvatar as ka, mountClass as ja, mountElement as Aa, ms as Pa, slugify as Oa } from "./vendor.es.js";
function ut(e = P(null)) {
  const { pressed: t } = Ue(), n = d({
    x: 0,
    y: 0,
    normX: 0,
    normY: 0,
    pressed: t,
    inside: !1
  });
  ge(() => {
    document.addEventListener("mousemove", a);
    const { isOutside: o } = Je(e);
    V(o, (s) => {
      n.inside = !s;
    });
  }), Fe(() => {
    document.removeEventListener("mousemove", a);
  });
  function a(o, s = e.value) {
    const r = s.closest("svg");
    if (!r)
      return;
    var c = r.createSVGPoint();
    c.x = o.clientX, c.y = o.clientY;
    let i = c.matrixTransform(r.getScreenCTM().inverse());
    n.x = i.x, n.y = i.y;
  }
  return {
    area: e,
    mouse: n
  };
}
const lt = {
  light: new K({
    saturation: [0.05, 0.08, 0.22],
    lightness: [0.85, 0.87, 0.9]
  }),
  pale: new K({
    saturation: [0.05, 0.42, 0.52],
    lightness: [0.75, 0.77, 0.9]
  }),
  regular: new K({
    saturation: [0.1, 0.5, 0.7],
    lightness: [0.3, 0.5, 0.7]
  }),
  deep: new K({
    saturation: [0.5, 0.6, 0.7],
    lightness: [0.5, 0.55, 0.6]
  }),
  dark: new K({
    saturation: [0.02, 0.5, 0.6],
    lightness: [0.18, 0.2, 0.5]
  })
};
function Ne(e = "deep") {
  return typeof e == "object" ? new K(e) : lt[e];
}
function Vt({
  pub: e,
  size: t = 200,
  light: n = 0.5,
  overlay: a = 0.5,
  draw: o = "squares",
  attachment: s = "fixed"
} = {}) {
  if (!!e)
    return {
      background: `linear-gradient(hsla(255,0%,${n * 100}%,${a}), hsla(255,0%,${n * 100}%,${a})), url(${Ye({
        pub: e,
        draw: o,
        reflect: !1,
        size: t
      })})`,
      backgroundSize: "cover, cover",
      backgroundAttachment: `${s},${s}`
    };
}
const ft = Ne("deep");
function dt(e = P(), { TIMEOUT: t = 1e4 } = {}) {
  const n = w();
  return e = P(e), { account: g(() => {
    const o = d({
      pub: e,
      color: g(() => e.value ? ft.hex(e.value) : "gray"),
      profile: {
        name: ""
      },
      pulse: 0,
      lastSeen: g(() => {
        let s = Date.now() - o.pulse;
        return s > t ? Q(s) : "online";
      }),
      blink: !1,
      db: n.user(e.value)
    });
    return n.user(e.value).get("pulse").on((s) => {
      o.blink = !o.blink, o.pulse = s;
    }).back().get("profile").map().on((s, r) => {
      o.profile[r] = s;
    }), o;
  }) };
}
function Qt() {
  const e = w(), { user: t } = x(), n = P("general"), a = d({
    general: {}
  }), o = e.user(f.pub).get("chat");
  o.map().on((l, m) => {
    var R;
    const [v, k] = m.split("@");
    a[v] = a[v] || {}, l ? a[v][k] = l : (R = a == null ? void 0 : a[v]) == null || delete R[k];
  });
  function s(l) {
    o.get(`${ie(l) || l}@${t.pub}`).put(!0, null, { opt: { cert: f.features.chat } });
  }
  const r = g(() => e.user(f.pub).get("chat/" + n.value)), c = g(() => {
    const l = d({});
    return r.value.map().on((m, v) => {
      const k = v.substring(0, 13), R = v.substring(14);
      l[v] = {
        timestamp: k,
        author: R,
        text: m
      };
    }), l;
  }), i = g(() => Object.values(c.value || {})), u = Ee(i), p = g(() => u.value.sort((l, m) => l.timestamp > m.timestamp ? 1 : -1));
  function h(l) {
    if (!l)
      return;
    let m = Date.now();
    r.value.get(`${m}@${t.pub}`).put(l, null, { opt: { cert: f.features.chat } });
  }
  return {
    send: h,
    addChat: s,
    currentChat: n,
    chats: a,
    messages: c,
    sorted: p
  };
}
function _t(e, { parse: t = !0 } = {}) {
  const n = w(), { user: a } = x(), o = d({}), s = P();
  n.user(e).get("epub").once((h) => s.value = h), n.user(e).get("chat").get(a.pub).map().once(function(h, l) {
    r(h, l, e, this);
  }), n.user().get("chat").get(e).map().once(function(h, l) {
    r(h, l, a.pub, this);
  });
  function r(h, l, m, v) {
    v.map().on(async (k, R) => {
      if (k && k.startsWith("SEA")) {
        const M = await O.secret(s.value, a.pair()), W = await O.work(M, l), D = await O.decrypt(k, W);
        if (!D || typeof D != "object")
          return;
        o[R] = {
          timestamp: D.timestamp,
          author: m,
          text: D.text
        };
      }
    });
  }
  async function c(h) {
    if (!h)
      return;
    const l = new Date(), m = {
      timestamp: l.getTime(),
      text: h
    }, v = l.toLocaleDateString("en-CA"), k = await O.secret(s.value, a.pair()), R = await O.work(k, v), M = await O.encrypt(m, R);
    n.user().get("chat").get(e).get(v).set(M);
  }
  const i = g(() => Object.values(o || {})), u = Ee(i), p = g(() => u.value.sort((h, l) => h.timestamp > l.timestamp ? 1 : -1));
  return {
    send: c,
    messages: o,
    sorted: p
  };
}
function en(e) {
  const t = w(), { user: n } = x(), a = d({}), o = P(!1);
  return t.user(e).get("epub").on((r) => o.value = r), t.user(e).get("chat").get(n.pub).map().map().on((r, c) => {
    r && !r.startsWith("SEA") || (a[c] = r);
  }), t.user().get("chat").get(e).map().map().on((r, c) => {
    r && !r.startsWith("SEA") || (a[c] = r);
  }), { count: g(() => Object.keys(a).length), available: o };
}
function tn() {
  const e = w(), { user: t } = x(), n = d({});
  return t.is && (e.user().get("chat").map().on((a, o) => {
    n[o] = a;
  }), e.user().get("mates").map().on(async (a, o) => {
    const s = await e.user(o).get("mates").get(t.pub), r = await e.user(o).get("epub");
    s && r && (n[o] = a);
  })), { list: n };
}
const Te = "https://etogun.glitch.me/gun", J = _("peer", Te), T = d({
  list: [],
  peer: J.value,
  host: new URL(J.value).hostname,
  status: "offline",
  started: 0,
  pulse: 0,
  lag: 0,
  diff: g(() => T.pulse - T.started),
  age: g(() => Q(T.diff)),
  delay: g(() => Date.now() - T.pulse),
  blink: !1
});
V(() => T.pulse, (e, t) => {
  T.blink = !T.blink, T.lag = e - t - 500;
});
function gt(e) {
  J.value = e, window.location.reload();
}
function mt() {
  J.value = Te, window.location.reload();
}
function nn() {
  const e = w();
  return T.pulse == 0 && e.get(T.host).map().on((t, n) => {
    T[n] = t;
  }), { relay: T, setPeer: gt, resetPeer: mt };
}
window.Buffer = Ze.Buffer;
window.setImmediate = setTimeout;
let S, ae;
function w(e = { localStorage: !1 }) {
  return S || (S = ee({ peers: [J.value], ...e })), S;
}
function pt(e = { localStorage: !1 }) {
  return ae || (ae = ee({ peers: [J.value], ...e })), ae;
}
var Ae, Pe;
const an = (Pe = (Ae = ee) == null ? void 0 : Ae.node) == null ? void 0 : Pe.soul;
var Oe, De;
const ht = (De = (Oe = ee) == null ? void 0 : Oe.text) == null ? void 0 : De.random, ce = d({}), ue = d({});
async function vt({
  source: e = "https://raw.githubusercontent.com/wiki/amark/gun/volunteer.dht.md"
} = {}) {
  let a = (await (await fetch(e)).text()).match(qe());
  return a.push(T.peer), a = Array.from(a), a.forEach((o) => {
    let s = new URL(o);
    if (s.pathname === "/gun" && s.pathname.indexOf("~~") === -1) {
      let r = performance.now();
      fetch(s.href, {
        method: "HEAD",
        mode: "cors",
        redirect: "follow",
        referrerPolicy: "no-referrer"
      }).then((c) => {
        let i = performance.now();
        c.ok ? ce[s.hostname] = {
          host: s.hostname,
          ping: (i - r).toFixed(),
          url: s.href
        } : ue[s.hostname] = c;
      }).catch((c) => {
        ue[s.hostname] = c;
      });
    }
  }), ce;
}
function on() {
  return { relays: ce, errors: ue, loadRelays: vt };
}
function sn(e) {
  return e.length == 44 && e.charAt(43) == "=";
}
async function rn(e, t, n) {
  const a = await O.secret(t.epub, n);
  return await O.encrypt(e, a);
}
async function cn(e, t, n) {
  const a = await O.secret(t.epub, n);
  return await O.decrypt(e, a);
}
async function q(e) {
  return await O.work(e, null, null, { name: "SHA-256" });
}
async function X(e) {
  let t = typeof e == "string" ? e : JSON.stringify(e), n = await q(t);
  return { hashed: t, hash: n };
}
async function un(e, t) {
  return await O.work(e, t, null, { name: "SHA-1", encode: "hex" });
}
function wt(e) {
  if (!e)
    return;
  const t = /[\+=\/]/g;
  return e.replace(t, bt);
}
function bt(e) {
  switch (e) {
    case "+":
      return "-";
    case "=":
      return ".";
    case "/":
      return "_";
  }
}
function ln(e) {
  if (!e)
    return;
  const t = /[\._\-]/g;
  return e.replace(t, yt);
}
function yt(e) {
  switch (e) {
    case "-":
      return "+";
    case ".":
      return "=";
    case "_":
      return "/";
  }
}
function fn(e, t) {
  if (e) {
    if (Object.prototype.toString.call(e) === "[object Object]")
      return e;
  } else
    return t || {};
  try {
    return JSON.parse(e);
  } catch {
    return t || {};
  }
}
async function Me({
  pair: e,
  tag: t = "word",
  dot: n = "",
  users: a = "*",
  personal: o = !1
} = {}) {
  let s = { "*": `${t}` };
  n && (s["."] = n), o && (s["+"] = "*");
  try {
    return await O.certify(a, s, e);
  } catch (r) {
    console.log("cert error: ", r);
  }
}
window.issueCert = Me;
async function ve({ pair: e, list: t = [] } = {}) {
  const n = {};
  for (let a of t)
    n[a.tag] = await Me({ ...a, pair: e });
  return n;
}
const G = d({
  word: null,
  def: null
}), le = _("dict-lang", "en");
V(G, () => {
  G.word && G.def && St(G);
});
function dn() {
  const e = w();
  x();
  const t = P(""), n = g(() => $e(t.value));
  async function a() {
    const i = await q(n.value);
    e.get("dict").get("#word").get(i).put(n.value), G.word = i, t.value = "";
  }
  const o = d({});
  e.user(f.pub).get("dict").map().on(async (i, u) => {
    if (!i)
      return;
    let p = u.slice(0, 44), h = u.slice(45, 89), l = await e.get("dict").get("#def").get(h).then();
    if (!!l) {
      try {
        l = JSON.parse(l);
      } catch (m) {
        console.log(m, l);
        return;
      }
      (l == null ? void 0 : l.lang) == le.value && (o[p] = o[p] || await e.get("dict").get("#word").get(p).then());
    }
  });
  const s = d({});
  e.get("dict").get("#word").map().once((i, u) => {
    i.includes(" ") || (s[u] = i);
  });
  const r = g(() => {
    let i = Object.entries(s).map((u) => ({ text: u[1], hash: u[0] }));
    return new te(i, {
      keys: ["text"],
      includeScore: !0
    });
  }), c = g(() => r.value.search(t.value));
  return { input: t, found: c, words: s, linked: o, word: n, addWord: a };
}
function gn(e) {
  const t = w(), n = P();
  return t.get("dict").get("#word").get(e).once((a, o) => {
    n.value = $e(a);
  }), { word: n };
}
function mn() {
  const e = w(), t = d({
    text: "",
    lang: le,
    part: "noun"
  });
  async function n() {
    const { hash: c, hashed: i } = await X(t);
    e.get("dict").get("#def").get(c).put(i), G.def = c, t.text = "", t.part = null;
  }
  const a = d({});
  e.user(f.pub).get("dict").map().on(async (c, i) => {
    if (!c)
      return;
    let u = i.slice(45, 89), p = await e.get("dict").get("#def").get(u).then();
    if (!!p)
      try {
        if (p = JSON.parse(p), (p == null ? void 0 : p.lang) != le.value)
          return;
        a[u] = a[u] || p;
      } catch (h) {
        console.log(h, p);
      }
  });
  const o = d({});
  e.get("dict").get("#def").map().once((c, i) => {
    o[i] = JSON.parse(c);
  });
  const s = g(() => {
    let c = [];
    for (let i in o)
      c.push({ hash: i, ...o[i] });
    return new te(c, {
      keys: ["text"],
      includeScore: !0
    });
  }), r = g(() => s.value.search(t.text));
  return { def: t, addDef: n, defs: o, found: r, linked: a };
}
async function St({ word: e, def: t } = {}) {
  var s;
  const n = w(), { user: a } = x();
  let o = await n.user(f.pub).get("dict").get(`${e}:${t}@${a.pub}`).then();
  n.user(f.pub).get("dict").get(`${e}:${t}@${a.pub}`).put(!o, null, { opt: { cert: (s = f.features) == null ? void 0 : s.dict } }), G.word = null, G.def = null;
}
function pn(e) {
  const t = w(), n = d({});
  return t.user(f.pub).get("dict").map().on((a, o) => {
    var p;
    if (o.indexOf(e) == -1)
      return;
    const { from: r, to: c, author: i } = pe(o);
    let u = r == e ? c : r;
    n[u] = n[u] || {}, a ? n[u][i] = a : ((p = n == null ? void 0 : n[u]) == null || delete p[i], Object.keys(n == null ? void 0 : n[u]).length == 0 && (n == null || delete n[u]));
  }), n;
}
function hn(e) {
  const t = w(), n = d({});
  return t.user(f.pub).get("dict").map().on((a, o) => {
    var i;
    const { from: s, to: r, author: c } = pe(o);
    c == e && (n[s] = n[s] || {}, a ? n[s][r] = a : ((i = n == null ? void 0 : n[s]) == null || delete i[r], Object.keys(n[s]).length == 0 && (n == null || delete n[s])));
  }), n;
}
function vn() {
  const e = w(), t = d({});
  return e.user(f.pub).get("dict").map().once(async (n, a) => {
    const { from: o, to: s, author: r } = pe(a);
    t[r] = t[r] || {}, t[r][o] = t[r][o] || {}, t[r][o][s] = n;
  }), t;
}
function wn() {
  const e = w(), t = d({});
  return e.user(f.pub).get("dict").map().once(async (n, a) => {
    let o = a.slice(45, 89), s = await e.get("dict").get("#def").get(o).then();
    if (!!s) {
      try {
        s = JSON.parse(s);
      } catch (r) {
        console.log(s, r);
      }
      !(s != null && s.lang) || (t[s == null ? void 0 : s.lang] = t[s == null ? void 0 : s.lang] || 0, t[s == null ? void 0 : s.lang]++);
    }
  }), t;
}
function pe(e) {
  return {
    from: e.slice(0, 44),
    to: e.slice(45, 89),
    author: e.slice(-87)
  };
}
function bn({ text: e, stress: t } = {}) {
  const n = "&#x301;";
  if (!e)
    return;
  let a = e.slice(0, t + 1) + n + e.slice(t + 1);
  return a[0].toUpperCase() + a.slice(1);
}
function $e(e) {
  if (!e)
    return "";
  let t = e.toLowerCase().matchAll(/\p{L}/gu, "");
  return Array.from(t).map((n) => n[0]).join("");
}
const yn = {
  noun: {
    en: "noun",
    ru: "\u0441\u0443\u0449",
    underline: "solid"
  },
  adj: {
    en: "adjective",
    ru: "\u043F\u0440\u0438\u043B",
    underline: "wavy"
  },
  verb: {
    en: "verb",
    ru: "\u0433\u043B\u0430\u0433",
    underline: "double"
  },
  adv: {
    en: "adverb",
    ru: "\u043D\u0430\u0440\u0435\u0447",
    underline: "dotted"
  }
}, Sn = [
  {
    code: "aa",
    name: "Afar",
    native: "Afar"
  },
  {
    code: "ab",
    name: "Abkhazian",
    native: "\u0410\u04A7\u0441\u0443\u0430"
  },
  {
    code: "af",
    name: "Afrikaans",
    native: "Afrikaans"
  },
  {
    code: "ak",
    name: "Akan",
    native: "Akana"
  },
  {
    code: "am",
    name: "Amharic",
    native: "\u12A0\u121B\u122D\u129B"
  },
  {
    code: "an",
    name: "Aragonese",
    native: "Aragon\xE9s"
  },
  {
    code: "ar",
    name: "Arabic",
    native: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629",
    rtl: 1
  },
  {
    code: "as",
    name: "Assamese",
    native: "\u0985\u09B8\u09AE\u09C0\u09AF\u09BC\u09BE"
  },
  {
    code: "av",
    name: "Avar",
    native: "\u0410\u0432\u0430\u0440"
  },
  {
    code: "ay",
    name: "Aymara",
    native: "Aymar"
  },
  {
    code: "az",
    name: "Azerbaijani",
    native: "Az\u0259rbaycanca / \u0622\u0630\u0631\u0628\u0627\u064A\u062C\u0627\u0646"
  },
  {
    code: "ba",
    name: "Bashkir",
    native: "\u0411\u0430\u0448\u04A1\u043E\u0440\u0442"
  },
  {
    code: "be",
    name: "Belarusian",
    native: "\u0411\u0435\u043B\u0430\u0440\u0443\u0441\u043A\u0430\u044F"
  },
  {
    code: "bg",
    name: "Bulgarian",
    native: "\u0411\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438"
  },
  {
    code: "bh",
    name: "Bihari",
    native: "\u092D\u094B\u091C\u092A\u0941\u0930\u0940"
  },
  {
    code: "bi",
    name: "Bislama",
    native: "Bislama"
  },
  {
    code: "bm",
    name: "Bambara",
    native: "Bamanankan"
  },
  {
    code: "bn",
    name: "Bengali",
    native: "\u09AC\u09BE\u0982\u09B2\u09BE"
  },
  {
    code: "bo",
    name: "Tibetan",
    native: "\u0F56\u0F7C\u0F51\u0F0B\u0F61\u0F72\u0F42 / Bod skad"
  },
  {
    code: "br",
    name: "Breton",
    native: "Brezhoneg"
  },
  {
    code: "bs",
    name: "Bosnian",
    native: "Bosanski"
  },
  {
    code: "ca",
    name: "Catalan",
    native: "Catal\xE0"
  },
  {
    code: "ce",
    name: "Chechen",
    native: "\u041D\u043E\u0445\u0447\u0438\u0439\u043D"
  },
  {
    code: "ch",
    name: "Chamorro",
    native: "Chamoru"
  },
  {
    code: "co",
    name: "Corsican",
    native: "Corsu"
  },
  {
    code: "cr",
    name: "Cree",
    native: "Nehiyaw"
  },
  {
    code: "cs",
    name: "Czech",
    native: "\u010Cesky"
  },
  {
    code: "cu",
    name: "Old Church Slavonic / Old Bulgarian",
    native: "\u0441\u043B\u043E\u0432\u0463\u043D\u044C\u0441\u043A\u044A / slov\u011Bn\u012Dsk\u016D"
  },
  {
    code: "cv",
    name: "Chuvash",
    native: "\u0427\u0103\u0432\u0430\u0448"
  },
  {
    code: "cy",
    name: "Welsh",
    native: "Cymraeg"
  },
  {
    code: "da",
    name: "Danish",
    native: "Dansk"
  },
  {
    code: "de",
    name: "German",
    native: "Deutsch"
  },
  {
    code: "dv",
    name: "Divehi",
    native: "\u078B\u07A8\u0788\u07AC\u0780\u07A8\u0784\u07A6\u0790\u07B0",
    rtl: 1
  },
  {
    code: "dz",
    name: "Dzongkha",
    native: "\u0F47\u0F7C\u0F44\u0F0B\u0F41"
  },
  {
    code: "ee",
    name: "Ewe",
    native: "\u0190\u028B\u025B"
  },
  {
    code: "el",
    name: "Greek",
    native: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC"
  },
  {
    code: "en",
    name: "English",
    native: "English"
  },
  {
    code: "eo",
    name: "Esperanto",
    native: "Esperanto"
  },
  {
    code: "es",
    name: "Spanish",
    native: "Espa\xF1ol"
  },
  {
    code: "et",
    name: "Estonian",
    native: "Eesti"
  },
  {
    code: "eu",
    name: "Basque",
    native: "Euskara"
  },
  {
    code: "fa",
    name: "Persian",
    native: "\u0641\u0627\u0631\u0633\u06CC",
    rtl: 1
  },
  {
    code: "ff",
    name: "Peul",
    native: "Fulfulde"
  },
  {
    code: "fi",
    name: "Finnish",
    native: "Suomi"
  },
  {
    code: "fj",
    name: "Fijian",
    native: "Na Vosa Vakaviti"
  },
  {
    code: "fo",
    name: "Faroese",
    native: "F\xF8royskt"
  },
  {
    code: "fr",
    name: "French",
    native: "Fran\xE7ais"
  },
  {
    code: "fy",
    name: "West Frisian",
    native: "Frysk"
  },
  {
    code: "ga",
    name: "Irish",
    native: "Gaeilge"
  },
  {
    code: "gd",
    name: "Scottish Gaelic",
    native: "G\xE0idhlig"
  },
  {
    code: "gl",
    name: "Galician",
    native: "Galego"
  },
  {
    code: "gn",
    name: "Guarani",
    native: "Ava\xF1e'\u1EBD"
  },
  {
    code: "gu",
    name: "Gujarati",
    native: "\u0A97\u0AC1\u0A9C\u0AB0\u0ABE\u0AA4\u0AC0"
  },
  {
    code: "gv",
    name: "Manx",
    native: "Gaelg"
  },
  {
    code: "ha",
    name: "Hausa",
    native: "\u0647\u064E\u0648\u064F\u0633\u064E",
    rtl: 1
  },
  {
    code: "he",
    name: "Hebrew",
    native: "\u05E2\u05D1\u05E8\u05D9\u05EA",
    rtl: 1
  },
  {
    code: "hi",
    name: "Hindi",
    native: "\u0939\u093F\u0928\u094D\u0926\u0940"
  },
  {
    code: "ho",
    name: "Hiri Motu",
    native: "Hiri Motu"
  },
  {
    code: "hr",
    name: "Croatian",
    native: "Hrvatski"
  },
  {
    code: "ht",
    name: "Haitian",
    native: "Kr\xE8yol ayisyen"
  },
  {
    code: "hu",
    name: "Hungarian",
    native: "Magyar"
  },
  {
    code: "hy",
    name: "Armenian",
    native: "\u0540\u0561\u0575\u0565\u0580\u0565\u0576"
  },
  {
    code: "hz",
    name: "Herero",
    native: "Otsiherero"
  },
  {
    code: "ia",
    name: "Interlingua",
    native: "Interlingua"
  },
  {
    code: "id",
    name: "Indonesian",
    native: "Bahasa Indonesia"
  },
  {
    code: "ie",
    name: "Interlingue",
    native: "Interlingue"
  },
  {
    code: "ig",
    name: "Igbo",
    native: "Igbo"
  },
  {
    code: "ii",
    name: "Sichuan Yi",
    native: "\uA187\uA259 / \u56DB\u5DDD\u5F5D\u8BED"
  },
  {
    code: "ik",
    name: "Inupiak",
    native: "I\xF1upiak"
  },
  {
    code: "io",
    name: "Ido",
    native: "Ido"
  },
  {
    code: "is",
    name: "Icelandic",
    native: "\xCDslenska"
  },
  {
    code: "it",
    name: "Italian",
    native: "Italiano"
  },
  {
    code: "iu",
    name: "Inuktitut",
    native: "\u1403\u14C4\u1483\u144E\u1450\u1466"
  },
  {
    code: "ja",
    name: "Japanese",
    native: "\u65E5\u672C\u8A9E"
  },
  {
    code: "jv",
    name: "Javanese",
    native: "Basa Jawa"
  },
  {
    code: "ka",
    name: "Georgian",
    native: "\u10E5\u10D0\u10E0\u10D7\u10E3\u10DA\u10D8"
  },
  {
    code: "kg",
    name: "Kongo",
    native: "KiKongo"
  },
  {
    code: "ki",
    name: "Kikuyu",
    native: "G\u0129k\u0169y\u0169"
  },
  {
    code: "kj",
    name: "Kuanyama",
    native: "Kuanyama"
  },
  {
    code: "kk",
    name: "Kazakh",
    native: "\u049A\u0430\u0437\u0430\u049B\u0448\u0430"
  },
  {
    code: "kl",
    name: "Greenlandic",
    native: "Kalaallisut"
  },
  {
    code: "km",
    name: "Cambodian",
    native: "\u1797\u17B6\u179F\u17B6\u1781\u17D2\u1798\u17C2\u179A"
  },
  {
    code: "kn",
    name: "Kannada",
    native: "\u0C95\u0CA8\u0CCD\u0CA8\u0CA1"
  },
  {
    code: "ko",
    name: "Korean",
    native: "\uD55C\uAD6D\uC5B4"
  },
  {
    code: "kr",
    name: "Kanuri",
    native: "Kanuri"
  },
  {
    code: "ks",
    name: "Kashmiri",
    native: "\u0915\u0936\u094D\u092E\u0940\u0930\u0940 / \u0643\u0634\u0645\u064A\u0631\u064A",
    rtl: 1
  },
  {
    code: "ku",
    name: "Kurdish",
    native: "Kurd\xEE / \u0643\u0648\u0631\u062F\u06CC",
    rtl: 1
  },
  {
    code: "kv",
    name: "Komi",
    native: "\u041A\u043E\u043C\u0438"
  },
  {
    code: "kw",
    name: "Cornish",
    native: "Kernewek"
  },
  {
    code: "ky",
    name: "Kirghiz",
    native: "K\u0131rg\u0131zca / \u041A\u044B\u0440\u0433\u044B\u0437\u0447\u0430"
  },
  {
    code: "la",
    name: "Latin",
    native: "Latina"
  },
  {
    code: "lb",
    name: "Luxembourgish",
    native: "L\xEBtzebuergesch"
  },
  {
    code: "lg",
    name: "Ganda",
    native: "Luganda"
  },
  {
    code: "li",
    name: "Limburgian",
    native: "Limburgs"
  },
  {
    code: "ln",
    name: "Lingala",
    native: "Ling\xE1la"
  },
  {
    code: "lo",
    name: "Laotian",
    native: "\u0EA5\u0EB2\u0EA7 / Pha xa lao"
  },
  {
    code: "lt",
    name: "Lithuanian",
    native: "Lietuvi\u0173"
  },
  {
    code: "lu",
    name: "Luba-Katanga",
    native: "Tshiluba"
  },
  {
    code: "lv",
    name: "Latvian",
    native: "Latvie\u0161u"
  },
  {
    code: "mg",
    name: "Malagasy",
    native: "Malagasy"
  },
  {
    code: "mh",
    name: "Marshallese",
    native: "Kajin Majel / Ebon"
  },
  {
    code: "mi",
    name: "Maori",
    native: "M\u0101ori"
  },
  {
    code: "mk",
    name: "Macedonian",
    native: "\u041C\u0430\u043A\u0435\u0434\u043E\u043D\u0441\u043A\u0438"
  },
  {
    code: "ml",
    name: "Malayalam",
    native: "\u0D2E\u0D32\u0D2F\u0D3E\u0D33\u0D02"
  },
  {
    code: "mn",
    name: "Mongolian",
    native: "\u041C\u043E\u043D\u0433\u043E\u043B"
  },
  {
    code: "mo",
    name: "Moldovan",
    native: "Moldoveneasc\u0103"
  },
  {
    code: "mr",
    name: "Marathi",
    native: "\u092E\u0930\u093E\u0920\u0940"
  },
  {
    code: "ms",
    name: "Malay",
    native: "Bahasa Melayu"
  },
  {
    code: "mt",
    name: "Maltese",
    native: "bil-Malti"
  },
  {
    code: "my",
    name: "Burmese",
    native: "\u1019\u103C\u1014\u103A\u1019\u102C\u1005\u102C"
  },
  {
    code: "na",
    name: "Nauruan",
    native: "Dorerin Naoero"
  },
  {
    code: "nb",
    name: "Norwegian Bokm\xE5l",
    native: "Norsk bokm\xE5l"
  },
  {
    code: "nd",
    name: "North Ndebele",
    native: "Sindebele"
  },
  {
    code: "ne",
    name: "Nepali",
    native: "\u0928\u0947\u092A\u093E\u0932\u0940"
  },
  {
    code: "ng",
    name: "Ndonga",
    native: "Oshiwambo"
  },
  {
    code: "nl",
    name: "Dutch",
    native: "Nederlands"
  },
  {
    code: "nn",
    name: "Norwegian Nynorsk",
    native: "Norsk nynorsk"
  },
  {
    code: "no",
    name: "Norwegian",
    native: "Norsk"
  },
  {
    code: "nr",
    name: "South Ndebele",
    native: "isiNdebele"
  },
  {
    code: "nv",
    name: "Navajo",
    native: "Din\xE9 bizaad"
  },
  {
    code: "ny",
    name: "Chichewa",
    native: "Chi-Chewa"
  },
  {
    code: "oc",
    name: "Occitan",
    native: "Occitan"
  },
  {
    code: "oj",
    name: "Ojibwa",
    native: "\u140A\u14C2\u1511\u14C8\u142F\u14A7\u140E\u14D0 / Anishinaabemowin"
  },
  {
    code: "om",
    name: "Oromo",
    native: "Oromoo"
  },
  {
    code: "or",
    name: "Oriya",
    native: "\u0B13\u0B21\u0B3C\u0B3F\u0B06"
  },
  {
    code: "os",
    name: "Ossetian / Ossetic",
    native: "\u0418\u0440\u043E\u043D\u0430\u0443"
  },
  {
    code: "pa",
    name: "Panjabi / Punjabi",
    native: "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40 / \u092A\u0902\u091C\u093E\u092C\u0940 / \u067E\u0646\u062C\u0627\u0628\u064A"
  },
  {
    code: "pi",
    name: "Pali",
    native: "P\u0101li / \u092A\u093E\u0934\u093F"
  },
  {
    code: "pl",
    name: "Polish",
    native: "Polski"
  },
  {
    code: "ps",
    name: "Pashto",
    native: "\u067E\u069A\u062A\u0648",
    rtl: 1
  },
  {
    code: "pt",
    name: "Portuguese",
    native: "Portugu\xEAs"
  },
  {
    code: "qu",
    name: "Quechua",
    native: "Runa Simi"
  },
  {
    code: "rm",
    name: "Raeto Romance",
    native: "Rumantsch"
  },
  {
    code: "rn",
    name: "Kirundi",
    native: "Kirundi"
  },
  {
    code: "ro",
    name: "Romanian",
    native: "Rom\xE2n\u0103"
  },
  {
    code: "ru",
    name: "Russian",
    native: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439"
  },
  {
    code: "rw",
    name: "Rwandi",
    native: "Kinyarwandi"
  },
  {
    code: "sa",
    name: "Sanskrit",
    native: "\u0938\u0902\u0938\u094D\u0915\u0943\u0924\u092E\u094D"
  },
  {
    code: "sc",
    name: "Sardinian",
    native: "Sardu"
  },
  {
    code: "sd",
    name: "Sindhi",
    native: "\u0938\u093F\u0928\u0927\u093F"
  },
  {
    code: "se",
    name: "Northern Sami",
    native: "S\xE1megiella"
  },
  {
    code: "sg",
    name: "Sango",
    native: "S\xE4ng\xF6"
  },
  {
    code: "sh",
    name: "Serbo-Croatian",
    native: "Srpskohrvatski / \u0421\u0440\u043F\u0441\u043A\u043E\u0445\u0440\u0432\u0430\u0442\u0441\u043A\u0438"
  },
  {
    code: "si",
    name: "Sinhalese",
    native: "\u0DC3\u0DD2\u0D82\u0DC4\u0DBD"
  },
  {
    code: "sk",
    name: "Slovak",
    native: "Sloven\u010Dina"
  },
  {
    code: "sl",
    name: "Slovenian",
    native: "Sloven\u0161\u010Dina"
  },
  {
    code: "sm",
    name: "Samoan",
    native: "Gagana Samoa"
  },
  {
    code: "sn",
    name: "Shona",
    native: "chiShona"
  },
  {
    code: "so",
    name: "Somalia",
    native: "Soomaaliga"
  },
  {
    code: "sq",
    name: "Albanian",
    native: "Shqip"
  },
  {
    code: "sr",
    name: "Serbian",
    native: "\u0421\u0440\u043F\u0441\u043A\u0438"
  },
  {
    code: "ss",
    name: "Swati",
    native: "SiSwati"
  },
  {
    code: "st",
    name: "Southern Sotho",
    native: "Sesotho"
  },
  {
    code: "su",
    name: "Sundanese",
    native: "Basa Sunda"
  },
  {
    code: "sv",
    name: "Swedish",
    native: "Svenska"
  },
  {
    code: "sw",
    name: "Swahili",
    native: "Kiswahili"
  },
  {
    code: "ta",
    name: "Tamil",
    native: "\u0BA4\u0BAE\u0BBF\u0BB4\u0BCD"
  },
  {
    code: "te",
    name: "Telugu",
    native: "\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41"
  },
  {
    code: "tg",
    name: "Tajik",
    native: "\u0422\u043E\u04B7\u0438\u043A\u04E3"
  },
  {
    code: "th",
    name: "Thai",
    native: "\u0E44\u0E17\u0E22 / Phasa Thai"
  },
  {
    code: "ti",
    name: "Tigrinya",
    native: "\u1275\u130D\u122D\u129B"
  },
  {
    code: "tk",
    name: "Turkmen",
    native: "\u0422\u0443\u0440\u043A\u043C\u0435\u043D / \u062A\u0631\u0643\u0645\u0646"
  },
  {
    code: "tl",
    name: "Tagalog / Filipino",
    native: "Tagalog"
  },
  {
    code: "tn",
    name: "Tswana",
    native: "Setswana"
  },
  {
    code: "to",
    name: "Tonga",
    native: "Lea Faka-Tonga"
  },
  {
    code: "tr",
    name: "Turkish",
    native: "T\xFCrk\xE7e"
  },
  {
    code: "ts",
    name: "Tsonga",
    native: "Xitsonga"
  },
  {
    code: "tt",
    name: "Tatar",
    native: "Tatar\xE7a"
  },
  {
    code: "tw",
    name: "Twi",
    native: "Twi"
  },
  {
    code: "ty",
    name: "Tahitian",
    native: "Reo M\u0101`ohi"
  },
  {
    code: "ug",
    name: "Uyghur",
    native: "Uy\u01A3urq\u0259 / \u0626\u06C7\u064A\u063A\u06C7\u0631\u0686\u06D5"
  },
  {
    code: "uk",
    name: "Ukrainian",
    native: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430"
  },
  {
    code: "ur",
    name: "Urdu",
    native: "\u0627\u0631\u062F\u0648",
    rtl: 1
  },
  {
    code: "uz",
    name: "Uzbek",
    native: "\u040E\u0437\u0431\u0435\u043A"
  },
  {
    code: "ve",
    name: "Venda",
    native: "Tshiven\u1E13a"
  },
  {
    code: "vi",
    name: "Vietnamese",
    native: "Ti\u1EBFng Vi\u1EC7t"
  },
  {
    code: "vo",
    name: "Volap\xFCk",
    native: "Volap\xFCk"
  },
  {
    code: "wa",
    name: "Walloon",
    native: "Walon"
  },
  {
    code: "wo",
    name: "Wolof",
    native: "Wollof"
  },
  {
    code: "xh",
    name: "Xhosa",
    native: "isiXhosa"
  },
  {
    code: "yi",
    name: "Yiddish",
    native: "\u05D9\u05D9\u05B4\u05D3\u05D9\u05E9",
    rtl: 1
  },
  {
    code: "yo",
    name: "Yoruba",
    native: "Yor\xF9b\xE1"
  },
  {
    code: "za",
    name: "Zhuang",
    native: "Cuengh / T\xF4\xF4 / \u58EE\u8BED"
  },
  {
    code: "zh",
    name: "Chinese",
    native: "\u4E2D\u6587"
  },
  {
    code: "zu",
    name: "Zulu",
    native: "isiZulu"
  }
];
function kt(e, t, n, a = !0) {
  const o = document.createElement("a");
  o.download = n, a ? (o.href = URL.createObjectURL(new Blob([e], { type: t })), setTimeout(function() {
    URL.revokeObjectURL(o.href);
  }, 1500)) : o.href = `data:${t};,${e}`, o.dataset.downloadurl = [t, o.download, o.href].join(":"), o.style.display = "none", document.body.appendChild(o), o.click(), document.body.removeChild(o);
}
function kn(e, t = (n) => console.log(n)) {
  let n = e.target.files[0];
  const a = 2e7;
  if (n.size > a) {
    console.error("File is bigger than " + Le(a)) + "";
    return;
  }
  let o = new FileReader();
  o.readAsText(n), o.onload = () => {
    t(o.result);
  };
}
function jn({
  preserveRatio: e = !1,
  picSize: t = 100,
  maxSize: n = 1024e4
} = {}) {
  const a = d({
    errors: [],
    status: null,
    output: {}
  });
  function o(m) {
    const v = m.target.files;
    c(), v.length && (a.status = "loading", [...v].map((k) => s(k)));
  }
  function s(m) {
    return r(m).then((v) => {
      a.output = {
        name: h(m.name),
        content: v,
        size: Le(Math.round(v.length * 3 / 4))
      }, a.status = "success";
    }), null;
  }
  function r(m) {
    return new Promise((v, k) => {
      const R = new FileReader(), M = new FileReader(), W = m.slice(0, 4);
      R.readAsArrayBuffer(W), R.onloadend = (D) => {
        let j = u(p(D.target.result));
        if (i(m.size) > i(n) && a.errors.push({
          message: "File size is too large!"
        }), j === !1 && a.errors.push({
          message: "File type is not supported!"
        }), a.errors.length > 0) {
          l(a.errors), c();
          return;
        } else
          M.readAsDataURL(m);
      }, M.onloadend = () => {
        const D = new Image();
        D.src = M.result, D.onload = () => {
          const j = e ? D.naturalWidth / D.naturalHeight : 1, y = document.createElement("canvas");
          y.width = t, y.height = t / j, y.getContext("2d").drawImage(D, 0, 0, y.width, y.height), v(y.toDataURL());
        };
      }, R.onerror = (D) => k(D), M.onerror = (D) => k(D);
    });
  }
  function c() {
    a.status = "", a.errors = [], a.output = {};
  }
  function i(m) {
    return m * Math.pow(10, -6);
  }
  function u(m) {
    return [
      "89504E47",
      "47494638",
      "FFD8FFDB",
      "FFD8FFE0",
      "FFD8FFE1",
      "FFD8FFE2",
      "FFD8FFE3",
      "FFD8FFE8",
      "FFD8FFED",
      "3C3F786D",
      "3C737667"
    ].includes(m);
  }
  function p(m) {
    const v = new Uint8Array(m);
    let k = [];
    return v.forEach((R) => {
      k.push(R.toString(16));
    }), k.join("").toUpperCase();
  }
  function h(m) {
    return m.replace(/\.[^/.]+$/, "").toLowerCase();
  }
  function l(m) {
    m.length === 2 ? console.error("File upload failed due to size and type!") : console.error(m[0].message + m[0].type);
  }
  return {
    state: a,
    handleChange: o
  };
}
const jt = ["bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
function Le(e) {
  let t = 0, n = parseInt(e, 10) || 0;
  for (; n >= 1024 && ++t; )
    n = n / 1024;
  return n.toFixed(n < 10 && t > 0 ? 1 : 0) + " " + jt[t];
}
function An(e) {
  var t = null;
  if (typeof e != "string")
    return t;
  var n = e.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
  return n && n.length && (t = n[1]), t;
}
function At(e) {
  var t;
  return (t = e.match(/[^:]\w+\/[\w-+\d.]+(?=;|,)/)) == null ? void 0 : t[0];
}
function Pt(e) {
  return e.substring(e.indexOf("/") + 1, e.indexOf(";base64"));
}
var we = {
  JVBERi0: "application/pdf",
  R0lGODdh: "image/gif",
  R0lGODlh: "image/gif",
  iVBORw0KGgo: "image/png",
  "/9j/": "image/jpg"
};
function be(e) {
  for (var t in we)
    if (e.indexOf(t) === 0)
      return we[t];
}
function Ot({ frontmatter: e = null, text: t = "" } = md) {
  let n = "";
  if (typeof e == "object")
    return n = `---
${xe.stringify(e)}---
 `, n + t;
}
function Dt(e) {
  const n = /^(?:\-\-\-)(.*?)(?:\-\-\-|\.\.\.)(?:\n*\s*)(.*)/s.exec(e.trim());
  let a, o;
  if (n) {
    a = n[1], o = n == null ? void 0 : n[2];
    try {
      a = xe.parse(a);
    } catch {
      a = {};
    }
    return { frontmatter: a, content: o };
  } else
    return { frontmatter: {}, content: e.trim() };
}
function Pn() {
  const e = new We({
    linkify: !0,
    typographer: !0
  });
  return e.use(He, {
    externalTarget: "_blank"
  }), e;
}
function Ft({ hash: e = "", loadMedia: t = !0 } = {}) {
  const n = w(), a = d({});
  n.get("posts").get("#index").get(e).on(async (r, c) => {
    try {
      Object.assign(a, JSON.parse(r));
    } catch {
      a.raw = r;
    }
    t && ["icon", "cover", "text"].forEach((i) => {
      a[i] && n.get("posts").get(`#${i}`).get(a[i]).on((u) => {
        a[i] = u;
      });
    });
  });
  const o = P(!1);
  async function s() {
    o.value = !0, await xt(a), o.value = !1;
  }
  return { post: a, download: s, downloading: o };
}
async function Et(e, t) {
  var s;
  const { user: n } = x();
  t.icon = await oe("icon", t.icon), t.cover = await oe("cover", t.cover), t.text = await oe("text", t.text);
  const { hashed: a, hash: o } = await X(t);
  console.log(o, t, e), S.get("posts").get("#index").get(`${o}`).put(a), S.user(f.pub).get("posts").get(`${e}:${o}@${n.pub}`).put(!0, null, { opt: { cert: (s = f.features) == null ? void 0 : s.posts } });
}
async function xt(e) {
  let { title: t } = e;
  const { zipPost: n, addFile: a, downloadZip: o } = Ge();
  if (t && !e.raw)
    await n({ ...e });
  else {
    t = "file";
    const s = await q(e.raw);
    await a({
      title: wt(s),
      file: e.raw
    });
  }
  return await o({ title: t }), !0;
}
async function ye(e, t) {
  return e && t && typeof t == "string" && t.length == 44 && t.slice(0, 5) != "data:" ? await S.get("posts").get(`#${e}`).get(t).then() : t;
}
async function oe(e, t) {
  if (e && t) {
    const n = await q(t);
    return S.get("posts").get(`#${e}`).get(`${n}`).put(t), n;
  } else
    return t;
}
async function On(e) {
  let t;
  try {
    t = JSON.parse(e);
  } catch {
    t = { base64: e };
  }
  return t;
}
function Dn({ tag: e, hash: t } = {}) {
  const n = P(0), a = g(() => Q(Date.now() - n.value || 1e3));
  S.get("posts").get("#index").get(t).on(function(s, r, c) {
    n.value = c.put[">"];
  });
  async function o() {
    let s = await S.get("posts").get("#index").get(t).then();
    S.get("posts").get("#index").get(t).put(s);
  }
  return { timestamp: n, msTime: a, refresh: o };
}
function Fn(e) {
  if (!e)
    return;
  const t = w(), n = d({}), a = d({});
  t.user(f.pub).get("posts").map().on(function(u, p) {
    let h = p.indexOf(e);
    if (h == -1)
      return;
    let l = p.slice(-87), m = p.slice(0, 44), v = p.slice(45, 89);
    h == 0 ? (n[v] = n[v] || {}, n[v][l] = u) : (a[m] = a[m] || {}, a[m][l] = u);
  });
  const o = g(() => {
    let u = 0;
    for (let p in n) {
      e:
        for (let h in n[p])
          if (n[p][h]) {
            u++;
            break e;
          }
    }
    return u;
  }), s = g(() => {
    let u = 0;
    for (let p in a) {
      e:
        for (let h in a[p])
          if (a[p][h]) {
            u++;
            break e;
          }
    }
    return u;
  }), r = P(!1);
  async function c() {
    r.value = !0, r.value = !await Rt(e, n);
  }
  function i(u) {
    Ct(e, u);
  }
  return {
    posts: n,
    backlinks: a,
    countPosts: o,
    countBacklinks: s,
    downloadPosts: c,
    downloading: r,
    uploadPosts: i
  };
}
async function Rt(e, t) {
  if (!t)
    return;
  const { zip: n, zipPost: a, downloadZip: o } = Ge(), s = {};
  for (let r in t)
    s[r] = Ft({ tag: e, hash: r }).post, await a({ ...s[r] });
  return await o({ title: `#${e}` }), !0;
}
function Ct(e, t) {
  [...t].forEach(async (n) => {
    const a = await Re.loadAsync(n);
    a.comment && console.info("Zip file comment: " + a.comment), a.forEach(async (o, s) => {
      var r;
      if (o.endsWith("index.md")) {
        let c = o.slice(0, -9), i = await s.async("string"), { frontmatter: u, content: p } = Dt(i);
        if (u = u || {}, u.title = (u == null ? void 0 : u.title) || c, u.icon) {
          const l = await a.file(`${c}/${u.icon}`).async("base64"), m = be(l);
          u.icon = `data:${m};base64,${l}`;
        }
        if (u.cover) {
          const l = await ((r = a == null ? void 0 : a.file(`${c}/${u.cover}`)) == null ? void 0 : r.async("base64")), m = be(l);
          u.cover = `data:${m};base64,${l}`;
        }
        let h = { ...u, content: p };
        Et(e, h);
      }
    });
  });
}
function En() {
  const e = w(), t = P(), n = g(() => ie(t.value)), a = d({
    list: {},
    all: g(() => {
      const s = [];
      for (let r in a.list)
        s.push({
          hash: r,
          tag: a.list[r]
        });
      return s.sort((r, c) => r && c && r.tag.toLowerCase() < c.tag.toLowerCase() ? -1 : 1);
    }),
    count: g(() => a.all.length),
    fuse: g(() => new te(a.all, {
      includeScore: !0,
      keys: ["tag"]
    })),
    results: g(() => t.value ? a.fuse.search(n.value) : []),
    minScore: g(() => {
      let s = 100;
      return a.results.forEach((r) => {
        r.score < s && (s = r.score);
      }), s;
    })
  });
  e.get("#tags").map().on((s, r) => {
    if (!!s)
      try {
        data = JSON.parse(s);
      } catch {
        a.list[r] = s;
      }
  });
  async function o(s = n.value) {
    if (!s)
      return;
    let r = ie(s);
    const c = await q(r);
    e.get("#tags").get(`${c}`).put(r);
  }
  return { search: t, slug: n, tags: a, addTag: o };
}
function xn(e, t = currentRoom.pub) {
  const n = w(), a = d({});
  return n.user(t).get(`${e}`).map().on(function(o, s) {
    let r = s.substring(0, 87);
    a[r] = a[r] || {}, a[r][s.substring(88)] = o;
  }), a;
}
async function Rn(e, t, n = currentRoom.pub, a) {
  var r;
  if (a || (a = await gun.get(`~${n}`).get("features").get(e).then()), !a && n == rootRoom.pub && (a = (r = rootRoom.features) == null ? void 0 : r[`#${e}`]), !a && n != user.pub) {
    console.log("No certificate found");
    return;
  }
  const { hashed: o, hash: s } = await hashObj(t);
  gun.get(`~${n}`).get(`#${e}`).get(`${s}@${user.pub}`).put(o, null, { opt: { cert: a } });
}
function Cn(e, t, n = currentRoom.pub) {
  const a = d({});
  return gun.get(`~${n}`).get(`#${e}`).map().once(function(o, s) {
    s.includes(t) && (a.hash = t, a.tag = e, a.data = safeJSONParse(o), a.authors = a.authors || {}, a.authors[s.slice(-87)] = !0);
  }), { record: a };
}
const Nt = ["rooms"];
function Nn({ tag: e, hash: t, back: n } = {}) {
  const { user: a } = x(), o = P("\u{1F44D}"), r = w().user(f.pub);
  Z(() => {
    Nt.includes(e) ? r.get(e).get(`${t}@${a.pub}`).on((i) => {
      i && i !== !0 && (o.value = i);
    }) : r.get("posts").get(`${e}:${t}@${a.pub}`).on((i) => {
      i && i !== !0 && (o.value = i);
    });
  });
  function c(i) {
    Tt({ tag: e, hash: t, back: n, reaction: Y(i || o.value) });
  }
  return { reaction: o, react: c };
}
async function Tt({ tag: e, hash: t, back: n, reaction: a = !0 } = {}) {
  var r, c;
  const { user: o } = x(), s = w();
  if (console.log(e, t, a), e == "rooms") {
    let i = s.user(f.pub).get(e).get(`${t}@${o.pub}`), u = await i.then();
    i.put(u ? null : a, null, {
      opt: { cert: (r = f.features) == null ? void 0 : r[e] }
    });
  } else {
    let i = s.user(f.pub).get("posts");
    n ? i = i.get(`${t}:${e}@${o.pub}`) : i = i.get(`${e}:${t}@${o.pub}`);
    let u = await i.then();
    i.put(u ? null : a, null, {
      opt: { cert: (c = f.features) == null ? void 0 : c.posts }
    });
  }
}
function Tn(e) {
  const t = {};
  for (let n in e) {
    let a = e[n];
    a && (t[a] = t[a] || [], t[a].push(n));
  }
  return t;
}
function Mn(e) {
  let t = 0;
  for (let n in e)
    e[n] && e[n] != "\u{1F5D1}" ? t++ : e[n] == "\u{1F5D1}" && t--;
  return t;
}
function $n(e) {
  const t = w(), n = d({});
  return t.user(f.pub).get("posts").map().on((a, o) => {
    var i;
    let s = o.slice(90), r = o.substring(0, 44), c = o.substring(45, 89);
    s == e && (a ? (n[a] = n[a] || {}, n[a][c] = r) : (i = n == null ? void 0 : n[a]) == null || delete i[c]);
  }), n;
}
function Ge() {
  const e = new Re();
  async function t({ title: s, file: r, folder: c = "." } = {}) {
    const i = At(r), u = Pt(r), p = await fetch(r).then((l) => l.blob()), h = `${s}.${u}`;
    return e.file(`${c}/${h}`, p, i), h;
  }
  function n({ md: s, title: r } = {}) {
    e.file(`${r}/index.md`, Ot(s), "text/markdown");
  }
  async function a(s = {}) {
    let { icon: r, cover: c, text: i, title: u, statement: p } = s;
    s == null || delete s.text, u || (u = p ? p.split(0, 12) : ht());
    const h = ["cover", "icon"];
    for (let l of h) {
      let m = await ye(l, s[l]);
      if (m) {
        const v = await t({
          title: l,
          file: m,
          folder: u
        });
        s[l] = v;
      }
    }
    i = await ye("text", i), n({
      title: u,
      md: {
        frontmatter: s,
        text: i
      }
    });
  }
  async function o({ title: s = "", addDate: r = !0 } = {}) {
    let c = new Date();
    const i = c.getTimezoneOffset();
    c = new Date(c.getTime() - i * 60 * 1e3);
    const u = c.toISOString().split("T")[0], p = await e.generateAsync({
      type: "blob",
      comment: `Exported from ${s} at ${location} on ${u}`,
      compression: "DEFLATE",
      compressionOptions: {
        level: 9
      }
    }), h = `${s}-${u}.zip`;
    return kt(p, "application/zip", h), !0;
  }
  return { zip: e, zipPost: a, addMd: n, addFile: t, downloadZip: o };
}
const z = {
  pub: "OUlhoY2Eq8QkZE_iWN3l6J2vvbkX33vowcFdqFoCoEQ.a-B1ImQK4aoiEpdW-38MAPc8oi16DHY57bDJ4dEZpX0",
  hosts: {
    "jFjrmOEaRy-GAJlOCdG4SGoaLm_4AGMPP1sfmzYPwwo.mp2H7IQuTWlFSahN6ZnXN9Za0pD3thiIYUyGCaMel-M": {
      enc: 'SEA{"ct":"pvG4zoG5OIM7gyT5Jsh+PuFLAf200NKIpa7X/OxNm+lneWOD6avNS9iEXx9GgTM18iSdE3CBrKydusfLcqiXFFfMZivXsUTnf2Mbe702drcEcr7x9JTRhEqo3ptmunn+a+NUtfOPeExNFSCKoqfdMzSIR/nZFdW/qGcV5DDZOjuYdbV9Sh1rbvDPThJNJERz3WioLv3SodSXo4J5pq+2NujebALBabIZJYw2RXOxPjRMSnaYjT4lAZTA3FCy4mmP9fReVNw46Zjs6GYoZzIer0E4q5thRKyzf9IDFRJLfwpjejYY/fQWW4YFffN+1QBOjDAysCws+nCBSmFeKuAr2vFTvzdUI7gcoeKOc16BRnTC5NF8qQnXMS4XoilvueQ4as2mffG6iEwUiU5TicZO77+fARiUfG5WIgjEdkE=","iv":"a6bjav88otAnmjv6iB/r","s":"W+WzjXaZ4EAu"}',
      profile: 'SEA{"m":{"c":"jFjrmOEaRy-GAJlOCdG4SGoaLm_4AGMPP1sfmzYPwwo.mp2H7IQuTWlFSahN6ZnXN9Za0pD3thiIYUyGCaMel-M","w":{"*":"profile"}},"s":"YIGcs8VXeD4eB21MFPM/wnpJnMkmuxX6wjA/1GD170ATGBob9Ps3WCGtRUyhT2AmCIOe7oXpinZdtd3SCSZh/A=="}',
      features: 'SEA{"m":{"c":"jFjrmOEaRy-GAJlOCdG4SGoaLm_4AGMPP1sfmzYPwwo.mp2H7IQuTWlFSahN6ZnXN9Za0pD3thiIYUyGCaMel-M","w":{"*":"features"}},"s":"vhnmYfslzJm6qWTUBp4meKtlzAkIxyayRJa1KNeCFJT27T7UX4X//+t5giRX6Z/rIz3aWEPZX9UK3LLhc/J91g=="}',
      hosts: 'SEA{"m":{"c":"jFjrmOEaRy-GAJlOCdG4SGoaLm_4AGMPP1sfmzYPwwo.mp2H7IQuTWlFSahN6ZnXN9Za0pD3thiIYUyGCaMel-M","w":{"*":"hosts"}},"s":"2x5ZTh1NYv+eCtRKwlKItC1j9ZV5YhhiWJiaNq8Y+8YBF93aaagY6CT0YzLYFvG/fKTBWN4lldaeI+cFV88AbA=="}'
    }
  },
  features: {
    rooms: 'SEA{"m":{"c":"*","w":{"*":"rooms","+":"*"}},"s":"iJjnFrGvM092KSqH9kUYJm0pBgd6HSg8b9kl9QPjdQYNDAZQe2btfDP6rXIVNPcYFIjEYqBCibuQhcAjODUQFg=="}',
    space: 'SEA{"m":{"c":"*","w":{"*":"space","+":"*"}},"s":"eTZNu+acczsk8ew+UKCseanlVJ4prm+N1cvLXe2T6Bccfk6a7gR5EjvyBat4iCv97HpcoYtfcQO1ImhgVzP/bQ=="}',
    posts: 'SEA{"m":{"c":"*","w":{"*":"posts","+":"*"}},"s":"g94jrn4qvausK0sf5ej+MDIqJr9QOyG6U/fwAfmjxWcxCSiVzra8ZhvwOA3PVsqdcRYMK9YFMZ2cNJhT84ew/w=="}',
    chat: 'SEA{"m":{"c":"*","w":{"*":"chat","+":"*"}},"s":"Nclaw2A61Dzx6wLNeGSFr+od7bdj0jYftz/8XDRTZTUUp42xnD1Hyp2GbmFGKrY8be+60XOxYB0Tcp+ewkPimA=="}',
    dict: 'SEA{"m":{"c":"*","w":{"*":"dict","+":"*"}},"s":"cmnSSjKGrbxEoJ3JyGfgeesLJ3fELC6aIy3nO4MmSLok4ZNxpx2HayQaQmi+8gfgwX86poYUm1WR2bDdUAgzmw=="}',
    projects: 'SEA{"m":{"c":"*","w":{"*":"projects","+":"*"}},"s":"Zx/1sVapPoqx0pVMrMElSWVwBbD1AH0uPP11/tte2qHUmww458tqwRNfC3XMhZVl/fR589I3VWoUXSfNGDPj+g=="}',
    gifts: 'SEA{"m":{"c":"*","w":{"*":"gifts","+":"*"}},"s":"YpWMF8FpZToI4KCc4ZxR4zBChQMF+C6HQF1maNpDyA6g9t/DY9tejELG+mc2CqcV9mDU/km2q7EeaZGnxQsREA=="}'
  }
}, f = d({
  pub: z.pub,
  isRoot: g(() => f.pub == z.pub),
  hosts: {},
  features: {},
  profile: {}
});
Z(() => {
  const e = w();
  f.pub == z.pub ? (f.hosts = z.hosts, f.features = z.features) : (f.features = {}, f.hosts = {}, e.user(f.pub).get("hosts").map().once((t, n) => {
    f.hosts[n] = t;
  }), e.user(f.pub).get("features").map().once((t, n) => {
    f.features[n] = t;
  }));
});
function Ln(e = f.pub) {
  const t = d({
    pub: e,
    isRoot: e != z.pub,
    hosts: {},
    features: {},
    profile: {}
  }), n = w();
  return n.user(e).get("profile").map().on((a, o) => {
    t.profile[o] = a;
  }), n.user(e).get("hosts").map().once((a, o) => {
    t.hosts[o] = a;
  }), n.user(e).get("features").map().once((a, o) => {
    t.features[o] = a;
  }), {
    room: t,
    submitRoom: $t,
    enterRoom: Lt,
    createRoom: he,
    leaveRoom: Gt,
    updateRoomProfile: fe
  };
}
function Gn(e = f.pub) {
  const t = P();
  S.user(e).get("profile").get("logo").on((o) => {
    if (!o) {
      t.value = null;
      return;
    }
    S.get("#logos").get(o).once((s) => {
      t.value = s;
    });
  });
  async function n(o) {
    if (o) {
      const s = await q(o);
      S.get("#logos").get(s).put(o), fe("logo", s);
    } else
      a();
  }
  function a() {
    fe("logo", null);
  }
  return {
    logo: t,
    uploadLogo: n,
    removeLogo: a
  };
}
function Bn() {
  return { rooms: g(() => Mt("rooms", f.pub)), createRoom: he };
}
function Mt(e, t = f.pub) {
  const n = w(), a = d({});
  return n.user(t).get(`${e}`).map().on(function(o, s) {
    let r = s.substring(0, 87);
    a[r] = a[r] || {}, a[r][s.substring(88)] = o;
  }), a;
}
function fe(e, t) {
  var s, r;
  const n = w(), { user: a } = x();
  let o = (r = (s = f.hosts) == null ? void 0 : s[a.pub]) == null ? void 0 : r.profile;
  n.user(f.pub).get("profile").get(e).put(t, null, { opt: { cert: o } });
}
async function he({ pair: e, name: t } = {}) {
  var u;
  const { user: n } = x();
  if (!e)
    return;
  const a = await ve({
    pair: e,
    list: [
      { tag: "profile", users: [n.pub] },
      { tag: "features", users: [n.pub] },
      { tag: "hosts", users: [n.pub] }
    ]
  }), o = await ve({
    pair: e,
    list: [
      { tag: "rooms", personal: !0 },
      { tag: "space", personal: !0 },
      { tag: "posts", personal: !0 },
      { tag: "chat", personal: !0 },
      { tag: "dict", personal: !0 },
      { tag: "projects", personal: !0 },
      { tag: "gifts", personal: !0 }
    ]
  }), s = await O.encrypt(e, n.pair()), r = await O.decrypt(s, n.pair());
  console.log("COPY THIS ROOM INFO TO USE IT AS A ROOT", {
    pub: r.pub,
    hosts: { [n.pub]: { enc: s, ...a } },
    features: o
  }, "STORE THIS KEY PAIR IN A SAFE PLACE", r);
  const c = w();
  c.user().get("safe").get("rooms").get(r.pub).put(s), c.user(f.pub).get("rooms").get(`${r.pub}@${n.pub}`).put(!0, null, { opt: { cert: (u = f == null ? void 0 : f.features) == null ? void 0 : u.rooms } });
  const i = c.user(r.pub);
  i.get("hosts").get(n.pub).put({
    enc: s,
    ...a
  }, null, { opt: { cert: a.hosts } }), i.get("features").put(o, null, { opt: { cert: a.features } }), t && i.get("profile").put({ name: t }, null, { opt: { cert: a.profile } });
}
async function In(e) {
  const t = await O.decrypt(e, b.pair());
  he({
    pair: t
  });
}
async function $t(e) {
  var a;
  const t = w(), n = await t.user(f.pub).get("rooms").get(`${e}@${b.pub}`).then();
  t.user(f.pub).get("rooms").get(`${e}@${b.pub}`).put(!n, null, { opt: { cert: (a = f.features) == null ? void 0 : a.rooms } });
}
function zn() {
  var t;
  w().user(f.pub).get("space").get(b.pub).put(JSON.stringify({ x: Math.random(), y: Math.random() }), null, {
    opt: { cert: (t = f.features) == null ? void 0 : t.space }
  });
}
function Lt(e) {
  f.pub = e;
}
function Gt() {
  f.pub = z.pub;
}
async function Kn({
  tag: e,
  key: t,
  text: n,
  pub: a = f.pub,
  cert: o
} = {}) {
  var s;
  if (o || (o = await S.user(a).get("features").get(e).then()), o || (o = (s = f.features) == null ? void 0 : s[`${e}`]), !o && a != b.pub) {
    console.log("No certificate found");
    return;
  }
  S.user(a).get(`${e}`).get(`${t}@${b.pub}`).put(n, null, { opt: { cert: o } });
}
let se = Date.now();
function Un({ TIMEOUT: e = 1e4 } = {}) {
  const t = w(), n = d({}), a = d({}), o = d({}), s = d({
    total: g(() => Object.keys(n).length),
    online: g(() => Object.keys(a).length),
    offline: g(() => Object.keys(o).length)
  });
  return t.user(f.pub).get("space").map().once((r, c) => {
    const { account: i } = dt(c);
    n[c] = i, n[c].order = g(() => se - i.value.pulse < e ? 1 : se - i.value.pulse), n[c].online = g(() => se - i.value.pulse < e);
  }), Z(() => {
    for (let r in n)
      n[r].online ? (a[r] = n[r], delete o[r]) : (o[r] = n[r], delete a[r]);
  }), { guests: n, online: a, offline: o, count: s };
}
function Jn() {
  x();
  const e = w(), t = d({});
  return e.user(f.pub).get(C).map().once((n, a) => {
    e.get("#" + C).get(a.slice(0, -88)).once((o, s) => {
      try {
        const r = JSON.parse(o);
        t[s] = r;
      } catch {
      }
    });
  }), { gifts: t };
}
function Yn() {
  const { user: e } = x(), t = w(), n = d({}), a = d({}), o = d({});
  t.user().get(C).map().on((r, c) => {
    t.get("#" + C).get(c).once((i) => {
      try {
        i = JSON.parse(i), n[c] = i, i.from == e.pub && (a[c] = i), i.to == e.pub && (o[c] = i);
      } catch {
      }
    });
  });
  const s = d({});
  return t.user(f.pub).get(C).map().once(async (r, c) => {
    let i = c.slice(0, -88);
    t.get("#" + C).get(i).once(async (u) => {
      try {
        u = JSON.parse(u), u.to == e.pub && (await t.user().get(C).get(i).then() || (s[i] = u));
      } catch {
      }
    });
  }), { gifts: n, from: a, to: o, newGifts: s };
}
function Zn(e) {
  const t = e.slice(-87), n = w(), a = d({});
  n.user(t).get(C).map().once((s, r) => {
    n.get("#" + C).get(r).once((c) => {
      try {
        c = JSON.parse(c), c.project == e && (a[r] = { ...c, state: {} }, n.user(c.from).get(C).get(r).on((i) => {
          a[r].state.from = i;
        }), n.user(c.to).get(C).get(r).on((i) => {
          a[r].state.to = i;
        }));
      } catch {
      }
    });
  });
  const o = g(() => {
    let s = {};
    for (let r in a) {
      let c = a[r];
      s[c.ql] = s[c.ql] || { list: {}, sum: 0, from: {} }, s[c.ql].list[r] = c;
    }
    for (let r in s) {
      s[r].sum = 0, s[r].from = {};
      for (let c in s[r].list) {
        let i = s[r].list[c];
        !(i.state.from && i.state.to) || (s[r].sum += Number(i.qn), s[r].from[i.from] = s[r].from[i.from] || 0, s[r].from[i.from] += Number(i.qn));
      }
    }
    return s;
  });
  return { gifts: a, collections: o };
}
function qn(e) {
  e || (e = b.pub);
  const t = d({}), n = w();
  return n.user(e).get("mates").map().once((a, o) => {
    a ? (t[o] = {
      emoji: Y(a),
      text: a
    }, n.user(o).get("mates").get(e).on((s) => {
      s ? t[o].back = Y(s) : delete t[o].back;
    })) : delete t[o];
  }), t;
}
function Y(e, t = "\u{1F44B}") {
  if (!e || typeof e != "string")
    return;
  let n = Xe.break(e)[0];
  return Bt(n) ? n : t;
}
function Bt(e) {
  return /\p{Extended_Pictographic}/u.test(e);
}
function Wn(e) {
  const t = P("\u{1F44B}"), n = P(!1), a = b.db.get("mates").get(e);
  a.on((s) => {
    n.value = Y(s);
  });
  function o() {
    a.put(n.value ? !1 : Y(t.value));
  }
  return { emoji: t, isMate: n, toggleMate: o };
}
const It = Ne("deep"), Hn = d({
  pub: null
}), b = d({
  initiated: !1,
  auth: !1,
  is: null,
  name: "",
  pub: g(() => {
    var e;
    return (e = b == null ? void 0 : b.is) == null ? void 0 : e.pub;
  }),
  color: g(() => b.pub ? It.hex(b.pub) : "gray"),
  pulse: 0,
  pulser: null,
  blink: !1,
  safe: {
    saved: null,
    password: null
  },
  pair() {
    var e, t, n;
    return (n = (t = (e = S == null ? void 0 : S.user) == null ? void 0 : e.call(S)) == null ? void 0 : t._) == null ? void 0 : n.sea;
  }
});
function x() {
  if (!b.initiated) {
    const e = w();
    b.db = e.user(), e.user().recall({ sessionStorage: !0 }, () => {
      console.log("user was recalled");
    }), e.on("auth", () => {
      zt(), console.log("user authenticated");
    }), b.initiated = !0;
  }
  return { user: b, auth: ne, leave: Kt };
}
function zt() {
  b.is = S.user().is, b.pulser && clearInterval(b.pulser), b.pulser = setInterval(() => {
    S.user().get("pulse").put(Date.now());
  }, 1e3), S.user().get("epub").put(b.is.epub), S.user().get("pulse").on((e) => {
    b.blink = !b.blink, b.pulse = e;
  }), S.user().get("safe").map().on((e, t) => {
    b.safe[t] = e;
  }), S.user().get("profile").get("name").on((e) => b.name = e), b.initiated = !0;
}
async function ne(e, t = () => {
}) {
  if (!Be(e)) {
    console.log("incorrect pair", e);
    return;
  }
  S.user().auth(e, async () => {
    t(e), console.log("user is authenticated");
  });
}
function Kt() {
  var t;
  let e = !!((t = b.is) != null && t.pub);
  b.initiated = !1, clearInterval(b.pulser), S.user().leave(), setTimeout(() => {
    e && !b.pair() && (b.is = null, console.info("User logged out"));
  }, 500);
}
function Xn(e) {
  if (!!e)
    return e.slice(1, 88) == b.pub;
}
function Vn(e) {
  S.user().get("profile").get(e).put("");
}
function Qn(e, t) {
  e && t !== void 0 && S.user().get("profile").get(e).put(t);
}
function Be(e) {
  return e && typeof e == "object" && e.pub && e.epub && e.priv && e.epriv;
}
const A = d({
  input: "",
  show: !1,
  safePair: !1,
  minLength: 5,
  safe: {},
  dec: {},
  links: {
    pass: g(() => {
      var e;
      return Se((e = A.safe) == null ? void 0 : e.enc);
    }),
    pair: g(() => Se(JSON.stringify(b.pair())))
  },
  set() {
    Ie(A.input), A.input = "", A.show = !1;
  }
});
function Se(e = "") {
  let t = me.encode(e);
  return window.location.origin + window.location.pathname + "#/auth/" + t;
}
function _n(e) {
  let t = e.indexOf("#/auth/"), n = e.substr(t + 7);
  return me.decode(n);
}
let ke = !1;
function ea() {
  return ke || (w().user().get("safe").map().on((t, n) => {
    A.safe[n] = t;
  }), Z(async () => {
    var t, n;
    if (!A.show) {
      A.dec = {};
      return;
    }
    (A == null ? void 0 : A.show) && ((t = A == null ? void 0 : A.safe) == null ? void 0 : t.pass) && (A.dec.pass = await O.decrypt(A.safe.pass, b.pair()), A.input = A.dec.pass), A.show && ((n = A == null ? void 0 : A.safe) == null ? void 0 : n.enc) && (A.dec.pair = await O.decrypt(A.safe.enc, A.dec.pass));
  })), ke = !0, { pass: A, setPass: Ie, logWithPass: Ut };
}
async function ta(e) {
  return await S.get(`~${e}`).get("safe").get("enc").then();
}
async function Ut(e, t) {
  let n = await S.get(`~${e}`).get("safe").get("enc").then(), a = await O.decrypt(n, t);
  ne(a);
}
async function Ie(e) {
  let t = await O.encrypt(b.pair(), e), n = await O.encrypt(e, b.pair());
  b.db.get("safe").get("enc").put(t), b.db.get("safe").get("pass").put(n);
}
function na(e, t) {
  if (!e)
    return;
  const n = me.decode(e);
  if (n.substring(0, 3) == "SEA")
    return t && Jt(n, t), "encrypted";
  try {
    let a = JSON.parse(n);
    return Be(a) && ne(a), "success";
  } catch {
    return "incorrect link";
  }
}
async function Jt(e, t) {
  let n = await O.decrypt(e, t);
  ne(n);
}
function aa(e) {
  const t = w(), n = d({}), a = d({
    from: !1,
    to: !1,
    complete: g(() => a.from && a.to),
    status: g(() => a.from ? a.to ? "complete" : "proposed" : "canceled")
  });
  return t.get("#" + C).get(e).once((o, s) => {
    try {
      Object.assign(n, JSON.parse(o)), t.user(n.from).get(C).get(s).on((r) => {
        a.from = r;
      }), t.user(n.to).get(C).get(s).on((r) => {
        a.to = r;
      });
    } catch {
    }
  }), { gift: n, state: a };
}
async function oa(e, t = !0) {
  const { user: n } = x();
  n.db.get(C).get(e).put(t);
}
function sa(e) {
  const { user: t } = x(), { now: n, pause: a } = Ve({ interval: 1e3, controls: !0 }), o = d({
    from: g(() => t == null ? void 0 : t.pub),
    to: "",
    qn: null,
    ql: null,
    wish: "",
    project: "",
    date: g(() => n.value.toLocaleString("en-GB")),
    room: g(() => f.pub)
  }), s = g(() => {
    let l = ze(o);
    return l.qn = Number(l.qn), l;
  }), r = ["from", "to", "qn", "ql"], c = g(() => r.reduce((m, v) => m && o[v], !0));
  V(o, (l) => {
    l.project && (o.to = l.project.slice(-87));
  });
  const i = Qe(async () => {
    const { hash: l, hashed: m } = await X(s.value);
    return l;
  }), u = P(!1);
  Object.assign(o, e);
  const p = w();
  async function h() {
    var v;
    const { hash: l, hashed: m } = await X(s.value);
    p.get("#" + C).get(l).put(m), p.user().get(C).get(l).put("proposed", () => {
      a(), u.value = !0;
    }), (v = f.features) != null && v.gifts && p.user(f.pub).get(C).get(`${l}@${t.pub}`).put(!0, () => {
      console.log(`gift ${l} published`);
    }, {
      opt: { cert: f.features.gifts }
    });
  }
  return { gift: o, cleanGift: s, valid: c, propose: h, proposed: u, hash: i };
}
function ze(e) {
  return Object.entries(e).filter(([t, n]) => !!n).reduce((t, [n, a]) => ({ ...t, [n]: a === Object(a) ? ze(a) : a }), {});
}
const C = "gifts", ra = {
  from: "",
  to: "",
  qn: 0,
  ql: "",
  wish: "",
  project: "",
  room: f.pub,
  date: ""
};
function ia(e) {
  const t = Object.entries(e.data);
  let n = t.sort((a, o) => {
    if (!a || !o)
      return 0;
    let s = Date.parse(a[0]);
    return Date.parse(o[0]) - s;
  });
  postMessage({ sorted: n, count: t.length });
}
const Yt = function(e) {
  var t = URL.createObjectURL(new Blob(["onmessage=", e.toString()], {
    type: "application/javascript"
  })), n = new Worker(t);
  return URL.revokeObjectURL(t), n;
};
function Zt(e) {
  const t = Object.entries(e.data);
  let n = t.sort((a, o) => {
    if (!a || !o)
      return 0;
    let s = Date.parse(a[0]);
    return Date.parse(o[0]) - s;
  });
  postMessage({ sorted: n, count: t.length });
}
function ca({
  name: e = "logs",
  after: t = "2021-01-01",
  before: n = "2023-01-01"
} = {}) {
  const o = w().get(e), s = new Ce.exports.DateTree(o, "minute"), r = d({}), c = P([]), i = P(0);
  let u;
  ge(() => {
    var h = Yt(Zt);
    u = s.on(function(l, m) {
      !(l != null && l.event) || (r[m] = l);
    }, { gte: t, lt: n }), Z(() => {
      h.postMessage(JSON.parse(JSON.stringify(r)));
    }), h.onmessage = (l) => {
      c.value = l.data.sorted, i.value = l.data.count;
    };
  }), Fe(() => {
    u.off();
  });
  function p(h) {
    !h || s.get(new Date()).put({ event: "now", data: h });
  }
  return { dateTree: r, sorted: c, count: i, putNow: p };
}
function ua(e = "text", t) {
  if (!t) {
    console.log("No data to log");
    return;
  }
  const n = new Ce.exports.DateTree(S.get("logs"), "minute");
  let a = { event: e, ...t };
  n.get(new Date()).put(a);
}
function la(e) {
  if (!e)
    return;
  let t = new Date(e);
  return {
    date: t.toLocaleDateString("en-CA"),
    time: t.toLocaleTimeString("ru-RU"),
    ms: Q(Date.now() - t.getTime())
  };
}
const U = d({
  title: "",
  public: !0,
  funding: !1
});
async function fa({ publish: e = !0 } = {}) {
  const t = w(), { user: n } = x(), a = t.user().get(B).get(U.title).put(U, () => {
    var o;
    !e || (t.user(f.pub).get(B).get(U.title + "@" + n.pub).put(a, null, {
      opt: { cert: (o = f.features) == null ? void 0 : o.projects }
    }), U.title = null);
  });
}
function da(e, t, n) {
  const a = S.user().get(B).get(e);
  a.get(t).put(n, () => {
    a.get("updatedAt").put(Date.now());
  });
}
function ga(e = P()) {
  e = P(e);
  const t = w();
  return { project: g(() => {
    const a = d({});
    return t.user(f.pub).get(B).get(e.value).map().on((o, s) => {
      a[s] = o;
    }), a;
  }) };
}
async function ma(e) {
  var o;
  const t = w(), n = pt(), { user: a } = x();
  if (e.includes(a.pub))
    t.user(f.pub).get(B).get(e).put(null, null, {
      opt: { cert: (o = f.features) == null ? void 0 : o.projects }
    });
  else if (f.hosts[a.pub]) {
    const s = await _e.exports.SEA.decrypt(f.hosts[a.pub].enc, a.pair());
    n.user().auth(s, () => {
      n.user().get(B).get(e).put(null);
    });
  }
}
function pa(e = f.pub) {
  const t = P(""), n = d({}), a = g(() => {
    const r = Object.entries(n).map((c) => ({ ...c[1], path: c[0] }));
    return new te(r, {
      includeScore: !0,
      ignoreLocation: !0,
      keys: ["title"]
    });
  }), o = g(() => U.title ? a.value.search(U.title) : Object.entries(n).map((r) => ({ item: { ...r[1], path: r[0] } })));
  return w().user(e).get(B).map().on((r, c) => {
    if (r == null) {
      delete n[c];
      return;
    }
    const i = { ...r, path: c };
    delete i._, n[c] = i;
  }), { projects: n, search: t, candidates: o };
}
function ha(e = f.pub) {
  const t = d({});
  return w().user(e).get(B).map().on((a, o) => {
    if (a == null) {
      delete t[o];
      return;
    }
    t[o] = !0;
  }), g(() => Object.keys(t).length);
}
const B = "projects";
function va({
  TIMEOUT: e = 1e4,
  randomness: t = 0.1
} = {}) {
  const n = P(), { area: a, mouse: o } = ut(n), { width: s, height: r } = et(n), c = d([0, 0]), i = tt(1, 0.5, 2), u = w(), { user: p } = x(), h = d({
    title: "space",
    joined: !1,
    db: g(() => u.user(f.pub).get("space")),
    cert: g(() => {
      var j;
      return (j = f.features) == null ? void 0 : j.space;
    }),
    my: {
      mouse: g(() => ({ x: o.x, y: o.y })),
      pos: null
    }
  });
  async function l() {
    h.joined = !0;
  }
  function m({ x: j = o.x, y = o.y } = {}) {
    var E;
    !p.pub || (h.joined || l(), c[0] = j, c[1] = y, h.db.get(p.pub).get("pos").put(JSON.stringify({ x: j, y }), null, {
      opt: { cert: (E = f.features) == null ? void 0 : E.space }
    }));
  }
  const v = d({}), k = d({}), R = d({}), M = g(() => {
    var y;
    const j = {};
    for (let E in v)
      Date.now() - ((y = v[E]) == null ? void 0 : y.pulse) < e && (j[E] = v[E]);
    return j;
  }), W = g(() => Object.keys(M.value).length);
  u.user(f.pub).get("space").map().once(async (j, y) => {
    y == p.pub && (h.joined = !0), v[y] = {
      pub: y,
      draw: "",
      blink: !1,
      pulse: 0,
      hasPos: !1,
      pos: {
        x: 0,
        y: 0
      }
    }, u.user(f.pub).get("space").get(y).get("pos").on((E, H) => {
      v[y].hasPos = !0, v[y].pos = typeof E == "string" ? JSON.parse(E) : E;
    }), u.user(f.pub).get("space").get(y).get("draw").on((E) => {
      v[y].draw = E;
    }), u.user(y).get("pulse").on((E) => {
      v[y].pulse = E, v[y].blink = !v[y].blink;
    }).back().get("mates").map().on((E, H) => {
      k[y] = k[y] || {}, k[y][H] = E;
    });
  });
  const D = {};
  return Z(() => {
    for (let j in k) {
      D[j] = D[j] || {};
      for (let y in k[j]) {
        let E = D[j][y] = D[j][y] || Math.random() * t;
        if (k[j][y]) {
          const H = k[j][y];
          let $ = v[j], L = v[y], Ke = Date.now() * 2 - ($ == null ? void 0 : $.pulse) - (L == null ? void 0 : L.pulse);
          $ && L && ($ == null ? void 0 : $.hasPos) && (L == null ? void 0 : L.hasPos) && Ke < e && (R[j + y] = {
            user: j,
            mate: y,
            emoji: Y(H),
            from: $.pos,
            to: L.pos,
            arrow: qt($.pos, L.pos, E)
          });
        } else
          delete R[j + y];
      }
    }
  }), {
    space: h,
    allGuests: v,
    guests: M,
    guestCount: W,
    links: R,
    plane: n,
    width: s,
    height: r,
    pos: c,
    zoom: i,
    area: a,
    join: l,
    place: m
  };
}
function qt(e, t, n = 0) {
  let a = nt(e.x, e.y, t.x, t.y, {
    padEnd: 20,
    padStart: 10
  });
  const [o, s, r, c, i, u, p, h, l, m] = a;
  return {
    sx: o,
    sy: s,
    c1x: r * (1 - n + 2 * n),
    c1y: c * (1 - n + 2 * n),
    c2x: i * (1 - n + 2 * n),
    c2y: u * (1 - n + 2 * n),
    ex: p,
    ey: h,
    ae: l,
    as: m
  };
}
const F = d({
  colors: [
    "#000000",
    ...new Array(12).fill(!0).map((e, t) => `hsl(${t * 30}, 100%,50%)`),
    "#ffffff"
  ],
  sizes: at([4, 8, 16, 24]),
  modes: ["line", "arrow", "stylus", "rectangle", "ellipse"],
  mode: g({
    get() {
      return je.value;
    },
    set(e) {
      je.value = e, e === "arrow" ? (I.mode = "line", I.arrowEnd = !0) : (I.mode = e, I.arrowEnd = !1);
    }
  }),
  enabled: !1,
  pinned: _("drawing-pinned", !1),
  canUndo: !1,
  canRedo: !1,
  canClear: !1,
  ing: !1,
  initiated: !1,
  content: ""
}), I = ot(_("drawing-brush", {
  color: F.colors[0],
  size: 10,
  mode: "stylus"
})), je = P("stylus");
let de = !1;
const Wt = d({
  brush: I,
  acceptsInputTypes: g(() => F.enabled ? void 0 : ["pen"])
}), N = st(rt(Wt));
function re(e) {
  de = !0, F.content != null ? N.load(F.content) : N.clear(), de = !1;
}
function Ht() {
  var e;
  F.canRedo = N.canRedo(), F.canUndo = N.canUndo(), F.canClear = !!((e = N.el) != null && e.children.length);
}
function wa() {
  if (!F.initiated) {
    const e = w(), { user: t } = x(), n = e.user(f.pub).get("space").get(t.pub).get("draw");
    n.on((o) => {
      F.ing || (F.content = o, re());
    });
    const a = ct(() => {
      var o;
      if (Ht(), !de) {
        let s = N.dump();
        F.content = s, e.user(f.pub).get("space").get(t.pub).get("draw").put(s, null, { opt: { cert: (o = f.features) == null ? void 0 : o.space } });
      }
    }, 200);
    N.on("changed", a), ge(() => {
      it(() => {
        re();
      });
    }), N.on("start", () => F.ing = !0), N.on("end", () => F.ing = !1), F.clear = () => {
      var o;
      N.clear(), F.content = "", n.put("", null, { opt: { cert: (o = f.features) == null ? void 0 : o.space } });
    }, window.addEventListener("keydown", (o) => {
      if (!F.enabled)
        return;
      const s = !o.ctrlKey && !o.altKey && !o.shiftKey && !o.metaKey;
      let r = !0;
      o.code === "KeyZ" && (o.ctrlKey || o.metaKey) ? o.shiftKey ? N.redo() : N.undo() : o.code === "Escape" ? F.enabled = !1 : o.code === "KeyC" && (o.ctrlKey || o.metaKey) ? F.clear() : o.code.startsWith("Digit") && s && +o.code[5] <= brushColors.length ? I.color = brushColors[+o.code[5] - 1] : r = !1, r && (o.preventDefault(), o.stopPropagation());
    }, !1);
  }
  return F.initiated = !0, {
    brush: I,
    draw: F,
    drauu: N,
    loadCanvas: re
  };
}
export {
  Sa as SEA,
  Rn as addHashedPersonal,
  Kn as addPersonal,
  Et as addPost,
  Vn as addProfileField,
  ne as auth,
  Pt as base64Extension,
  At as base64FileType,
  An as base64MimeType,
  I as brush,
  ha as countProjects,
  Mn as countRating,
  Ot as createMd,
  he as createRoom,
  f as currentRoom,
  cn as decFrom,
  ra as defaultGift,
  Te as defaultPeer,
  be as detectMimeType,
  le as dictLang,
  G as dictRecord,
  Rt as downloadFeed,
  kt as downloadFile,
  xt as downloadPost,
  N as drauu,
  Wt as drauuOptions,
  F as draw,
  rn as encFor,
  Lt as enterRoom,
  la as formatDate,
  ht as genUUID,
  ve as generateCerts,
  Y as getFirstEmoji,
  Cn as getHashedPersonal,
  un as getShortHash,
  C as giftPath,
  oa as giftState,
  S as gun,
  ae as gun2,
  ka as gunAvatar,
  ta as hasPass,
  X as hashObj,
  q as hashText,
  Bt as isEmoji,
  sn as isHash,
  Xn as isMine,
  Be as isPair,
  Me as issueCert,
  zn as joinRoom,
  yn as langParts,
  Sn as languages,
  Kt as leave,
  Gt as leaveRoom,
  $e as letterFilter,
  Mt as listPersonal,
  xn as listPersonalTag,
  re as loadCanvas,
  ye as loadFromHash,
  vt as loadRelays,
  ua as logEvent,
  ja as mountClass,
  Aa as mountElement,
  Pa as ms,
  U as newProject,
  Yt as newWorker,
  pe as parseHashLink,
  _n as parseLink,
  Dt as parseMd,
  On as parsePost,
  A as pass,
  J as peer,
  B as projectsPath,
  Tt as reactToPost,
  In as recreateRoom,
  T as relay,
  ma as removeProject,
  bn as renderStress,
  z as rootRoom,
  wt as safeHash,
  fn as safeJSONParse,
  Hn as selectedUser,
  Oa as slugify,
  ia as sortByDate,
  an as soul,
  $t as submitRoom,
  ln as unsafeHash,
  Qn as updateProfile,
  fa as updateProject,
  da as updateProjectField,
  fe as updateRoomProfile,
  Ht as updateState,
  Ct as uploadFeed,
  kn as uploadText,
  dt as useAccount,
  Vt as useBackground,
  Qt as useChat,
  Ne as useColor,
  mn as useDefs,
  vn as useDictAuthors,
  wn as useDictLangs,
  hn as useDictRecordsBy,
  pn as useDictRecordsFor,
  wa as useDraw,
  aa as useGift,
  Jn as useGifts,
  Un as useGuests,
  w as useGun,
  pt as useGun2,
  ca as useLog,
  Wn as useMate,
  qn as useMates,
  Pn as useMd,
  Yn as useMyGifts,
  sa as useNewGift,
  ea as usePass,
  na as usePassLink,
  jn as usePictureUpload,
  Ft as usePost,
  Dn as usePostTimestamp,
  Fn as usePosts,
  _t as usePrivateChat,
  en as usePrivateChatCount,
  tn as usePrivateChatList,
  ga as useProject,
  Zn as useProjectGifts,
  pa as useProjects,
  Nn as useReaction,
  Tn as useReactions,
  nn as useRelay,
  on as useRelays,
  Ln as useRoom,
  Gn as useRoomLogo,
  Bn as useRooms,
  va as useSpace,
  ut as useSvgMouse,
  En as useTagList,
  x as useUser,
  $n as useUserPosts,
  gn as useWord,
  dn as useWords,
  Ge as useZip,
  b as user
};
//# sourceMappingURL=composables.mjs.map
