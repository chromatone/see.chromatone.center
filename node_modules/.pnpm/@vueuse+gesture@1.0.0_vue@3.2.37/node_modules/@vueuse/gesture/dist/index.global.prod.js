/*!
  * @vueuse/gesture v1.0.0
  * (c) 2021 
  * @license MIT
  */
var VueuseGesture=function(t,e){"use strict";function n(){return"undefined"!=typeof window&&"ontouchstart"in window}function s(t){return"pointerId"in t?null:"touchend"===t.type?t.changedTouches:t.targetTouches}function i(t){return Array.from(s(t)).map((t=>t.identifier))}function r(t){const e="buttons"in t?t.buttons:0,{shiftKey:n,altKey:s,metaKey:i,ctrlKey:r}=t;return{buttons:e,shiftKey:n,altKey:s,metaKey:i,ctrlKey:r}}const o=t=>t;function a(t,e=o){const n=s(t),{clientX:i,clientY:r}=n?n[0]:t;return e([i,r])}function h(t,e,n=o){const[s,i]=Array.from(t.touches).filter((t=>e.includes(t.identifier)));if(!s||!i)throw Error("The event doesn't have two pointers matching the pointerIds");const r=i.clientX-s.clientX,a=i.clientY-s.clientY,h=(i.clientX+s.clientX)/2,c=(i.clientY+s.clientY)/2;return{values:n([Math.hypot(r,a),-180*Math.atan2(r,a)/Math.PI]),origin:n([h,c])}}function c(t,e=o){let{deltaX:n,deltaY:s,deltaMode:i}=t;return 1===i?(n*=40,s*=40):2===i&&(n*=800,s*=800),e([n,s])}function l(t,e=o){return e([t.scale,t.rotation])}function u(){}function d(...t){return 0===t.length?u:1===t.length?t[0]:function(){var e;for(let n of t)e=n.apply(this,arguments)||e;return e}}function v(t,e){if(void 0===t){if(void 0===e)throw new Error("Must define fallback value if undefined is expected");t=e}return Array.isArray(t)?t:[t,t]}function f(t,e){return Object.assign({},e,t||{})}function g(t,...e){return"function"==typeof t?t(...e):t}function p(t){return{_active:!1,_blocked:!1,_intentional:[!1,!1],_movement:[0,0],_initial:[0,0],_bounds:[[-1/0,1/0],[-1/0,1/0]],_lastEventType:void 0,_dragStarted:!1,_dragPreventScroll:!1,_dragIsTap:!0,_dragDelayed:!1,event:void 0,intentional:!1,values:[0,0],velocities:[0,0],delta:[0,0],movement:[0,0],offset:[0,0],lastOffset:[0,0],direction:[0,0],initial:[0,0],previous:[0,0],first:!1,last:!1,active:!1,timeStamp:0,startTime:0,elapsedTime:0,cancel:u,canceled:!1,memo:void 0,args:void 0,...t}}function m(){return{shared:{hovering:!1,scrolling:!1,wheeling:!1,dragging:!1,moving:!1,pinching:!1,touches:0,buttons:0,down:!1,shiftKey:!1,altKey:!1,metaKey:!1,ctrlKey:!1,locked:!1},drag:p({_pointerId:void 0,axis:void 0,xy:[0,0],vxvy:[0,0],velocity:0,distance:0,tap:!1,swipe:[0,0]}),pinch:p({_pointerIds:[],da:[0,0],vdva:[0,0],origin:void 0,turns:0}),wheel:p({axis:void 0,xy:[0,0],vxvy:[0,0],velocity:0,distance:0}),move:p({axis:void 0,xy:[0,0],vxvy:[0,0],velocity:0,distance:0}),scroll:p({axis:void 0,xy:[0,0],vxvy:[0,0],velocity:0,distance:0})}}class S{constructor(t){this.classes=t,this.pointerIds=new Set,this.touchIds=new Set,this.supportsTouchEvents=n(),this.supportsGestureEvents=function(){try{return"constructor"in GestureEvent}catch(t){return!1}}(),this.bind=(...t)=>{const n={};for(let e of this.classes)new e(this,t).addBindings(n);for(let e in this.nativeRefs)_(n,e,(n=>this.nativeRefs[e]({...this.state.shared,event:n,args:t})));return this.config.domTarget?function({config:t,domListeners:n},s){const{eventOptions:i,domTarget:r}=t,o=e.unref(r);if(!o)throw new Error("domTarget must be defined");E(o,y(n),i);for(let[t,e]of Object.entries(s)){const s=t.slice(2).toLowerCase();n.push([s,d(...e)])}T(o,n,i)}(this,n):function({config:t},e){const n={},s=t.eventOptions.capture?"Capture":"";for(let[t,i]of Object.entries(e)){const e=Array.isArray(i)?i:[i];n[t+s]=d(...e)}return n}(this,n)},this.clean=()=>{const{eventOptions:t,domTarget:n}=this.config,s=e.unref(n);s&&E(s,y(this.domListeners),t),Object.values(this.timeouts).forEach(clearTimeout),function(t){const{config:{window:n,eventOptions:s},windowListeners:i}=t,r=e.unref(n);if(!r)return;for(let t in i){E(r,i[t],s)}t.windowListeners={}}(this)},this.classes=t,this.state=m(),this.timeouts={},this.domListeners=[],this.windowListeners={}}}function w(t,e){"pointerId"in e?t.pointerIds.add(e.pointerId):t.touchIds=new Set(i(e))}function b(t,e){"pointerId"in e?t.pointerIds.delete(e.pointerId):i(e).forEach((e=>t.touchIds.delete(e)))}function y(t=[]){return t.splice(0,t.length)}function _(t,e,n){t[e]||(t[e]=[]),t[e].push(n)}function T(t,e=[],n={}){if(t)for(let[s,i]of e)t.addEventListener(s,i,n)}function E(t,e=[],n={}){if(t)for(let[s,i]of e)t.removeEventListener(s,i,n)}function G(t,e){return t.map(((t,n)=>t+e[n]))}function M(t,e){return t.map(((t,n)=>t-e[n]))}function D(t){return Math.hypot(...t)}function x(t,e=t){const n=D(e),s=0===n?0:1/n,i=e.map((t=>s*t));return{distance:D(t),direction:i}}function O(t,e,n){const s=D(e),i=0===s?0:1/s,r=0===n?0:1/n,o=r*s,a=e.map((t=>r*t)),h=e.map((t=>i*t));return{velocities:a,velocity:o,distance:D(t),direction:h}}function P(t){return Math.sign?Math.sign(t):Number(t>0)-Number(t<0)||+t}function I(t,e,n){return 0===e||Math.abs(e)===1/0?function(t,e){return Math.pow(t,5*e)}(t,n):t*e*n/(e+n*t)}function K(t,e,n,s=.15){return 0===s?function(t,e,n){return Math.max(e,Math.min(t,n))}(t,e,n):t<e?-I(e-t,n-e,s)+e:t>n?+I(t-n,n-e,s)+n:t}const C=new Map,k=t=>t;class H{constructor(t,e=[]){this.controller=t,this.args=e,this.debounced=!0,this.setTimeout=(t,e=140,...n)=>{clearTimeout(this.controller.timeouts[this.stateKey]),this.controller.timeouts[this.stateKey]=window.setTimeout(t,e,...n)},this.clearTimeout=()=>{clearTimeout(this.controller.timeouts[this.stateKey])},this.fireGestureHandler=(t=!1)=>{if(this.state._blocked)return this.debounced||(this.state._active=!1,this.clean()),null;if(!t&&!this.state.intentional&&!this.config.triggerAllEvents)return null;if(this.state.intentional){const t=this.state.active,e=this.state._active;this.state.active=e,this.state.first=e&&!t,this.state.last=t&&!e,this.controller.state.shared[this.ingKey]=e}const e=this.controller.pointerIds.size||this.controller.touchIds.size,n=this.controller.state.shared.buttons>0||e>0,s={...this.controller.state.shared,...this.state,...this.mapStateValues(this.state),locked:!!document.pointerLockElement,touches:e,down:n},i=this.handler(s);return this.state.memo=void 0!==i?i:this.state.memo,s},this.controller=t,this.args=e}get config(){return this.controller.config[this.stateKey]}get enabled(){return this.controller.config.enabled&&this.config.enabled}get state(){return this.controller.state[this.stateKey]}get handler(){return this.controller.handlers[this.stateKey]}get transform(){return this.config.transform||this.controller.config.transform||k}updateSharedState(t){Object.assign(this.controller.state.shared,t)}updateGestureState(t){Object.assign(this.state,t)}checkIntentionality(t,e){return{_intentional:t,_blocked:!1}}getMovement(t){const{rubberband:e,threshold:n}=this.config,{_bounds:s,_initial:i,_active:r,_intentional:o,lastOffset:a,movement:h}=this.state,c=this.getInternalMovement(t,this.state),l=this.transform(n).map(Math.abs),u=!1===o[0]?W(c[0],l[0]):o[0],d=!1===o[1]?W(c[1],l[1]):o[1],v=this.checkIntentionality([u,d],c);if(v._blocked)return{...v,_movement:c,delta:[0,0]};const f=v._intentional,g=c;let p=[!1!==f[0]?c[0]-f[0]:0,!1!==f[1]?c[1]-f[1]:0];const m=G(p,a),S=r?e:[0,0];return p=L(s,G(p,i),S),{...v,intentional:!1!==f[0]||!1!==f[1],_initial:i,_movement:g,movement:p,values:t,offset:L(s,m,S),delta:M(p,h)}}clean(){this.clearTimeout()}}function W(t,e){return Math.abs(t)>=e&&P(t)*e}function L(t,[e,n],[s,i]){const[[r,o],[a,h]]=t;return[K(e,r,o,s),K(n,a,h,i)]}function j({state:t},e,n){const{timeStamp:s,type:i}=e;return{_lastEventType:i,event:e,timeStamp:s,elapsedTime:n?0:s-t.startTime,previous:t.values}}function V({state:t,config:e,stateKey:n,args:s},i,r){const o=t.offset,a=r.timeStamp,{initial:h,bounds:c}=e,l={...m()[n],_active:!0,args:s,values:i,initial:i,offset:o,lastOffset:o,startTime:a};return{...l,_initial:g(h,l),_bounds:g(c,l)}}class Y extends H{getInternalMovement(t,e){return M(t,e.initial)}checkIntentionality(t,e){if(!1===t[0]&&!1===t[1])return{_intentional:t,axis:this.state.axis};const[n,s]=e.map(Math.abs),i=this.state.axis||(n>s?"x":n<s?"y":void 0);return this.config.axis||this.config.lockDirection?i?this.config.axis&&i!==this.config.axis?{_intentional:t,_blocked:!0,axis:i}:(t["x"===i?1:0]=!1,{_intentional:t,_blocked:!1,axis:i}):{_intentional:[!1,!1],_blocked:!1,axis:i}:{_intentional:t,_blocked:!1,axis:i}}getKinematics(t,e){const n=this.getMovement(t);if(!n._blocked){Object.assign(n,O(n.movement,n.delta,e.timeStamp-this.state.timeStamp))}return n}mapStateValues(t){return{xy:t.values,vxvy:t.velocities}}}function X(t){"persist"in t&&"function"==typeof t.persist&&t.persist()}class A extends Y{constructor(){super(...arguments),this.ingKey="dragging",this.stateKey="drag",this.setPointerCapture=t=>{if(this.config.useTouch||document.pointerLockElement)return;const{target:e,pointerId:n}=t;e&&"setPointerCapture"in e&&e.setPointerCapture(n),this.updateGestureState({_dragTarget:e,_dragPointerId:n})},this.releasePointerCapture=()=>{if(this.config.useTouch||document.pointerLockElement)return;const{_dragTarget:t,_dragPointerId:e}=this.state;if(e&&t&&"releasePointerCapture"in t&&(!("hasPointerCapture"in t)||t.hasPointerCapture(e)))try{t.releasePointerCapture(e)}catch(t){}},this.preventScroll=t=>{this.state._dragPreventScroll&&t.cancelable&&t.preventDefault()},this.getEventId=t=>this.config.useTouch?t.changedTouches[0].identifier:t.pointerId,this.isValidEvent=t=>this.state._pointerId===this.getEventId(t),this.shouldPreventWindowScrollY=this.config.preventWindowScrollY&&this.controller.supportsTouchEvents,this.setUpWindowScrollDetection=t=>{X(t),function({config:t,windowListeners:n},s,i=[],r=t.eventOptions){const o=e.unref(t.window);o&&(E(o,n[s],r),T(o,n[s]=i,r))}(this.controller,this.stateKey,[["touchmove",this.preventScroll],["touchend",this.clean.bind(this)],["touchcancel",this.clean.bind(this)]],{passive:!1}),this.setTimeout(this.startDrag.bind(this),250,t)},this.setUpDelayedDragTrigger=t=>{this.state._dragDelayed=!0,X(t),this.setTimeout(this.startDrag.bind(this),this.config.delay,t)},this.setStartState=t=>{const e=a(t,this.transform);this.updateSharedState(r(t)),this.updateGestureState({...V(this,e,t),...j(this,t,!0),_pointerId:this.getEventId(t)}),this.updateGestureState(this.getMovement(e))},this.onDragStart=t=>{w(this.controller,t),this.enabled&&!this.state._active&&(this.setStartState(t),this.setPointerCapture(t),this.shouldPreventWindowScrollY?this.setUpWindowScrollDetection(t):this.config.delay>0?this.setUpDelayedDragTrigger(t):this.startDrag(t,!0))},this.onDragChange=t=>{if(this.state.canceled||!this.state._active||!this.isValidEvent(t)||this.state._lastEventType===t.type&&t.timeStamp===this.state.timeStamp)return;let e;if(document.pointerLockElement){const{movementX:n,movementY:s}=t;e=G(this.transform([n,s]),this.state.values)}else e=a(t,this.transform);const n=this.getKinematics(e,t);if(!this.state._dragStarted){if(this.state._dragDelayed)return void this.startDrag(t);if(!this.shouldPreventWindowScrollY)return;if(this.state._dragPreventScroll||!n.axis)return;if("x"!==n.axis)return void(this.state._active=!1);this.startDrag(t)}const s=r(t);this.updateSharedState(s);const i=j(this,t),o=D(n._movement);let{_dragIsTap:h}=this.state;h&&o>=3&&(h=!1),this.updateGestureState({...i,...n,_dragIsTap:h}),this.fireGestureHandler()},this.onDragEnd=t=>{if(b(this.controller,t),!this.isValidEvent(t))return;if(this.clean(),!this.state._active)return;this.state._active=!1;const e=this.state._dragIsTap,[n,s]=this.state.velocities,[i,r]=this.state.movement,[o,a]=this.state._intentional,[h,c]=this.config.swipeVelocity,[l,u]=this.config.swipeDistance,d=this.config.swipeDuration,v={...j(this,t),...this.getMovement(this.state.values)},f=[0,0];v.elapsedTime<d&&(!1!==o&&Math.abs(n)>h&&Math.abs(i)>l&&(f[0]=P(n)),!1!==a&&Math.abs(s)>c&&Math.abs(r)>u&&(f[1]=P(s))),this.updateSharedState({buttons:0}),this.updateGestureState({...v,tap:e,swipe:f}),this.fireGestureHandler(this.config.filterTaps&&!0===e)},this.clean=()=>{super.clean(),this.state._dragStarted=!1,this.releasePointerCapture(),function({config:t,windowListeners:n},s,i=t.eventOptions){const r=e.unref(t.window);r&&(E(r,n[s],i),delete n[s])}(this.controller,this.stateKey)},this.onCancel=()=>{this.state.canceled||(this.updateGestureState({canceled:!0,_active:!1}),this.updateSharedState({buttons:0}),e.nextTick(this.fireGestureHandler))},this.onClick=t=>{this.state._dragIsTap||t.stopPropagation()}}startDrag(t,e=!1){this.state._active&&!this.state._dragStarted&&(e||this.setStartState(t),this.updateGestureState({_dragStarted:!0,_dragPreventScroll:!0,cancel:this.onCancel}),this.clearTimeout(),this.fireGestureHandler())}addBindings(t){if(this.config.useTouch?(_(t,"onTouchStart",this.onDragStart),_(t,"onTouchMove",this.onDragChange),_(t,"onTouchEnd",this.onDragEnd),_(t,"onTouchCancel",this.onDragEnd)):(_(t,"onPointerDown",this.onDragStart),_(t,"onPointerMove",this.onDragChange),_(t,"onPointerUp",this.onDragEnd),_(t,"onPointerCancel",this.onDragEnd)),this.config.filterTaps){_(t,this.controller.config.eventOptions.capture?"onClick":"onClickCapture",this.onClick)}}}function B(t,e){let n,s,i=[],r=!1;return function(...o){return r&&n===this&&e(o,i)||(s=t.apply(this,o),r=!0,n=this,i=o),s}}function z(t,e){if(t===e)return!0;if(t&&e&&"object"==typeof t&&"object"==typeof e){if(t.constructor!==e.constructor)return!1;let n,s,i,r;if(Array.isArray(t)){if(n=t.length,n!==e.length)return!1;for(s=n;0!=s--;)if(!z(t[s],e[s]))return!1;return!0}if("function"==typeof Map&&t instanceof Map&&e instanceof Map){if(t.size!==e.size)return!1;for(r=t.entries();!(s=r.next()).done;)if(!e.has(s.value[0]))return!1;for(r=t.entries();!(s=r.next()).done;)if(!z(s.value[1],e.get(s.value[0])))return!1;return!0}if("function"==typeof Set&&t instanceof Set&&e instanceof Set){if(t.size!==e.size)return!1;for(r=t.entries();!(s=r.next()).done;)if(!e.has(s.value[0]))return!1;return!0}if(t.constructor===RegExp)return t.source===e.source&&t.flags===e.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===e.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===e.toString();if(i=Object.keys(t),n=i.length,n!==Object.keys(e).length)return!1;for(s=n;0!=s--;)if(!Object.prototype.hasOwnProperty.call(e,i[s]))return!1;if("undefined"!=typeof Element&&t instanceof Element)return!1;for(s=n;0!=s--;)if(!("_owner"===i[s]&&t.$$typeof||z(t[i[s]],e[i[s]])))return!1;return!0}return t!=t&&e!=e}function R(t,e){try{return z(t,e)}catch(t){if((t.message||"").match(/stack|recursion/i))return console.warn("react-fast-compare cannot handle circular refs"),!1;throw t}}function U(t={},e){const n={};for(const[s,i]of Object.entries(e))switch(typeof i){case"function":n[s]=i.call(n,t[s],s,t);break;case"object":n[s]=U(t[s],i);break;case"boolean":i&&(n[s]=t[s])}return n}const N={threshold:(t=0)=>v(t),rubberband(t=0){switch(t){case!0:return v(.15);case!1:return v(0);default:return v(t)}},enabled:(t=!0)=>t,triggerAllEvents:(t=!1)=>t,initial:(t=0)=>"function"==typeof t?t:v(t),transform:!0},F={...N,axis:!0,lockDirection:(t=!1)=>t,bounds(t={}){if("function"==typeof t)return e=>F.bounds(t(e));const{left:e=-1/0,right:n=1/0,top:s=-1/0,bottom:i=1/0}=t;return[[e,n],[s,i]]}},$="undefined"!=typeof window&&window.document&&window.document.createElement,q={enabled:(t=!0)=>t,domTarget:!0,window:(t=($?window:void 0))=>t,eventOptions:({passive:t=!0,capture:e=!1}={})=>({passive:t,capture:e}),transform:!0},J={...N,bounds(t,e,{distanceBounds:n={},angleBounds:s={}}){const i=t=>{const e=f(g(n,t),{min:-1/0,max:1/0});return[e.min,e.max]},r=t=>{const e=f(g(s,t),{min:-1/0,max:1/0});return[e.min,e.max]};return"function"!=typeof n&&"function"!=typeof s?[i(),r()]:t=>[i(t),r(t)]}},Q={...F,useTouch:(t=!0)=>t&&n(),preventWindowScrollY:(t=!1)=>t,threshold(t,e,{filterTaps:n=!1,lockDirection:s=!1,axis:i}){const r=v(t,n?3:s||i?1:0);return this.filterTaps=n,r},swipeVelocity:(t=.5)=>v(t),swipeDistance:(t=50)=>v(t),swipeDuration:(t=250)=>t,delay(t=0){switch(t){case!0:return 180;case!1:return 0;default:return t}}};function Z(t){return U(t,q)}function tt(t={}){return U(t,F)}function et(t={}){return U(t,J)}function nt(t={}){return U(t,Q)}function st({domTarget:t,eventOptions:e,window:n,enabled:s,...i}){const r=Z({domTarget:t,eventOptions:e,window:n,enabled:s});return r.move=tt(i),r}function it({domTarget:t,eventOptions:e,window:n,enabled:s,...i}){const r=Z({domTarget:t,eventOptions:e,window:n,enabled:s});return r.hover={enabled:!0,...i},r}function rt({domTarget:t,eventOptions:e,window:n,enabled:s,...i}){const r=Z({domTarget:t,eventOptions:e,window:n,enabled:s});return r.drag=nt(i),r}function ot({domTarget:t,eventOptions:e,window:n,enabled:s,...i}){const r=Z({domTarget:t,eventOptions:e,window:n,enabled:s});return r.pinch=et(i),r}function at({domTarget:t,eventOptions:e,window:n,enabled:s,...i}){const r=Z({domTarget:t,eventOptions:e,window:n,enabled:s});return r.scroll=tt(i),r}function ht({domTarget:t,eventOptions:e,window:n,enabled:s,...i}){const r=Z({domTarget:t,eventOptions:e,window:n,enabled:s});return r.wheel=tt(i),r}function ct(t,n,s={}){const i=function(t){const e=new Set;t.drag&&e.add(C.get("drag"));t.wheel&&e.add(C.get("wheel"));t.scroll&&e.add(C.get("scroll"));t.move&&e.add(C.get("move"));t.pinch&&e.add(C.get("pinch"));t.hover&&e.add(C.get("hover"));return e}(t),r=new S(i);return r.config=n,r.handlers=t,r.nativeRefs=s,e.getCurrentInstance()&&!n.manual&&(e.onMounted(r.bind),e.onUnmounted(r.clean)),r}function lt(t,n={}){C.set("drag",A);const s=e.ref();return s.value||(s.value=B(rt,R)),ct({drag:t},s.value(n))}class ut extends Y{constructor(){super(...arguments),this.ingKey="moving",this.stateKey="move",this.debounced=!0,this.onMove=t=>{this.enabled&&(this.setTimeout(this.onMoveEnd),this.state._active?this.onMoveChange(t):this.onMoveStart(t))},this.onMoveStart=t=>{this.updateSharedState(r(t));const e=a(t,this.transform);this.updateGestureState({...V(this,e,t),...j(this,t,!0)}),this.updateGestureState(this.getMovement(e)),this.fireGestureHandler()},this.onMoveChange=t=>{this.updateSharedState(r(t));const e=a(t,this.transform);this.updateGestureState({...j(this,t),...this.getKinematics(e,t)}),this.fireGestureHandler()},this.onMoveEnd=()=>{if(this.clean(),!this.state._active)return;this.updateGestureState(this.getMovement(this.state.values)),this.updateGestureState({velocities:[0,0],velocity:0,_active:!1}),this.fireGestureHandler()},this.hoverTransform=()=>this.controller.config.hover.transform||this.controller.config.transform,this.onPointerEnter=t=>{if(this.controller.state.shared.hovering=!0,this.controller.config.enabled){if(this.controller.config.hover.enabled){const e=a(t,this.hoverTransform()),n={...this.controller.state.shared,...this.state,...j(this,t,!0),args:this.args,values:e,active:!0,hovering:!0};this.controller.handlers.hover({...n,...this.mapStateValues(n)})}"move"in this.controller.handlers&&this.onMoveStart(t)}},this.onPointerLeave=t=>{if(this.controller.state.shared.hovering=!1,"move"in this.controller.handlers&&this.onMoveEnd(),!this.controller.config.hover.enabled)return;const e=a(t,this.hoverTransform()),n={...this.controller.state.shared,...this.state,...j(this,t),args:this.args,values:e,active:!1};this.controller.handlers.hover({...n,...this.mapStateValues(n)})}}addBindings(t){"move"in this.controller.handlers&&_(t,"onPointerMove",this.onMove),"hover"in this.controller.handlers&&(_(t,"onPointerEnter",this.onPointerEnter),_(t,"onPointerLeave",this.onPointerLeave))}}class dt extends H{getInternalMovement(t,e){const n=e.values[1];let[s,i=n]=t,r=i-n,o=e.turns;return Math.abs(r)>270&&(o+=P(r)),M([s,i-360*o],e.initial)}getKinematics(t,e){const n=this.getMovement(t),s=(t[1]-n._movement[1]-this.state.initial[1])/360,i=e.timeStamp-this.state.timeStamp,{distance:r,velocity:o,...a}=O(n.movement,n.delta,i);return{turns:s,...n,...a}}mapStateValues(t){return{da:t.values,vdva:t.velocities}}}class vt extends dt{constructor(){super(...arguments),this.ingKey="pinching",this.stateKey="pinch",this.onPinchStart=t=>{w(this.controller,t);const e=this.controller.touchIds;if(!this.enabled)return;if(this.state._active&&this.state._pointerIds.every((t=>e.has(t))))return;if(e.size<2)return;const n=Array.from(e).slice(0,2),{values:s,origin:i}=h(t,n,this.transform);this.updateSharedState(r(t)),this.updateGestureState({...V(this,s,t),...j(this,t,!0),_pointerIds:n,cancel:this.onCancel,origin:i}),this.updateGestureState(this.getMovement(s)),this.fireGestureHandler()},this.onPinchChange=t=>{const{canceled:e,_active:n}=this.state;if(e||!n||t.timeStamp===this.state.timeStamp)return;const s=r(t);this.updateSharedState(s);try{const{values:e,origin:n}=h(t,this.state._pointerIds,this.transform),s=this.getKinematics(e,t);this.updateGestureState({...j(this,t),...s,origin:n}),this.fireGestureHandler()}catch(e){this.onPinchEnd(t)}},this.onPinchEnd=t=>{b(this.controller,t);const e=i(t);this.state._pointerIds.every((t=>!e.includes(t)))||(this.clean(),this.state._active&&(this.updateGestureState({...j(this,t),...this.getMovement(this.state.values),_active:!1}),this.fireGestureHandler()))},this.onCancel=()=>{this.state.canceled||(this.updateGestureState({_active:!1,canceled:!0}),this.fireGestureHandler())},this.onGestureStart=t=>{if(!this.enabled)return;t.preventDefault();const e=l(t,this.transform);this.updateSharedState(r(t)),this.updateGestureState({...V(this,e,t),...j(this,t,!0),origin:[t.clientX,t.clientY],cancel:this.onCancel}),this.updateGestureState(this.getMovement(e)),this.fireGestureHandler()},this.onGestureChange=t=>{const{canceled:e,_active:n}=this.state;if(e||!n)return;t.preventDefault();const s=r(t);this.updateSharedState(s);const i=l(t,this.transform);i[0]=260*(i[0]-this.state.event.scale)+this.state.values[0];const o=this.getKinematics(i,t);this.updateGestureState({...j(this,t),...o,origin:[t.clientX,t.clientY]}),this.fireGestureHandler()},this.onGestureEnd=t=>{this.clean(),this.state._active&&(this.updateGestureState({...j(this,t),...this.getMovement(this.state.values),_active:!1,origin:[t.clientX,t.clientY]}),this.fireGestureHandler())},this.wheelShouldRun=t=>this.enabled&&t.ctrlKey,this.getWheelValuesFromEvent=t=>{const[,e]=c(t,this.transform),{values:[n,s]}=this.state;return{values:[n-7*e,void 0!==s?s:0],origin:[t.clientX,t.clientY],delta:[0,e]}},this.onWheel=t=>{this.wheelShouldRun(t)&&(this.setTimeout(this.onWheelEnd),this.state._active?this.onWheelChange(t):this.onWheelStart(t))},this.onWheelStart=t=>{const{values:e,delta:n,origin:s}=this.getWheelValuesFromEvent(t);t.cancelable?t.preventDefault():"development"===process.env.NODE_ENV&&console.warn("To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode."),this.updateSharedState(r(t)),this.updateGestureState({...V(this,e,t),...j(this,t,!0),initial:this.state.values,offset:e,delta:n,origin:s}),this.updateGestureState(this.getMovement(e)),this.fireGestureHandler()},this.onWheelChange=t=>{t.cancelable&&t.preventDefault(),this.updateSharedState(r(t));const{values:e,origin:n,delta:s}=this.getWheelValuesFromEvent(t);this.updateGestureState({...j(this,t),...this.getKinematics(e,t),origin:n,delta:s}),this.fireGestureHandler()},this.onWheelEnd=()=>{this.clean(),this.state._active&&(this.state._active=!1,this.updateGestureState(this.getMovement(this.state.values)),this.fireGestureHandler())}}addBindings(t){this.controller.config.domTarget&&!this.controller.supportsTouchEvents&&this.controller.supportsGestureEvents?(_(t,"onGestureStart",this.onGestureStart),_(t,"onGestureChange",this.onGestureChange),_(t,"onGestureEnd",this.onGestureEnd)):(_(t,"onTouchStart",this.onPinchStart),_(t,"onTouchMove",this.onPinchChange),_(t,"onTouchEnd",this.onPinchEnd),_(t,"onTouchCancel",this.onPinchEnd),_(t,"onWheel",this.onWheel))}}class ft extends Y{constructor(){super(...arguments),this.ingKey="scrolling",this.stateKey="scroll",this.debounced=!0,this.handleEvent=t=>{if(!this.enabled)return;this.clearTimeout(),this.setTimeout(this.onEnd);const e=function(t,e=o){const{scrollX:n,scrollY:s,scrollLeft:i,scrollTop:r}=t.currentTarget;return e([n||i||0,s||r||0])}(t,this.transform);if(this.updateSharedState(r(t)),this.state._active)this.updateGestureState({...j(this,t),...this.getKinematics(e,t)});else{this.updateGestureState({...V(this,e,t),...j(this,t,!0),initial:this.state.values});const n=this.getMovement(e),s=x(n.delta);this.updateGestureState(n),this.updateGestureState(s)}this.fireGestureHandler()},this.onEnd=()=>{this.clean(),this.state._active&&(this.updateGestureState({...this.getMovement(this.state.values),_active:!1,velocities:[0,0],velocity:0}),this.fireGestureHandler())}}addBindings(t){_(t,"onScroll",this.handleEvent)}}class gt extends Y{constructor(){super(...arguments),this.ingKey="wheeling",this.stateKey="wheel",this.debounced=!0,this.handleEvent=t=>{if(t.ctrlKey&&"pinch"in this.controller.handlers)return;if(!this.enabled)return;this.setTimeout(this.onEnd),this.updateSharedState(r(t));const e=G(c(t,this.transform),this.state.values);if(this.state._active)this.updateGestureState({...j(this,t),...this.getKinematics(e,t)});else{this.updateGestureState({...V(this,e,t),...j(this,t,!0),initial:this.state.values});const n=this.getMovement(e),s=x(n.delta);this.updateGestureState(n),this.updateGestureState(s)}this.fireGestureHandler()},this.onEnd=()=>{if(this.clean(),!this.state._active)return;const t=this.getMovement(this.state.values);this.updateGestureState(t),this.updateGestureState({_active:!1,velocities:[0,0],velocity:0}),this.fireGestureHandler()}}addBindings(t){_(t,"onWheel",this.handleEvent)}}const pt=/^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;function mt(t,e){const n=e+"Start",s=e+"End";return i=>{let r;return i.first&&n in t&&t[n](i),e in t&&(r=t[e](i)),i.last&&s in t&&t[s](i),r}}function St(t,n={}){C.set("hover",ut);const s=e.ref();return s.value||(s.value=B(it,R)),ct({hover:t},s.value(n))}function wt(t,n={}){C.set("move",ut);const s=e.ref();return s.value||(s.value=B(st,R)),ct({move:t},s.value(n))}function bt(t,n={}){C.set("pinch",vt);const s=e.ref();return s.value||(s.value=B(ot,R)),ct({pinch:t},s.value(n))}function yt(t,n={}){C.set("scroll",ft);const s=e.ref();return s.value||(s.value=B(at,R)),ct({scroll:t},s.value(n))}function _t(t,n={}){C.set("wheel",gt);const s=e.ref();return s.value||(s.value=B(ht,R)),ct({wheel:t},s.value(n))}const Tt=(t,e)=>({created:t,unmounted:e,bind:t,unbind:e}),Et=t=>`Your v-${t} directive must have a handler specified as a value`,Gt=()=>Tt(((t,e,n)=>{if(!e.value)throw new Error(Et("drag"));t.gestures||(t.gestures={});const s=lt(e.value,{domTarget:t,manual:!0});s.bind(),t.gestures.drag=s}),((t,e,n)=>{t.gestures&&t.gestures.drag&&t.gestures.drag.clean()})),Mt=()=>Tt(((t,e,n)=>{if(!e.value)throw new Error(Et("move"));t.gestures||(t.gestures={});const s=wt(e.value,{domTarget:t,manual:!0});s.bind(),t.gestures.move=s}),((t,e,n)=>{t.gestures&&t.gestures.move&&t.gestures.move.clean()})),Dt=()=>Tt(((t,e,n)=>{if(!e.value)throw new Error(Et("hover"));t.gestures||(t.gestures={});const s=St(e.value,{domTarget:t,manual:!0});s.bind(),t.gestures.hover=s}),((t,e,n)=>{t.gestures&&t.gestures.hover&&t.gestures.hover.clean()})),xt=()=>Tt(((t,e,n)=>{if(!e.value)throw new Error(Et("pinch"));t.gestures||(t.gestures={});const s=bt(e.value,{domTarget:t,manual:!0});s.bind(),t.gestures.pinch=s}),((t,e,n)=>{t.gestures&&t.gestures.pinch&&t.gestures.pinch.clean()})),Ot=()=>Tt(((t,e,n)=>{if(!e.value)throw new Error(Et("wheel"));t.gestures||(t.gestures={});const s=_t(e.value,{domTarget:t,manual:!0});s.bind(),t.gestures.wheel=s}),((t,e,n)=>{t.gestures&&t.gestures.wheel&&t.gestures.wheel.clean()})),Pt=()=>Tt(((t,e,n)=>{if(!e.value)throw new Error(Et("scroll"));t.gestures||(t.gestures={});const s=yt(e.value,{domTarget:t,manual:!0});s.bind(),t.gestures.drag=s}),((t,e,n)=>{t.gestures&&t.gestures.drag&&t.gestures.drag.clean()}));return t.GesturePlugin={install(t,e){Object.entries({drag:Gt,hover:Dt,move:Mt,pinch:xt,scroll:Pt,wheel:Ot}).forEach((([e,n])=>t.directive(e,n())))}},t.addV=G,t.dragDirective=Gt,t.hoverDirective=Dt,t.moveDirective=Mt,t.pinchDirective=xt,t.rubberbandIfOutOfBounds=K,t.scrollDirective=Pt,t.subV=M,t.useDrag=lt,t.useGesture=function(t,e){const[n,s,i]=function(t){const e={},n={},s=new Set;for(let i in t)pt.test(i)?(s.add(RegExp.lastMatch),n[i]=t[i]):e[i]=t[i];return[n,e,s]}(t);C.set("drag",A),C.set("hover",ut),C.set("move",ut),C.set("pinch",vt),C.set("scroll",ft),C.set("wheel",gt);const r=function(t,e=new Set){const{drag:n,wheel:s,move:i,scroll:r,pinch:o,hover:a,eventOptions:h,window:c,transform:l,domTarget:u,enabled:d}=t,v=Z({domTarget:u,eventOptions:h,transform:l,window:c,enabled:d});return e.has("onDrag")&&(v.drag=nt(n)),e.has("onWheel")&&(v.wheel=tt(s)),e.has("onScroll")&&(v.scroll=tt(r)),e.has("onMove")&&(v.move=tt(i)),e.has("onPinch")&&(v.pinch=et(o)),e.has("onHover")&&(v.hover={enabled:!0,...a}),v}(e,i),o={};return i.has("onDrag")&&(o.drag=mt(n,"onDrag")),i.has("onWheel")&&(o.wheel=mt(n,"onWheel")),i.has("onScroll")&&(o.scroll=mt(n,"onScroll")),i.has("onMove")&&(o.move=mt(n,"onMove")),i.has("onPinch")&&(o.pinch=mt(n,"onPinch")),i.has("onHover")&&(o.hover=n.onHover),ct(o,r,s)},t.useHover=St,t.useMove=wt,t.usePinch=bt,t.useScroll=yt,t.useWheel=_t,t.wheelDirective=Ot,Object.defineProperty(t,"__esModule",{value:!0}),t}({},VueDemi);
