(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x4, {
    get: (a8, b5) => (typeof require !== "undefined" ? require : a8)[b5]
  }) : x4)(function(x4) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x4 + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all4) => {
    for (var name2 in all4)
      __defProp(target, name2, { get: all4[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod2, secondTarget) => (__copyProps(target, mod2, "default"), secondTarget && __copyProps(secondTarget, mod2, "default"));
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target, mod2));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

  // node_modules/.pnpm/tslib@2.4.0/node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/.pnpm/tslib@2.4.0/node_modules/tslib/tslib.js"(exports, module) {
      var __extends2;
      var __assign2;
      var __rest2;
      var __decorate2;
      var __param2;
      var __metadata2;
      var __awaiter2;
      var __generator2;
      var __exportStar2;
      var __values2;
      var __read2;
      var __spread2;
      var __spreadArrays2;
      var __spreadArray2;
      var __await2;
      var __asyncGenerator2;
      var __asyncDelegator2;
      var __asyncValues2;
      var __makeTemplateObject2;
      var __importStar2;
      var __importDefault2;
      var __classPrivateFieldGet2;
      var __classPrivateFieldSet2;
      var __classPrivateFieldIn2;
      var __createBinding2;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v3) {
            return exports2[id] = previous ? previous(id, v3) : v3;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b5) {
          d5.__proto__ = b5;
        } || function(d5, b5) {
          for (var p6 in b5)
            if (Object.prototype.hasOwnProperty.call(b5, p6))
              d5[p6] = b5[p6];
        };
        __extends2 = function(d5, b5) {
          if (typeof b5 !== "function" && b5 !== null)
            throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
          extendStatics(d5, b5);
          function __() {
            this.constructor = d5;
          }
          d5.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
        };
        __assign2 = Object.assign || function(t8) {
          for (var s4, i8 = 1, n8 = arguments.length; i8 < n8; i8++) {
            s4 = arguments[i8];
            for (var p6 in s4)
              if (Object.prototype.hasOwnProperty.call(s4, p6))
                t8[p6] = s4[p6];
          }
          return t8;
        };
        __rest2 = function(s4, e8) {
          var t8 = {};
          for (var p6 in s4)
            if (Object.prototype.hasOwnProperty.call(s4, p6) && e8.indexOf(p6) < 0)
              t8[p6] = s4[p6];
          if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i8 = 0, p6 = Object.getOwnPropertySymbols(s4); i8 < p6.length; i8++) {
              if (e8.indexOf(p6[i8]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p6[i8]))
                t8[p6[i8]] = s4[p6[i8]];
            }
          return t8;
        };
        __decorate2 = function(decorators, target, key, desc) {
          var c6 = arguments.length, r8 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d5;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r8 = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i8 = decorators.length - 1; i8 >= 0; i8--)
              if (d5 = decorators[i8])
                r8 = (c6 < 3 ? d5(r8) : c6 > 3 ? d5(target, key, r8) : d5(target, key)) || r8;
          return c6 > 3 && r8 && Object.defineProperty(target, key, r8), r8;
        };
        __param2 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata2 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter2 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve2) {
              resolve2(value);
            });
          }
          return new (P || (P = Promise))(function(resolve2, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e8) {
                reject(e8);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e8) {
                reject(e8);
              }
            }
            function step(result) {
              result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator2 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t8[0] & 1)
              throw t8[1];
            return t8[1];
          }, trys: [], ops: [] }, f4, y3, t8, g2;
          return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
            return this;
          }), g2;
          function verb(n8) {
            return function(v3) {
              return step([n8, v3]);
            };
          }
          function step(op) {
            if (f4)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f4 = 1, y3 && (t8 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t8 = y3["return"]) && t8.call(y3), 0) : y3.next) && !(t8 = t8.call(y3, op[1])).done)
                  return t8;
                if (y3 = 0, t8)
                  op = [op[0] & 2, t8.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t8 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y3 = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t8 = _.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t8[1]) {
                      _.label = t8[1];
                      t8 = op;
                      break;
                    }
                    if (t8 && _.label < t8[2]) {
                      _.label = t8[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t8[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e8) {
                op = [6, e8];
                y3 = 0;
              } finally {
                f4 = t8 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar2 = function(m3, o8) {
          for (var p6 in m3)
            if (p6 !== "default" && !Object.prototype.hasOwnProperty.call(o8, p6))
              __createBinding2(o8, m3, p6);
        };
        __createBinding2 = Object.create ? function(o8, m3, k2, k22) {
          if (k22 === void 0)
            k22 = k2;
          var desc = Object.getOwnPropertyDescriptor(m3, k2);
          if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m3[k2];
            } };
          }
          Object.defineProperty(o8, k22, desc);
        } : function(o8, m3, k2, k22) {
          if (k22 === void 0)
            k22 = k2;
          o8[k22] = m3[k2];
        };
        __values2 = function(o8) {
          var s4 = typeof Symbol === "function" && Symbol.iterator, m3 = s4 && o8[s4], i8 = 0;
          if (m3)
            return m3.call(o8);
          if (o8 && typeof o8.length === "number")
            return {
              next: function() {
                if (o8 && i8 >= o8.length)
                  o8 = void 0;
                return { value: o8 && o8[i8++], done: !o8 };
              }
            };
          throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read2 = function(o8, n8) {
          var m3 = typeof Symbol === "function" && o8[Symbol.iterator];
          if (!m3)
            return o8;
          var i8 = m3.call(o8), r8, ar = [], e8;
          try {
            while ((n8 === void 0 || n8-- > 0) && !(r8 = i8.next()).done)
              ar.push(r8.value);
          } catch (error) {
            e8 = { error };
          } finally {
            try {
              if (r8 && !r8.done && (m3 = i8["return"]))
                m3.call(i8);
            } finally {
              if (e8)
                throw e8.error;
            }
          }
          return ar;
        };
        __spread2 = function() {
          for (var ar = [], i8 = 0; i8 < arguments.length; i8++)
            ar = ar.concat(__read2(arguments[i8]));
          return ar;
        };
        __spreadArrays2 = function() {
          for (var s4 = 0, i8 = 0, il = arguments.length; i8 < il; i8++)
            s4 += arguments[i8].length;
          for (var r8 = Array(s4), k2 = 0, i8 = 0; i8 < il; i8++)
            for (var a8 = arguments[i8], j2 = 0, jl = a8.length; j2 < jl; j2++, k2++)
              r8[k2] = a8[j2];
          return r8;
        };
        __spreadArray2 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i8 = 0, l5 = from.length, ar; i8 < l5; i8++) {
              if (ar || !(i8 in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i8);
                ar[i8] = from[i8];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await2 = function(v3) {
          return this instanceof __await2 ? (this.v = v3, this) : new __await2(v3);
        };
        __asyncGenerator2 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g2 = generator.apply(thisArg, _arguments || []), i8, q = [];
          return i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
            return this;
          }, i8;
          function verb(n8) {
            if (g2[n8])
              i8[n8] = function(v3) {
                return new Promise(function(a8, b5) {
                  q.push([n8, v3, a8, b5]) > 1 || resume(n8, v3);
                });
              };
          }
          function resume(n8, v3) {
            try {
              step(g2[n8](v3));
            } catch (e8) {
              settle(q[0][3], e8);
            }
          }
          function step(r8) {
            r8.value instanceof __await2 ? Promise.resolve(r8.value.v).then(fulfill, reject) : settle(q[0][2], r8);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f4, v3) {
            if (f4(v3), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator2 = function(o8) {
          var i8, p6;
          return i8 = {}, verb("next"), verb("throw", function(e8) {
            throw e8;
          }), verb("return"), i8[Symbol.iterator] = function() {
            return this;
          }, i8;
          function verb(n8, f4) {
            i8[n8] = o8[n8] ? function(v3) {
              return (p6 = !p6) ? { value: __await2(o8[n8](v3)), done: n8 === "return" } : f4 ? f4(v3) : v3;
            } : f4;
          }
        };
        __asyncValues2 = function(o8) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m3 = o8[Symbol.asyncIterator], i8;
          return m3 ? m3.call(o8) : (o8 = typeof __values2 === "function" ? __values2(o8) : o8[Symbol.iterator](), i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
            return this;
          }, i8);
          function verb(n8) {
            i8[n8] = o8[n8] && function(v3) {
              return new Promise(function(resolve2, reject) {
                v3 = o8[n8](v3), settle(resolve2, reject, v3.done, v3.value);
              });
            };
          }
          function settle(resolve2, reject, d5, v3) {
            Promise.resolve(v3).then(function(v4) {
              resolve2({ value: v4, done: d5 });
            }, reject);
          }
        };
        __makeTemplateObject2 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o8, v3) {
          Object.defineProperty(o8, "default", { enumerable: true, value: v3 });
        } : function(o8, v3) {
          o8["default"] = v3;
        };
        __importStar2 = function(mod2) {
          if (mod2 && mod2.__esModule)
            return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k2 in mod2)
              if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
                __createBinding2(result, mod2, k2);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
        __importDefault2 = function(mod2) {
          return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
        };
        __classPrivateFieldGet2 = function(receiver, state, kind, f4) {
          if (kind === "a" && !f4)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
        };
        __classPrivateFieldSet2 = function(receiver, state, value, kind, f4) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f4)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
        };
        __classPrivateFieldIn2 = function(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        };
        exporter("__extends", __extends2);
        exporter("__assign", __assign2);
        exporter("__rest", __rest2);
        exporter("__decorate", __decorate2);
        exporter("__param", __param2);
        exporter("__metadata", __metadata2);
        exporter("__awaiter", __awaiter2);
        exporter("__generator", __generator2);
        exporter("__exportStar", __exportStar2);
        exporter("__createBinding", __createBinding2);
        exporter("__values", __values2);
        exporter("__read", __read2);
        exporter("__spread", __spread2);
        exporter("__spreadArrays", __spreadArrays2);
        exporter("__spreadArray", __spreadArray2);
        exporter("__await", __await2);
        exporter("__asyncGenerator", __asyncGenerator2);
        exporter("__asyncDelegator", __asyncDelegator2);
        exporter("__asyncValues", __asyncValues2);
        exporter("__makeTemplateObject", __makeTemplateObject2);
        exporter("__importStar", __importStar2);
        exporter("__importDefault", __importDefault2);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
        exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
      });
    }
  });

  // node_modules/.pnpm/@vue+shared@3.2.37/node_modules/@vue/shared/dist/shared.esm-bundler.js
  var shared_esm_bundler_exports = {};
  __export(shared_esm_bundler_exports, {
    EMPTY_ARR: () => EMPTY_ARR,
    EMPTY_OBJ: () => EMPTY_OBJ,
    NO: () => NO,
    NOOP: () => NOOP,
    PatchFlagNames: () => PatchFlagNames,
    camelize: () => camelize,
    capitalize: () => capitalize,
    def: () => def,
    escapeHtml: () => escapeHtml,
    escapeHtmlComment: () => escapeHtmlComment,
    extend: () => extend,
    genPropsAccessExp: () => genPropsAccessExp,
    generateCodeFrame: () => generateCodeFrame,
    getGlobalThis: () => getGlobalThis,
    hasChanged: () => hasChanged,
    hasOwn: () => hasOwn,
    hyphenate: () => hyphenate,
    includeBooleanAttr: () => includeBooleanAttr,
    invokeArrayFns: () => invokeArrayFns,
    isArray: () => isArray2,
    isBooleanAttr: () => isBooleanAttr,
    isBuiltInDirective: () => isBuiltInDirective,
    isDate: () => isDate,
    isFunction: () => isFunction2,
    isGloballyWhitelisted: () => isGloballyWhitelisted,
    isHTMLTag: () => isHTMLTag,
    isIntegerKey: () => isIntegerKey,
    isKnownHtmlAttr: () => isKnownHtmlAttr,
    isKnownSvgAttr: () => isKnownSvgAttr,
    isMap: () => isMap,
    isModelListener: () => isModelListener,
    isNoUnitNumericStyleProp: () => isNoUnitNumericStyleProp,
    isObject: () => isObject2,
    isOn: () => isOn,
    isPlainObject: () => isPlainObject,
    isPromise: () => isPromise,
    isReservedProp: () => isReservedProp,
    isSSRSafeAttrName: () => isSSRSafeAttrName,
    isSVGTag: () => isSVGTag,
    isSet: () => isSet,
    isSpecialBooleanAttr: () => isSpecialBooleanAttr,
    isString: () => isString2,
    isSymbol: () => isSymbol,
    isVoidTag: () => isVoidTag,
    looseEqual: () => looseEqual,
    looseIndexOf: () => looseIndexOf,
    makeMap: () => makeMap,
    normalizeClass: () => normalizeClass,
    normalizeProps: () => normalizeProps,
    normalizeStyle: () => normalizeStyle,
    objectToString: () => objectToString,
    parseStringStyle: () => parseStringStyle,
    propsToAttrMap: () => propsToAttrMap,
    remove: () => remove,
    slotFlagsText: () => slotFlagsText,
    stringifyStyle: () => stringifyStyle,
    toDisplayString: () => toDisplayString,
    toHandlerKey: () => toHandlerKey,
    toNumber: () => toNumber,
    toRawType: () => toRawType,
    toTypeString: () => toTypeString
  });
  function makeMap(str, expectsLowerCase) {
    const map2 = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i8 = 0; i8 < list.length; i8++) {
      map2[list[i8]] = true;
    }
    return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
  }
  function generateCodeFrame(source, start3 = 0, end = source.length) {
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i8 = 0; i8 < lines.length; i8++) {
      count += lines[i8].length + (newlineSequences[i8] && newlineSequences[i8].length || 0);
      if (count >= start3) {
        for (let j2 = i8 - range2; j2 <= i8 + range2 || end > count; j2++) {
          if (j2 < 0 || j2 >= lines.length)
            continue;
          const line = j2 + 1;
          res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j2]}`);
          const lineLength = lines[j2].length;
          const newLineSeqLength = newlineSequences[j2] && newlineSequences[j2].length || 0;
          if (j2 === i8) {
            const pad = start3 - (count - (lineLength + newLineSeqLength));
            const length = Math.max(1, end > count ? lineLength - pad : end - start3);
            res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
          } else if (j2 > i8) {
            if (end > count) {
              const length = Math.max(Math.min(end - count, lineLength), 1);
              res.push(`   |  ` + "^".repeat(length));
            }
            count += lineLength + newLineSeqLength;
          }
        }
        break;
      }
    }
    return res.join("\n");
  }
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  function isSSRSafeAttrName(name2) {
    if (attrValidationCache.hasOwnProperty(name2)) {
      return attrValidationCache[name2];
    }
    const isUnsafe = unsafeAttrCharRE.test(name2);
    if (isUnsafe) {
      console.error(`unsafe attribute name: ${name2}`);
    }
    return attrValidationCache[name2] = !isUnsafe;
  }
  function normalizeStyle(value) {
    if (isArray2(value)) {
      const res = {};
      for (let i8 = 0; i8 < value.length; i8++) {
        const item = value[i8];
        const normalized = isString2(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString2(value)) {
      return value;
    } else if (isObject2(value)) {
      return value;
    }
  }
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function stringifyStyle(styles) {
    let ret = "";
    if (!styles || isString2(styles)) {
      return ret;
    }
    for (const key in styles) {
      const value = styles[key];
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      if (isString2(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
        ret += `${normalizedKey}:${value};`;
      }
    }
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString2(value)) {
      res = value;
    } else if (isArray2(value)) {
      for (let i8 = 0; i8 < value.length; i8++) {
        const normalized = normalizeClass(value[i8]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject2(value)) {
      for (const name2 in value) {
        if (value[name2]) {
          res += name2 + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps(props) {
    if (!props)
      return null;
    let { class: klass, style } = props;
    if (klass && !isString2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (style) {
      props.style = normalizeStyle(style);
    }
    return props;
  }
  function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) {
      return str;
    }
    let html = "";
    let escaped;
    let index15;
    let lastIndex = 0;
    for (index15 = match.index; index15 < str.length; index15++) {
      switch (str.charCodeAt(index15)) {
        case 34:
          escaped = "&quot;";
          break;
        case 38:
          escaped = "&amp;";
          break;
        case 39:
          escaped = "&#39;";
          break;
        case 60:
          escaped = "&lt;";
          break;
        case 62:
          escaped = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index15) {
        html += str.slice(lastIndex, index15);
      }
      lastIndex = index15 + 1;
      html += escaped;
    }
    return lastIndex !== index15 ? html + str.slice(lastIndex, index15) : html;
  }
  function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
  }
  function looseCompareArrays(a8, b5) {
    if (a8.length !== b5.length)
      return false;
    let equal = true;
    for (let i8 = 0; equal && i8 < a8.length; i8++) {
      equal = looseEqual(a8[i8], b5[i8]);
    }
    return equal;
  }
  function looseEqual(a8, b5) {
    if (a8 === b5)
      return true;
    let aValidType = isDate(a8);
    let bValidType = isDate(b5);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a8.getTime() === b5.getTime() : false;
    }
    aValidType = isSymbol(a8);
    bValidType = isSymbol(b5);
    if (aValidType || bValidType) {
      return a8 === b5;
    }
    aValidType = isArray2(a8);
    bValidType = isArray2(b5);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a8, b5) : false;
    }
    aValidType = isObject2(a8);
    bValidType = isObject2(b5);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a8).length;
      const bKeysCount = Object.keys(b5).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a8) {
        const aHasKey = a8.hasOwnProperty(key);
        const bHasKey = b5.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a8[key], b5[key])) {
          return false;
        }
      }
    }
    return String(a8) === String(b5);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  function genPropsAccessExp(name2) {
    return identRE.test(name2) ? `__props.${name2}` : `__props[${JSON.stringify(name2)}]`;
  }
  var PatchFlagNames, slotFlagsText, GLOBALS_WHITE_LISTED, isGloballyWhitelisted, range2, specialBooleanAttrs, isSpecialBooleanAttr, isBooleanAttr, unsafeAttrCharRE, attrValidationCache, propsToAttrMap, isNoUnitNumericStyleProp, isKnownHtmlAttr, isKnownSvgAttr, listDelimiterRE, propertyDelimiterRE, HTML_TAGS, SVG_TAGS, VOID_TAGS, isHTMLTag, isSVGTag, isVoidTag, escapeRE, commentStripRE, toDisplayString, replacer, EMPTY_OBJ, EMPTY_ARR, NOOP, NO, onRE, isOn, isModelListener, extend, remove, hasOwnProperty, hasOwn, isArray2, isMap, isSet, isDate, isFunction2, isString2, isSymbol, isObject2, isPromise, objectToString, toTypeString, toRawType, isPlainObject, isIntegerKey, isReservedProp, isBuiltInDirective, cacheStringFunction, camelizeRE, camelize, hyphenateRE, hyphenate, capitalize, toHandlerKey, hasChanged, invokeArrayFns, def, toNumber, _globalThis, getGlobalThis, identRE;
  var init_shared_esm_bundler = __esm({
    "node_modules/.pnpm/@vue+shared@3.2.37/node_modules/@vue/shared/dist/shared.esm-bundler.js"() {
      PatchFlagNames = {
        [1]: `TEXT`,
        [2]: `CLASS`,
        [4]: `STYLE`,
        [8]: `PROPS`,
        [16]: `FULL_PROPS`,
        [32]: `HYDRATE_EVENTS`,
        [64]: `STABLE_FRAGMENT`,
        [128]: `KEYED_FRAGMENT`,
        [256]: `UNKEYED_FRAGMENT`,
        [512]: `NEED_PATCH`,
        [1024]: `DYNAMIC_SLOTS`,
        [2048]: `DEV_ROOT_FRAGMENT`,
        [-1]: `HOISTED`,
        [-2]: `BAIL`
      };
      slotFlagsText = {
        [1]: "STABLE",
        [2]: "DYNAMIC",
        [3]: "FORWARDED"
      };
      GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
      isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
      range2 = 2;
      specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
      unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
      attrValidationCache = {};
      propsToAttrMap = {
        acceptCharset: "accept-charset",
        className: "class",
        htmlFor: "for",
        httpEquiv: "http-equiv"
      };
      isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
      isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
      isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
      listDelimiterRE = /;(?![^(]*\))/g;
      propertyDelimiterRE = /:(.+)/;
      HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
      SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
      VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
      isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
      isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
      isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
      escapeRE = /["'&<>]/;
      commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
      toDisplayString = (val) => {
        return isString2(val) ? val : val == null ? "" : isArray2(val) || isObject2(val) && (val.toString === objectToString || !isFunction2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      replacer = (_key, val) => {
        if (val && val.__v_isRef) {
          return replacer(_key, val.value);
        } else if (isMap(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries4, [key, val2]) => {
              entries4[`${key} =>`] = val2;
              return entries4;
            }, {})
          };
        } else if (isSet(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()]
          };
        } else if (isObject2(val) && !isArray2(val) && !isPlainObject(val)) {
          return String(val);
        }
        return val;
      };
      EMPTY_OBJ = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
      EMPTY_ARR = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
      NOOP = () => {
      };
      NO = () => false;
      onRE = /^on[^a-z]/;
      isOn = (key) => onRE.test(key);
      isModelListener = (key) => key.startsWith("onUpdate:");
      extend = Object.assign;
      remove = (arr, el) => {
        const i8 = arr.indexOf(el);
        if (i8 > -1) {
          arr.splice(i8, 1);
        }
      };
      hasOwnProperty = Object.prototype.hasOwnProperty;
      hasOwn = (val, key) => hasOwnProperty.call(val, key);
      isArray2 = Array.isArray;
      isMap = (val) => toTypeString(val) === "[object Map]";
      isSet = (val) => toTypeString(val) === "[object Set]";
      isDate = (val) => toTypeString(val) === "[object Date]";
      isFunction2 = (val) => typeof val === "function";
      isString2 = (val) => typeof val === "string";
      isSymbol = (val) => typeof val === "symbol";
      isObject2 = (val) => val !== null && typeof val === "object";
      isPromise = (val) => {
        return isObject2(val) && isFunction2(val.then) && isFunction2(val.catch);
      };
      objectToString = Object.prototype.toString;
      toTypeString = (value) => objectToString.call(value);
      toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      isPlainObject = (val) => toTypeString(val) === "[object Object]";
      isIntegerKey = (key) => isString2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
      isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
      cacheStringFunction = (fn) => {
        const cache4 = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache4[str];
          return hit || (cache4[str] = fn(str));
        };
      };
      camelizeRE = /-(\w)/g;
      camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_, c6) => c6 ? c6.toUpperCase() : "");
      });
      hyphenateRE = /\B([A-Z])/g;
      hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
      capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
      toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
      hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      invokeArrayFns = (fns, arg) => {
        for (let i8 = 0; i8 < fns.length; i8++) {
          fns[i8](arg);
        }
      };
      def = (obj, key, value) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
        });
      };
      toNumber = (val) => {
        const n8 = parseFloat(val);
        return isNaN(n8) ? val : n8;
      };
      getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
    }
  });

  // node_modules/.pnpm/@vue+compiler-core@3.2.37/node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
  function defaultOnError(error) {
    throw error;
  }
  function defaultOnWarn(msg) {
    process.env.NODE_ENV !== "production" && console.warn(`[Vue warn] ${msg.message}`);
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
    const msg = process.env.NODE_ENV !== "production" || false ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
  }
  function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach((s4) => {
      helperNameMap[s4] = helpers[s4];
    });
  }
  function createRoot(children, loc = locStub) {
    return {
      type: 0,
      children,
      helpers: [],
      components: [],
      directives: [],
      hoists: [],
      imports: [],
      cached: 0,
      temps: 0,
      codegenNode: void 0,
      loc
    };
  }
  function createVNodeCall(context2, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
    if (context2) {
      if (isBlock) {
        context2.helper(OPEN_BLOCK);
        context2.helper(getVNodeBlockHelper(context2.inSSR, isComponent2));
      } else {
        context2.helper(getVNodeHelper(context2.inSSR, isComponent2));
      }
      if (directives) {
        context2.helper(WITH_DIRECTIVES);
      }
    }
    return {
      type: 13,
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent: isComponent2,
      loc
    };
  }
  function createArrayExpression(elements, loc = locStub) {
    return {
      type: 17,
      loc,
      elements
    };
  }
  function createObjectExpression(properties, loc = locStub) {
    return {
      type: 15,
      loc,
      properties
    };
  }
  function createObjectProperty(key, value) {
    return {
      type: 16,
      loc: locStub,
      key: isString2(key) ? createSimpleExpression(key, true) : key,
      value
    };
  }
  function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
    return {
      type: 4,
      loc,
      content,
      isStatic,
      constType: isStatic ? 3 : constType
    };
  }
  function createInterpolation(content, loc) {
    return {
      type: 5,
      loc,
      content: isString2(content) ? createSimpleExpression(content, false, loc) : content
    };
  }
  function createCompoundExpression(children, loc = locStub) {
    return {
      type: 8,
      loc,
      children
    };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
    return {
      type: 14,
      loc,
      callee,
      arguments: args
    };
  }
  function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
    return {
      type: 18,
      params,
      returns,
      newline,
      isSlot,
      loc
    };
  }
  function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
      type: 19,
      test,
      consequent,
      alternate,
      newline,
      loc: locStub
    };
  }
  function createCacheExpression(index15, value, isVNode2 = false) {
    return {
      type: 20,
      index: index15,
      value,
      isVNode: isVNode2,
      loc: locStub
    };
  }
  function createBlockStatement(body) {
    return {
      type: 21,
      body,
      loc: locStub
    };
  }
  function createTemplateLiteral(elements) {
    return {
      type: 22,
      elements,
      loc: locStub
    };
  }
  function createIfStatement(test, consequent, alternate) {
    return {
      type: 23,
      test,
      consequent,
      alternate,
      loc: locStub
    };
  }
  function createAssignmentExpression(left, right) {
    return {
      type: 24,
      left,
      right,
      loc: locStub
    };
  }
  function createSequenceExpression(expressions) {
    return {
      type: 25,
      expressions,
      loc: locStub
    };
  }
  function createReturnStatement(returns) {
    return {
      type: 26,
      returns,
      loc: locStub
    };
  }
  function isCoreComponent(tag) {
    if (isBuiltInType(tag, "Teleport")) {
      return TELEPORT;
    } else if (isBuiltInType(tag, "Suspense")) {
      return SUSPENSE;
    } else if (isBuiltInType(tag, "KeepAlive")) {
      return KEEP_ALIVE;
    } else if (isBuiltInType(tag, "BaseTransition")) {
      return BASE_TRANSITION;
    }
  }
  function getInnerRange(loc, offset, length) {
    const source = loc.source.slice(offset, offset + length);
    const newLoc = {
      source,
      start: advancePositionWithClone(loc.start, loc.source, offset),
      end: loc.end
    };
    if (length != null) {
      newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
    }
    return newLoc;
  }
  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
  }
  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i8 = 0; i8 < numberOfCharacters; i8++) {
      if (source.charCodeAt(i8) === 10) {
        linesCount++;
        lastNewLinePos = i8;
      }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
    return pos;
  }
  function assert2(condition, msg) {
    if (!condition) {
      throw new Error(msg || `unexpected compiler condition`);
    }
  }
  function findDir(node, name2, allowEmpty = false) {
    for (let i8 = 0; i8 < node.props.length; i8++) {
      const p6 = node.props[i8];
      if (p6.type === 7 && (allowEmpty || p6.exp) && (isString2(name2) ? p6.name === name2 : name2.test(p6.name))) {
        return p6;
      }
    }
  }
  function findProp(node, name2, dynamicOnly = false, allowEmpty = false) {
    for (let i8 = 0; i8 < node.props.length; i8++) {
      const p6 = node.props[i8];
      if (p6.type === 6) {
        if (dynamicOnly)
          continue;
        if (p6.name === name2 && (p6.value || allowEmpty)) {
          return p6;
        }
      } else if (p6.name === "bind" && (p6.exp || allowEmpty) && isStaticArgOf(p6.arg, name2)) {
        return p6;
      }
    }
  }
  function isStaticArgOf(arg, name2) {
    return !!(arg && isStaticExp(arg) && arg.content === name2);
  }
  function hasDynamicKeyVBind(node) {
    return node.props.some((p6) => p6.type === 7 && p6.name === "bind" && (!p6.arg || p6.arg.type !== 4 || !p6.arg.isStatic));
  }
  function isText(node) {
    return node.type === 5 || node.type === 2;
  }
  function isVSlot(p6) {
    return p6.type === 7 && p6.name === "slot";
  }
  function isTemplateNode(node) {
    return node.type === 1 && node.tagType === 3;
  }
  function isSlotOutlet(node) {
    return node.type === 1 && node.tagType === 2;
  }
  function getVNodeHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
  }
  function getVNodeBlockHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
  }
  function getUnnormalizedProps(props, callPath = []) {
    if (props && !isString2(props) && props.type === 14) {
      const callee = props.callee;
      if (!isString2(callee) && propsHelperSet.has(callee)) {
        return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
      }
    }
    return [props, callPath];
  }
  function injectProp(node, prop, context2) {
    let propsWithInjection;
    let props = node.type === 13 ? node.props : node.arguments[2];
    let callPath = [];
    let parentCall;
    if (props && !isString2(props) && props.type === 14) {
      const ret = getUnnormalizedProps(props);
      props = ret[0];
      callPath = ret[1];
      parentCall = callPath[callPath.length - 1];
    }
    if (props == null || isString2(props)) {
      propsWithInjection = createObjectExpression([prop]);
    } else if (props.type === 14) {
      const first = props.arguments[0];
      if (!isString2(first) && first.type === 15) {
        first.properties.unshift(prop);
      } else {
        if (props.callee === TO_HANDLERS) {
          propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
          ]);
        } else {
          props.arguments.unshift(createObjectExpression([prop]));
        }
      }
      !propsWithInjection && (propsWithInjection = props);
    } else if (props.type === 15) {
      let alreadyExists = false;
      if (prop.key.type === 4) {
        const propKeyName = prop.key.content;
        alreadyExists = props.properties.some((p6) => p6.key.type === 4 && p6.key.content === propKeyName);
      }
      if (!alreadyExists) {
        props.properties.unshift(prop);
      }
      propsWithInjection = props;
    } else {
      propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
        createObjectExpression([prop]),
        props
      ]);
      if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
        parentCall = callPath[callPath.length - 2];
      }
    }
    if (node.type === 13) {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.props = propsWithInjection;
      }
    } else {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.arguments[2] = propsWithInjection;
      }
    }
  }
  function toValidAssetId(name2, type) {
    return `_${type}_${name2.replace(/[^\w]/g, (searchValue, replaceValue) => {
      return searchValue === "-" ? "_" : name2.charCodeAt(replaceValue).toString();
    })}`;
  }
  function hasScopeRef(node, ids) {
    if (!node || Object.keys(ids).length === 0) {
      return false;
    }
    switch (node.type) {
      case 1:
        for (let i8 = 0; i8 < node.props.length; i8++) {
          const p6 = node.props[i8];
          if (p6.type === 7 && (hasScopeRef(p6.arg, ids) || hasScopeRef(p6.exp, ids))) {
            return true;
          }
        }
        return node.children.some((c6) => hasScopeRef(c6, ids));
      case 11:
        if (hasScopeRef(node.source, ids)) {
          return true;
        }
        return node.children.some((c6) => hasScopeRef(c6, ids));
      case 9:
        return node.branches.some((b5) => hasScopeRef(b5, ids));
      case 10:
        if (hasScopeRef(node.condition, ids)) {
          return true;
        }
        return node.children.some((c6) => hasScopeRef(c6, ids));
      case 4:
        return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
      case 8:
        return node.children.some((c6) => isObject2(c6) && hasScopeRef(c6, ids));
      case 5:
      case 12:
        return hasScopeRef(node.content, ids);
      case 2:
      case 3:
        return false;
      default:
        if (process.env.NODE_ENV !== "production")
          ;
        return false;
    }
  }
  function getMemoedVNodeCall(node) {
    if (node.type === 14 && node.callee === WITH_MEMO) {
      return node.arguments[1].returns;
    } else {
      return node;
    }
  }
  function makeBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
      node.isBlock = true;
      removeHelper(getVNodeHelper(inSSR, node.isComponent));
      helper(OPEN_BLOCK);
      helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
  }
  function getCompatValue(key, context2) {
    const config = context2.options ? context2.options.compatConfig : context2.compatConfig;
    const value = config && config[key];
    if (key === "MODE") {
      return value || 3;
    } else {
      return value;
    }
  }
  function isCompatEnabled(key, context2) {
    const mode2 = getCompatValue("MODE", context2);
    const value = getCompatValue(key, context2);
    return mode2 === 3 ? value === true : value !== false;
  }
  function checkCompatEnabled(key, context2, loc, ...args) {
    const enabled = isCompatEnabled(key, context2);
    if (process.env.NODE_ENV !== "production" && enabled) {
      warnDeprecation(key, context2, loc, ...args);
    }
    return enabled;
  }
  function warnDeprecation(key, context2, loc, ...args) {
    const val = getCompatValue(key, context2);
    if (val === "suppress-warning") {
      return;
    }
    const { message, link } = deprecationData[key];
    const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key;
    if (loc)
      err.loc = loc;
    context2.onWarn(err);
  }
  function baseParse(content, options2 = {}) {
    const context2 = createParserContext(content, options2);
    const start3 = getCursor(context2);
    return createRoot(parseChildren(context2, 0, []), getSelection(context2, start3));
  }
  function createParserContext(content, rawOptions) {
    const options2 = extend({}, defaultParserOptions);
    let key;
    for (key in rawOptions) {
      options2[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
    }
    return {
      options: options2,
      column: 1,
      line: 1,
      offset: 0,
      originalSource: content,
      source: content,
      inPre: false,
      inVPre: false,
      onWarn: options2.onWarn
    };
  }
  function parseChildren(context2, mode2, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0;
    const nodes = [];
    while (!isEnd(context2, mode2, ancestors)) {
      const s4 = context2.source;
      let node = void 0;
      if (mode2 === 0 || mode2 === 1) {
        if (!context2.inVPre && startsWith(s4, context2.options.delimiters[0])) {
          node = parseInterpolation(context2, mode2);
        } else if (mode2 === 0 && s4[0] === "<") {
          if (s4.length === 1) {
            emitError(context2, 5, 1);
          } else if (s4[1] === "!") {
            if (startsWith(s4, "<!--")) {
              node = parseComment(context2);
            } else if (startsWith(s4, "<!DOCTYPE")) {
              node = parseBogusComment(context2);
            } else if (startsWith(s4, "<![CDATA[")) {
              if (ns !== 0) {
                node = parseCDATA(context2, ancestors);
              } else {
                emitError(context2, 1);
                node = parseBogusComment(context2);
              }
            } else {
              emitError(context2, 11);
              node = parseBogusComment(context2);
            }
          } else if (s4[1] === "/") {
            if (s4.length === 2) {
              emitError(context2, 5, 2);
            } else if (s4[2] === ">") {
              emitError(context2, 14, 2);
              advanceBy(context2, 3);
              continue;
            } else if (/[a-z]/i.test(s4[2])) {
              emitError(context2, 23);
              parseTag(context2, 1, parent);
              continue;
            } else {
              emitError(context2, 12, 2);
              node = parseBogusComment(context2);
            }
          } else if (/[a-z]/i.test(s4[1])) {
            node = parseElement(context2, ancestors);
            if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context2) && node && node.tag === "template" && !node.props.some((p6) => p6.type === 7 && isSpecialTemplateDirective(p6.name))) {
              process.env.NODE_ENV !== "production" && warnDeprecation("COMPILER_NATIVE_TEMPLATE", context2, node.loc);
              node = node.children;
            }
          } else if (s4[1] === "?") {
            emitError(context2, 21, 1);
            node = parseBogusComment(context2);
          } else {
            emitError(context2, 12, 1);
          }
        }
      }
      if (!node) {
        node = parseText(context2, mode2);
      }
      if (isArray2(node)) {
        for (let i8 = 0; i8 < node.length; i8++) {
          pushNode(nodes, node[i8]);
        }
      } else {
        pushNode(nodes, node);
      }
    }
    let removedWhitespace = false;
    if (mode2 !== 2 && mode2 !== 1) {
      const shouldCondense = context2.options.whitespace !== "preserve";
      for (let i8 = 0; i8 < nodes.length; i8++) {
        const node = nodes[i8];
        if (!context2.inPre && node.type === 2) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i8 - 1];
            const next = nodes[i8 + 1];
            if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
              removedWhitespace = true;
              nodes[i8] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
          }
        } else if (node.type === 3 && !context2.options.comments) {
          removedWhitespace = true;
          nodes[i8] = null;
        }
      }
      if (context2.inPre && parent && context2.options.isPreTag(parent.tag)) {
        const first = nodes[0];
        if (first && first.type === 2) {
          first.content = first.content.replace(/^\r?\n/, "");
        }
      }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function pushNode(nodes, node) {
    if (node.type === 2) {
      const prev = last(nodes);
      if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
        prev.content += node.content;
        prev.loc.end = node.loc.end;
        prev.loc.source += node.loc.source;
        return;
      }
    }
    nodes.push(node);
  }
  function parseCDATA(context2, ancestors) {
    advanceBy(context2, 9);
    const nodes = parseChildren(context2, 3, ancestors);
    if (context2.source.length === 0) {
      emitError(context2, 6);
    } else {
      advanceBy(context2, 3);
    }
    return nodes;
  }
  function parseComment(context2) {
    const start3 = getCursor(context2);
    let content;
    const match = /--(\!)?>/.exec(context2.source);
    if (!match) {
      content = context2.source.slice(4);
      advanceBy(context2, context2.source.length);
      emitError(context2, 7);
    } else {
      if (match.index <= 3) {
        emitError(context2, 0);
      }
      if (match[1]) {
        emitError(context2, 10);
      }
      content = context2.source.slice(4, match.index);
      const s4 = context2.source.slice(0, match.index);
      let prevIndex = 1, nestedIndex = 0;
      while ((nestedIndex = s4.indexOf("<!--", prevIndex)) !== -1) {
        advanceBy(context2, nestedIndex - prevIndex + 1);
        if (nestedIndex + 4 < s4.length) {
          emitError(context2, 16);
        }
        prevIndex = nestedIndex + 1;
      }
      advanceBy(context2, match.index + match[0].length - prevIndex + 1);
    }
    return {
      type: 3,
      content,
      loc: getSelection(context2, start3)
    };
  }
  function parseBogusComment(context2) {
    const start3 = getCursor(context2);
    const contentStart = context2.source[1] === "?" ? 1 : 2;
    let content;
    const closeIndex = context2.source.indexOf(">");
    if (closeIndex === -1) {
      content = context2.source.slice(contentStart);
      advanceBy(context2, context2.source.length);
    } else {
      content = context2.source.slice(contentStart, closeIndex);
      advanceBy(context2, closeIndex + 1);
    }
    return {
      type: 3,
      content,
      loc: getSelection(context2, start3)
    };
  }
  function parseElement(context2, ancestors) {
    const wasInPre = context2.inPre;
    const wasInVPre = context2.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context2, 0, parent);
    const isPreBoundary = context2.inPre && !wasInPre;
    const isVPreBoundary = context2.inVPre && !wasInVPre;
    if (element.isSelfClosing || context2.options.isVoidTag(element.tag)) {
      if (isPreBoundary) {
        context2.inPre = false;
      }
      if (isVPreBoundary) {
        context2.inVPre = false;
      }
      return element;
    }
    ancestors.push(element);
    const mode2 = context2.options.getTextMode(element, parent);
    const children = parseChildren(context2, mode2, ancestors);
    ancestors.pop();
    {
      const inlineTemplateProp = element.props.find((p6) => p6.type === 6 && p6.name === "inline-template");
      if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context2, inlineTemplateProp.loc)) {
        const loc = getSelection(context2, element.loc.end);
        inlineTemplateProp.value = {
          type: 2,
          content: loc.source,
          loc
        };
      }
    }
    element.children = children;
    if (startsWithEndTagOpen(context2.source, element.tag)) {
      parseTag(context2, 1, parent);
    } else {
      emitError(context2, 24, 0, element.loc.start);
      if (context2.source.length === 0 && element.tag.toLowerCase() === "script") {
        const first = children[0];
        if (first && startsWith(first.loc.source, "<!--")) {
          emitError(context2, 8);
        }
      }
    }
    element.loc = getSelection(context2, element.loc.start);
    if (isPreBoundary) {
      context2.inPre = false;
    }
    if (isVPreBoundary) {
      context2.inVPre = false;
    }
    return element;
  }
  function parseTag(context2, type, parent) {
    const start3 = getCursor(context2);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context2.source);
    const tag = match[1];
    const ns = context2.options.getNamespace(tag, parent);
    advanceBy(context2, match[0].length);
    advanceSpaces(context2);
    const cursor = getCursor(context2);
    const currentSource = context2.source;
    if (context2.options.isPreTag(tag)) {
      context2.inPre = true;
    }
    let props = parseAttributes(context2, type);
    if (type === 0 && !context2.inVPre && props.some((p6) => p6.type === 7 && p6.name === "pre")) {
      context2.inVPre = true;
      extend(context2, cursor);
      context2.source = currentSource;
      props = parseAttributes(context2, type).filter((p6) => p6.name !== "v-pre");
    }
    let isSelfClosing = false;
    if (context2.source.length === 0) {
      emitError(context2, 9);
    } else {
      isSelfClosing = startsWith(context2.source, "/>");
      if (type === 1 && isSelfClosing) {
        emitError(context2, 4);
      }
      advanceBy(context2, isSelfClosing ? 2 : 1);
    }
    if (type === 1) {
      return;
    }
    if (process.env.NODE_ENV !== "production" && isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context2)) {
      let hasIf = false;
      let hasFor = false;
      for (let i8 = 0; i8 < props.length; i8++) {
        const p6 = props[i8];
        if (p6.type === 7) {
          if (p6.name === "if") {
            hasIf = true;
          } else if (p6.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context2, getSelection(context2, start3));
          break;
        }
      }
    }
    let tagType = 0;
    if (!context2.inVPre) {
      if (tag === "slot") {
        tagType = 2;
      } else if (tag === "template") {
        if (props.some((p6) => p6.type === 7 && isSpecialTemplateDirective(p6.name))) {
          tagType = 3;
        }
      } else if (isComponent(tag, props, context2)) {
        tagType = 1;
      }
    }
    return {
      type: 1,
      ns,
      tag,
      tagType,
      props,
      isSelfClosing,
      children: [],
      loc: getSelection(context2, start3),
      codegenNode: void 0
    };
  }
  function isComponent(tag, props, context2) {
    const options2 = context2.options;
    if (options2.isCustomElement(tag)) {
      return false;
    }
    if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options2.isBuiltInComponent && options2.isBuiltInComponent(tag) || options2.isNativeTag && !options2.isNativeTag(tag)) {
      return true;
    }
    for (let i8 = 0; i8 < props.length; i8++) {
      const p6 = props[i8];
      if (p6.type === 6) {
        if (p6.name === "is" && p6.value) {
          if (p6.value.content.startsWith("vue:")) {
            return true;
          } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context2, p6.loc)) {
            return true;
          }
        }
      } else {
        if (p6.name === "is") {
          return true;
        } else if (p6.name === "bind" && isStaticArgOf(p6.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context2, p6.loc)) {
          return true;
        }
      }
    }
  }
  function parseAttributes(context2, type) {
    const props = [];
    const attributeNames = /* @__PURE__ */ new Set();
    while (context2.source.length > 0 && !startsWith(context2.source, ">") && !startsWith(context2.source, "/>")) {
      if (startsWith(context2.source, "/")) {
        emitError(context2, 22);
        advanceBy(context2, 1);
        advanceSpaces(context2);
        continue;
      }
      if (type === 1) {
        emitError(context2, 3);
      }
      const attr = parseAttribute(context2, attributeNames);
      if (attr.type === 6 && attr.value && attr.name === "class") {
        attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
      }
      if (type === 0) {
        props.push(attr);
      }
      if (/^[^\t\r\n\f />]/.test(context2.source)) {
        emitError(context2, 15);
      }
      advanceSpaces(context2);
    }
    return props;
  }
  function parseAttribute(context2, nameSet) {
    const start3 = getCursor(context2);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context2.source);
    const name2 = match[0];
    if (nameSet.has(name2)) {
      emitError(context2, 2);
    }
    nameSet.add(name2);
    if (name2[0] === "=") {
      emitError(context2, 19);
    }
    {
      const pattern = /["'<]/g;
      let m3;
      while (m3 = pattern.exec(name2)) {
        emitError(context2, 17, m3.index);
      }
    }
    advanceBy(context2, name2.length);
    let value = void 0;
    if (/^[\t\r\n\f ]*=/.test(context2.source)) {
      advanceSpaces(context2);
      advanceBy(context2, 1);
      advanceSpaces(context2);
      value = parseAttributeValue(context2);
      if (!value) {
        emitError(context2, 13);
      }
    }
    const loc = getSelection(context2, start3);
    if (!context2.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name2)) {
      const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name2);
      let isPropShorthand = startsWith(name2, ".");
      let dirName = match2[1] || (isPropShorthand || startsWith(name2, ":") ? "bind" : startsWith(name2, "@") ? "on" : "slot");
      let arg;
      if (match2[2]) {
        const isSlot = dirName === "slot";
        const startOffset = name2.lastIndexOf(match2[2]);
        const loc2 = getSelection(context2, getNewPosition(context2, start3, startOffset), getNewPosition(context2, start3, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
        let content = match2[2];
        let isStatic = true;
        if (content.startsWith("[")) {
          isStatic = false;
          if (!content.endsWith("]")) {
            emitError(context2, 27);
            content = content.slice(1);
          } else {
            content = content.slice(1, content.length - 1);
          }
        } else if (isSlot) {
          content += match2[3] || "";
        }
        arg = {
          type: 4,
          content,
          isStatic,
          constType: isStatic ? 3 : 0,
          loc: loc2
        };
      }
      if (value && value.isQuoted) {
        const valueLoc = value.loc;
        valueLoc.start.offset++;
        valueLoc.start.column++;
        valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
        valueLoc.source = valueLoc.source.slice(1, -1);
      }
      const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
      if (isPropShorthand)
        modifiers.push("prop");
      if (dirName === "bind" && arg) {
        if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context2, loc, arg.loc.source)) {
          dirName = "model";
          modifiers.splice(modifiers.indexOf("sync"), 1);
        }
        if (process.env.NODE_ENV !== "production" && modifiers.includes("prop")) {
          checkCompatEnabled("COMPILER_V_BIND_PROP", context2, loc);
        }
      }
      return {
        type: 7,
        name: dirName,
        exp: value && {
          type: 4,
          content: value.content,
          isStatic: false,
          constType: 0,
          loc: value.loc
        },
        arg,
        modifiers,
        loc
      };
    }
    if (!context2.inVPre && startsWith(name2, "v-")) {
      emitError(context2, 26);
    }
    return {
      type: 6,
      name: name2,
      value: value && {
        type: 2,
        content: value.content,
        loc: value.loc
      },
      loc
    };
  }
  function parseAttributeValue(context2) {
    const start3 = getCursor(context2);
    let content;
    const quote = context2.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
      advanceBy(context2, 1);
      const endIndex = context2.source.indexOf(quote);
      if (endIndex === -1) {
        content = parseTextData(context2, context2.source.length, 4);
      } else {
        content = parseTextData(context2, endIndex, 4);
        advanceBy(context2, 1);
      }
    } else {
      const match = /^[^\t\r\n\f >]+/.exec(context2.source);
      if (!match) {
        return void 0;
      }
      const unexpectedChars = /["'<=`]/g;
      let m3;
      while (m3 = unexpectedChars.exec(match[0])) {
        emitError(context2, 18, m3.index);
      }
      content = parseTextData(context2, match[0].length, 4);
    }
    return { content, isQuoted, loc: getSelection(context2, start3) };
  }
  function parseInterpolation(context2, mode2) {
    const [open, close] = context2.options.delimiters;
    const closeIndex = context2.source.indexOf(close, open.length);
    if (closeIndex === -1) {
      emitError(context2, 25);
      return void 0;
    }
    const start3 = getCursor(context2);
    advanceBy(context2, open.length);
    const innerStart = getCursor(context2);
    const innerEnd = getCursor(context2);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context2.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context2, rawContentLength, mode2);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
      advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context2, close.length);
    return {
      type: 5,
      content: {
        type: 4,
        isStatic: false,
        constType: 0,
        content,
        loc: getSelection(context2, innerStart, innerEnd)
      },
      loc: getSelection(context2, start3)
    };
  }
  function parseText(context2, mode2) {
    const endTokens = mode2 === 3 ? ["]]>"] : ["<", context2.options.delimiters[0]];
    let endIndex = context2.source.length;
    for (let i8 = 0; i8 < endTokens.length; i8++) {
      const index15 = context2.source.indexOf(endTokens[i8], 1);
      if (index15 !== -1 && endIndex > index15) {
        endIndex = index15;
      }
    }
    const start3 = getCursor(context2);
    const content = parseTextData(context2, endIndex, mode2);
    return {
      type: 2,
      content,
      loc: getSelection(context2, start3)
    };
  }
  function parseTextData(context2, length, mode2) {
    const rawText = context2.source.slice(0, length);
    advanceBy(context2, length);
    if (mode2 === 2 || mode2 === 3 || !rawText.includes("&")) {
      return rawText;
    } else {
      return context2.options.decodeEntities(rawText, mode2 === 4);
    }
  }
  function getCursor(context2) {
    const { column, line, offset } = context2;
    return { column, line, offset };
  }
  function getSelection(context2, start3, end) {
    end = end || getCursor(context2);
    return {
      start: start3,
      end,
      source: context2.originalSource.slice(start3.offset, end.offset)
    };
  }
  function last(xs) {
    return xs[xs.length - 1];
  }
  function startsWith(source, searchString) {
    return source.startsWith(searchString);
  }
  function advanceBy(context2, numberOfCharacters) {
    const { source } = context2;
    advancePositionWithMutation(context2, source, numberOfCharacters);
    context2.source = source.slice(numberOfCharacters);
  }
  function advanceSpaces(context2) {
    const match = /^[\t\r\n\f ]+/.exec(context2.source);
    if (match) {
      advanceBy(context2, match[0].length);
    }
  }
  function getNewPosition(context2, start3, numberOfCharacters) {
    return advancePositionWithClone(start3, context2.originalSource.slice(start3.offset, numberOfCharacters), numberOfCharacters);
  }
  function emitError(context2, code, offset, loc = getCursor(context2)) {
    if (offset) {
      loc.offset += offset;
      loc.column += offset;
    }
    context2.options.onError(createCompilerError(code, {
      start: loc,
      end: loc,
      source: ""
    }));
  }
  function isEnd(context2, mode2, ancestors) {
    const s4 = context2.source;
    switch (mode2) {
      case 0:
        if (startsWith(s4, "</")) {
          for (let i8 = ancestors.length - 1; i8 >= 0; --i8) {
            if (startsWithEndTagOpen(s4, ancestors[i8].tag)) {
              return true;
            }
          }
        }
        break;
      case 1:
      case 2: {
        const parent = last(ancestors);
        if (parent && startsWithEndTagOpen(s4, parent.tag)) {
          return true;
        }
        break;
      }
      case 3:
        if (startsWith(s4, "]]>")) {
          return true;
        }
        break;
    }
    return !s4;
  }
  function startsWithEndTagOpen(source, tag) {
    return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
  }
  function hoistStatic(root, context2) {
    walk(root, context2, isSingleElementRoot(root, root.children[0]));
  }
  function isSingleElementRoot(root, child) {
    const { children } = root;
    return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
  }
  function walk(node, context2, doNotHoistNode = false) {
    const { children } = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i8 = 0; i8 < children.length; i8++) {
      const child = children[i8];
      if (child.type === 1 && child.tagType === 0) {
        const constantType = doNotHoistNode ? 0 : getConstantType(child, context2);
        if (constantType > 0) {
          if (constantType >= 2) {
            child.codegenNode.patchFlag = -1 + (process.env.NODE_ENV !== "production" ? ` /* HOISTED */` : ``);
            child.codegenNode = context2.hoist(child.codegenNode);
            hoistedCount++;
            continue;
          }
        } else {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            const flag = getPatchFlag(codegenNode);
            if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context2) >= 2) {
              const props = getNodeProps(child);
              if (props) {
                codegenNode.props = context2.hoist(props);
              }
            }
            if (codegenNode.dynamicProps) {
              codegenNode.dynamicProps = context2.hoist(codegenNode.dynamicProps);
            }
          }
        }
      } else if (child.type === 12 && getConstantType(child.content, context2) >= 2) {
        child.codegenNode = context2.hoist(child.codegenNode);
        hoistedCount++;
      }
      if (child.type === 1) {
        const isComponent2 = child.tagType === 1;
        if (isComponent2) {
          context2.scopes.vSlot++;
        }
        walk(child, context2);
        if (isComponent2) {
          context2.scopes.vSlot--;
        }
      } else if (child.type === 11) {
        walk(child, context2, child.children.length === 1);
      } else if (child.type === 9) {
        for (let i9 = 0; i9 < child.branches.length; i9++) {
          walk(child.branches[i9], context2, child.branches[i9].children.length === 1);
        }
      }
    }
    if (hoistedCount && context2.transformHoist) {
      context2.transformHoist(children, context2, node);
    }
    if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray2(node.codegenNode.children)) {
      node.codegenNode.children = context2.hoist(createArrayExpression(node.codegenNode.children));
    }
  }
  function getConstantType(node, context2) {
    const { constantCache } = context2;
    switch (node.type) {
      case 1:
        if (node.tagType !== 0) {
          return 0;
        }
        const cached = constantCache.get(node);
        if (cached !== void 0) {
          return cached;
        }
        const codegenNode = node.codegenNode;
        if (codegenNode.type !== 13) {
          return 0;
        }
        if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
          return 0;
        }
        const flag = getPatchFlag(codegenNode);
        if (!flag) {
          let returnType2 = 3;
          const generatedPropsType = getGeneratedPropsConstantType(node, context2);
          if (generatedPropsType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (generatedPropsType < returnType2) {
            returnType2 = generatedPropsType;
          }
          for (let i8 = 0; i8 < node.children.length; i8++) {
            const childType = getConstantType(node.children[i8], context2);
            if (childType === 0) {
              constantCache.set(node, 0);
              return 0;
            }
            if (childType < returnType2) {
              returnType2 = childType;
            }
          }
          if (returnType2 > 1) {
            for (let i8 = 0; i8 < node.props.length; i8++) {
              const p6 = node.props[i8];
              if (p6.type === 7 && p6.name === "bind" && p6.exp) {
                const expType = getConstantType(p6.exp, context2);
                if (expType === 0) {
                  constantCache.set(node, 0);
                  return 0;
                }
                if (expType < returnType2) {
                  returnType2 = expType;
                }
              }
            }
          }
          if (codegenNode.isBlock) {
            for (let i8 = 0; i8 < node.props.length; i8++) {
              const p6 = node.props[i8];
              if (p6.type === 7) {
                constantCache.set(node, 0);
                return 0;
              }
            }
            context2.removeHelper(OPEN_BLOCK);
            context2.removeHelper(getVNodeBlockHelper(context2.inSSR, codegenNode.isComponent));
            codegenNode.isBlock = false;
            context2.helper(getVNodeHelper(context2.inSSR, codegenNode.isComponent));
          }
          constantCache.set(node, returnType2);
          return returnType2;
        } else {
          constantCache.set(node, 0);
          return 0;
        }
      case 2:
      case 3:
        return 3;
      case 9:
      case 11:
      case 10:
        return 0;
      case 5:
      case 12:
        return getConstantType(node.content, context2);
      case 4:
        return node.constType;
      case 8:
        let returnType = 3;
        for (let i8 = 0; i8 < node.children.length; i8++) {
          const child = node.children[i8];
          if (isString2(child) || isSymbol(child)) {
            continue;
          }
          const childType = getConstantType(child, context2);
          if (childType === 0) {
            return 0;
          } else if (childType < returnType) {
            returnType = childType;
          }
        }
        return returnType;
      default:
        if (process.env.NODE_ENV !== "production")
          ;
        return 0;
    }
  }
  function getConstantTypeOfHelperCall(value, context2) {
    if (value.type === 14 && !isString2(value.callee) && allowHoistedHelperSet.has(value.callee)) {
      const arg = value.arguments[0];
      if (arg.type === 4) {
        return getConstantType(arg, context2);
      } else if (arg.type === 14) {
        return getConstantTypeOfHelperCall(arg, context2);
      }
    }
    return 0;
  }
  function getGeneratedPropsConstantType(node, context2) {
    let returnType = 3;
    const props = getNodeProps(node);
    if (props && props.type === 15) {
      const { properties } = props;
      for (let i8 = 0; i8 < properties.length; i8++) {
        const { key, value } = properties[i8];
        const keyType = getConstantType(key, context2);
        if (keyType === 0) {
          return keyType;
        }
        if (keyType < returnType) {
          returnType = keyType;
        }
        let valueType;
        if (value.type === 4) {
          valueType = getConstantType(value, context2);
        } else if (value.type === 14) {
          valueType = getConstantTypeOfHelperCall(value, context2);
        } else {
          valueType = 0;
        }
        if (valueType === 0) {
          return valueType;
        }
        if (valueType < returnType) {
          returnType = valueType;
        }
      }
    }
    return returnType;
  }
  function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13) {
      return codegenNode.props;
    }
  }
  function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : void 0;
  }
  function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
    const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
    const context2 = {
      selfName: nameMatch && capitalize(camelize(nameMatch[1])),
      prefixIdentifiers,
      hoistStatic: hoistStatic2,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      isCustomElement,
      expressionPlugins,
      scopeId,
      slotted,
      ssr,
      inSSR,
      ssrCssVars,
      bindingMetadata,
      inline,
      isTS,
      onError,
      onWarn,
      compatConfig,
      root,
      helpers: /* @__PURE__ */ new Map(),
      components: /* @__PURE__ */ new Set(),
      directives: /* @__PURE__ */ new Set(),
      hoists: [],
      imports: [],
      constantCache: /* @__PURE__ */ new Map(),
      temps: 0,
      cached: 0,
      identifiers: /* @__PURE__ */ Object.create(null),
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0
      },
      parent: null,
      currentNode: root,
      childIndex: 0,
      inVOnce: false,
      helper(name2) {
        const count = context2.helpers.get(name2) || 0;
        context2.helpers.set(name2, count + 1);
        return name2;
      },
      removeHelper(name2) {
        const count = context2.helpers.get(name2);
        if (count) {
          const currentCount = count - 1;
          if (!currentCount) {
            context2.helpers.delete(name2);
          } else {
            context2.helpers.set(name2, currentCount);
          }
        }
      },
      helperString(name2) {
        return `_${helperNameMap[context2.helper(name2)]}`;
      },
      replaceNode(node) {
        if (process.env.NODE_ENV !== "production") {
          if (!context2.currentNode) {
            throw new Error(`Node being replaced is already removed.`);
          }
          if (!context2.parent) {
            throw new Error(`Cannot replace root node.`);
          }
        }
        context2.parent.children[context2.childIndex] = context2.currentNode = node;
      },
      removeNode(node) {
        if (process.env.NODE_ENV !== "production" && !context2.parent) {
          throw new Error(`Cannot remove root node.`);
        }
        const list = context2.parent.children;
        const removalIndex = node ? list.indexOf(node) : context2.currentNode ? context2.childIndex : -1;
        if (process.env.NODE_ENV !== "production" && removalIndex < 0) {
          throw new Error(`node being removed is not a child of current parent`);
        }
        if (!node || node === context2.currentNode) {
          context2.currentNode = null;
          context2.onNodeRemoved();
        } else {
          if (context2.childIndex > removalIndex) {
            context2.childIndex--;
            context2.onNodeRemoved();
          }
        }
        context2.parent.children.splice(removalIndex, 1);
      },
      onNodeRemoved: () => {
      },
      addIdentifiers(exp) {
      },
      removeIdentifiers(exp) {
      },
      hoist(exp) {
        if (isString2(exp))
          exp = createSimpleExpression(exp);
        context2.hoists.push(exp);
        const identifier = createSimpleExpression(`_hoisted_${context2.hoists.length}`, false, exp.loc, 2);
        identifier.hoisted = exp;
        return identifier;
      },
      cache(exp, isVNode2 = false) {
        return createCacheExpression(context2.cached++, exp, isVNode2);
      }
    };
    {
      context2.filters = /* @__PURE__ */ new Set();
    }
    return context2;
  }
  function transform(root, options2) {
    const context2 = createTransformContext(root, options2);
    traverseNode(root, context2);
    if (options2.hoistStatic) {
      hoistStatic(root, context2);
    }
    if (!options2.ssr) {
      createRootCodegen(root, context2);
    }
    root.helpers = [...context2.helpers.keys()];
    root.components = [...context2.components];
    root.directives = [...context2.directives];
    root.imports = context2.imports;
    root.hoists = context2.hoists;
    root.temps = context2.temps;
    root.cached = context2.cached;
    {
      root.filters = [...context2.filters];
    }
  }
  function createRootCodegen(root, context2) {
    const { helper } = context2;
    const { children } = root;
    if (children.length === 1) {
      const child = children[0];
      if (isSingleElementRoot(root, child) && child.codegenNode) {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          makeBlock(codegenNode, context2);
        }
        root.codegenNode = codegenNode;
      } else {
        root.codegenNode = child;
      }
    } else if (children.length > 1) {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (process.env.NODE_ENV !== "production" && children.filter((c6) => c6.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      root.codegenNode = createVNodeCall(context2, helper(FRAGMENT), void 0, root.children, patchFlag + (process.env.NODE_ENV !== "production" ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, void 0, false);
    } else
      ;
  }
  function traverseChildren(parent, context2) {
    let i8 = 0;
    const nodeRemoved = () => {
      i8--;
    };
    for (; i8 < parent.children.length; i8++) {
      const child = parent.children[i8];
      if (isString2(child))
        continue;
      context2.parent = parent;
      context2.childIndex = i8;
      context2.onNodeRemoved = nodeRemoved;
      traverseNode(child, context2);
    }
  }
  function traverseNode(node, context2) {
    context2.currentNode = node;
    const { nodeTransforms } = context2;
    const exitFns = [];
    for (let i9 = 0; i9 < nodeTransforms.length; i9++) {
      const onExit = nodeTransforms[i9](node, context2);
      if (onExit) {
        if (isArray2(onExit)) {
          exitFns.push(...onExit);
        } else {
          exitFns.push(onExit);
        }
      }
      if (!context2.currentNode) {
        return;
      } else {
        node = context2.currentNode;
      }
    }
    switch (node.type) {
      case 3:
        if (!context2.ssr) {
          context2.helper(CREATE_COMMENT);
        }
        break;
      case 5:
        if (!context2.ssr) {
          context2.helper(TO_DISPLAY_STRING);
        }
        break;
      case 9:
        for (let i9 = 0; i9 < node.branches.length; i9++) {
          traverseNode(node.branches[i9], context2);
        }
        break;
      case 10:
      case 11:
      case 1:
      case 0:
        traverseChildren(node, context2);
        break;
    }
    context2.currentNode = node;
    let i8 = exitFns.length;
    while (i8--) {
      exitFns[i8]();
    }
  }
  function createStructuralDirectiveTransform(name2, fn) {
    const matches2 = isString2(name2) ? (n8) => n8 === name2 : (n8) => name2.test(n8);
    return (node, context2) => {
      if (node.type === 1) {
        const { props } = node;
        if (node.tagType === 3 && props.some(isVSlot)) {
          return;
        }
        const exitFns = [];
        for (let i8 = 0; i8 < props.length; i8++) {
          const prop = props[i8];
          if (prop.type === 7 && matches2(prop.name)) {
            props.splice(i8, 1);
            i8--;
            const onExit = fn(node, prop, context2);
            if (onExit)
              exitFns.push(onExit);
          }
        }
        return exitFns;
      }
    };
  }
  function createCodegenContext(ast, { mode: mode2 = "function", prefixIdentifiers = mode2 === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
    const context2 = {
      mode: mode2,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeImports,
      runtimeGlobalName,
      runtimeModuleName,
      ssrRuntimeModuleName,
      ssr,
      isTS,
      inSSR,
      source: ast.loc.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: void 0,
      helper(key) {
        return `_${helperNameMap[key]}`;
      },
      push(code, node) {
        context2.code += code;
      },
      indent() {
        newline(++context2.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context2.indentLevel;
        } else {
          newline(--context2.indentLevel);
        }
      },
      newline() {
        newline(context2.indentLevel);
      }
    };
    function newline(n8) {
      context2.push("\n" + `  `.repeat(n8));
    }
    return context2;
  }
  function generate(ast, options2 = {}) {
    const context2 = createCodegenContext(ast, options2);
    if (options2.onContextCreated)
      options2.onContextCreated(context2);
    const { mode: mode2, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context2;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode2 !== "module";
    const preambleContext = context2;
    {
      genFunctionPreamble(ast, preambleContext);
    }
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
    const signature = args.join(", ");
    {
      push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
      push(`with (_ctx) {`);
      indent();
      if (hasHelpers) {
        push(`const { ${ast.helpers.map(aliasHelper).join(", ")} } = _Vue`);
        push(`
`);
        newline();
      }
    }
    if (ast.components.length) {
      genAssets(ast.components, "component", context2);
      if (ast.directives.length || ast.temps > 0) {
        newline();
      }
    }
    if (ast.directives.length) {
      genAssets(ast.directives, "directive", context2);
      if (ast.temps > 0) {
        newline();
      }
    }
    if (ast.filters && ast.filters.length) {
      newline();
      genAssets(ast.filters, "filter", context2);
      newline();
    }
    if (ast.temps > 0) {
      push(`let `);
      for (let i8 = 0; i8 < ast.temps; i8++) {
        push(`${i8 > 0 ? `, ` : ``}_temp${i8}`);
      }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
      push(`
`);
      newline();
    }
    if (!ssr) {
      push(`return `);
    }
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context2);
    } else {
      push(`null`);
    }
    if (useWithBlock) {
      deindent();
      push(`}`);
    }
    deindent();
    push(`}`);
    return {
      ast,
      code: context2.code,
      preamble: ``,
      map: context2.map ? context2.map.toJSON() : void 0
    };
  }
  function genFunctionPreamble(ast, context2) {
    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context2;
    const VueBinding = runtimeGlobalName;
    if (ast.helpers.length > 0) {
      {
        push(`const _Vue = ${VueBinding}
`);
        if (ast.hoists.length) {
          const staticHelpers = [
            CREATE_VNODE,
            CREATE_ELEMENT_VNODE,
            CREATE_COMMENT,
            CREATE_TEXT,
            CREATE_STATIC
          ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
          push(`const { ${staticHelpers} } = _Vue
`);
        }
      }
    }
    genHoists(ast.hoists, context2);
    newline();
    push(`return `);
  }
  function genAssets(assets, type, { helper, push, newline, isTS }) {
    const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
    for (let i8 = 0; i8 < assets.length; i8++) {
      let id = assets[i8];
      const maybeSelfReference = id.endsWith("__self");
      if (maybeSelfReference) {
        id = id.slice(0, -6);
      }
      push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
      if (i8 < assets.length - 1) {
        newline();
      }
    }
  }
  function genHoists(hoists, context2) {
    if (!hoists.length) {
      return;
    }
    context2.pure = true;
    const { push, newline, helper, scopeId, mode: mode2 } = context2;
    newline();
    for (let i8 = 0; i8 < hoists.length; i8++) {
      const exp = hoists[i8];
      if (exp) {
        push(`const _hoisted_${i8 + 1} = ${``}`);
        genNode(exp, context2);
        newline();
      }
    }
    context2.pure = false;
  }
  function isText$1(n8) {
    return isString2(n8) || n8.type === 4 || n8.type === 2 || n8.type === 5 || n8.type === 8;
  }
  function genNodeListAsArray(nodes, context2) {
    const multilines = nodes.length > 3 || process.env.NODE_ENV !== "production" && nodes.some((n8) => isArray2(n8) || !isText$1(n8));
    context2.push(`[`);
    multilines && context2.indent();
    genNodeList(nodes, context2, multilines);
    multilines && context2.deindent();
    context2.push(`]`);
  }
  function genNodeList(nodes, context2, multilines = false, comma = true) {
    const { push, newline } = context2;
    for (let i8 = 0; i8 < nodes.length; i8++) {
      const node = nodes[i8];
      if (isString2(node)) {
        push(node);
      } else if (isArray2(node)) {
        genNodeListAsArray(node, context2);
      } else {
        genNode(node, context2);
      }
      if (i8 < nodes.length - 1) {
        if (multilines) {
          comma && push(",");
          newline();
        } else {
          comma && push(", ");
        }
      }
    }
  }
  function genNode(node, context2) {
    if (isString2(node)) {
      context2.push(node);
      return;
    }
    if (isSymbol(node)) {
      context2.push(context2.helper(node));
      return;
    }
    switch (node.type) {
      case 1:
      case 9:
      case 11:
        process.env.NODE_ENV !== "production" && assert2(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
        genNode(node.codegenNode, context2);
        break;
      case 2:
        genText(node, context2);
        break;
      case 4:
        genExpression(node, context2);
        break;
      case 5:
        genInterpolation(node, context2);
        break;
      case 12:
        genNode(node.codegenNode, context2);
        break;
      case 8:
        genCompoundExpression(node, context2);
        break;
      case 3:
        genComment(node, context2);
        break;
      case 13:
        genVNodeCall(node, context2);
        break;
      case 14:
        genCallExpression(node, context2);
        break;
      case 15:
        genObjectExpression(node, context2);
        break;
      case 17:
        genArrayExpression(node, context2);
        break;
      case 18:
        genFunctionExpression(node, context2);
        break;
      case 19:
        genConditionalExpression(node, context2);
        break;
      case 20:
        genCacheExpression(node, context2);
        break;
      case 21:
        genNodeList(node.body, context2, true, false);
        break;
      case 22:
        break;
      case 23:
        break;
      case 24:
        break;
      case 25:
        break;
      case 26:
        break;
      case 10:
        break;
      default:
        if (process.env.NODE_ENV !== "production") {
          assert2(false, `unhandled codegen node type: ${node.type}`);
          const exhaustiveCheck = node;
          return exhaustiveCheck;
        }
    }
  }
  function genText(node, context2) {
    context2.push(JSON.stringify(node.content), node);
  }
  function genExpression(node, context2) {
    const { content, isStatic } = node;
    context2.push(isStatic ? JSON.stringify(content) : content, node);
  }
  function genInterpolation(node, context2) {
    const { push, helper, pure } = context2;
    if (pure)
      push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context2);
    push(`)`);
  }
  function genCompoundExpression(node, context2) {
    for (let i8 = 0; i8 < node.children.length; i8++) {
      const child = node.children[i8];
      if (isString2(child)) {
        context2.push(child);
      } else {
        genNode(child, context2);
      }
    }
  }
  function genExpressionAsPropertyKey(node, context2) {
    const { push } = context2;
    if (node.type === 8) {
      push(`[`);
      genCompoundExpression(node, context2);
      push(`]`);
    } else if (node.isStatic) {
      const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
      push(text, node);
    } else {
      push(`[${node.content}]`, node);
    }
  }
  function genComment(node, context2) {
    const { push, helper, pure } = context2;
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
  }
  function genVNodeCall(node, context2) {
    const { push, helper, pure } = context2;
    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node;
    if (directives) {
      push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
      push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
      push(PURE_ANNOTATION);
    }
    const callHelper = isBlock ? getVNodeBlockHelper(context2.inSSR, isComponent2) : getVNodeHelper(context2.inSSR, isComponent2);
    push(helper(callHelper) + `(`, node);
    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context2);
    push(`)`);
    if (isBlock) {
      push(`)`);
    }
    if (directives) {
      push(`, `);
      genNode(directives, context2);
      push(`)`);
    }
  }
  function genNullableArgs(args) {
    let i8 = args.length;
    while (i8--) {
      if (args[i8] != null)
        break;
    }
    return args.slice(0, i8 + 1).map((arg) => arg || `null`);
  }
  function genCallExpression(node, context2) {
    const { push, helper, pure } = context2;
    const callee = isString2(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context2);
    push(`)`);
  }
  function genObjectExpression(node, context2) {
    const { push, indent, deindent, newline } = context2;
    const { properties } = node;
    if (!properties.length) {
      push(`{}`, node);
      return;
    }
    const multilines = properties.length > 1 || process.env.NODE_ENV !== "production" && properties.some((p6) => p6.value.type !== 4);
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i8 = 0; i8 < properties.length; i8++) {
      const { key, value } = properties[i8];
      genExpressionAsPropertyKey(key, context2);
      push(`: `);
      genNode(value, context2);
      if (i8 < properties.length - 1) {
        push(`,`);
        newline();
      }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
  }
  function genArrayExpression(node, context2) {
    genNodeListAsArray(node.elements, context2);
  }
  function genFunctionExpression(node, context2) {
    const { push, indent, deindent } = context2;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
      push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if (isArray2(params)) {
      genNodeList(params, context2);
    } else if (params) {
      genNode(params, context2);
    }
    push(`) => `);
    if (newline || body) {
      push(`{`);
      indent();
    }
    if (returns) {
      if (newline) {
        push(`return `);
      }
      if (isArray2(returns)) {
        genNodeListAsArray(returns, context2);
      } else {
        genNode(returns, context2);
      }
    } else if (body) {
      genNode(body, context2);
    }
    if (newline || body) {
      deindent();
      push(`}`);
    }
    if (isSlot) {
      if (node.isNonScopedSlot) {
        push(`, undefined, true`);
      }
      push(`)`);
    }
  }
  function genConditionalExpression(node, context2) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context2;
    if (test.type === 4) {
      const needsParens = !isSimpleIdentifier(test.content);
      needsParens && push(`(`);
      genExpression(test, context2);
      needsParens && push(`)`);
    } else {
      push(`(`);
      genNode(test, context2);
      push(`)`);
    }
    needNewline && indent();
    context2.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context2);
    context2.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19;
    if (!isNested) {
      context2.indentLevel++;
    }
    genNode(alternate, context2);
    if (!isNested) {
      context2.indentLevel--;
    }
    needNewline && deindent(true);
  }
  function genCacheExpression(node, context2) {
    const { push, helper, indent, deindent, newline } = context2;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
      indent();
      push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
      newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context2);
    if (node.isVNode) {
      push(`,`);
      newline();
      push(`${helper(SET_BLOCK_TRACKING)}(1),`);
      newline();
      push(`_cache[${node.index}]`);
      deindent();
    }
    push(`)`);
  }
  function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
    {
      return;
    }
  }
  function isReferencedIdentifier(id, parent, parentStack) {
    {
      return false;
    }
  }
  function isInDestructureAssignment(parent, parentStack) {
    if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
      let i8 = parentStack.length;
      while (i8--) {
        const p6 = parentStack[i8];
        if (p6.type === "AssignmentExpression") {
          return true;
        } else if (p6.type !== "ObjectProperty" && !p6.type.endsWith("Pattern")) {
          break;
        }
      }
    }
    return false;
  }
  function walkFunctionParams(node, onIdent) {
    for (const p6 of node.params) {
      for (const id of extractIdentifiers(p6)) {
        onIdent(id);
      }
    }
  }
  function walkBlockDeclarations(block, onIdent) {
    for (const stmt of block.body) {
      if (stmt.type === "VariableDeclaration") {
        if (stmt.declare)
          continue;
        for (const decl of stmt.declarations) {
          for (const id of extractIdentifiers(decl.id)) {
            onIdent(id);
          }
        }
      } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
        if (stmt.declare || !stmt.id)
          continue;
        onIdent(stmt.id);
      }
    }
  }
  function extractIdentifiers(param, nodes = []) {
    switch (param.type) {
      case "Identifier":
        nodes.push(param);
        break;
      case "MemberExpression":
        let object = param;
        while (object.type === "MemberExpression") {
          object = object.object;
        }
        nodes.push(object);
        break;
      case "ObjectPattern":
        for (const prop of param.properties) {
          if (prop.type === "RestElement") {
            extractIdentifiers(prop.argument, nodes);
          } else {
            extractIdentifiers(prop.value, nodes);
          }
        }
        break;
      case "ArrayPattern":
        param.elements.forEach((element) => {
          if (element)
            extractIdentifiers(element, nodes);
        });
        break;
      case "RestElement":
        extractIdentifiers(param.argument, nodes);
        break;
      case "AssignmentPattern":
        extractIdentifiers(param.left, nodes);
        break;
    }
    return nodes;
  }
  function validateBrowserExpression(node, context2, asParams = false, asRawStatements = false) {
    const exp = node.content;
    if (!exp.trim()) {
      return;
    }
    try {
      new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
    } catch (e8) {
      let message = e8.message;
      const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
      if (keywordMatch) {
        message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
      }
      context2.onError(createCompilerError(44, node.loc, void 0, message));
    }
  }
  function processExpression(node, context2, asParams = false, asRawStatements = false, localVars = Object.create(context2.identifiers)) {
    {
      if (process.env.NODE_ENV !== "production") {
        validateBrowserExpression(node, context2, asParams, asRawStatements);
      }
      return node;
    }
  }
  function processIf(node, dir, context2, processCodegen) {
    if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
      const loc = dir.exp ? dir.exp.loc : node.loc;
      context2.onError(createCompilerError(28, dir.loc));
      dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if (process.env.NODE_ENV !== "production" && true && dir.exp) {
      validateBrowserExpression(dir.exp, context2);
    }
    if (dir.name === "if") {
      const branch = createIfBranch(node, dir);
      const ifNode = {
        type: 9,
        loc: node.loc,
        branches: [branch]
      };
      context2.replaceNode(ifNode);
      if (processCodegen) {
        return processCodegen(ifNode, branch, true);
      }
    } else {
      const siblings = context2.parent.children;
      const comments = [];
      let i8 = siblings.indexOf(node);
      while (i8-- >= -1) {
        const sibling = siblings[i8];
        if (process.env.NODE_ENV !== "production" && sibling && sibling.type === 3) {
          context2.removeNode(sibling);
          comments.unshift(sibling);
          continue;
        }
        if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
          context2.removeNode(sibling);
          continue;
        }
        if (sibling && sibling.type === 9) {
          if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
            context2.onError(createCompilerError(30, node.loc));
          }
          context2.removeNode();
          const branch = createIfBranch(node, dir);
          if (process.env.NODE_ENV !== "production" && comments.length && !(context2.parent && context2.parent.type === 1 && isBuiltInType(context2.parent.tag, "transition"))) {
            branch.children = [...comments, ...branch.children];
          }
          if (process.env.NODE_ENV !== "production" || false) {
            const key = branch.userKey;
            if (key) {
              sibling.branches.forEach(({ userKey }) => {
                if (isSameKey(userKey, key)) {
                  context2.onError(createCompilerError(29, branch.userKey.loc));
                }
              });
            }
          }
          sibling.branches.push(branch);
          const onExit = processCodegen && processCodegen(sibling, branch, false);
          traverseNode(branch, context2);
          if (onExit)
            onExit();
          context2.currentNode = null;
        } else {
          context2.onError(createCompilerError(30, node.loc));
        }
        break;
      }
    }
  }
  function createIfBranch(node, dir) {
    const isTemplateIf = node.tagType === 3;
    return {
      type: 10,
      loc: node.loc,
      condition: dir.name === "else" ? void 0 : dir.exp,
      children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
      userKey: findProp(node, `key`),
      isTemplateIf
    };
  }
  function createCodegenNodeForBranch(branch, keyIndex, context2) {
    if (branch.condition) {
      return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context2), createCallExpression(context2.helper(CREATE_COMMENT), [
        process.env.NODE_ENV !== "production" ? '"v-if"' : '""',
        "true"
      ]));
    } else {
      return createChildrenCodegenNode(branch, keyIndex, context2);
    }
  }
  function createChildrenCodegenNode(branch, keyIndex, context2) {
    const { helper } = context2;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
    if (needFragmentWrapper) {
      if (children.length === 1 && firstChild.type === 11) {
        const vnodeCall = firstChild.codegenNode;
        injectProp(vnodeCall, keyProperty, context2);
        return vnodeCall;
      } else {
        let patchFlag = 64;
        let patchFlagText = PatchFlagNames[64];
        if (process.env.NODE_ENV !== "production" && !branch.isTemplateIf && children.filter((c6) => c6.type !== 3).length === 1) {
          patchFlag |= 2048;
          patchFlagText += `, ${PatchFlagNames[2048]}`;
        }
        return createVNodeCall(context2, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (process.env.NODE_ENV !== "production" ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, false, branch.loc);
      }
    } else {
      const ret = firstChild.codegenNode;
      const vnodeCall = getMemoedVNodeCall(ret);
      if (vnodeCall.type === 13) {
        makeBlock(vnodeCall, context2);
      }
      injectProp(vnodeCall, keyProperty, context2);
      return ret;
    }
  }
  function isSameKey(a8, b5) {
    if (!a8 || a8.type !== b5.type) {
      return false;
    }
    if (a8.type === 6) {
      if (a8.value.content !== b5.value.content) {
        return false;
      }
    } else {
      const exp = a8.exp;
      const branchExp = b5.exp;
      if (exp.type !== branchExp.type) {
        return false;
      }
      if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
        return false;
      }
    }
    return true;
  }
  function getParentCondition(node) {
    while (true) {
      if (node.type === 19) {
        if (node.alternate.type === 19) {
          node = node.alternate;
        } else {
          return node;
        }
      } else if (node.type === 20) {
        node = node.value;
      }
    }
  }
  function processFor(node, dir, context2, processCodegen) {
    if (!dir.exp) {
      context2.onError(createCompilerError(31, dir.loc));
      return;
    }
    const parseResult = parseForExpression(dir.exp, context2);
    if (!parseResult) {
      context2.onError(createCompilerError(32, dir.loc));
      return;
    }
    const { addIdentifiers, removeIdentifiers, scopes } = context2;
    const { source, value, key, index: index15 } = parseResult;
    const forNode = {
      type: 11,
      loc: dir.loc,
      source,
      valueAlias: value,
      keyAlias: key,
      objectIndexAlias: index15,
      parseResult,
      children: isTemplateNode(node) ? node.children : [node]
    };
    context2.replaceNode(forNode);
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
      scopes.vFor--;
      if (onExit)
        onExit();
    };
  }
  function parseForExpression(input2, context2) {
    const loc = input2.loc;
    const exp = input2.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
      return;
    const [, LHS, RHS] = inMatch;
    const result = {
      source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
      value: void 0,
      key: void 0,
      index: void 0
    };
    if (process.env.NODE_ENV !== "production" && true) {
      validateBrowserExpression(result.source, context2);
    }
    let valueContent = LHS.trim().replace(stripParensRE, "").trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
      valueContent = valueContent.replace(forIteratorRE, "").trim();
      const keyContent = iteratorMatch[1].trim();
      let keyOffset;
      if (keyContent) {
        keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
        result.key = createAliasExpression(loc, keyContent, keyOffset);
        if (process.env.NODE_ENV !== "production" && true) {
          validateBrowserExpression(result.key, context2, true);
        }
      }
      if (iteratorMatch[2]) {
        const indexContent = iteratorMatch[2].trim();
        if (indexContent) {
          result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
          if (process.env.NODE_ENV !== "production" && true) {
            validateBrowserExpression(result.index, context2, true);
          }
        }
      }
    }
    if (valueContent) {
      result.value = createAliasExpression(loc, valueContent, trimmedOffset);
      if (process.env.NODE_ENV !== "production" && true) {
        validateBrowserExpression(result.value, context2, true);
      }
    }
    return result;
  }
  function createAliasExpression(range4, content, offset) {
    return createSimpleExpression(content, false, getInnerRange(range4, offset, content.length));
  }
  function createForLoopParams({ value, key, index: index15 }, memoArgs = []) {
    return createParamsList([value, key, index15, ...memoArgs]);
  }
  function createParamsList(args) {
    let i8 = args.length;
    while (i8--) {
      if (args[i8])
        break;
    }
    return args.slice(0, i8 + 1).map((arg, i9) => arg || createSimpleExpression(`_`.repeat(i9 + 1), false));
  }
  function buildSlots(node, context2, buildSlotFn = buildClientSlotFn) {
    context2.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    let hasDynamicSlots = context2.scopes.vSlot > 0 || context2.scopes.vFor > 0;
    const onComponentSlot = findDir(node, "slot", true);
    if (onComponentSlot) {
      const { arg, exp } = onComponentSlot;
      if (arg && !isStaticExp(arg)) {
        hasDynamicSlots = true;
      }
      slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
    }
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = /* @__PURE__ */ new Set();
    for (let i8 = 0; i8 < children.length; i8++) {
      const slotElement = children[i8];
      let slotDir;
      if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
        if (slotElement.type !== 3) {
          implicitDefaultChildren.push(slotElement);
        }
        continue;
      }
      if (onComponentSlot) {
        context2.onError(createCompilerError(37, slotDir.loc));
        break;
      }
      hasTemplateSlots = true;
      const { children: slotChildren, loc: slotLoc } = slotElement;
      const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
      let staticSlotName;
      if (isStaticExp(slotName)) {
        staticSlotName = slotName ? slotName.content : `default`;
      } else {
        hasDynamicSlots = true;
      }
      const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
      let vIf;
      let vElse;
      let vFor;
      if (vIf = findDir(slotElement, "if")) {
        hasDynamicSlots = true;
        dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
      } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
        let j2 = i8;
        let prev;
        while (j2--) {
          prev = children[j2];
          if (prev.type !== 3) {
            break;
          }
        }
        if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
          children.splice(i8, 1);
          i8--;
          let conditional = dynamicSlots[dynamicSlots.length - 1];
          while (conditional.alternate.type === 19) {
            conditional = conditional.alternate;
          }
          conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
        } else {
          context2.onError(createCompilerError(30, vElse.loc));
        }
      } else if (vFor = findDir(slotElement, "for")) {
        hasDynamicSlots = true;
        const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context2);
        if (parseResult) {
          dynamicSlots.push(createCallExpression(context2.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
          ]));
        } else {
          context2.onError(createCompilerError(32, vFor.loc));
        }
      } else {
        if (staticSlotName) {
          if (seenSlotNames.has(staticSlotName)) {
            context2.onError(createCompilerError(38, dirLoc));
            continue;
          }
          seenSlotNames.add(staticSlotName);
          if (staticSlotName === "default") {
            hasNamedDefaultSlot = true;
          }
        }
        slotsProperties.push(createObjectProperty(slotName, slotFunction));
      }
    }
    if (!onComponentSlot) {
      const buildDefaultSlotProperty = (props, children2) => {
        const fn = buildSlotFn(props, children2, loc);
        if (context2.compatConfig) {
          fn.isNonScopedSlot = true;
        }
        return createObjectProperty(`default`, fn);
      };
      if (!hasTemplateSlots) {
        slotsProperties.push(buildDefaultSlotProperty(void 0, children));
      } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
        if (hasNamedDefaultSlot) {
          context2.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
        } else {
          slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
        }
      }
    }
    const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + (process.env.NODE_ENV !== "production" ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false))), loc);
    if (dynamicSlots.length) {
      slots = createCallExpression(context2.helper(CREATE_SLOTS), [
        slots,
        createArrayExpression(dynamicSlots)
      ]);
    }
    return {
      slots,
      hasDynamicSlots
    };
  }
  function buildDynamicSlot(name2, fn) {
    return createObjectExpression([
      createObjectProperty(`name`, name2),
      createObjectProperty(`fn`, fn)
    ]);
  }
  function hasForwardedSlots(children) {
    for (let i8 = 0; i8 < children.length; i8++) {
      const child = children[i8];
      switch (child.type) {
        case 1:
          if (child.tagType === 2 || hasForwardedSlots(child.children)) {
            return true;
          }
          break;
        case 9:
          if (hasForwardedSlots(child.branches))
            return true;
          break;
        case 10:
        case 11:
          if (hasForwardedSlots(child.children))
            return true;
          break;
      }
    }
    return false;
  }
  function isNonWhitespaceContent(node) {
    if (node.type !== 2 && node.type !== 12)
      return true;
    return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
  }
  function resolveComponentType(node, context2, ssr = false) {
    let { tag } = node;
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(node, "is");
    if (isProp) {
      if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2)) {
        const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
        if (exp) {
          return createCallExpression(context2.helper(RESOLVE_DYNAMIC_COMPONENT), [
            exp
          ]);
        }
      } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
        tag = isProp.value.content.slice(4);
      }
    }
    const isDir = !isExplicitDynamic && findDir(node, "is");
    if (isDir && isDir.exp) {
      return createCallExpression(context2.helper(RESOLVE_DYNAMIC_COMPONENT), [
        isDir.exp
      ]);
    }
    const builtIn = isCoreComponent(tag) || context2.isBuiltInComponent(tag);
    if (builtIn) {
      if (!ssr)
        context2.helper(builtIn);
      return builtIn;
    }
    context2.helper(RESOLVE_COMPONENT);
    context2.components.add(tag);
    return toValidAssetId(tag, `component`);
  }
  function buildProps(node, context2, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
    const { tag, loc: elementLoc, children } = node;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    const hasChildren = children.length > 0;
    let shouldUseBlock = false;
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const analyzePatchFlag = ({ key, value }) => {
      if (isStaticExp(key)) {
        const name2 = key.content;
        const isEventHandler = isOn(name2);
        if (isEventHandler && (!isComponent2 || isDynamicComponent) && name2.toLowerCase() !== "onclick" && name2 !== "onUpdate:modelValue" && !isReservedProp(name2)) {
          hasHydrationEventBinding = true;
        }
        if (isEventHandler && isReservedProp(name2)) {
          hasVnodeHook = true;
        }
        if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context2) > 0) {
          return;
        }
        if (name2 === "ref") {
          hasRef = true;
        } else if (name2 === "class") {
          hasClassBinding = true;
        } else if (name2 === "style") {
          hasStyleBinding = true;
        } else if (name2 !== "key" && !dynamicPropNames.includes(name2)) {
          dynamicPropNames.push(name2);
        }
        if (isComponent2 && (name2 === "class" || name2 === "style") && !dynamicPropNames.includes(name2)) {
          dynamicPropNames.push(name2);
        }
      } else {
        hasDynamicKeys = true;
      }
    };
    for (let i8 = 0; i8 < props.length; i8++) {
      const prop = props[i8];
      if (prop.type === 6) {
        const { loc, name: name2, value } = prop;
        let isStatic = true;
        if (name2 === "ref") {
          hasRef = true;
          if (context2.scopes.vFor > 0) {
            properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
          }
        }
        if (name2 === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2))) {
          continue;
        }
        properties.push(createObjectProperty(createSimpleExpression(name2, true, getInnerRange(loc, 0, name2.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
      } else {
        const { name: name2, arg, exp, loc } = prop;
        const isVBind = name2 === "bind";
        const isVOn = name2 === "on";
        if (name2 === "slot") {
          if (!isComponent2) {
            context2.onError(createCompilerError(40, loc));
          }
          continue;
        }
        if (name2 === "once" || name2 === "memo") {
          continue;
        }
        if (name2 === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2))) {
          continue;
        }
        if (isVOn && ssr) {
          continue;
        }
        if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
          shouldUseBlock = true;
        }
        if (isVBind && isStaticArgOf(arg, "ref") && context2.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
        }
        if (!arg && (isVBind || isVOn)) {
          hasDynamicKeys = true;
          if (exp) {
            if (properties.length) {
              mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
              properties = [];
            }
            if (isVBind) {
              {
                if (process.env.NODE_ENV !== "production") {
                  const hasOverridableKeys = mergeArgs.some((arg2) => {
                    if (arg2.type === 15) {
                      return arg2.properties.some(({ key }) => {
                        if (key.type !== 4 || !key.isStatic) {
                          return true;
                        }
                        return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                      });
                    } else {
                      return true;
                    }
                  });
                  if (hasOverridableKeys) {
                    checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context2, loc);
                  }
                }
                if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context2)) {
                  mergeArgs.unshift(exp);
                  continue;
                }
              }
              mergeArgs.push(exp);
            } else {
              mergeArgs.push({
                type: 14,
                loc,
                callee: context2.helper(TO_HANDLERS),
                arguments: [exp]
              });
            }
          } else {
            context2.onError(createCompilerError(isVBind ? 34 : 35, loc));
          }
          continue;
        }
        const directiveTransform = context2.directiveTransforms[name2];
        if (directiveTransform) {
          const { props: props2, needRuntime } = directiveTransform(prop, node, context2);
          !ssr && props2.forEach(analyzePatchFlag);
          properties.push(...props2);
          if (needRuntime) {
            runtimeDirectives.push(prop);
            if (isSymbol(needRuntime)) {
              directiveImportMap.set(prop, needRuntime);
            }
          }
        } else if (!isBuiltInDirective(name2)) {
          runtimeDirectives.push(prop);
          if (hasChildren) {
            shouldUseBlock = true;
          }
        }
      }
    }
    let propsExpression = void 0;
    if (mergeArgs.length) {
      if (properties.length) {
        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
      }
      if (mergeArgs.length > 1) {
        propsExpression = createCallExpression(context2.helper(MERGE_PROPS), mergeArgs, elementLoc);
      } else {
        propsExpression = mergeArgs[0];
      }
    } else if (properties.length) {
      propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    if (hasDynamicKeys) {
      patchFlag |= 16;
    } else {
      if (hasClassBinding && !isComponent2) {
        patchFlag |= 2;
      }
      if (hasStyleBinding && !isComponent2) {
        patchFlag |= 4;
      }
      if (dynamicPropNames.length) {
        patchFlag |= 8;
      }
      if (hasHydrationEventBinding) {
        patchFlag |= 32;
      }
    }
    if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
      patchFlag |= 512;
    }
    if (!context2.inSSR && propsExpression) {
      switch (propsExpression.type) {
        case 15:
          let classKeyIndex = -1;
          let styleKeyIndex = -1;
          let hasDynamicKey = false;
          for (let i8 = 0; i8 < propsExpression.properties.length; i8++) {
            const key = propsExpression.properties[i8].key;
            if (isStaticExp(key)) {
              if (key.content === "class") {
                classKeyIndex = i8;
              } else if (key.content === "style") {
                styleKeyIndex = i8;
              }
            } else if (!key.isHandlerKey) {
              hasDynamicKey = true;
            }
          }
          const classProp = propsExpression.properties[classKeyIndex];
          const styleProp = propsExpression.properties[styleKeyIndex];
          if (!hasDynamicKey) {
            if (classProp && !isStaticExp(classProp.value)) {
              classProp.value = createCallExpression(context2.helper(NORMALIZE_CLASS), [classProp.value]);
            }
            if (styleProp && (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || styleProp.value.type === 17)) {
              styleProp.value = createCallExpression(context2.helper(NORMALIZE_STYLE), [styleProp.value]);
            }
          } else {
            propsExpression = createCallExpression(context2.helper(NORMALIZE_PROPS), [propsExpression]);
          }
          break;
        case 14:
          break;
        default:
          propsExpression = createCallExpression(context2.helper(NORMALIZE_PROPS), [
            createCallExpression(context2.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]);
          break;
      }
    }
    return {
      props: propsExpression,
      directives: runtimeDirectives,
      patchFlag,
      dynamicPropNames,
      shouldUseBlock
    };
  }
  function dedupeProperties(properties) {
    const knownProps = /* @__PURE__ */ new Map();
    const deduped = [];
    for (let i8 = 0; i8 < properties.length; i8++) {
      const prop = properties[i8];
      if (prop.key.type === 8 || !prop.key.isStatic) {
        deduped.push(prop);
        continue;
      }
      const name2 = prop.key.content;
      const existing = knownProps.get(name2);
      if (existing) {
        if (name2 === "style" || name2 === "class" || isOn(name2)) {
          mergeAsArray(existing, prop);
        }
      } else {
        knownProps.set(name2, prop);
        deduped.push(prop);
      }
    }
    return deduped;
  }
  function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17) {
      existing.value.elements.push(incoming.value);
    } else {
      existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
  }
  function buildDirectiveArgs(dir, context2) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
      dirArgs.push(context2.helperString(runtime));
    } else {
      {
        context2.helper(RESOLVE_DIRECTIVE);
        context2.directives.add(dir.name);
        dirArgs.push(toValidAssetId(dir.name, `directive`));
      }
    }
    const { loc } = dir;
    if (dir.exp)
      dirArgs.push(dir.exp);
    if (dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
      if (!dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(`void 0`);
      }
      const trueExpression = createSimpleExpression(`true`, false, loc);
      dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
  }
  function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i8 = 0, l5 = props.length; i8 < l5; i8++) {
      propsNamesString += JSON.stringify(props[i8]);
      if (i8 < l5 - 1)
        propsNamesString += ", ";
    }
    return propsNamesString + `]`;
  }
  function isComponentTag(tag) {
    return tag === "component" || tag === "Component";
  }
  function processSlotOutlet(node, context2) {
    let slotName = `"default"`;
    let slotProps = void 0;
    const nonNameProps = [];
    for (let i8 = 0; i8 < node.props.length; i8++) {
      const p6 = node.props[i8];
      if (p6.type === 6) {
        if (p6.value) {
          if (p6.name === "name") {
            slotName = JSON.stringify(p6.value.content);
          } else {
            p6.name = camelize2(p6.name);
            nonNameProps.push(p6);
          }
        }
      } else {
        if (p6.name === "bind" && isStaticArgOf(p6.arg, "name")) {
          if (p6.exp)
            slotName = p6.exp;
        } else {
          if (p6.name === "bind" && p6.arg && isStaticExp(p6.arg)) {
            p6.arg.content = camelize2(p6.arg.content);
          }
          nonNameProps.push(p6);
        }
      }
    }
    if (nonNameProps.length > 0) {
      const { props, directives } = buildProps(node, context2, nonNameProps, false, false);
      slotProps = props;
      if (directives.length) {
        context2.onError(createCompilerError(36, directives[0].loc));
      }
    }
    return {
      slotName,
      slotProps
    };
  }
  function createTransformProps(props = []) {
    return { props };
  }
  function rewriteFilter(node, context2) {
    if (node.type === 4) {
      parseFilter(node, context2);
    } else {
      for (let i8 = 0; i8 < node.children.length; i8++) {
        const child = node.children[i8];
        if (typeof child !== "object")
          continue;
        if (child.type === 4) {
          parseFilter(child, context2);
        } else if (child.type === 8) {
          rewriteFilter(node, context2);
        } else if (child.type === 5) {
          rewriteFilter(child.content, context2);
        }
      }
    }
  }
  function parseFilter(node, context2) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c6, prev, i8, expression, filters = [];
    for (i8 = 0; i8 < exp.length; i8++) {
      prev = c6;
      c6 = exp.charCodeAt(i8);
      if (inSingle) {
        if (c6 === 39 && prev !== 92)
          inSingle = false;
      } else if (inDouble) {
        if (c6 === 34 && prev !== 92)
          inDouble = false;
      } else if (inTemplateString) {
        if (c6 === 96 && prev !== 92)
          inTemplateString = false;
      } else if (inRegex) {
        if (c6 === 47 && prev !== 92)
          inRegex = false;
      } else if (c6 === 124 && exp.charCodeAt(i8 + 1) !== 124 && exp.charCodeAt(i8 - 1) !== 124 && !curly && !square && !paren) {
        if (expression === void 0) {
          lastFilterIndex = i8 + 1;
          expression = exp.slice(0, i8).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c6) {
          case 34:
            inDouble = true;
            break;
          case 39:
            inSingle = true;
            break;
          case 96:
            inTemplateString = true;
            break;
          case 40:
            paren++;
            break;
          case 41:
            paren--;
            break;
          case 91:
            square++;
            break;
          case 93:
            square--;
            break;
          case 123:
            curly++;
            break;
          case 125:
            curly--;
            break;
        }
        if (c6 === 47) {
          let j2 = i8 - 1;
          let p6;
          for (; j2 >= 0; j2--) {
            p6 = exp.charAt(j2);
            if (p6 !== " ")
              break;
          }
          if (!p6 || !validDivisionCharRE.test(p6)) {
            inRegex = true;
          }
        }
      }
    }
    if (expression === void 0) {
      expression = exp.slice(0, i8).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }
    function pushFilter() {
      filters.push(exp.slice(lastFilterIndex, i8).trim());
      lastFilterIndex = i8 + 1;
    }
    if (filters.length) {
      process.env.NODE_ENV !== "production" && warnDeprecation("COMPILER_FILTER", context2, node.loc);
      for (i8 = 0; i8 < filters.length; i8++) {
        expression = wrapFilter(expression, filters[i8], context2);
      }
      node.content = expression;
    }
  }
  function wrapFilter(exp, filter2, context2) {
    context2.helper(RESOLVE_FILTER);
    const i8 = filter2.indexOf("(");
    if (i8 < 0) {
      context2.filters.add(filter2);
      return `${toValidAssetId(filter2, "filter")}(${exp})`;
    } else {
      const name2 = filter2.slice(0, i8);
      const args = filter2.slice(i8 + 1);
      context2.filters.add(name2);
      return `${toValidAssetId(name2, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
    }
  }
  function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        transformOnce,
        transformIf,
        transformMemo,
        transformFor,
        ...[transformFilter],
        ...process.env.NODE_ENV !== "production" ? [transformExpression] : [],
        transformSlotOutlet,
        transformElement,
        trackSlotScopes,
        transformText
      ],
      {
        on: transformOn,
        bind: transformBind,
        model: transformModel
      }
    ];
  }
  function baseCompile(template, options2 = {}) {
    const onError = options2.onError || defaultOnError;
    const isModuleMode = options2.mode === "module";
    {
      if (options2.prefixIdentifiers === true) {
        onError(createCompilerError(46));
      } else if (isModuleMode) {
        onError(createCompilerError(47));
      }
    }
    const prefixIdentifiers = false;
    if (options2.cacheHandlers) {
      onError(createCompilerError(48));
    }
    if (options2.scopeId && !isModuleMode) {
      onError(createCompilerError(49));
    }
    const ast = isString2(template) ? baseParse(template, options2) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, extend({}, options2, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...options2.nodeTransforms || []
      ],
      directiveTransforms: extend({}, directiveTransforms, options2.directiveTransforms || {})
    }));
    return generate(ast, extend({}, options2, {
      prefixIdentifiers
    }));
  }
  var errorMessages, FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, locStub, isStaticExp, isBuiltInType, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, propsHelperSet, deprecationData, decodeRE, decodeMap, defaultParserOptions, isSpecialTemplateDirective, allowHoistedHelperSet, PURE_ANNOTATION, aliasHelper, isFunctionType, isStaticProperty, isStaticPropertyKey, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformFor, forAliasRE, forIteratorRE, stripParensRE, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, cacheStringFunction2, camelizeRE2, camelize2, transformSlotOutlet, fnExpRE, transformOn, transformBind, injectPrefix, transformText, seen, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen$1, transformMemo, noopDirectiveTransform;
  var init_compiler_core_esm_bundler = __esm({
    "node_modules/.pnpm/@vue+compiler-core@3.2.37/node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
      init_shared_esm_bundler();
      init_shared_esm_bundler();
      errorMessages = {
        [0]: "Illegal comment.",
        [1]: "CDATA section is allowed only in XML context.",
        [2]: "Duplicate attribute.",
        [3]: "End tag cannot have attributes.",
        [4]: "Illegal '/' in tags.",
        [5]: "Unexpected EOF in tag.",
        [6]: "Unexpected EOF in CDATA section.",
        [7]: "Unexpected EOF in comment.",
        [8]: "Unexpected EOF in script.",
        [9]: "Unexpected EOF in tag.",
        [10]: "Incorrectly closed comment.",
        [11]: "Incorrectly opened comment.",
        [12]: "Illegal tag name. Use '&lt;' to print '<'.",
        [13]: "Attribute value was expected.",
        [14]: "End tag name was expected.",
        [15]: "Whitespace was expected.",
        [16]: "Unexpected '<!--' in comment.",
        [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
        [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
        [19]: "Attribute name cannot start with '='.",
        [21]: "'<?' is allowed only in XML context.",
        [20]: `Unexpected null character.`,
        [22]: "Illegal '/' in tags.",
        [23]: "Invalid end tag.",
        [24]: "Element is missing end tag.",
        [25]: "Interpolation end sign was not found.",
        [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
        [26]: "Legal directive name was expected.",
        [28]: `v-if/v-else-if is missing expression.`,
        [29]: `v-if/else branches must use unique keys.`,
        [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
        [31]: `v-for is missing expression.`,
        [32]: `v-for has invalid expression.`,
        [33]: `<template v-for> key should be placed on the <template> tag.`,
        [34]: `v-bind is missing expression.`,
        [35]: `v-on is missing expression.`,
        [36]: `Unexpected custom directive on <slot> outlet.`,
        [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
        [38]: `Duplicate slot names found. `,
        [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
        [40]: `v-slot can only be used on components or <template> tags.`,
        [41]: `v-model is missing expression.`,
        [42]: `v-model value must be a valid JavaScript member expression.`,
        [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
        [44]: `Error parsing JavaScript expression: `,
        [45]: `<KeepAlive> expects exactly one child component.`,
        [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
        [47]: `ES module mode is not supported in this build of compiler.`,
        [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
        [49]: `"scopeId" option is only supported in module mode.`,
        [50]: ``
      };
      FRAGMENT = Symbol(process.env.NODE_ENV !== "production" ? `Fragment` : ``);
      TELEPORT = Symbol(process.env.NODE_ENV !== "production" ? `Teleport` : ``);
      SUSPENSE = Symbol(process.env.NODE_ENV !== "production" ? `Suspense` : ``);
      KEEP_ALIVE = Symbol(process.env.NODE_ENV !== "production" ? `KeepAlive` : ``);
      BASE_TRANSITION = Symbol(process.env.NODE_ENV !== "production" ? `BaseTransition` : ``);
      OPEN_BLOCK = Symbol(process.env.NODE_ENV !== "production" ? `openBlock` : ``);
      CREATE_BLOCK = Symbol(process.env.NODE_ENV !== "production" ? `createBlock` : ``);
      CREATE_ELEMENT_BLOCK = Symbol(process.env.NODE_ENV !== "production" ? `createElementBlock` : ``);
      CREATE_VNODE = Symbol(process.env.NODE_ENV !== "production" ? `createVNode` : ``);
      CREATE_ELEMENT_VNODE = Symbol(process.env.NODE_ENV !== "production" ? `createElementVNode` : ``);
      CREATE_COMMENT = Symbol(process.env.NODE_ENV !== "production" ? `createCommentVNode` : ``);
      CREATE_TEXT = Symbol(process.env.NODE_ENV !== "production" ? `createTextVNode` : ``);
      CREATE_STATIC = Symbol(process.env.NODE_ENV !== "production" ? `createStaticVNode` : ``);
      RESOLVE_COMPONENT = Symbol(process.env.NODE_ENV !== "production" ? `resolveComponent` : ``);
      RESOLVE_DYNAMIC_COMPONENT = Symbol(process.env.NODE_ENV !== "production" ? `resolveDynamicComponent` : ``);
      RESOLVE_DIRECTIVE = Symbol(process.env.NODE_ENV !== "production" ? `resolveDirective` : ``);
      RESOLVE_FILTER = Symbol(process.env.NODE_ENV !== "production" ? `resolveFilter` : ``);
      WITH_DIRECTIVES = Symbol(process.env.NODE_ENV !== "production" ? `withDirectives` : ``);
      RENDER_LIST = Symbol(process.env.NODE_ENV !== "production" ? `renderList` : ``);
      RENDER_SLOT = Symbol(process.env.NODE_ENV !== "production" ? `renderSlot` : ``);
      CREATE_SLOTS = Symbol(process.env.NODE_ENV !== "production" ? `createSlots` : ``);
      TO_DISPLAY_STRING = Symbol(process.env.NODE_ENV !== "production" ? `toDisplayString` : ``);
      MERGE_PROPS = Symbol(process.env.NODE_ENV !== "production" ? `mergeProps` : ``);
      NORMALIZE_CLASS = Symbol(process.env.NODE_ENV !== "production" ? `normalizeClass` : ``);
      NORMALIZE_STYLE = Symbol(process.env.NODE_ENV !== "production" ? `normalizeStyle` : ``);
      NORMALIZE_PROPS = Symbol(process.env.NODE_ENV !== "production" ? `normalizeProps` : ``);
      GUARD_REACTIVE_PROPS = Symbol(process.env.NODE_ENV !== "production" ? `guardReactiveProps` : ``);
      TO_HANDLERS = Symbol(process.env.NODE_ENV !== "production" ? `toHandlers` : ``);
      CAMELIZE = Symbol(process.env.NODE_ENV !== "production" ? `camelize` : ``);
      CAPITALIZE = Symbol(process.env.NODE_ENV !== "production" ? `capitalize` : ``);
      TO_HANDLER_KEY = Symbol(process.env.NODE_ENV !== "production" ? `toHandlerKey` : ``);
      SET_BLOCK_TRACKING = Symbol(process.env.NODE_ENV !== "production" ? `setBlockTracking` : ``);
      PUSH_SCOPE_ID = Symbol(process.env.NODE_ENV !== "production" ? `pushScopeId` : ``);
      POP_SCOPE_ID = Symbol(process.env.NODE_ENV !== "production" ? `popScopeId` : ``);
      WITH_CTX = Symbol(process.env.NODE_ENV !== "production" ? `withCtx` : ``);
      UNREF = Symbol(process.env.NODE_ENV !== "production" ? `unref` : ``);
      IS_REF = Symbol(process.env.NODE_ENV !== "production" ? `isRef` : ``);
      WITH_MEMO = Symbol(process.env.NODE_ENV !== "production" ? `withMemo` : ``);
      IS_MEMO_SAME = Symbol(process.env.NODE_ENV !== "production" ? `isMemoSame` : ``);
      helperNameMap = {
        [FRAGMENT]: `Fragment`,
        [TELEPORT]: `Teleport`,
        [SUSPENSE]: `Suspense`,
        [KEEP_ALIVE]: `KeepAlive`,
        [BASE_TRANSITION]: `BaseTransition`,
        [OPEN_BLOCK]: `openBlock`,
        [CREATE_BLOCK]: `createBlock`,
        [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
        [CREATE_VNODE]: `createVNode`,
        [CREATE_ELEMENT_VNODE]: `createElementVNode`,
        [CREATE_COMMENT]: `createCommentVNode`,
        [CREATE_TEXT]: `createTextVNode`,
        [CREATE_STATIC]: `createStaticVNode`,
        [RESOLVE_COMPONENT]: `resolveComponent`,
        [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
        [RESOLVE_DIRECTIVE]: `resolveDirective`,
        [RESOLVE_FILTER]: `resolveFilter`,
        [WITH_DIRECTIVES]: `withDirectives`,
        [RENDER_LIST]: `renderList`,
        [RENDER_SLOT]: `renderSlot`,
        [CREATE_SLOTS]: `createSlots`,
        [TO_DISPLAY_STRING]: `toDisplayString`,
        [MERGE_PROPS]: `mergeProps`,
        [NORMALIZE_CLASS]: `normalizeClass`,
        [NORMALIZE_STYLE]: `normalizeStyle`,
        [NORMALIZE_PROPS]: `normalizeProps`,
        [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
        [TO_HANDLERS]: `toHandlers`,
        [CAMELIZE]: `camelize`,
        [CAPITALIZE]: `capitalize`,
        [TO_HANDLER_KEY]: `toHandlerKey`,
        [SET_BLOCK_TRACKING]: `setBlockTracking`,
        [PUSH_SCOPE_ID]: `pushScopeId`,
        [POP_SCOPE_ID]: `popScopeId`,
        [WITH_CTX]: `withCtx`,
        [UNREF]: `unref`,
        [IS_REF]: `isRef`,
        [WITH_MEMO]: `withMemo`,
        [IS_MEMO_SAME]: `isMemoSame`
      };
      locStub = {
        source: "",
        start: { line: 1, column: 1, offset: 0 },
        end: { line: 1, column: 1, offset: 0 }
      };
      isStaticExp = (p6) => p6.type === 4 && p6.isStatic;
      isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
      nonIdentifierRE = /^\d|[^\$\w]/;
      isSimpleIdentifier = (name2) => !nonIdentifierRE.test(name2);
      validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
      validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
      whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
      isMemberExpressionBrowser = (path) => {
        path = path.trim().replace(whitespaceRE, (s4) => s4.trim());
        let state = 0;
        let stateStack = [];
        let currentOpenBracketCount = 0;
        let currentOpenParensCount = 0;
        let currentStringType = null;
        for (let i8 = 0; i8 < path.length; i8++) {
          const char = path.charAt(i8);
          switch (state) {
            case 0:
              if (char === "[") {
                stateStack.push(state);
                state = 1;
                currentOpenBracketCount++;
              } else if (char === "(") {
                stateStack.push(state);
                state = 2;
                currentOpenParensCount++;
              } else if (!(i8 === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                return false;
              }
              break;
            case 1:
              if (char === `'` || char === `"` || char === "`") {
                stateStack.push(state);
                state = 3;
                currentStringType = char;
              } else if (char === `[`) {
                currentOpenBracketCount++;
              } else if (char === `]`) {
                if (!--currentOpenBracketCount) {
                  state = stateStack.pop();
                }
              }
              break;
            case 2:
              if (char === `'` || char === `"` || char === "`") {
                stateStack.push(state);
                state = 3;
                currentStringType = char;
              } else if (char === `(`) {
                currentOpenParensCount++;
              } else if (char === `)`) {
                if (i8 === path.length - 1) {
                  return false;
                }
                if (!--currentOpenParensCount) {
                  state = stateStack.pop();
                }
              }
              break;
            case 3:
              if (char === currentStringType) {
                state = stateStack.pop();
                currentStringType = null;
              }
              break;
          }
        }
        return !currentOpenBracketCount && !currentOpenParensCount;
      };
      isMemberExpressionNode = NOOP;
      isMemberExpression = isMemberExpressionBrowser;
      propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
      deprecationData = {
        ["COMPILER_IS_ON_ELEMENT"]: {
          message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
          link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
        },
        ["COMPILER_V_BIND_SYNC"]: {
          message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
        },
        ["COMPILER_V_BIND_PROP"]: {
          message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
        },
        ["COMPILER_V_BIND_OBJECT_ORDER"]: {
          message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
        },
        ["COMPILER_V_ON_NATIVE"]: {
          message: `.native modifier for v-on has been removed as is no longer necessary.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
        },
        ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
          message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
        },
        ["COMPILER_NATIVE_TEMPLATE"]: {
          message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
        },
        ["COMPILER_INLINE_TEMPLATE"]: {
          message: `"inline-template" has been removed in Vue 3.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
        },
        ["COMPILER_FILTER"]: {
          message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
        }
      };
      decodeRE = /&(gt|lt|amp|apos|quot);/g;
      decodeMap = {
        gt: ">",
        lt: "<",
        amp: "&",
        apos: "'",
        quot: '"'
      };
      defaultParserOptions = {
        delimiters: [`{{`, `}}`],
        getNamespace: () => 0,
        getTextMode: () => 0,
        isVoidTag: NO,
        isPreTag: NO,
        isCustomElement: NO,
        decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
        onError: defaultOnError,
        onWarn: defaultOnWarn,
        comments: process.env.NODE_ENV !== "production"
      };
      isSpecialTemplateDirective = /* @__PURE__ */ makeMap(`if,else,else-if,for,slot`);
      allowHoistedHelperSet = /* @__PURE__ */ new Set([
        NORMALIZE_CLASS,
        NORMALIZE_STYLE,
        NORMALIZE_PROPS,
        GUARD_REACTIVE_PROPS
      ]);
      PURE_ANNOTATION = `/*#__PURE__*/`;
      aliasHelper = (s4) => `${helperNameMap[s4]}: _${helperNameMap[s4]}`;
      isFunctionType = (node) => {
        return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
      };
      isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
      isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
      prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
      stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
      transformExpression = (node, context2) => {
        if (node.type === 5) {
          node.content = processExpression(node.content, context2);
        } else if (node.type === 1) {
          for (let i8 = 0; i8 < node.props.length; i8++) {
            const dir = node.props[i8];
            if (dir.type === 7 && dir.name !== "for") {
              const exp = dir.exp;
              const arg = dir.arg;
              if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
                dir.exp = processExpression(exp, context2, dir.name === "slot");
              }
              if (arg && arg.type === 4 && !arg.isStatic) {
                dir.arg = processExpression(arg, context2);
              }
            }
          }
        }
      };
      transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context2) => {
        return processIf(node, dir, context2, (ifNode, branch, isRoot) => {
          const siblings = context2.parent.children;
          let i8 = siblings.indexOf(ifNode);
          let key = 0;
          while (i8-- >= 0) {
            const sibling = siblings[i8];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context2);
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context2);
            }
          };
        });
      });
      transformFor = createStructuralDirectiveTransform("for", (node, dir, context2) => {
        const { helper, removeHelper } = context2;
        return processFor(node, dir, context2, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`);
          const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
          const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(context2, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (process.env.NODE_ENV !== "production" ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, false, node.loc);
          return () => {
            let childBlock;
            const { children } = forNode;
            if ((process.env.NODE_ENV !== "production" || false) && isTemplate) {
              node.children.some((c6) => {
                if (c6.type === 1) {
                  const key = findProp(c6, "key");
                  if (key) {
                    context2.onError(createCompilerError(33, key.loc));
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context2);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(context2, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + (process.env.NODE_ENV !== "production" ? ` /* ${PatchFlagNames[64]} */` : ``), void 0, void 0, true, void 0, false);
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context2);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(getVNodeBlockHelper(context2.inSSR, childBlock.isComponent));
                } else {
                  removeHelper(getVNodeHelper(context2.inSSR, childBlock.isComponent));
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context2.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context2.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                createSimpleExpression(`_cached`)
              ]));
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context2.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context2.cached++)));
            } else {
              renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
            }
          };
        });
      });
      forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
      forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
      stripParensRE = /^\(|\)$/g;
      defaultFallback = createSimpleExpression(`undefined`, false);
      trackSlotScopes = (node, context2) => {
        if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
          const vSlot = findDir(node, "slot");
          if (vSlot) {
            vSlot.exp;
            context2.scopes.vSlot++;
            return () => {
              context2.scopes.vSlot--;
            };
          }
        }
      };
      trackVForSlotScopes = (node, context2) => {
        let vFor;
        if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
          const result = vFor.parseResult = parseForExpression(vFor.exp, context2);
          if (result) {
            const { value, key, index: index15 } = result;
            const { addIdentifiers, removeIdentifiers } = context2;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index15 && addIdentifiers(index15);
            return () => {
              value && removeIdentifiers(value);
              key && removeIdentifiers(key);
              index15 && removeIdentifiers(index15);
            };
          }
        }
      };
      buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
      directiveImportMap = /* @__PURE__ */ new WeakMap();
      transformElement = (node, context2) => {
        return function postTransformElement() {
          node = context2.currentNode;
          if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
            return;
          }
          const { tag, props } = node;
          const isComponent2 = node.tagType === 1;
          let vnodeTag = isComponent2 ? resolveComponentType(node, context2) : `"${tag}"`;
          const isDynamicComponent = isObject2(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
          let vnodeProps;
          let vnodeChildren;
          let vnodePatchFlag;
          let patchFlag = 0;
          let vnodeDynamicProps;
          let dynamicPropNames;
          let vnodeDirectives;
          let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
          if (props.length > 0) {
            const propsBuildResult = buildProps(node, context2, void 0, isComponent2, isDynamicComponent);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context2))) : void 0;
            if (propsBuildResult.shouldUseBlock) {
              shouldUseBlock = true;
            }
          }
          if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
              shouldUseBlock = true;
              patchFlag |= 1024;
              if (process.env.NODE_ENV !== "production" && node.children.length > 1) {
                context2.onError(createCompilerError(45, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                }));
              }
            }
            const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
              const { slots, hasDynamicSlots } = buildSlots(node, context2);
              vnodeChildren = slots;
              if (hasDynamicSlots) {
                patchFlag |= 1024;
              }
            } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
              const child = node.children[0];
              const type = child.type;
              const hasDynamicTextChild = type === 5 || type === 8;
              if (hasDynamicTextChild && getConstantType(child, context2) === 0) {
                patchFlag |= 1;
              }
              if (hasDynamicTextChild || type === 2) {
                vnodeChildren = child;
              } else {
                vnodeChildren = node.children;
              }
            } else {
              vnodeChildren = node.children;
            }
          }
          if (patchFlag !== 0) {
            if (process.env.NODE_ENV !== "production") {
              if (patchFlag < 0) {
                vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
              } else {
                const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n8) => n8 > 0 && patchFlag & n8).map((n8) => PatchFlagNames[n8]).join(`, `);
                vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
              }
            } else {
              vnodePatchFlag = String(patchFlag);
            }
            if (dynamicPropNames && dynamicPropNames.length) {
              vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
          }
          node.codegenNode = createVNodeCall(context2, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
        };
      };
      process.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
      process.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
      cacheStringFunction2 = (fn) => {
        const cache4 = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache4[str];
          return hit || (cache4[str] = fn(str));
        };
      };
      camelizeRE2 = /-(\w)/g;
      camelize2 = cacheStringFunction2((str) => {
        return str.replace(camelizeRE2, (_, c6) => c6 ? c6.toUpperCase() : "");
      });
      transformSlotOutlet = (node, context2) => {
        if (isSlotOutlet(node)) {
          const { children, loc } = node;
          const { slotName, slotProps } = processSlotOutlet(node, context2);
          const slotArgs = [
            context2.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName,
            "{}",
            "undefined",
            "true"
          ];
          let expectedLen = 2;
          if (slotProps) {
            slotArgs[2] = slotProps;
            expectedLen = 3;
          }
          if (children.length) {
            slotArgs[3] = createFunctionExpression([], children, false, false, loc);
            expectedLen = 4;
          }
          if (context2.scopeId && !context2.slotted) {
            expectedLen = 5;
          }
          slotArgs.splice(expectedLen);
          node.codegenNode = createCallExpression(context2.helper(RENDER_SLOT), slotArgs, loc);
        }
      };
      fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
      transformOn = (dir, node, context2, augmentor) => {
        const { loc, modifiers, arg } = dir;
        if (!dir.exp && !modifiers.length) {
          context2.onError(createCompilerError(35, loc));
        }
        let eventName;
        if (arg.type === 4) {
          if (arg.isStatic) {
            let rawName = arg.content;
            if (rawName.startsWith("vue:")) {
              rawName = `vnode-${rawName.slice(4)}`;
            }
            eventName = createSimpleExpression(toHandlerKey(camelize(rawName)), true, arg.loc);
          } else {
            eventName = createCompoundExpression([
              `${context2.helperString(TO_HANDLER_KEY)}(`,
              arg,
              `)`
            ]);
          }
        } else {
          eventName = arg;
          eventName.children.unshift(`${context2.helperString(TO_HANDLER_KEY)}(`);
          eventName.children.push(`)`);
        }
        let exp = dir.exp;
        if (exp && !exp.content.trim()) {
          exp = void 0;
        }
        let shouldCache = context2.cacheHandlers && !exp && !context2.inVOnce;
        if (exp) {
          const isMemberExp = isMemberExpression(exp.content);
          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
          const hasMultipleStatements = exp.content.includes(`;`);
          if (process.env.NODE_ENV !== "production" && true) {
            validateBrowserExpression(exp, context2, false, hasMultipleStatements);
          }
          if (isInlineStatement || shouldCache && isMemberExp) {
            exp = createCompoundExpression([
              `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
              exp,
              hasMultipleStatements ? `}` : `)`
            ]);
          }
        }
        let ret = {
          props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
          ]
        };
        if (augmentor) {
          ret = augmentor(ret);
        }
        if (shouldCache) {
          ret.props[0].value = context2.cache(ret.props[0].value);
        }
        ret.props.forEach((p6) => p6.key.isHandlerKey = true);
        return ret;
      };
      transformBind = (dir, _node, context2) => {
        const { exp, modifiers, loc } = dir;
        const arg = dir.arg;
        if (arg.type !== 4) {
          arg.children.unshift(`(`);
          arg.children.push(`) || ""`);
        } else if (!arg.isStatic) {
          arg.content = `${arg.content} || ""`;
        }
        if (modifiers.includes("camel")) {
          if (arg.type === 4) {
            if (arg.isStatic) {
              arg.content = camelize(arg.content);
            } else {
              arg.content = `${context2.helperString(CAMELIZE)}(${arg.content})`;
            }
          } else {
            arg.children.unshift(`${context2.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
          }
        }
        if (!context2.inSSR) {
          if (modifiers.includes("prop")) {
            injectPrefix(arg, ".");
          }
          if (modifiers.includes("attr")) {
            injectPrefix(arg, "^");
          }
        }
        if (!exp || exp.type === 4 && !exp.content.trim()) {
          context2.onError(createCompilerError(34, loc));
          return {
            props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
          };
        }
        return {
          props: [createObjectProperty(arg, exp)]
        };
      };
      injectPrefix = (arg, prefix) => {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = prefix + arg.content;
          } else {
            arg.content = `\`${prefix}\${${arg.content}}\``;
          }
        } else {
          arg.children.unshift(`'${prefix}' + (`);
          arg.children.push(`)`);
        }
      };
      transformText = (node, context2) => {
        if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
          return () => {
            const children = node.children;
            let currentContainer = void 0;
            let hasText = false;
            for (let i8 = 0; i8 < children.length; i8++) {
              const child = children[i8];
              if (isText(child)) {
                hasText = true;
                for (let j2 = i8 + 1; j2 < children.length; j2++) {
                  const next = children[j2];
                  if (isText(next)) {
                    if (!currentContainer) {
                      currentContainer = children[i8] = createCompoundExpression([child], child.loc);
                    }
                    currentContainer.children.push(` + `, next);
                    children.splice(j2, 1);
                    j2--;
                  } else {
                    currentContainer = void 0;
                    break;
                  }
                }
              }
            }
            if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p6) => p6.type === 7 && !context2.directiveTransforms[p6.name]) && !(node.tag === "template"))) {
              return;
            }
            for (let i8 = 0; i8 < children.length; i8++) {
              const child = children[i8];
              if (isText(child) || child.type === 8) {
                const callArgs = [];
                if (child.type !== 2 || child.content !== " ") {
                  callArgs.push(child);
                }
                if (!context2.ssr && getConstantType(child, context2) === 0) {
                  callArgs.push(1 + (process.env.NODE_ENV !== "production" ? ` /* ${PatchFlagNames[1]} */` : ``));
                }
                children[i8] = {
                  type: 12,
                  content: child,
                  loc: child.loc,
                  codegenNode: createCallExpression(context2.helper(CREATE_TEXT), callArgs)
                };
              }
            }
          };
        }
      };
      seen = /* @__PURE__ */ new WeakSet();
      transformOnce = (node, context2) => {
        if (node.type === 1 && findDir(node, "once", true)) {
          if (seen.has(node) || context2.inVOnce) {
            return;
          }
          seen.add(node);
          context2.inVOnce = true;
          context2.helper(SET_BLOCK_TRACKING);
          return () => {
            context2.inVOnce = false;
            const cur = context2.currentNode;
            if (cur.codegenNode) {
              cur.codegenNode = context2.cache(cur.codegenNode, true);
            }
          };
        }
      };
      transformModel = (dir, node, context2) => {
        const { exp, arg } = dir;
        if (!exp) {
          context2.onError(createCompilerError(41, dir.loc));
          return createTransformProps();
        }
        const rawExp = exp.loc.source;
        const expString = exp.type === 4 ? exp.content : rawExp;
        context2.bindingMetadata[rawExp];
        const maybeRef = false;
        if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
          context2.onError(createCompilerError(42, exp.loc));
          return createTransformProps();
        }
        const propName = arg ? arg : createSimpleExpression("modelValue", true);
        const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
        let assignmentExp;
        const eventArg = context2.isTS ? `($event: any)` : `$event`;
        {
          assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            exp,
            `) = $event)`
          ]);
        }
        const props = [
          createObjectProperty(propName, dir.exp),
          createObjectProperty(eventName, assignmentExp)
        ];
        if (dir.modifiers.length && node.tagType === 1) {
          const modifiers = dir.modifiers.map((m3) => (isSimpleIdentifier(m3) ? m3 : JSON.stringify(m3)) + `: true`).join(`, `);
          const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
          props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
        }
        return createTransformProps(props);
      };
      validDivisionCharRE = /[\w).+\-_$\]]/;
      transformFilter = (node, context2) => {
        if (!isCompatEnabled("COMPILER_FILTER", context2)) {
          return;
        }
        if (node.type === 5) {
          rewriteFilter(node.content, context2);
        }
        if (node.type === 1) {
          node.props.forEach((prop) => {
            if (prop.type === 7 && prop.name !== "for" && prop.exp) {
              rewriteFilter(prop.exp, context2);
            }
          });
        }
      };
      seen$1 = /* @__PURE__ */ new WeakSet();
      transformMemo = (node, context2) => {
        if (node.type === 1) {
          const dir = findDir(node, "memo");
          if (!dir || seen$1.has(node)) {
            return;
          }
          seen$1.add(node);
          return () => {
            const codegenNode = node.codegenNode || context2.currentNode.codegenNode;
            if (codegenNode && codegenNode.type === 13) {
              if (node.tagType !== 1) {
                makeBlock(codegenNode, context2);
              }
              node.codegenNode = createCallExpression(context2.helper(WITH_MEMO), [
                dir.exp,
                createFunctionExpression(void 0, codegenNode),
                `_cache`,
                String(context2.cached++)
              ]);
            }
          };
        }
      };
      noopDirectiveTransform = () => ({ props: [] });
    }
  });

  // node_modules/.pnpm/@vue+compiler-dom@3.2.37/node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
  var compiler_dom_esm_bundler_exports = {};
  __export(compiler_dom_esm_bundler_exports, {
    BASE_TRANSITION: () => BASE_TRANSITION,
    CAMELIZE: () => CAMELIZE,
    CAPITALIZE: () => CAPITALIZE,
    CREATE_BLOCK: () => CREATE_BLOCK,
    CREATE_COMMENT: () => CREATE_COMMENT,
    CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
    CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
    CREATE_SLOTS: () => CREATE_SLOTS,
    CREATE_STATIC: () => CREATE_STATIC,
    CREATE_TEXT: () => CREATE_TEXT,
    CREATE_VNODE: () => CREATE_VNODE,
    DOMDirectiveTransforms: () => DOMDirectiveTransforms,
    DOMNodeTransforms: () => DOMNodeTransforms,
    FRAGMENT: () => FRAGMENT,
    GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
    IS_MEMO_SAME: () => IS_MEMO_SAME,
    IS_REF: () => IS_REF,
    KEEP_ALIVE: () => KEEP_ALIVE,
    MERGE_PROPS: () => MERGE_PROPS,
    NORMALIZE_CLASS: () => NORMALIZE_CLASS,
    NORMALIZE_PROPS: () => NORMALIZE_PROPS,
    NORMALIZE_STYLE: () => NORMALIZE_STYLE,
    OPEN_BLOCK: () => OPEN_BLOCK,
    POP_SCOPE_ID: () => POP_SCOPE_ID,
    PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
    RENDER_LIST: () => RENDER_LIST,
    RENDER_SLOT: () => RENDER_SLOT,
    RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
    RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
    RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
    RESOLVE_FILTER: () => RESOLVE_FILTER,
    SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
    SUSPENSE: () => SUSPENSE,
    TELEPORT: () => TELEPORT,
    TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
    TO_HANDLERS: () => TO_HANDLERS,
    TO_HANDLER_KEY: () => TO_HANDLER_KEY,
    TRANSITION: () => TRANSITION,
    TRANSITION_GROUP: () => TRANSITION_GROUP,
    UNREF: () => UNREF,
    V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
    V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
    V_MODEL_RADIO: () => V_MODEL_RADIO,
    V_MODEL_SELECT: () => V_MODEL_SELECT,
    V_MODEL_TEXT: () => V_MODEL_TEXT,
    V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
    V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
    V_SHOW: () => V_SHOW,
    WITH_CTX: () => WITH_CTX,
    WITH_DIRECTIVES: () => WITH_DIRECTIVES,
    WITH_MEMO: () => WITH_MEMO,
    advancePositionWithClone: () => advancePositionWithClone,
    advancePositionWithMutation: () => advancePositionWithMutation,
    assert: () => assert2,
    baseCompile: () => baseCompile,
    baseParse: () => baseParse,
    buildDirectiveArgs: () => buildDirectiveArgs,
    buildProps: () => buildProps,
    buildSlots: () => buildSlots,
    checkCompatEnabled: () => checkCompatEnabled,
    compile: () => compile,
    createArrayExpression: () => createArrayExpression,
    createAssignmentExpression: () => createAssignmentExpression,
    createBlockStatement: () => createBlockStatement,
    createCacheExpression: () => createCacheExpression,
    createCallExpression: () => createCallExpression,
    createCompilerError: () => createCompilerError,
    createCompoundExpression: () => createCompoundExpression,
    createConditionalExpression: () => createConditionalExpression,
    createDOMCompilerError: () => createDOMCompilerError,
    createForLoopParams: () => createForLoopParams,
    createFunctionExpression: () => createFunctionExpression,
    createIfStatement: () => createIfStatement,
    createInterpolation: () => createInterpolation,
    createObjectExpression: () => createObjectExpression,
    createObjectProperty: () => createObjectProperty,
    createReturnStatement: () => createReturnStatement,
    createRoot: () => createRoot,
    createSequenceExpression: () => createSequenceExpression,
    createSimpleExpression: () => createSimpleExpression,
    createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
    createTemplateLiteral: () => createTemplateLiteral,
    createTransformContext: () => createTransformContext,
    createVNodeCall: () => createVNodeCall,
    extractIdentifiers: () => extractIdentifiers,
    findDir: () => findDir,
    findProp: () => findProp,
    generate: () => generate,
    generateCodeFrame: () => generateCodeFrame,
    getBaseTransformPreset: () => getBaseTransformPreset,
    getConstantType: () => getConstantType,
    getInnerRange: () => getInnerRange,
    getMemoedVNodeCall: () => getMemoedVNodeCall,
    getVNodeBlockHelper: () => getVNodeBlockHelper,
    getVNodeHelper: () => getVNodeHelper,
    hasDynamicKeyVBind: () => hasDynamicKeyVBind,
    hasScopeRef: () => hasScopeRef,
    helperNameMap: () => helperNameMap,
    injectProp: () => injectProp,
    isBuiltInType: () => isBuiltInType,
    isCoreComponent: () => isCoreComponent,
    isFunctionType: () => isFunctionType,
    isInDestructureAssignment: () => isInDestructureAssignment,
    isMemberExpression: () => isMemberExpression,
    isMemberExpressionBrowser: () => isMemberExpressionBrowser,
    isMemberExpressionNode: () => isMemberExpressionNode,
    isReferencedIdentifier: () => isReferencedIdentifier,
    isSimpleIdentifier: () => isSimpleIdentifier,
    isSlotOutlet: () => isSlotOutlet,
    isStaticArgOf: () => isStaticArgOf,
    isStaticExp: () => isStaticExp,
    isStaticProperty: () => isStaticProperty,
    isStaticPropertyKey: () => isStaticPropertyKey,
    isTemplateNode: () => isTemplateNode,
    isText: () => isText,
    isVSlot: () => isVSlot,
    locStub: () => locStub,
    makeBlock: () => makeBlock,
    noopDirectiveTransform: () => noopDirectiveTransform,
    parse: () => parse,
    parserOptions: () => parserOptions,
    processExpression: () => processExpression,
    processFor: () => processFor,
    processIf: () => processIf,
    processSlotOutlet: () => processSlotOutlet,
    registerRuntimeHelpers: () => registerRuntimeHelpers,
    resolveComponentType: () => resolveComponentType,
    toValidAssetId: () => toValidAssetId,
    trackSlotScopes: () => trackSlotScopes,
    trackVForSlotScopes: () => trackVForSlotScopes,
    transform: () => transform,
    transformBind: () => transformBind,
    transformElement: () => transformElement,
    transformExpression: () => transformExpression,
    transformModel: () => transformModel,
    transformOn: () => transformOn,
    transformStyle: () => transformStyle,
    traverseNode: () => traverseNode,
    walkBlockDeclarations: () => walkBlockDeclarations,
    walkFunctionParams: () => walkFunctionParams,
    walkIdentifiers: () => walkIdentifiers,
    warnDeprecation: () => warnDeprecation
  });
  function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
      decoder = document.createElement("div");
    }
    if (asAttr) {
      decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
      return decoder.children[0].getAttribute("foo");
    } else {
      decoder.innerHTML = raw;
      return decoder.textContent;
    }
  }
  function createDOMCompilerError(code, loc) {
    return createCompilerError(code, loc, process.env.NODE_ENV !== "production" || false ? DOMErrorMessages : void 0);
  }
  function hasMultipleChildren(node) {
    const children = node.children = node.children.filter((c6) => c6.type !== 3 && !(c6.type === 2 && !c6.content.trim()));
    const child = children[0];
    return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
  }
  function compile(template, options2 = {}) {
    return baseCompile(template, extend({}, parserOptions, options2, {
      nodeTransforms: [
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options2.nodeTransforms || []
      ],
      directiveTransforms: extend({}, DOMDirectiveTransforms, options2.directiveTransforms || {}),
      transformHoist: null
    }));
  }
  function parse(template, options2 = {}) {
    return baseParse(template, extend({}, parserOptions, options2));
  }
  var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, isRawTextContainer, parserOptions, transformStyle, parseInlineCSS, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, transformTransition, ignoreSideEffectTags, DOMNodeTransforms, DOMDirectiveTransforms;
  var init_compiler_dom_esm_bundler = __esm({
    "node_modules/.pnpm/@vue+compiler-dom@3.2.37/node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
      init_compiler_core_esm_bundler();
      init_compiler_core_esm_bundler();
      init_shared_esm_bundler();
      V_MODEL_RADIO = Symbol(process.env.NODE_ENV !== "production" ? `vModelRadio` : ``);
      V_MODEL_CHECKBOX = Symbol(process.env.NODE_ENV !== "production" ? `vModelCheckbox` : ``);
      V_MODEL_TEXT = Symbol(process.env.NODE_ENV !== "production" ? `vModelText` : ``);
      V_MODEL_SELECT = Symbol(process.env.NODE_ENV !== "production" ? `vModelSelect` : ``);
      V_MODEL_DYNAMIC = Symbol(process.env.NODE_ENV !== "production" ? `vModelDynamic` : ``);
      V_ON_WITH_MODIFIERS = Symbol(process.env.NODE_ENV !== "production" ? `vOnModifiersGuard` : ``);
      V_ON_WITH_KEYS = Symbol(process.env.NODE_ENV !== "production" ? `vOnKeysGuard` : ``);
      V_SHOW = Symbol(process.env.NODE_ENV !== "production" ? `vShow` : ``);
      TRANSITION = Symbol(process.env.NODE_ENV !== "production" ? `Transition` : ``);
      TRANSITION_GROUP = Symbol(process.env.NODE_ENV !== "production" ? `TransitionGroup` : ``);
      registerRuntimeHelpers({
        [V_MODEL_RADIO]: `vModelRadio`,
        [V_MODEL_CHECKBOX]: `vModelCheckbox`,
        [V_MODEL_TEXT]: `vModelText`,
        [V_MODEL_SELECT]: `vModelSelect`,
        [V_MODEL_DYNAMIC]: `vModelDynamic`,
        [V_ON_WITH_MODIFIERS]: `withModifiers`,
        [V_ON_WITH_KEYS]: `withKeys`,
        [V_SHOW]: `vShow`,
        [TRANSITION]: `Transition`,
        [TRANSITION_GROUP]: `TransitionGroup`
      });
      isRawTextContainer = /* @__PURE__ */ makeMap("style,iframe,script,noscript", true);
      parserOptions = {
        isVoidTag,
        isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
        isPreTag: (tag) => tag === "pre",
        decodeEntities: decodeHtmlBrowser,
        isBuiltInComponent: (tag) => {
          if (isBuiltInType(tag, `Transition`)) {
            return TRANSITION;
          } else if (isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
          }
        },
        getNamespace(tag, parent) {
          let ns = parent ? parent.ns : 0;
          if (parent && ns === 2) {
            if (parent.tag === "annotation-xml") {
              if (tag === "svg") {
                return 1;
              }
              if (parent.props.some((a8) => a8.type === 6 && a8.name === "encoding" && a8.value != null && (a8.value.content === "text/html" || a8.value.content === "application/xhtml+xml"))) {
                ns = 0;
              }
            } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
              ns = 0;
            }
          } else if (parent && ns === 1) {
            if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
              ns = 0;
            }
          }
          if (ns === 0) {
            if (tag === "svg") {
              return 1;
            }
            if (tag === "math") {
              return 2;
            }
          }
          return ns;
        },
        getTextMode({ tag, ns }) {
          if (ns === 0) {
            if (tag === "textarea" || tag === "title") {
              return 1;
            }
            if (isRawTextContainer(tag)) {
              return 2;
            }
          }
          return 0;
        }
      };
      transformStyle = (node) => {
        if (node.type === 1) {
          node.props.forEach((p6, i8) => {
            if (p6.type === 6 && p6.name === "style" && p6.value) {
              node.props[i8] = {
                type: 7,
                name: `bind`,
                arg: createSimpleExpression(`style`, true, p6.loc),
                exp: parseInlineCSS(p6.value.content, p6.loc),
                modifiers: [],
                loc: p6.loc
              };
            }
          });
        }
      };
      parseInlineCSS = (cssText, loc) => {
        const normalized = parseStringStyle(cssText);
        return createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
      };
      DOMErrorMessages = {
        [50]: `v-html is missing expression.`,
        [51]: `v-html will override element children.`,
        [52]: `v-text is missing expression.`,
        [53]: `v-text will override element children.`,
        [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
        [55]: `v-model argument is not supported on plain elements.`,
        [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
        [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
        [58]: `v-show is missing expression.`,
        [59]: `<Transition> expects exactly one child element or component.`,
        [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
      };
      transformVHtml = (dir, node, context2) => {
        const { exp, loc } = dir;
        if (!exp) {
          context2.onError(createDOMCompilerError(50, loc));
        }
        if (node.children.length) {
          context2.onError(createDOMCompilerError(51, loc));
          node.children.length = 0;
        }
        return {
          props: [
            createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression("", true))
          ]
        };
      };
      transformVText = (dir, node, context2) => {
        const { exp, loc } = dir;
        if (!exp) {
          context2.onError(createDOMCompilerError(52, loc));
        }
        if (node.children.length) {
          context2.onError(createDOMCompilerError(53, loc));
          node.children.length = 0;
        }
        return {
          props: [
            createObjectProperty(createSimpleExpression(`textContent`, true), exp ? getConstantType(exp, context2) > 0 ? exp : createCallExpression(context2.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression("", true))
          ]
        };
      };
      transformModel2 = (dir, node, context2) => {
        const baseResult = transformModel(dir, node, context2);
        if (!baseResult.props.length || node.tagType === 1) {
          return baseResult;
        }
        if (dir.arg) {
          context2.onError(createDOMCompilerError(55, dir.arg.loc));
        }
        function checkDuplicatedValue() {
          const value = findProp(node, "value");
          if (value) {
            context2.onError(createDOMCompilerError(57, value.loc));
          }
        }
        const { tag } = node;
        const isCustomElement = context2.isCustomElement(tag);
        if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === "input" || isCustomElement) {
            const type = findProp(node, `type`);
            if (type) {
              if (type.type === 7) {
                directiveToUse = V_MODEL_DYNAMIC;
              } else if (type.value) {
                switch (type.value.content) {
                  case "radio":
                    directiveToUse = V_MODEL_RADIO;
                    break;
                  case "checkbox":
                    directiveToUse = V_MODEL_CHECKBOX;
                    break;
                  case "file":
                    isInvalidType = true;
                    context2.onError(createDOMCompilerError(56, dir.loc));
                    break;
                  default:
                    process.env.NODE_ENV !== "production" && checkDuplicatedValue();
                    break;
                }
              }
            } else if (hasDynamicKeyVBind(node)) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else {
              process.env.NODE_ENV !== "production" && checkDuplicatedValue();
            }
          } else if (tag === "select") {
            directiveToUse = V_MODEL_SELECT;
          } else {
            process.env.NODE_ENV !== "production" && checkDuplicatedValue();
          }
          if (!isInvalidType) {
            baseResult.needRuntime = context2.helper(directiveToUse);
          }
        } else {
          context2.onError(createDOMCompilerError(54, dir.loc));
        }
        baseResult.props = baseResult.props.filter((p6) => !(p6.key.type === 4 && p6.key.content === "modelValue"));
        return baseResult;
      };
      isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
      isNonKeyModifier = /* @__PURE__ */ makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
      maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
      isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`, true);
      resolveModifiers = (key, modifiers, context2, loc) => {
        const keyModifiers = [];
        const nonKeyModifiers = [];
        const eventOptionModifiers = [];
        for (let i8 = 0; i8 < modifiers.length; i8++) {
          const modifier = modifiers[i8];
          if (modifier === "native" && checkCompatEnabled("COMPILER_V_ON_NATIVE", context2, loc)) {
            eventOptionModifiers.push(modifier);
          } else if (isEventOptionModifier(modifier)) {
            eventOptionModifiers.push(modifier);
          } else {
            if (maybeKeyModifier(modifier)) {
              if (isStaticExp(key)) {
                if (isKeyboardEvent(key.content)) {
                  keyModifiers.push(modifier);
                } else {
                  nonKeyModifiers.push(modifier);
                }
              } else {
                keyModifiers.push(modifier);
                nonKeyModifiers.push(modifier);
              }
            } else {
              if (isNonKeyModifier(modifier)) {
                nonKeyModifiers.push(modifier);
              } else {
                keyModifiers.push(modifier);
              }
            }
          }
        }
        return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
        };
      };
      transformClick = (key, event) => {
        const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
        return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
          `(`,
          key,
          `) === "onClick" ? "${event}" : (`,
          key,
          `)`
        ]) : key;
      };
      transformOn2 = (dir, node, context2) => {
        return transformOn(dir, node, context2, (baseResult) => {
          const { modifiers } = dir;
          if (!modifiers.length)
            return baseResult;
          let { key, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context2, dir.loc);
          if (nonKeyModifiers.includes("right")) {
            key = transformClick(key, `onContextmenu`);
          }
          if (nonKeyModifiers.includes("middle")) {
            key = transformClick(key, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
            handlerExp = createCallExpression(context2.helper(V_ON_WITH_MODIFIERS), [
              handlerExp,
              JSON.stringify(nonKeyModifiers)
            ]);
          }
          if (keyModifiers.length && (!isStaticExp(key) || isKeyboardEvent(key.content))) {
            handlerExp = createCallExpression(context2.helper(V_ON_WITH_KEYS), [
              handlerExp,
              JSON.stringify(keyModifiers)
            ]);
          }
          if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
            key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
          }
          return {
            props: [createObjectProperty(key, handlerExp)]
          };
        });
      };
      transformShow = (dir, node, context2) => {
        const { exp, loc } = dir;
        if (!exp) {
          context2.onError(createDOMCompilerError(58, loc));
        }
        return {
          props: [],
          needRuntime: context2.helper(V_SHOW)
        };
      };
      transformTransition = (node, context2) => {
        if (node.type === 1 && node.tagType === 1) {
          const component = context2.isBuiltInComponent(node.tag);
          if (component === TRANSITION) {
            return () => {
              if (!node.children.length) {
                return;
              }
              if (hasMultipleChildren(node)) {
                context2.onError(createDOMCompilerError(59, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                }));
              }
              const child = node.children[0];
              if (child.type === 1) {
                for (const p6 of child.props) {
                  if (p6.type === 7 && p6.name === "show") {
                    node.props.push({
                      type: 6,
                      name: "persisted",
                      value: void 0,
                      loc: node.loc
                    });
                  }
                }
              }
            };
          }
        }
      };
      ignoreSideEffectTags = (node, context2) => {
        if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
          context2.onError(createDOMCompilerError(60, node.loc));
          context2.removeNode();
        }
      };
      DOMNodeTransforms = [
        transformStyle,
        ...process.env.NODE_ENV !== "production" ? [transformTransition] : []
      ];
      DOMDirectiveTransforms = {
        cloak: noopDirectiveTransform,
        html: transformVHtml,
        text: transformVText,
        model: transformModel2,
        on: transformOn2,
        show: transformShow
      };
    }
  });

  // node_modules/.pnpm/@vue+reactivity@3.2.37/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
  function warn2(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function recordEffectScope(effect2, scope = activeEffectScope) {
    if (scope && scope.active) {
      scope.effects.push(effect2);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    } else if (process.env.NODE_ENV !== "production") {
      warn2(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
    }
  }
  function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
      for (let i8 = 0; i8 < deps.length; i8++) {
        deps[i8].delete(effect2);
      }
      deps.length = 0;
    }
  }
  function effect(fn, options2) {
    if (fn.effect) {
      fn = fn.effect.fn;
    }
    const _effect = new ReactiveEffect(fn);
    if (options2) {
      extend(_effect, options2);
      if (options2.scope)
        recordEffectScope(_effect, options2.scope);
    }
    if (!options2 || !options2.lazy) {
      _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
  }
  function stop(runner) {
    runner.effect.stop();
  }
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last2 = trackStack.pop();
    shouldTrack = last2 === void 0 ? true : last2;
  }
  function track(target, type, key) {
    if (shouldTrack && activeEffect) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = createDep());
      }
      const eventInfo = process.env.NODE_ENV !== "production" ? { effect: activeEffect, target, type, key } : void 0;
      trackEffects(dep, eventInfo);
    }
  }
  function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
      if (!newTracked(dep)) {
        dep.n |= trackOpBit;
        shouldTrack2 = !wasTracked(dep);
      }
    } else {
      shouldTrack2 = !dep.has(activeEffect);
    }
    if (shouldTrack2) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (process.env.NODE_ENV !== "production" && activeEffect.onTrack) {
        activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type === "clear") {
      deps = [...depsMap.values()];
    } else if (key === "length" && isArray2(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const eventInfo = process.env.NODE_ENV !== "production" ? { target, type, key, newValue, oldValue, oldTarget } : void 0;
    if (deps.length === 1) {
      if (deps[0]) {
        if (process.env.NODE_ENV !== "production") {
          triggerEffects(deps[0], eventInfo);
        } else {
          triggerEffects(deps[0]);
        }
      }
    } else {
      const effects = [];
      for (const dep of deps) {
        if (dep) {
          effects.push(...dep);
        }
      }
      if (process.env.NODE_ENV !== "production") {
        triggerEffects(createDep(effects), eventInfo);
      } else {
        triggerEffects(createDep(effects));
      }
    }
  }
  function triggerEffects(dep, debuggerEventExtraInfo) {
    const effects = isArray2(dep) ? dep : [...dep];
    for (const effect2 of effects) {
      if (effect2.computed) {
        triggerEffect(effect2, debuggerEventExtraInfo);
      }
    }
    for (const effect2 of effects) {
      if (!effect2.computed) {
        triggerEffect(effect2, debuggerEventExtraInfo);
      }
    }
  }
  function triggerEffect(effect2, debuggerEventExtraInfo) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
      if (process.env.NODE_ENV !== "production" && effect2.onTrigger) {
        effect2.onTrigger(extend({ effect: effect2 }, debuggerEventExtraInfo));
      }
      if (effect2.scheduler) {
        effect2.scheduler();
      } else {
        effect2.run();
      }
    }
  }
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i8 = 0, l5 = this.length; i8 < l5; i8++) {
          track(arr, "get", i8 + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly2 = false, shallow = false) {
    return function get10(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return shallow;
      } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray2(target);
      if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject2(res)) {
        return isReadonly2 ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
        return false;
      }
      if (!shallow && !isReadonly(value)) {
        if (!isShallow(value)) {
          value = toRaw(value);
          oldValue = toRaw(oldValue);
        }
        if (!isArray2(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray2(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  function get$1(target, key, isReadonly2 = false, isShallow3 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (key !== rawKey) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow3 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (key !== rawKey) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get10 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (process.env.NODE_ENV !== "production") {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get10.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get10 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (process.env.NODE_ENV !== "production") {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get10 ? get10.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = process.env.NODE_ENV !== "production" ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow3) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow3 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow3) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow3 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (process.env.NODE_ENV !== "production") {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function shallowReactive2(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject2(target)) {
      if (process.env.NODE_ENV !== "production") {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    def(value, "__v_skip", true);
    return value;
  }
  function trackRefValue(ref5) {
    if (shouldTrack && activeEffect) {
      ref5 = toRaw(ref5);
      if (process.env.NODE_ENV !== "production") {
        trackEffects(ref5.dep || (ref5.dep = createDep()), {
          target: ref5,
          type: "get",
          key: "value"
        });
      } else {
        trackEffects(ref5.dep || (ref5.dep = createDep()));
      }
    }
  }
  function triggerRefValue(ref5, newVal) {
    ref5 = toRaw(ref5);
    if (ref5.dep) {
      if (process.env.NODE_ENV !== "production") {
        triggerEffects(ref5.dep, {
          target: ref5,
          type: "set",
          key: "value",
          newValue: newVal
        });
      } else {
        triggerEffects(ref5.dep);
      }
    }
  }
  function isRef(r8) {
    return !!(r8 && r8.__v_isRef === true);
  }
  function ref2(value) {
    return createRef(value, false);
  }
  function shallowRef2(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  function triggerRef(ref5) {
    triggerRefValue(ref5, process.env.NODE_ENV !== "production" ? ref5.value : void 0);
  }
  function unref(ref5) {
    return isRef(ref5) ? ref5.value : ref5;
  }
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function customRef(factory) {
    return new CustomRefImpl(factory);
  }
  function toRefs(object) {
    if (process.env.NODE_ENV !== "production" && !isProxy(object)) {
      console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray2(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = toRef(object, key);
    }
    return ret;
  }
  function toRef(object, key, defaultValue) {
    const val = object[key];
    return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
  }
  function computed2(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction2(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = process.env.NODE_ENV !== "production" ? () => {
        console.warn("Write operation failed: computed value is readonly");
      } : NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (process.env.NODE_ENV !== "production" && debugOptions && !isSSR) {
      cRef.effect.onTrack = debugOptions.onTrack;
      cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
  }
  var activeEffectScope, EffectScope, createDep, wasTracked, newTracked, initDepMarkers, finalizeDepMarkers, targetMap, effectTrackDepth, trackOpBit, maxMarkerBits, activeEffect, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, shouldTrack, trackStack, isNonTrackableKeys, builtInSymbols, get, shallowGet, readonlyGet, shallowReadonlyGet, arrayInstrumentations, set, shallowSet, mutableHandlers, readonlyHandlers, shallowReactiveHandlers, shallowReadonlyHandlers, toShallow, getProto, mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations, mutableCollectionHandlers, shallowCollectionHandlers, readonlyCollectionHandlers, shallowReadonlyCollectionHandlers, reactiveMap, shallowReactiveMap, readonlyMap, shallowReadonlyMap, toReactive, toReadonly, RefImpl, shallowUnwrapHandlers, CustomRefImpl, ObjectRefImpl, ComputedRefImpl, _a;
  var init_reactivity_esm_bundler = __esm({
    "node_modules/.pnpm/@vue+reactivity@3.2.37/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"() {
      init_shared_esm_bundler();
      EffectScope = class {
        constructor(detached = false) {
          this.active = true;
          this.effects = [];
          this.cleanups = [];
          if (!detached && activeEffectScope) {
            this.parent = activeEffectScope;
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
          }
        }
        run(fn) {
          if (this.active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          } else if (process.env.NODE_ENV !== "production") {
            warn2(`cannot run an inactive effect scope.`);
          }
        }
        on() {
          activeEffectScope = this;
        }
        off() {
          activeEffectScope = this.parent;
        }
        stop(fromParent) {
          if (this.active) {
            let i8, l5;
            for (i8 = 0, l5 = this.effects.length; i8 < l5; i8++) {
              this.effects[i8].stop();
            }
            for (i8 = 0, l5 = this.cleanups.length; i8 < l5; i8++) {
              this.cleanups[i8]();
            }
            if (this.scopes) {
              for (i8 = 0, l5 = this.scopes.length; i8 < l5; i8++) {
                this.scopes[i8].stop(true);
              }
            }
            if (this.parent && !fromParent) {
              const last2 = this.parent.scopes.pop();
              if (last2 && last2 !== this) {
                this.parent.scopes[this.index] = last2;
                last2.index = this.index;
              }
            }
            this.active = false;
          }
        }
      };
      createDep = (effects) => {
        const dep = new Set(effects);
        dep.w = 0;
        dep.n = 0;
        return dep;
      };
      wasTracked = (dep) => (dep.w & trackOpBit) > 0;
      newTracked = (dep) => (dep.n & trackOpBit) > 0;
      initDepMarkers = ({ deps }) => {
        if (deps.length) {
          for (let i8 = 0; i8 < deps.length; i8++) {
            deps[i8].w |= trackOpBit;
          }
        }
      };
      finalizeDepMarkers = (effect2) => {
        const { deps } = effect2;
        if (deps.length) {
          let ptr = 0;
          for (let i8 = 0; i8 < deps.length; i8++) {
            const dep = deps[i8];
            if (wasTracked(dep) && !newTracked(dep)) {
              dep.delete(effect2);
            } else {
              deps[ptr++] = dep;
            }
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
          }
          deps.length = ptr;
        }
      };
      targetMap = /* @__PURE__ */ new WeakMap();
      effectTrackDepth = 0;
      trackOpBit = 1;
      maxMarkerBits = 30;
      ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
      MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
      ReactiveEffect = class {
        constructor(fn, scheduler = null, scope) {
          this.fn = fn;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this.parent = void 0;
          recordEffectScope(this, scope);
        }
        run() {
          if (!this.active) {
            return this.fn();
          }
          let parent = activeEffect;
          let lastShouldTrack = shouldTrack;
          while (parent) {
            if (parent === this) {
              return;
            }
            parent = parent.parent;
          }
          try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
              initDepMarkers(this);
            } else {
              cleanupEffect(this);
            }
            return this.fn();
          } finally {
            if (effectTrackDepth <= maxMarkerBits) {
              finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) {
              this.stop();
            }
          }
        }
        stop() {
          if (activeEffect === this) {
            this.deferStop = true;
          } else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
              this.onStop();
            }
            this.active = false;
          }
        }
      };
      shouldTrack = true;
      trackStack = [];
      isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
      builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol));
      get = /* @__PURE__ */ createGetter();
      shallowGet = /* @__PURE__ */ createGetter(false, true);
      readonlyGet = /* @__PURE__ */ createGetter(true);
      shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
      arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
      set = /* @__PURE__ */ createSetter();
      shallowSet = /* @__PURE__ */ createSetter(true);
      mutableHandlers = {
        get,
        set,
        deleteProperty,
        has,
        ownKeys
      };
      readonlyHandlers = {
        get: readonlyGet,
        set(target, key) {
          if (process.env.NODE_ENV !== "production") {
            warn2(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
          }
          return true;
        },
        deleteProperty(target, key) {
          if (process.env.NODE_ENV !== "production") {
            warn2(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
          }
          return true;
        }
      };
      shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
        get: shallowGet,
        set: shallowSet
      });
      shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
        get: shallowReadonlyGet
      });
      toShallow = (value) => value;
      getProto = (v3) => Reflect.getPrototypeOf(v3);
      [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
      mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      shallowReadonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, true)
      };
      reactiveMap = /* @__PURE__ */ new WeakMap();
      shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      readonlyMap = /* @__PURE__ */ new WeakMap();
      shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      toReactive = (value) => isObject2(value) ? reactive2(value) : value;
      toReadonly = (value) => isObject2(value) ? readonly(value) : value;
      RefImpl = class {
        constructor(value, __v_isShallow) {
          this.__v_isShallow = __v_isShallow;
          this.dep = void 0;
          this.__v_isRef = true;
          this._rawValue = __v_isShallow ? value : toRaw(value);
          this._value = __v_isShallow ? value : toReactive(value);
        }
        get value() {
          trackRefValue(this);
          return this._value;
        }
        set value(newVal) {
          newVal = this.__v_isShallow ? newVal : toRaw(newVal);
          if (hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this.__v_isShallow ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
          }
        }
      };
      shallowUnwrapHandlers = {
        get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      CustomRefImpl = class {
        constructor(factory) {
          this.dep = void 0;
          this.__v_isRef = true;
          const { get: get10, set: set3 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
          this._get = get10;
          this._set = set3;
        }
        get value() {
          return this._get();
        }
        set value(newVal) {
          this._set(newVal);
        }
      };
      ObjectRefImpl = class {
        constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this.__v_isRef = true;
        }
        get value() {
          const val = this._object[this._key];
          return val === void 0 ? this._defaultValue : val;
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
      };
      ComputedRefImpl = class {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this._dirty = true;
          this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
              this._dirty = true;
              triggerRefValue(this);
            }
          });
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          trackRefValue(self2);
          if (self2._dirty || !self2._cacheable) {
            self2._dirty = false;
            self2._value = self2.effect.run();
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
      };
      _a = "__v_isReadonly";
    }
  });

  // node_modules/.pnpm/@vue+runtime-core@3.2.37/node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  function warn3(msg, ...args) {
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.join(""),
        instance && instance.proxy,
        trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
      ]);
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last2 = normalizedStack[0];
      if (last2 && last2.vnode === currentVNode) {
        last2.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i8) => {
      logs.push(...i8 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys3 = Object.keys(props);
    keys3.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys3.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString2(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction2(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
      res = args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
    return res;
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction2(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    const values = [];
    for (let i8 = 0; i8 < fn.length; i8++) {
      values.push(callWithAsyncErrorHandling(fn[i8], instance, type, args));
    }
    return values;
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = process.env.NODE_ENV !== "production" ? ErrorTypeStrings[type] : type;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i8 = 0; i8 < errorCapturedHooks.length; i8++) {
            if (errorCapturedHooks[i8](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
    if (process.env.NODE_ENV !== "production") {
      const info = ErrorTypeStrings[type];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn3(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    } else {
      console.error(err);
    }
  }
  function nextTick2(fn) {
    const p6 = currentFlushPromise || resolvedPromise;
    return fn ? p6.then(this ? fn.bind(this) : fn) : p6;
  }
  function findInsertionIndex(id) {
    let start3 = flushIndex + 1;
    let end = queue.length;
    while (start3 < end) {
      const middle = start3 + end >>> 1;
      const middleJobId = getId(queue[middle]);
      middleJobId < id ? start3 = middle + 1 : end = middle;
    }
    return start3;
  }
  function queueJob(job) {
    if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i8 = queue.indexOf(job);
    if (i8 > flushIndex) {
      queue.splice(i8, 1);
    }
  }
  function queueCb(cb, activeQueue, pendingQueue, index15) {
    if (!isArray2(cb)) {
      if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index15 + 1 : index15)) {
        pendingQueue.push(cb);
      }
    } else {
      pendingQueue.push(...cb);
    }
    queueFlush();
  }
  function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
  }
  function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
  }
  function flushPreFlushCbs(seen2, parentJob = null) {
    if (pendingPreFlushCbs.length) {
      currentPreFlushParentJob = parentJob;
      activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
      pendingPreFlushCbs.length = 0;
      if (process.env.NODE_ENV !== "production") {
        seen2 = seen2 || /* @__PURE__ */ new Map();
      }
      for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
        if (process.env.NODE_ENV !== "production" && checkRecursiveUpdates(seen2, activePreFlushCbs[preFlushIndex])) {
          continue;
        }
        activePreFlushCbs[preFlushIndex]();
      }
      activePreFlushCbs = null;
      preFlushIndex = 0;
      currentPreFlushParentJob = null;
      flushPreFlushCbs(seen2, parentJob);
    }
  }
  function flushPostFlushCbs(seen2) {
    flushPreFlushCbs();
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)];
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      if (process.env.NODE_ENV !== "production") {
        seen2 = seen2 || /* @__PURE__ */ new Map();
      }
      activePostFlushCbs.sort((a8, b5) => getId(a8) - getId(b5));
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        if (process.env.NODE_ENV !== "production" && checkRecursiveUpdates(seen2, activePostFlushCbs[postFlushIndex])) {
          continue;
        }
        activePostFlushCbs[postFlushIndex]();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  function flushJobs(seen2) {
    isFlushPending = false;
    isFlushing = true;
    if (process.env.NODE_ENV !== "production") {
      seen2 = seen2 || /* @__PURE__ */ new Map();
    }
    flushPreFlushCbs(seen2);
    queue.sort((a8, b5) => getId(a8) - getId(b5));
    const check = process.env.NODE_ENV !== "production" ? (job) => checkRecursiveUpdates(seen2, job) : NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (process.env.NODE_ENV !== "production" && check(job)) {
            continue;
          }
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs(seen2);
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
        flushJobs(seen2);
      }
    }
  }
  function checkRecursiveUpdates(seen2, fn) {
    if (!seen2.has(fn)) {
      seen2.set(fn, 1);
    } else {
      const count = seen2.get(fn);
      if (count > RECURSION_LIMIT) {
        const instance = fn.ownerInstance;
        const componentName = instance && getComponentName(instance.type);
        warn3(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
        return true;
      } else {
        seen2.set(fn, count + 1);
      }
    }
  }
  function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record2 = map.get(id);
    if (!record2) {
      createRecord(id, instance.type);
      record2 = map.get(id);
    }
    record2.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id, initialDef) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    const record2 = map.get(id);
    if (!record2) {
      return;
    }
    record2.initialDef.render = newRender;
    [...record2.instances].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id, newComp) {
    const record2 = map.get(id);
    if (!record2)
      return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record2.initialDef, newComp);
    const instances = [...record2.instances];
    for (const instance of instances) {
      const oldComp = normalizeClassComponent(instance.type);
      if (!hmrDirtyComponents.has(oldComp)) {
        if (oldComp !== record2.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.add(oldComp);
      }
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        hmrDirtyComponents.add(oldComp);
        instance.ceReload(newComp.styles);
        hmrDirtyComponents.delete(oldComp);
      } else if (instance.parent) {
        queueJob(instance.parent.update);
        if (instance.parent.type.__asyncLoader && instance.parent.ceReload) {
          instance.parent.ceReload(newComp.styles);
        }
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
      }
    }
    queuePostFlushCb(() => {
      for (const instance of instances) {
        hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
      }
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key in oldComp) {
      if (key !== "__file" && !(key in newComp)) {
        delete oldComp[key];
      }
    }
  }
  function tryWrap(fn) {
    return (id, arg) => {
      try {
        return fn(id, arg);
      } catch (e8) {
        console.error(e8);
        console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
      }
    };
  }
  function emit(event, ...args) {
    if (devtools) {
      devtools.emit(event, ...args);
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook(hook, target) {
    var _a3, _b;
    devtools = hook;
    if (devtools) {
      devtools.enabled = true;
      buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
      buffer = [];
    } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a3 = window.navigator) === null || _a3 === void 0 ? void 0 : _a3.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook(newHook, target);
      });
      setTimeout(() => {
        if (!devtools) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app, version3) {
    emit("app:init", app, version3, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit("app:unmount", app);
  }
  function createDevtoolsComponentHook(hook) {
    return (component) => {
      emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
  }
  function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
      emit(hook, component.appContext.app, component.uid, component, type, time);
    };
  }
  function devtoolsComponentEmit(component, event, params) {
    emit("component:emit", component.appContext.app, component, event, params);
  }
  function emit$1(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
      return;
    const props = instance.vnode.props || EMPTY_OBJ;
    if (process.env.NODE_ENV !== "production") {
      const { emitsOptions, propsOptions: [propsOptions] } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
            warn3(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
          }
        } else {
          const validator = emitsOptions[event];
          if (isFunction2(validator)) {
            const isValid = validator(...rawArgs);
            if (!isValid) {
              warn3(`Invalid event arguments: event validation failed for event "${event}".`);
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modelArg = isModelListener2 && event.slice(7);
    if (modelArg && modelArg in props) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
      if (trim) {
        args = rawArgs.map((a8) => a8.trim());
      }
      if (number) {
        args = rawArgs.map(toNumber);
      }
    }
    if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
      devtoolsComponentEmit(instance, event, args);
    }
    if (process.env.NODE_ENV !== "production") {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn3(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
      }
    }
    let handlerName;
    let handler2 = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
    if (!handler2 && isModelListener2) {
      handler2 = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler2) {
      callWithAsyncErrorHandling(handler2, instance, 6, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache4 = appContext.emitsCache;
    const cached = cache4.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction2(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      cache4.set(comp, null);
      return null;
    }
    if (isArray2(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    cache4.set(comp, normalized);
    return normalized;
  }
  function isEmitListener(options2, key) {
    if (!options2 || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options2, key[0].toLowerCase() + key.slice(1)) || hasOwn(options2, hyphenate(key)) || hasOwn(options2, key);
  }
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      const res = fn(...args);
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
      if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render: render2, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if (process.env.NODE_ENV !== "production") {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
        fallthroughAttrs = attrs;
      } else {
        const render3 = Component;
        if (process.env.NODE_ENV !== "production" && attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(render3.length > 1 ? render3(props, process.env.NODE_ENV !== "production" ? {
          get attrs() {
            markAttrsAccessed();
            return attrs;
          },
          slots,
          emit: emit2
        } : { attrs, slots, emit: emit2 }) : render3(props, null));
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (process.env.NODE_ENV !== "production" && result.patchFlag > 0 && result.patchFlag & 2048) {
      [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys3 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys3.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys3.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
          }
          root = cloneVNode(root, fallthroughAttrs);
        } else if (process.env.NODE_ENV !== "production" && !accessedAttrs && root.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i8 = 0, l5 = allAttrs.length; i8 < l5; i8++) {
            const key = allAttrs[i8];
            if (isOn(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn3(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
          }
          if (eventAttrs.length) {
            warn3(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
          }
        }
      }
    }
    if (vnode.dirs) {
      if (process.env.NODE_ENV !== "production" && !isElementRoot(root)) {
        warn3(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
      }
      root = cloneVNode(root);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (process.env.NODE_ENV !== "production" && !isElementRoot(root)) {
        warn3(`Component inside <Transition> renders non-element root node that cannot be animated.`);
      }
      root.transition = vnode.transition;
    }
    if (process.env.NODE_ENV !== "production" && setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  function filterSingleRoot(children) {
    let singleRoot;
    for (let i8 = 0; i8 < children.length; i8++) {
      const child = children[i8];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (process.env.NODE_ENV !== "production" && (prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i8 = 0; i8 < dynamicProps.length; i8++) {
          const key = dynamicProps[i8];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i8 = 0; i8 < nextKeys.length; i8++) {
      const key = nextKeys[i8];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent && parent.subTree === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    }
  }
  function triggerEvent(vnode, name2) {
    const eventListener = vnode.props && vnode.props[name2];
    if (isFunction2(eventListener)) {
      eventListener();
    }
  }
  function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
    patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    if (suspense.deps > 0) {
      triggerEvent(vnode, "onPending");
      triggerEvent(vnode, "onFallback");
      patch(null, vnode.ssFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds);
      setActiveBranch(suspense, vnode.ssFallback);
    } else {
      suspense.resolve();
    }
  }
  function patchSuspense(n1, n22, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = n22.suspense = n1.suspense;
    suspense.vnode = n22;
    n22.el = n1.el;
    const newBranch = n22.ssContent;
    const newFallback = n22.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
      suspense.pendingBranch = newBranch;
      if (isSameVNodeType(newBranch, pendingBranch)) {
        patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else if (isInFallback) {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else {
        suspense.pendingId++;
        if (isHydrating) {
          suspense.isHydrating = false;
          suspense.activeBranch = pendingBranch;
        } else {
          unmount(pendingBranch, parentComponent, suspense);
        }
        suspense.deps = 0;
        suspense.effects.length = 0;
        suspense.hiddenContainer = createElement("div");
        if (isInFallback) {
          patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newFallback);
          }
        } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
          suspense.resolve(true);
        } else {
          patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
          if (suspense.deps <= 0) {
            suspense.resolve();
          }
        }
      }
    } else {
      if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newBranch);
      } else {
        triggerEvent(n22, "onPending");
        suspense.pendingBranch = newBranch;
        suspense.pendingId++;
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          const { timeout, pendingId } = suspense;
          if (timeout > 0) {
            setTimeout(() => {
              if (suspense.pendingId === pendingId) {
                suspense.fallback(newFallback);
              }
            }, timeout);
          } else if (timeout === 0) {
            suspense.fallback(newFallback);
          }
        }
      }
    }
  }
  function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    if (process.env.NODE_ENV !== "production" && true && !hasWarned) {
      hasWarned = true;
      console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove: remove2 } } = rendererInternals;
    const timeout = toNumber(vnode.props && vnode.props.timeout);
    const suspense = {
      vnode,
      parent,
      parentComponent,
      isSVG,
      container,
      hiddenContainer,
      anchor,
      deps: 0,
      pendingId: 0,
      timeout: typeof timeout === "number" ? timeout : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: true,
      isHydrating,
      isUnmounted: false,
      effects: [],
      resolve(resume = false) {
        if (process.env.NODE_ENV !== "production") {
          if (!resume && !suspense.pendingBranch) {
            throw new Error(`suspense.resolve() is called without a pending branch.`);
          }
          if (suspense.isUnmounted) {
            throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
          }
        }
        const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
        if (suspense.isHydrating) {
          suspense.isHydrating = false;
        } else if (!resume) {
          const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = () => {
              if (pendingId === suspense.pendingId) {
                move(pendingBranch, container2, anchor2, 0);
              }
            };
          }
          let { anchor: anchor2 } = suspense;
          if (activeBranch) {
            anchor2 = next(activeBranch);
            unmount(activeBranch, parentComponent2, suspense, true);
          }
          if (!delayEnter) {
            move(pendingBranch, container2, anchor2, 0);
          }
        }
        setActiveBranch(suspense, pendingBranch);
        suspense.pendingBranch = null;
        suspense.isInFallback = false;
        let parent2 = suspense.parent;
        let hasUnresolvedAncestor = false;
        while (parent2) {
          if (parent2.pendingBranch) {
            parent2.effects.push(...effects);
            hasUnresolvedAncestor = true;
            break;
          }
          parent2 = parent2.parent;
        }
        if (!hasUnresolvedAncestor) {
          queuePostFlushCb(effects);
        }
        suspense.effects = [];
        triggerEvent(vnode2, "onResolve");
      },
      fallback(fallbackVNode) {
        if (!suspense.pendingBranch) {
          return;
        }
        const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
        triggerEvent(vnode2, "onFallback");
        const anchor2 = next(activeBranch);
        const mountFallback = () => {
          if (!suspense.isInFallback) {
            return;
          }
          patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, isSVG2, slotScopeIds, optimized);
          setActiveBranch(suspense, fallbackVNode);
        };
        const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = mountFallback;
        }
        suspense.isInFallback = true;
        unmount(activeBranch, parentComponent2, null, true);
        if (!delayEnter) {
          mountFallback();
        }
      },
      move(container2, anchor2, type) {
        suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
        suspense.container = container2;
      },
      next() {
        return suspense.activeBranch && next(suspense.activeBranch);
      },
      registerDep(instance, setupRenderEffect) {
        const isInPendingSuspense = !!suspense.pendingBranch;
        if (isInPendingSuspense) {
          suspense.deps++;
        }
        const hydratedEl = instance.vnode.el;
        instance.asyncDep.catch((err) => {
          handleError(err, instance, 0);
        }).then((asyncSetupResult) => {
          if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
            return;
          }
          instance.asyncResolved = true;
          const { vnode: vnode2 } = instance;
          if (process.env.NODE_ENV !== "production") {
            pushWarningContext(vnode2);
          }
          handleSetupResult(instance, asyncSetupResult, false);
          if (hydratedEl) {
            vnode2.el = hydratedEl;
          }
          const placeholder = !hydratedEl && instance.subTree.el;
          setupRenderEffect(instance, vnode2, parentNode(hydratedEl || instance.subTree.el), hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
          if (placeholder) {
            remove2(placeholder);
          }
          updateHOCHostEl(instance, vnode2.el);
          if (process.env.NODE_ENV !== "production") {
            popWarningContext();
          }
          if (isInPendingSuspense && --suspense.deps === 0) {
            suspense.resolve();
          }
        });
      },
      unmount(parentSuspense, doRemove) {
        suspense.isUnmounted = true;
        if (suspense.activeBranch) {
          unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
        }
        if (suspense.pendingBranch) {
          unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
        }
      }
    };
    return suspense;
  }
  function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
    const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) {
      suspense.resolve();
    }
    return result;
  }
  function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
  }
  function normalizeSuspenseSlot(s4) {
    let block;
    if (isFunction2(s4)) {
      const trackBlock = isBlockTreeEnabled && s4._c;
      if (trackBlock) {
        s4._d = false;
        openBlock();
      }
      s4 = s4();
      if (trackBlock) {
        s4._d = true;
        block = currentBlock;
        closeBlock();
      }
    }
    if (isArray2(s4)) {
      const singleChild = filterSingleRoot(s4);
      if (process.env.NODE_ENV !== "production" && !singleChild) {
        warn3(`<Suspense> slots expect a single root node.`);
      }
      s4 = singleChild;
    }
    s4 = normalizeVNode(s4);
    if (block && !s4.dynamicChildren) {
      s4.dynamicChildren = block.filter((c6) => c6 !== s4);
    }
    return s4;
  }
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray2(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = vnode.el = branch.el;
    if (parentComponent && parentComponent.subTree === vnode) {
      parentComponent.vnode.el = el;
      updateHOCHostEl(parentComponent, el);
    }
  }
  function provide(key, value) {
    if (!currentInstance) {
      if (process.env.NODE_ENV !== "production") {
        warn3(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
      const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction2(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
      } else if (process.env.NODE_ENV !== "production") {
        warn3(`injection "${String(key)}" not found.`);
      }
    } else if (process.env.NODE_ENV !== "production") {
      warn3(`inject() can only be used inside setup() or functional components.`);
    }
  }
  function watchEffect2(effect2, options2) {
    return doWatch(effect2, null, options2);
  }
  function watchPostEffect(effect2, options2) {
    return doWatch(effect2, null, process.env.NODE_ENV !== "production" ? Object.assign(Object.assign({}, options2), { flush: "post" }) : { flush: "post" });
  }
  function watchSyncEffect(effect2, options2) {
    return doWatch(effect2, null, process.env.NODE_ENV !== "production" ? Object.assign(Object.assign({}, options2), { flush: "sync" }) : { flush: "sync" });
  }
  function watch2(source, cb, options2) {
    if (process.env.NODE_ENV !== "production" && !isFunction2(cb)) {
      warn3(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options2);
  }
  function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
    if (process.env.NODE_ENV !== "production" && !cb) {
      if (immediate !== void 0) {
        warn3(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
      }
      if (deep !== void 0) {
        warn3(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
      }
    }
    const warnInvalidSource = (s4) => {
      warn3(`Invalid watch source: `, s4, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => source;
      deep = true;
    } else if (isArray2(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s4) => isReactive(s4) || isShallow(s4));
      getter = () => source.map((s4) => {
        if (isRef(s4)) {
          return s4.value;
        } else if (isReactive(s4)) {
          return traverse(s4);
        } else if (isFunction2(s4)) {
          return callWithErrorHandling(s4, instance, 2);
        } else {
          process.env.NODE_ENV !== "production" && warnInvalidSource(s4);
        }
      });
    } else if (isFunction2(source)) {
      if (cb) {
        getter = () => callWithErrorHandling(source, instance, 2);
      } else {
        getter = () => {
          if (instance && instance.isUnmounted) {
            return;
          }
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
        };
      }
    } else {
      getter = NOOP;
      process.env.NODE_ENV !== "production" && warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
      cleanup = effect2.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
      };
    };
    if (isInSSRComponentSetup) {
      onCleanup = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onCleanup
        ]);
      }
      return NOOP;
    }
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect2.active) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v3, i8) => hasChanged(v3, oldValue[i8])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
            onCleanup
          ]);
          oldValue = newValue;
        }
      } else {
        effect2.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      scheduler = () => queuePreFlushCb(job);
    }
    const effect2 = new ReactiveEffect(getter, scheduler);
    if (process.env.NODE_ENV !== "production") {
      effect2.onTrack = onTrack;
      effect2.onTrigger = onTrigger;
    }
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect2.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
    } else {
      effect2.run();
    }
    return () => {
      effect2.stop();
      if (instance && instance.scope) {
        remove(instance.scope.effects, effect2);
      }
    };
  }
  function instanceWatch(source, value, options2) {
    const publicThis = this.proxy;
    const getter = isString2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction2(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options2 = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options2);
    if (cur) {
      setCurrentInstance(cur);
    } else {
      unsetCurrentInstance();
    }
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i8 = 0; i8 < segments.length && cur; i8++) {
        cur = cur[segments[i8]];
      }
      return cur;
    };
  }
  function traverse(value, seen2) {
    if (!isObject2(value) || value["__v_skip"]) {
      return value;
    }
    seen2 = seen2 || /* @__PURE__ */ new Set();
    if (seen2.has(value)) {
      return value;
    }
    seen2.add(value);
    if (isRef(value)) {
      traverse(value.value, seen2);
    } else if (isArray2(value)) {
      for (let i8 = 0; i8 < value.length; i8++) {
        traverse(value[i8], seen2);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v3) => {
        traverse(v3, seen2);
      });
    } else if (isPlainObject(value)) {
      for (const key in value) {
        traverse(value[key], seen2);
      }
    }
    return value;
  }
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted2(() => {
      state.isMounted = true;
    });
    onBeforeUnmount2(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode: mode2, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook3 = (hook, args) => {
      hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook3(hook, args);
      if (isArray2(hook)) {
        if (hook.every((hook2) => hook2.length <= 1))
          done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode: mode2,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el._leaveCb) {
          el._leaveCb(true);
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
          leavingVNode.el._leaveCb();
        }
        callHook3(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el._enterCb = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook3(cancelHook, [el]);
          } else {
            callHook3(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el._enterCb = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key2 = String(vnode.key);
        if (el._enterCb) {
          el._enterCb(true);
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook3(onBeforeLeave, [el]);
        let called = false;
        const done = el._leaveCb = (cancelled) => {
          if (called)
            return;
          called = true;
          remove2();
          if (cancelled) {
            callHook3(onLeaveCancelled, [el]);
          } else {
            callHook3(onAfterLeave, [el]);
          }
          el._leaveCb = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        return resolveTransitionHooks(vnode2, props, state, instance);
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i8 = 0; i8 < children.length; i8++) {
      let child = children[i8];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i8);
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i8 = 0; i8 < ret.length; i8++) {
        ret[i8].patchFlag = -2;
      }
    }
    return ret;
  }
  function defineComponent(options2) {
    return isFunction2(options2) ? { setup: options2, name: options2.name } : options2;
  }
  function defineAsyncComponent(source) {
    if (isFunction2(source)) {
      source = { loader: source };
    }
    const {
      loader,
      loadingComponent,
      errorComponent,
      delay = 200,
      timeout,
      suspensible = true,
      onError: userOnError
    } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
      retries++;
      pendingRequest = null;
      return load();
    };
    const load = () => {
      let thisRequest;
      return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
        err = err instanceof Error ? err : new Error(String(err));
        if (userOnError) {
          return new Promise((resolve2, reject) => {
            const userRetry = () => resolve2(retry());
            const userFail = () => reject(err);
            userOnError(err, userRetry, userFail, retries + 1);
          });
        } else {
          throw err;
        }
      }).then((comp) => {
        if (thisRequest !== pendingRequest && pendingRequest) {
          return pendingRequest;
        }
        if (process.env.NODE_ENV !== "production" && !comp) {
          warn3(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
        }
        if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
          comp = comp.default;
        }
        if (process.env.NODE_ENV !== "production" && comp && !isObject2(comp) && !isFunction2(comp)) {
          throw new Error(`Invalid async component load result: ${comp}`);
        }
        resolvedComp = comp;
        return comp;
      }));
    };
    return defineComponent({
      name: "AsyncComponentWrapper",
      __asyncLoader: load,
      get __asyncResolved() {
        return resolvedComp;
      },
      setup() {
        const instance = currentInstance;
        if (resolvedComp) {
          return () => createInnerComp(resolvedComp, instance);
        }
        const onError = (err) => {
          pendingRequest = null;
          handleError(err, instance, 13, !errorComponent);
        };
        if (suspensible && instance.suspense || isInSSRComponentSetup) {
          return load().then((comp) => {
            return () => createInnerComp(comp, instance);
          }).catch((err) => {
            onError(err);
            return () => errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          });
        }
        const loaded = ref2(false);
        const error = ref2();
        const delayed = ref2(!!delay);
        if (delay) {
          setTimeout(() => {
            delayed.value = false;
          }, delay);
        }
        if (timeout != null) {
          setTimeout(() => {
            if (!loaded.value && !error.value) {
              const err = new Error(`Async component timed out after ${timeout}ms.`);
              onError(err);
              error.value = err;
            }
          }, timeout);
        }
        load().then(() => {
          loaded.value = true;
          if (instance.parent && isKeepAlive(instance.parent.vnode)) {
            queueJob(instance.parent.update);
          }
        }).catch((err) => {
          onError(err);
          error.value = err;
        });
        return () => {
          if (loaded.value && resolvedComp) {
            return createInnerComp(resolvedComp, instance);
          } else if (error.value && errorComponent) {
            return createVNode(errorComponent, {
              error: error.value
            });
          } else if (loadingComponent && !delayed.value) {
            return createVNode(loadingComponent);
          }
        };
      }
    });
  }
  function createInnerComp(comp, { vnode: { ref: ref5, props, children, shapeFlag }, parent }) {
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref5;
    return vnode;
  }
  function matches(pattern, name2) {
    if (isArray2(pattern)) {
      return pattern.some((p6) => matches(p6, name2));
    } else if (isString2(pattern)) {
      return pattern.split(",").includes(name2);
    } else if (pattern.test) {
      return pattern.test(name2);
    }
    return false;
  }
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256) {
      shapeFlag -= 256;
    }
    if (shapeFlag & 512) {
      shapeFlag -= 512;
    }
    vnode.shapeFlag = shapeFlag;
  }
  function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        if (target.isUnmounted) {
          return;
        }
        pauseTracking();
        setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        unsetCurrentInstance();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else if (process.env.NODE_ENV !== "production") {
      const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
      warn3(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
  }
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  function validateDirectiveName(name2) {
    if (isBuiltInDirective(name2)) {
      warn3("Do not use built-in directive ids as custom directive id: " + name2);
    }
  }
  function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
      process.env.NODE_ENV !== "production" && warn3(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i8 = 0; i8 < directives.length; i8++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i8];
      if (isFunction2(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i8 = 0; i8 < bindings.length; i8++) {
      const binding = bindings[i8];
      if (oldBindings) {
        binding.oldValue = oldBindings[i8].value;
      }
      let hook = binding.dir[name2];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  function resolveComponent(name2, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
  }
  function resolveDynamicComponent(component) {
    if (isString2(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveDirective(name2) {
    return resolveAsset(DIRECTIVES, name2);
  }
  function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(Component, false);
        if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize(camelize(name2)))) {
          return Component;
        }
      }
      const res = resolve(instance[type] || Component[type], name2) || resolve(instance.appContext[type], name2);
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (process.env.NODE_ENV !== "production" && warnMissing && !res) {
        const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
        warn3(`Failed to resolve ${type.slice(0, -1)}: ${name2}${extra}`);
      }
      return res;
    } else if (process.env.NODE_ENV !== "production") {
      warn3(`resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`);
    }
  }
  function resolve(registry, name2) {
    return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize(camelize(name2))]);
  }
  function renderList(source, renderItem, cache4, index15) {
    let ret;
    const cached = cache4 && cache4[index15];
    if (isArray2(source) || isString2(source)) {
      ret = new Array(source.length);
      for (let i8 = 0, l5 = source.length; i8 < l5; i8++) {
        ret[i8] = renderItem(source[i8], i8, void 0, cached && cached[i8]);
      }
    } else if (typeof source === "number") {
      if (process.env.NODE_ENV !== "production" && !Number.isInteger(source)) {
        warn3(`The v-for range expect an integer value but got ${source}.`);
      }
      ret = new Array(source);
      for (let i8 = 0; i8 < source; i8++) {
        ret[i8] = renderItem(i8 + 1, i8, void 0, cached && cached[i8]);
      }
    } else if (isObject2(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(source, (item, i8) => renderItem(item, i8, void 0, cached && cached[i8]));
      } else {
        const keys3 = Object.keys(source);
        ret = new Array(keys3.length);
        for (let i8 = 0, l5 = keys3.length; i8 < l5; i8++) {
          const key = keys3[i8];
          ret[i8] = renderItem(source[key], key, i8, cached && cached[i8]);
        }
      }
    } else {
      ret = [];
    }
    if (cache4) {
      cache4[index15] = ret;
    }
    return ret;
  }
  function createSlots(slots, dynamicSlots) {
    for (let i8 = 0; i8 < dynamicSlots.length; i8++) {
      const slot = dynamicSlots[i8];
      if (isArray2(slot)) {
        for (let j2 = 0; j2 < slot.length; j2++) {
          slots[slot[j2].name] = slot[j2].fn;
        }
      } else if (slot) {
        slots[slot.name] = slot.fn;
      }
    }
    return slots;
  }
  function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
      return createVNode("slot", name2 === "default" ? null : { name: name2 }, fallback && fallback());
    }
    let slot = slots[name2];
    if (process.env.NODE_ENV !== "production" && slot && slot.length > 1) {
      warn3(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
      slot = () => [];
    }
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, { key: props.key || `_${name2}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child))
        return true;
      if (child.type === Comment)
        return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  function toHandlers(obj) {
    const ret = {};
    if (process.env.NODE_ENV !== "production" && !isObject2(obj)) {
      warn3(`v-on with no argument expects an object value.`);
      return ret;
    }
    for (const key in obj) {
      ret[toHandlerKey(key)] = obj[key];
    }
    return ret;
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key) => {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key](instance),
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key) => {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key) => {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key[0])) {
          warn3(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
          return;
        }
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key],
          set: NOOP
        });
      }
    });
  }
  function createDuplicateChecker() {
    const cache4 = /* @__PURE__ */ Object.create(null);
    return (type, key) => {
      if (cache4[key]) {
        warn3(`${type} property "${key}" is already defined in ${cache4[key]}.`);
      } else {
        cache4[key] = type;
      }
    };
  }
  function applyOptions(instance) {
    const options2 = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options2.beforeCreate) {
      callHook(options2.beforeCreate, instance, "bc");
    }
    const {
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      expose,
      inheritAttrs,
      components,
      directives,
      filters
    } = options2;
    const checkDuplicateProperties = process.env.NODE_ENV !== "production" ? createDuplicateChecker() : null;
    if (process.env.NODE_ENV !== "production") {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction2(methodHandler)) {
          if (process.env.NODE_ENV !== "production") {
            Object.defineProperty(ctx, key, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            ctx[key] = methodHandler.bind(publicThis);
          }
          if (process.env.NODE_ENV !== "production") {
            checkDuplicateProperties("Methods", key);
          }
        } else if (process.env.NODE_ENV !== "production") {
          warn3(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
        }
      }
    }
    if (dataOptions) {
      if (process.env.NODE_ENV !== "production" && !isFunction2(dataOptions)) {
        warn3(`The data option must be a function. Plain object usage is no longer supported.`);
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (process.env.NODE_ENV !== "production" && isPromise(data)) {
        warn3(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
      }
      if (!isObject2(data)) {
        process.env.NODE_ENV !== "production" && warn3(`data() should return an object.`);
      } else {
        instance.data = reactive2(data);
        if (process.env.NODE_ENV !== "production") {
          for (const key in data) {
            checkDuplicateProperties("Data", key);
            if (!isReservedPrefix(key[0])) {
              Object.defineProperty(ctx, key, {
                configurable: true,
                enumerable: true,
                get: () => data[key],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get10 = isFunction2(opt) ? opt.bind(publicThis, publicThis) : isFunction2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (process.env.NODE_ENV !== "production" && get10 === NOOP) {
          warn3(`Computed property "${key}" has no getter.`);
        }
        const set3 = !isFunction2(opt) && isFunction2(opt.set) ? opt.set.bind(publicThis) : process.env.NODE_ENV !== "production" ? () => {
          warn3(`Write operation failed: computed property "${key}" is readonly.`);
        } : NOOP;
        const c6 = computed3({
          get: get10,
          set: set3
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c6.value,
          set: (v3) => c6.value = v3
        });
        if (process.env.NODE_ENV !== "production") {
          checkDuplicateProperties("Computed", key);
        }
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray2(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted2, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount2, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray2(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components)
      instance.components = components;
    if (directives)
      instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
    if (isArray2(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject2(opt)) {
        if ("default" in opt) {
          injected = inject(opt.from || key, opt.default, true);
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        if (unwrapRef) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v3) => injected.value = v3
          });
        } else {
          if (process.env.NODE_ENV !== "production") {
            warn3(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
          }
          ctx[key] = injected;
        }
      } else {
        ctx[key] = injected;
      }
      if (process.env.NODE_ENV !== "production") {
        checkDuplicateProperties("Inject", key);
      }
    }
  }
  function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(isArray2(hook) ? hook.map((h8) => h8.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
  }
  function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString2(raw)) {
      const handler2 = ctx[raw];
      if (isFunction2(handler2)) {
        watch2(getter, handler2);
      } else if (process.env.NODE_ENV !== "production") {
        warn3(`Invalid watch handler specified by key "${raw}"`, handler2);
      }
    } else if (isFunction2(raw)) {
      watch2(getter, raw.bind(publicThis));
    } else if (isObject2(raw)) {
      if (isArray2(raw)) {
        raw.forEach((r8) => createWatcher(r8, ctx, publicThis, key));
      } else {
        const handler2 = isFunction2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction2(handler2)) {
          watch2(getter, handler2, raw);
        } else if (process.env.NODE_ENV !== "production") {
          warn3(`Invalid watch handler specified by key "${raw.handler}"`, handler2);
        }
      }
    } else if (process.env.NODE_ENV !== "production") {
      warn3(`Invalid watch option: "${key}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache4, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache4.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach((m3) => mergeOptions(resolved, m3, optionMergeStrategies, true));
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache4.set(base, resolved);
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach((m3) => mergeOptions(to, m3, strats, true));
    }
    for (const key in from) {
      if (asMixin && key === "expose") {
        process.env.NODE_ENV !== "production" && warn3(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
      } else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(isFunction2(to) ? to.call(this, this) : to, isFunction2(from) ? from.call(this, this) : from);
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray2(raw)) {
      const res = {};
      for (let i8 = 0; i8 < raw.length; i8++) {
        res[raw[i8]] = raw[i8];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray2(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from) : from;
  }
  function mergeWatchOptions(to, from) {
    if (!to)
      return from;
    if (!from)
      return to;
    const merged = extend(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray2(to[key], from[key]);
    }
    return merged;
  }
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (process.env.NODE_ENV !== "production") {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive2(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = toRaw(props);
    const [options2] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (!(process.env.NODE_ENV !== "production" && (instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId)) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i8 = 0; i8 < propsToUpdate.length; i8++) {
          let key = propsToUpdate[i8];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options2) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(options2, rawCurrentProps, camelizedKey, value, instance, false);
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options2) {
            if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(options2, rawCurrentProps, key, void 0, instance, true);
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance, "set", "$attrs");
    }
    if (process.env.NODE_ENV !== "production") {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options2, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options2 && hasOwn(options2, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i8 = 0; i8 < needCastKeys.length; i8++) {
        const key = needCastKeys[i8];
        props[key] = resolvePropValue(options2, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options2, props, key, value, instance, isAbsent) {
    const opt = options2[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && isFunction2(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(null, props);
            unsetCurrentInstance();
          }
        } else {
          value = defaultValue;
        }
      }
      if (opt[0]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[1] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache4 = appContext.propsCache;
    const cached = cache4.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction2(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys3] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys3)
          needCastKeys.push(...keys3);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      cache4.set(comp, EMPTY_ARR);
      return EMPTY_ARR;
    }
    if (isArray2(raw)) {
      for (let i8 = 0; i8 < raw.length; i8++) {
        if (process.env.NODE_ENV !== "production" && !isString2(raw[i8])) {
          warn3(`props must be strings when using array syntax.`, raw[i8]);
        }
        const normalizedKey = camelize(raw[i8]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (process.env.NODE_ENV !== "production" && !isObject2(raw)) {
        warn3(`invalid props options`, raw);
      }
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray2(opt) || isFunction2(opt) ? { type: opt } : opt;
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[0] = booleanIndex > -1;
            prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    cache4.set(comp, res);
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$") {
      return true;
    } else if (process.env.NODE_ENV !== "production") {
      warn3(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? "null" : "";
  }
  function isSameType(a8, b5) {
    return getType(a8) === getType(b5);
  }
  function getTypeIndex(type, expectedTypes) {
    if (isArray2(expectedTypes)) {
      return expectedTypes.findIndex((t8) => isSameType(t8, type));
    } else if (isFunction2(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options2 = instance.propsOptions[0];
    for (const key in options2) {
      let opt = options2[key];
      if (opt == null)
        continue;
      validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
    }
  }
  function validateProp(name2, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    if (required && isAbsent) {
      warn3('Missing required prop: "' + name2 + '"');
      return;
    }
    if (value == null && !prop.required) {
      return;
    }
    if (type != null && type !== true) {
      let isValid = false;
      const types2 = isArray2(type) ? type : [type];
      const expectedTypes = [];
      for (let i8 = 0; i8 < types2.length && !isValid; i8++) {
        const { valid, expectedType } = assertType(value, types2[i8]);
        expectedTypes.push(expectedType || "");
        isValid = valid;
      }
      if (!isValid) {
        warn3(getInvalidTypeMessage(name2, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value)) {
      warn3('Invalid prop: custom validator check failed for prop "' + name2 + '".');
    }
  }
  function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
      const t8 = typeof value;
      valid = t8 === expectedType.toLowerCase();
      if (!valid && t8 === "object") {
        valid = value instanceof type;
      }
    } else if (expectedType === "Object") {
      valid = isObject2(value);
    } else if (expectedType === "Array") {
      valid = isArray2(value);
    } else if (expectedType === "null") {
      valid = value === null;
    } else {
      valid = value instanceof type;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name2, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name2}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean2(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value, type) {
    if (type === "String") {
      return `"${value}"`;
    } else if (type === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type.toLowerCase() === elem);
  }
  function isBoolean2(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  function createAppAPI(render2, hydrate2) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction2(rootComponent)) {
        rootComponent = Object.assign({}, rootComponent);
      }
      if (rootProps != null && !isObject2(rootProps)) {
        process.env.NODE_ENV !== "production" && warn3(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context2 = createAppContext();
      const installedPlugins = /* @__PURE__ */ new Set();
      let isMounted = false;
      const app = context2.app = {
        _uid: uid++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context2,
        _instance: null,
        version: version2,
        get config() {
          return context2.config;
        },
        set config(v3) {
          if (process.env.NODE_ENV !== "production") {
            warn3(`app.config cannot be replaced. Modify individual options instead.`);
          }
        },
        use(plugin, ...options2) {
          if (installedPlugins.has(plugin)) {
            process.env.NODE_ENV !== "production" && warn3(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction2(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options2);
          } else if (isFunction2(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options2);
          } else if (process.env.NODE_ENV !== "production") {
            warn3(`A plugin must either be a function or an object with an "install" function.`);
          }
          return app;
        },
        mixin(mixin) {
          if (__VUE_OPTIONS_API__) {
            if (!context2.mixins.includes(mixin)) {
              context2.mixins.push(mixin);
            } else if (process.env.NODE_ENV !== "production") {
              warn3("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
            }
          } else if (process.env.NODE_ENV !== "production") {
            warn3("Mixins are only available in builds supporting Options API");
          }
          return app;
        },
        component(name2, component) {
          if (process.env.NODE_ENV !== "production") {
            validateComponentName(name2, context2.config);
          }
          if (!component) {
            return context2.components[name2];
          }
          if (process.env.NODE_ENV !== "production" && context2.components[name2]) {
            warn3(`Component "${name2}" has already been registered in target app.`);
          }
          context2.components[name2] = component;
          return app;
        },
        directive(name2, directive) {
          if (process.env.NODE_ENV !== "production") {
            validateDirectiveName(name2);
          }
          if (!directive) {
            return context2.directives[name2];
          }
          if (process.env.NODE_ENV !== "production" && context2.directives[name2]) {
            warn3(`Directive "${name2}" has already been registered in target app.`);
          }
          context2.directives[name2] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, isSVG) {
          if (!isMounted) {
            if (process.env.NODE_ENV !== "production" && rootContainer.__vue_app__) {
              warn3(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
            }
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context2;
            if (process.env.NODE_ENV !== "production") {
              context2.reload = () => {
                render2(cloneVNode(vnode), rootContainer, isSVG);
              };
            }
            if (isHydrate && hydrate2) {
              hydrate2(vnode, rootContainer);
            } else {
              render2(vnode, rootContainer, isSVG);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
              app._instance = vnode.component;
              devtoolsInitApp(app, version2);
            }
            return getExposeProxy(vnode.component) || vnode.component.proxy;
          } else if (process.env.NODE_ENV !== "production") {
            warn3(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
          }
        },
        unmount() {
          if (isMounted) {
            render2(null, app._container);
            if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else if (process.env.NODE_ENV !== "production") {
            warn3(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key, value) {
          if (process.env.NODE_ENV !== "production" && key in context2.provides) {
            warn3(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
          }
          context2.provides[key] = value;
          return app;
        }
      };
      return app;
    };
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray2(rawRef)) {
      rawRef.forEach((r8, i8) => setRef(r8, oldRawRef && (isArray2(oldRawRef) ? oldRawRef[i8] : oldRawRef), parentSuspense, vnode, isUnmount));
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref5 } = rawRef;
    if (process.env.NODE_ENV !== "production" && !owner) {
      warn3(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref5) {
      if (isString2(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction2(ref5)) {
      callWithErrorHandling(ref5, owner, 12, [value, refs]);
    } else {
      const _isString = isString2(ref5);
      const _isRef = isRef(ref5);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? refs[ref5] : ref5.value;
            if (isUnmount) {
              isArray2(existing) && remove(existing, refValue);
            } else {
              if (!isArray2(existing)) {
                if (_isString) {
                  refs[ref5] = [refValue];
                  if (hasOwn(setupState, ref5)) {
                    setupState[ref5] = refs[ref5];
                  }
                } else {
                  ref5.value = [refValue];
                  if (rawRef.k)
                    refs[rawRef.k] = ref5.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref5] = value;
            if (hasOwn(setupState, ref5)) {
              setupState[ref5] = value;
            }
          } else if (_isRef) {
            ref5.value = value;
            if (rawRef.k)
              refs[rawRef.k] = value;
          } else if (process.env.NODE_ENV !== "production") {
            warn3("Invalid template ref type:", ref5, `(${typeof ref5})`);
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else if (process.env.NODE_ENV !== "production") {
        warn3("Invalid template ref type:", ref5, `(${typeof ref5})`);
      }
    }
  }
  function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp: patchProp2, createText, nextSibling, parentNode, remove: remove2, insert, createComment } } = rendererInternals;
    const hydrate2 = (vnode, container) => {
      if (!container.hasChildNodes()) {
        process.env.NODE_ENV !== "production" && warn3(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
        patch(null, vnode, container);
        flushPostFlushCbs();
        container._vnode = vnode;
        return;
      }
      hasMismatch = false;
      hydrateNode(container.firstChild, vnode, null, null, null);
      flushPostFlushCbs();
      container._vnode = vnode;
      if (hasMismatch && true) {
        console.error(`Hydration completed but contains mismatches.`);
      }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
      const isFragmentStart = isComment(node) && node.data === "[";
      const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
      const { type, ref: ref5, shapeFlag, patchFlag } = vnode;
      const domType = node.nodeType;
      vnode.el = node;
      if (patchFlag === -2) {
        optimized = false;
        vnode.dynamicChildren = null;
      }
      let nextNode = null;
      switch (type) {
        case Text:
          if (domType !== 3) {
            if (vnode.children === "") {
              insert(vnode.el = createText(""), parentNode(node), node);
              nextNode = node;
            } else {
              nextNode = onMismatch();
            }
          } else {
            if (node.data !== vnode.children) {
              hasMismatch = true;
              process.env.NODE_ENV !== "production" && warn3(`Hydration text mismatch:
- Client: ${JSON.stringify(node.data)}
- Server: ${JSON.stringify(vnode.children)}`);
              node.data = vnode.children;
            }
            nextNode = nextSibling(node);
          }
          break;
        case Comment:
          if (domType !== 8 || isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = nextSibling(node);
          }
          break;
        case Static:
          if (domType !== 1 && domType !== 3) {
            nextNode = onMismatch();
          } else {
            nextNode = node;
            const needToAdoptContent = !vnode.children.length;
            for (let i8 = 0; i8 < vnode.staticCount; i8++) {
              if (needToAdoptContent)
                vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
              if (i8 === vnode.staticCount - 1) {
                vnode.anchor = nextNode;
              }
              nextNode = nextSibling(nextNode);
            }
            return nextNode;
          }
          break;
        case Fragment:
          if (!isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
          break;
        default:
          if (shapeFlag & 1) {
            if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
          } else if (shapeFlag & 6) {
            vnode.slotScopeIds = slotScopeIds;
            const container = parentNode(node);
            mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
            nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
            if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
              nextNode = nextSibling(nextNode);
            }
            if (isAsyncWrapper(vnode)) {
              let subTree;
              if (isFragmentStart) {
                subTree = createVNode(Fragment);
                subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
              } else {
                subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
              }
              subTree.el = node;
              vnode.component.subTree = subTree;
            }
          } else if (shapeFlag & 64) {
            if (domType !== 8) {
              nextNode = onMismatch();
            } else {
              nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
            }
          } else if (shapeFlag & 128) {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
          } else if (process.env.NODE_ENV !== "production") {
            warn3("Invalid HostVNode type:", type, `(${typeof type})`);
          }
      }
      if (ref5 != null) {
        setRef(ref5, null, parentSuspense, vnode);
      }
      return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!vnode.dynamicChildren;
      const { type, props, patchFlag, shapeFlag, dirs } = vnode;
      const forcePatchValue = type === "input" && dirs || type === "option";
      if (process.env.NODE_ENV !== "production" || forcePatchValue || patchFlag !== -1) {
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        if (props) {
          if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
            for (const key in props) {
              if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {
                patchProp2(el, key, null, props[key], false, void 0, parentComponent);
              }
            }
          } else if (props.onClick) {
            patchProp2(el, "onClick", null, props.onClick, false, void 0, parentComponent);
          }
        }
        let vnodeHooks;
        if (vnodeHooks = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHooks, parentComponent, vnode);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
          queueEffectWithSuspense(() => {
            vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
        if (shapeFlag & 16 && !(props && (props.innerHTML || props.textContent))) {
          let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
          let hasWarned2 = false;
          while (next) {
            hasMismatch = true;
            if (process.env.NODE_ENV !== "production" && !hasWarned2) {
              warn3(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
              hasWarned2 = true;
            }
            const cur = next;
            next = next.nextSibling;
            remove2(cur);
          }
        } else if (shapeFlag & 8) {
          if (el.textContent !== vnode.children) {
            hasMismatch = true;
            process.env.NODE_ENV !== "production" && warn3(`Hydration text content mismatch in <${vnode.type}>:
- Client: ${el.textContent}
- Server: ${vnode.children}`);
            el.textContent = vnode.children;
          }
        }
      }
      return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!parentVNode.dynamicChildren;
      const children = parentVNode.children;
      const l5 = children.length;
      let hasWarned2 = false;
      for (let i8 = 0; i8 < l5; i8++) {
        const vnode = optimized ? children[i8] : children[i8] = normalizeVNode(children[i8]);
        if (node) {
          node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        } else if (vnode.type === Text && !vnode.children) {
          continue;
        } else {
          hasMismatch = true;
          if (process.env.NODE_ENV !== "production" && !hasWarned2) {
            warn3(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
            hasWarned2 = true;
          }
          patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        }
      }
      return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      const { slotScopeIds: fragmentSlotScopeIds } = vnode;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      const container = parentNode(node);
      const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
      if (next && isComment(next) && next.data === "]") {
        return nextSibling(vnode.anchor = next);
      } else {
        hasMismatch = true;
        insert(vnode.anchor = createComment(`]`), container, next);
        return next;
      }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
      hasMismatch = true;
      process.env.NODE_ENV !== "production" && warn3(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node, node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``);
      vnode.el = null;
      if (isFragment) {
        const end = locateClosingAsyncAnchor(node);
        while (true) {
          const next2 = nextSibling(node);
          if (next2 && next2 !== end) {
            remove2(next2);
          } else {
            break;
          }
        }
      }
      const next = nextSibling(node);
      const container = parentNode(node);
      remove2(node);
      patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      return next;
    };
    const locateClosingAsyncAnchor = (node) => {
      let match = 0;
      while (node) {
        node = nextSibling(node);
        if (node && isComment(node)) {
          if (node.data === "[")
            match++;
          if (node.data === "]") {
            if (match === 0) {
              return nextSibling(node);
            } else {
              match--;
            }
          }
        }
      }
      return node;
    };
    return [hydrate2, hydrateNode];
  }
  function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported2()) {
      perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
      devtoolsPerfStart(instance, type, isSupported2() ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported2()) {
      const startTag = `vue-${type}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
      devtoolsPerfEnd(instance, type, isSupported2() ? perf.now() : Date.now());
    }
  }
  function isSupported2() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
      process.env.NODE_ENV !== "production" && needWarn.push(`__VUE_OPTIONS_API__`);
      getGlobalThis().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
      process.env.NODE_ENV !== "production" && needWarn.push(`__VUE_PROD_DEVTOOLS__`);
      getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (process.env.NODE_ENV !== "production" && needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
    }
  }
  function createRenderer(options2) {
    return baseCreateRenderer(options2);
  }
  function createHydrationRenderer(options2) {
    return baseCreateRenderer(options2, createHydrationFunctions);
  }
  function baseCreateRenderer(options2, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
      setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options2;
    const patch = (n1, n22, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = process.env.NODE_ENV !== "production" && isHmrUpdating ? false : !!n22.dynamicChildren) => {
      if (n1 === n22) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n22)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n22.patchFlag === -2) {
        optimized = false;
        n22.dynamicChildren = null;
      }
      const { type, ref: ref5, shapeFlag } = n22;
      switch (type) {
        case Text:
          processText(n1, n22, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n22, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n22, container, anchor, isSVG);
          } else if (process.env.NODE_ENV !== "production") {
            patchStaticNode(n1, n22, container, isSVG);
          }
          break;
        case Fragment:
          processFragment(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          break;
        default:
          if (shapeFlag & 1) {
            processElement(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 6) {
            processComponent(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 64) {
            type.process(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128) {
            type.process(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (process.env.NODE_ENV !== "production") {
            warn3("Invalid VNode type:", type, `(${typeof type})`);
          }
      }
      if (ref5 != null && parentComponent) {
        setRef(ref5, n1 && n1.ref, parentSuspense, n22 || n1, !n22);
      }
    };
    const processText = (n1, n22, container, anchor) => {
      if (n1 == null) {
        hostInsert(n22.el = hostCreateText(n22.children), container, anchor);
      } else {
        const el = n22.el = n1.el;
        if (n22.children !== n1.children) {
          hostSetText(el, n22.children);
        }
      }
    };
    const processCommentNode = (n1, n22, container, anchor) => {
      if (n1 == null) {
        hostInsert(n22.el = hostCreateComment(n22.children || ""), container, anchor);
      } else {
        n22.el = n1.el;
      }
    };
    const mountStaticNode = (n22, container, anchor, isSVG) => {
      [n22.el, n22.anchor] = hostInsertStaticContent(n22.children, container, anchor, isSVG, n22.el, n22.anchor);
    };
    const patchStaticNode = (n1, n22, container, isSVG) => {
      if (n22.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n22.el, n22.anchor] = hostInsertStaticContent(n22.children, container, anchor, isSVG);
      } else {
        n22.el = n1.el;
        n22.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      isSVG = isSVG || n22.type === "svg";
      if (n1 == null) {
        mountElement(n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        patchElement(n1, n22, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
      if (!(process.env.NODE_ENV !== "production") && vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
        el = vnode.el = hostCloneNode(vnode.el);
      } else {
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      }
      if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
        Object.defineProperty(el, "__vnode", {
          value: vnode,
          enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
          value: parentComponent,
          enumerable: false
        });
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i8 = 0; i8 < slotScopeIds.length; i8++) {
          hostSetScopeId(el, slotScopeIds[i8]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (process.env.NODE_ENV !== "production" && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start3 = 0) => {
      for (let i8 = start3; i8 < children.length; i8++) {
        const child = children[i8] = optimized ? cloneIfMounted(children[i8]) : normalizeVNode(children[i8]);
        patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const patchElement = (n1, n22, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const el = n22.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n22;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n22.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n22, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n22, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      const areChildrenSVG = isSVG && n22.type !== "foreignObject";
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
        if (process.env.NODE_ENV !== "production" && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n22);
        }
      } else if (!optimized) {
        patchChildren(n1, n22, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, n22, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, isSVG);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n22.dynamicProps;
            for (let i8 = 0; i8 < propsToUpdate.length; i8++) {
              const key = propsToUpdate[i8];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n22.children) {
            hostSetElementText(el, n22.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, n22, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n22, n1);
          dirs && invokeDirectiveHook(n22, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
      for (let i8 = 0; i8 < newChildren.length; i8++) {
        const oldVNode = oldChildren[i8];
        const newVNode = newChildren[i8];
        const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
        patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
      if (oldProps !== newProps) {
        for (const key in newProps) {
          if (isReservedProp(key))
            continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
      }
    };
    const processFragment = (n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n22.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n22.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n22;
      if (process.env.NODE_ENV !== "production" && (isHmrUpdating || patchFlag & 2048)) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(n22.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
          if (process.env.NODE_ENV !== "production" && parentComponent && parentComponent.type.__hmrId) {
            traverseStaticChildren(n1, n22);
          } else if (n22.key != null || parentComponent && n22 === parentComponent.subTree) {
            traverseStaticChildren(n1, n22, true);
          }
        } else {
          patchChildren(n1, n22, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    };
    const processComponent = (n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      n22.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n22.shapeFlag & 512) {
          parentComponent.ctx.activate(n22, container, anchor, isSVG, optimized);
        } else {
          mountComponent(n22, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
      } else {
        updateComponent(n1, n22, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
      const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
      if (process.env.NODE_ENV !== "production" && instance.type.__hmrId) {
        registerHMR(instance);
      }
      if (process.env.NODE_ENV !== "production") {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance, `init`);
        }
        setupComponent(instance);
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
        return;
      }
      setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
      if (process.env.NODE_ENV !== "production") {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n22, optimized) => {
      const instance = n22.component = n1.component;
      if (shouldUpdateComponent(n1, n22, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          if (process.env.NODE_ENV !== "production") {
            pushWarningContext(n22);
          }
          updateComponentPreRender(instance, n22, optimized);
          if (process.env.NODE_ENV !== "production") {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n22;
          invalidateJob(instance.update);
          instance.update();
        }
      } else {
        n22.el = n1.el;
        instance.vnode = n22;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m: m3, parent } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              if (process.env.NODE_ENV !== "production") {
                startMeasure(instance, `render`);
              }
              instance.subTree = renderComponentRoot(instance);
              if (process.env.NODE_ENV !== "production") {
                endMeasure(instance, `render`);
              }
              if (process.env.NODE_ENV !== "production") {
                startMeasure(instance, `hydrate`);
              }
              hydrateNode(el, instance.subTree, instance, parentSuspense, null);
              if (process.env.NODE_ENV !== "production") {
                endMeasure(instance, `hydrate`);
              }
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
            } else {
              hydrateSubTree();
            }
          } else {
            if (process.env.NODE_ENV !== "production") {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            if (process.env.NODE_ENV !== "production") {
              endMeasure(instance, `render`);
            }
            if (process.env.NODE_ENV !== "production") {
              startMeasure(instance, `patch`);
            }
            patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
            if (process.env.NODE_ENV !== "production") {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m3) {
            queuePostRenderEffect(m3, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u: u7, parent, vnode } = instance;
          let originNext = next;
          let vnodeHook;
          if (process.env.NODE_ENV !== "production") {
            pushWarningContext(next || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          if (process.env.NODE_ENV !== "production") {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          if (process.env.NODE_ENV !== "production") {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          if (process.env.NODE_ENV !== "production") {
            startMeasure(instance, `patch`);
          }
          patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
          if (process.env.NODE_ENV !== "production") {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u7) {
            queuePostRenderEffect(u7, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
          }
          if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
            devtoolsComponentUpdated(instance);
          }
          if (process.env.NODE_ENV !== "production") {
            popWarningContext();
          }
        }
      };
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope);
      const update = instance.update = () => effect2.run();
      update.id = instance.uid;
      toggleRecurse(instance, true);
      if (process.env.NODE_ENV !== "production") {
        effect2.onTrack = instance.rtc ? (e8) => invokeArrayFns(instance.rtc, e8) : void 0;
        effect2.onTrigger = instance.rtg ? (e8) => invokeArrayFns(instance.rtg, e8) : void 0;
        update.ownerInstance = instance;
      }
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(void 0, instance.update);
      resetTracking();
    };
    const patchChildren = (n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c22 = n22.children;
      const { patchFlag, shapeFlag } = n22;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(c1, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(c1, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c22 !== c1) {
          hostSetElementText(container, c22);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(c1, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c22 = c22 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c22.length;
      const commonLength = Math.min(oldLength, newLength);
      let i8;
      for (i8 = 0; i8 < commonLength; i8++) {
        const nextChild = c22[i8] = optimized ? cloneIfMounted(c22[i8]) : normalizeVNode(c22[i8]);
        patch(c1[i8], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
      if (oldLength > newLength) {
        unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
      } else {
        mountChildren(c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
      }
    };
    const patchKeyedChildren = (c1, c22, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let i8 = 0;
      const l22 = c22.length;
      let e1 = c1.length - 1;
      let e22 = l22 - 1;
      while (i8 <= e1 && i8 <= e22) {
        const n1 = c1[i8];
        const n22 = c22[i8] = optimized ? cloneIfMounted(c22[i8]) : normalizeVNode(c22[i8]);
        if (isSameVNodeType(n1, n22)) {
          patch(n1, n22, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        i8++;
      }
      while (i8 <= e1 && i8 <= e22) {
        const n1 = c1[e1];
        const n22 = c22[e22] = optimized ? cloneIfMounted(c22[e22]) : normalizeVNode(c22[e22]);
        if (isSameVNodeType(n1, n22)) {
          patch(n1, n22, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        e1--;
        e22--;
      }
      if (i8 > e1) {
        if (i8 <= e22) {
          const nextPos = e22 + 1;
          const anchor = nextPos < l22 ? c22[nextPos].el : parentAnchor;
          while (i8 <= e22) {
            patch(null, c22[i8] = optimized ? cloneIfMounted(c22[i8]) : normalizeVNode(c22[i8]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            i8++;
          }
        }
      } else if (i8 > e22) {
        while (i8 <= e1) {
          unmount(c1[i8], parentComponent, parentSuspense, true);
          i8++;
        }
      } else {
        const s1 = i8;
        const s22 = i8;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i8 = s22; i8 <= e22; i8++) {
          const nextChild = c22[i8] = optimized ? cloneIfMounted(c22[i8]) : normalizeVNode(c22[i8]);
          if (nextChild.key != null) {
            if (process.env.NODE_ENV !== "production" && keyToNewIndexMap.has(nextChild.key)) {
              warn3(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
            }
            keyToNewIndexMap.set(nextChild.key, i8);
          }
        }
        let j2;
        let patched = 0;
        const toBePatched = e22 - s22 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i8 = 0; i8 < toBePatched; i8++)
          newIndexToOldIndexMap[i8] = 0;
        for (i8 = s1; i8 <= e1; i8++) {
          const prevChild = c1[i8];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j2 = s22; j2 <= e22; j2++) {
              if (newIndexToOldIndexMap[j2 - s22] === 0 && isSameVNodeType(prevChild, c22[j2])) {
                newIndex = j2;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s22] = i8 + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(prevChild, c22[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j2 = increasingNewIndexSequence.length - 1;
        for (i8 = toBePatched - 1; i8 >= 0; i8--) {
          const nextIndex = s22 + i8;
          const nextChild = c22[nextIndex];
          const anchor = nextIndex + 1 < l22 ? c22[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i8] === 0) {
            patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (moved) {
            if (j2 < 0 || i8 !== increasingNewIndexSequence[j2]) {
              move(nextChild, container, anchor, 2);
            } else {
              j2--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i8 = 0; i8 < children.length; i8++) {
          move(children[i8], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove3 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove3();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove3, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const { type, props, ref: ref5, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
      if (ref5 != null) {
        setRef(ref5, null, parentSuspense, vnode, true);
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
        } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        if (process.env.NODE_ENV !== "production" && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach((child) => {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove2(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (process.env.NODE_ENV !== "production" && instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope, update, subTree, um } = instance;
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update) {
        update.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start3 = 0) => {
      for (let i8 = start3; i8 < children.length; i8++) {
        unmount(children[i8], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render2 = (vnode, container, isSVG) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(container._vnode || null, vnode, container, null, null, null, isSVG);
      }
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options2
    };
    let hydrate2;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate2, hydrateNode] = createHydrationFns(internals);
    }
    return {
      render: render2,
      hydrate: hydrate2,
      createApp: createAppAPI(render2, hydrate2)
    };
  }
  function toggleRecurse({ effect: effect2, update }, allowed) {
    effect2.allowRecurse = update.allowRecurse = allowed;
  }
  function traverseStaticChildren(n1, n22, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n22.children;
    if (isArray2(ch1) && isArray2(ch2)) {
      for (let i8 = 0; i8 < ch1.length; i8++) {
        const c1 = ch1[i8];
        let c22 = ch2[i8];
        if (c22.shapeFlag & 1 && !c22.dynamicChildren) {
          if (c22.patchFlag <= 0 || c22.patchFlag === 32) {
            c22 = ch2[i8] = cloneIfMounted(ch2[i8]);
            c22.el = c1.el;
          }
          if (!shallow)
            traverseStaticChildren(c1, c22);
        }
        if (process.env.NODE_ENV !== "production" && c22.type === Comment && !c22.el) {
          c22.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p6 = arr.slice();
    const result = [0];
    let i8, j2, u7, v3, c6;
    const len = arr.length;
    for (i8 = 0; i8 < len; i8++) {
      const arrI = arr[i8];
      if (arrI !== 0) {
        j2 = result[result.length - 1];
        if (arr[j2] < arrI) {
          p6[i8] = j2;
          result.push(i8);
          continue;
        }
        u7 = 0;
        v3 = result.length - 1;
        while (u7 < v3) {
          c6 = u7 + v3 >> 1;
          if (arr[result[c6]] < arrI) {
            u7 = c6 + 1;
          } else {
            v3 = c6;
          }
        }
        if (arrI < arr[result[u7]]) {
          if (u7 > 0) {
            p6[i8] = result[u7 - 1];
          }
          result[u7] = i8;
        }
      }
    }
    u7 = result.length;
    v3 = result[u7 - 1];
    while (u7-- > 0) {
      result[u7] = v3;
      v3 = p6[v3];
    }
    return result;
  }
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i8 = 0; i8 < children.length; i8++) {
          move(children[i8], container, parentAnchor, 2);
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            targetAnchor = nextSibling(targetAnchor);
            if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
      }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n22) {
    if (process.env.NODE_ENV !== "production" && n22.shapeFlag & 6 && hmrDirtyComponents.has(n22.type)) {
      return false;
    }
    return n1.type === n22.type && n1.key === n22.key;
  }
  function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
  }
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString2(children) ? 8 : 16;
    }
    if (process.env.NODE_ENV !== "production" && vnode.key !== vnode.key) {
      warn3(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      if (process.env.NODE_ENV !== "production" && !type) {
        warn3(`Invalid vnode type when creating vnode: ${type}.`);
      }
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(type, props, true);
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag |= -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString2(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject2(style)) {
        if (isProxy(style) && !isArray2(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject2(type) ? 4 : isFunction2(type) ? 2 : 0;
    if (process.env.NODE_ENV !== "production" && shapeFlag & 4 && isProxy(type)) {
      type = toRaw(type);
      warn3(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref: ref5, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? mergeRef && ref5 ? isArray2(ref5) ? ref5.concat(normalizeRef(extraProps)) : [ref5, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref5,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: process.env.NODE_ENV !== "production" && patchFlag === -1 && isArray2(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: vnode.transition,
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor
    };
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray2(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray2(child)) {
      return createVNode(Fragment, null, child.slice());
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray2(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !(InternalObjectKey in children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction2(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i8 = 0; i8 < args.length; i8++) {
      const toMerge = args[i8];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray2(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid$1++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new EffectScope(true),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: type.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    if (process.env.NODE_ENV !== "production") {
      instance.ctx = createDevRenderContext(instance);
    } else {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$1.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  function validateComponentName(name2, config) {
    const appIsNativeTag = config.isNativeTag || NO;
    if (isBuiltInTag(name2) || appIsNativeTag(name2)) {
      warn3("Do not use built-in or reserved HTML elements as component id: " + name2);
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a3;
    const Component = instance.type;
    if (process.env.NODE_ENV !== "production") {
      if (Component.name) {
        validateComponentName(Component.name, instance.appContext.config);
      }
      if (Component.components) {
        const names5 = Object.keys(Component.components);
        for (let i8 = 0; i8 < names5.length; i8++) {
          validateComponentName(names5[i8], instance.appContext.config);
        }
      }
      if (Component.directives) {
        const names5 = Object.keys(Component.directives);
        for (let i8 = 0; i8 < names5.length; i8++) {
          validateDirectiveName(names5[i8]);
        }
      }
      if (Component.compilerOptions && isRuntimeOnly()) {
        warn3(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
      }
    }
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if (process.env.NODE_ENV !== "production") {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(setup, instance, 0, [process.env.NODE_ENV !== "production" ? shallowReadonly(instance.props) : instance.props, setupContext]);
      resetTracking();
      unsetCurrentInstance();
      if (isPromise(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e8) => {
            handleError(e8, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (process.env.NODE_ENV !== "production" && !instance.suspense) {
            const name2 = (_a3 = Component.name) !== null && _a3 !== void 0 ? _a3 : "Anonymous";
            warn3(`Component <${name2}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction2(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject2(setupResult)) {
      if (process.env.NODE_ENV !== "production" && isVNode(setupResult)) {
        warn3(`setup() should not return VNodes directly - return a render function instead.`);
      }
      if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      if (process.env.NODE_ENV !== "production") {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (process.env.NODE_ENV !== "production" && setupResult !== void 0) {
      warn3(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
  }
  function registerRuntimeCompiler(_compile) {
    compile2 = _compile;
    installWithProxy = (i8) => {
      if (i8.render._rc) {
        i8.withProxy = new Proxy(i8.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
      }
    };
  }
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile2 && !Component.render) {
        const template = Component.template;
        if (template) {
          if (process.env.NODE_ENV !== "production") {
            startMeasure(instance, `compile`);
          }
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend(extend({
            isCustomElement,
            delimiters
          }, compilerOptions), componentCompilerOptions);
          Component.render = compile2(template, finalCompilerOptions);
          if (process.env.NODE_ENV !== "production") {
            endMeasure(instance, `compile`);
          }
        }
      }
      instance.render = Component.render || NOOP;
      if (installWithProxy) {
        installWithProxy(instance);
      }
    }
    if (__VUE_OPTIONS_API__ && true) {
      setCurrentInstance(instance);
      pauseTracking();
      applyOptions(instance);
      resetTracking();
      unsetCurrentInstance();
    }
    if (process.env.NODE_ENV !== "production" && !Component.render && instance.render === NOOP && !isSSR) {
      if (!compile2 && Component.template) {
        warn3(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
      } else {
        warn3(`Component is missing template or render function.`);
      }
    }
  }
  function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, process.env.NODE_ENV !== "production" ? {
      get(target, key) {
        markAttrsAccessed();
        track(instance, "get", "$attrs");
        return target[key];
      },
      set() {
        warn3(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn3(`setupContext.attrs is readonly.`);
        return false;
      }
    } : {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    });
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      if (process.env.NODE_ENV !== "production" && instance.exposed) {
        warn3(`expose() should be called only once per setup().`);
      }
      instance.exposed = exposed || {};
    };
    let attrs;
    if (process.env.NODE_ENV !== "production") {
      return Object.freeze({
        get attrs() {
          return attrs || (attrs = createAttrsProxy(instance));
        },
        get slots() {
          return shallowReadonly(instance.slots);
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    } else {
      return {
        get attrs() {
          return attrs || (attrs = createAttrsProxy(instance));
        },
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getExposeProxy(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        }
      }));
    }
  }
  function getComponentName(Component, includeInferred = true) {
    return isFunction2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name2 = getComponentName(Component);
    if (!name2 && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name2 = match[1];
      }
    }
    if (!name2 && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name2 = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction2(value) && "__vccOpts" in value;
  }
  function defineProps() {
    if (process.env.NODE_ENV !== "production") {
      warnRuntimeUsage(`defineProps`);
    }
    return null;
  }
  function defineEmits() {
    if (process.env.NODE_ENV !== "production") {
      warnRuntimeUsage(`defineEmits`);
    }
    return null;
  }
  function defineExpose(exposed) {
    if (process.env.NODE_ENV !== "production") {
      warnRuntimeUsage(`defineExpose`);
    }
  }
  function withDefaults(props, defaults) {
    if (process.env.NODE_ENV !== "production") {
      warnRuntimeUsage(`withDefaults`);
    }
    return null;
  }
  function useSlots() {
    return getContext2().slots;
  }
  function useAttrs() {
    return getContext2().attrs;
  }
  function getContext2() {
    const i8 = getCurrentInstance();
    if (process.env.NODE_ENV !== "production" && !i8) {
      warn3(`useContext() called without active instance.`);
    }
    return i8.setupContext || (i8.setupContext = createSetupContext(i8));
  }
  function mergeDefaults(raw, defaults) {
    const props = isArray2(raw) ? raw.reduce((normalized, p6) => (normalized[p6] = {}, normalized), {}) : raw;
    for (const key in defaults) {
      const opt = props[key];
      if (opt) {
        if (isArray2(opt) || isFunction2(opt)) {
          props[key] = { type: opt, default: defaults[key] };
        } else {
          opt.default = defaults[key];
        }
      } else if (opt === null) {
        props[key] = { default: defaults[key] };
      } else if (process.env.NODE_ENV !== "production") {
        warn3(`props default key "${key}" has no corresponding declaration.`);
      }
    }
    return props;
  }
  function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
      if (!excludedKeys.includes(key)) {
        Object.defineProperty(ret, key, {
          enumerable: true,
          get: () => props[key]
        });
      }
    }
    return ret;
  }
  function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (process.env.NODE_ENV !== "production" && !ctx) {
      warn3(`withAsyncContext called without active current instance. This is likely a bug.`);
    }
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if (isPromise(awaitable)) {
      awaitable = awaitable.catch((e8) => {
        setCurrentInstance(ctx);
        throw e8;
      });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
  }
  function h(type, propsOrChildren, children) {
    const l5 = arguments.length;
    if (l5 === 2) {
      if (isObject2(propsOrChildren) && !isArray2(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l5 > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l5 === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  function isShallow2(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function initCustomFormatter() {
    if (!(process.env.NODE_ENV !== "production") || typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#0b1bc9" };
    const stringStyle = { style: "color:#b62e24" };
    const keywordStyle = { style: "color:#9d288c" };
    const formatter = {
      header(obj) {
        if (!isObject2(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            formatValue(obj.value),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow2(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow2(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed7 = extractKeys(instance, "computed");
      if (computed7) {
        blocks.push(createInstanceBlock("computed", computed7));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v3, asRaw = true) {
      if (typeof v3 === "number") {
        return ["span", numberStyle, v3];
      } else if (typeof v3 === "string") {
        return ["span", stringStyle, JSON.stringify(v3)];
      } else if (typeof v3 === "boolean") {
        return ["span", keywordStyle, v3];
      } else if (isObject2(v3)) {
        return ["object", { object: asRaw ? toRaw(v3) : v3 }];
      } else {
        return ["span", stringStyle, String(v3)];
      }
    }
    function extractKeys(instance, type) {
      const Comp = instance.type;
      if (isFunction2(Comp)) {
        return;
      }
      const extracted = {};
      for (const key in instance.ctx) {
        if (isKeyOfType(Comp, key, type)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type) {
      const opts = Comp[type];
      if (isArray2(opts) && opts.includes(key) || isObject2(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m3) => isKeyOfType(m3, key, type))) {
        return true;
      }
    }
    function genRefFlag(v3) {
      if (isShallow2(v3)) {
        return `ShallowRef`;
      }
      if (v3.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  function withMemo(memo, render2, cache4, index15) {
    const cached = cache4[index15];
    if (cached && isMemoSame(cached, memo)) {
      return cached;
    }
    const ret = render2();
    ret.memo = memo.slice();
    return cache4[index15] = ret;
  }
  function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
      return false;
    }
    for (let i8 = 0; i8 < prev.length; i8++) {
      if (hasChanged(prev[i8], memo[i8])) {
        return false;
      }
    }
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(cached);
    }
    return true;
  }
  var stack, ErrorTypeStrings, isFlushing, isFlushPending, queue, flushIndex, pendingPreFlushCbs, activePreFlushCbs, preFlushIndex, pendingPostFlushCbs, activePostFlushCbs, postFlushIndex, resolvedPromise, currentFlushPromise, currentPreFlushParentJob, RECURSION_LIMIT, getId, isHmrUpdating, hmrDirtyComponents, map, devtools, buffer, devtoolsNotInstalled, devtoolsComponentAdded, devtoolsComponentUpdated, devtoolsComponentRemoved, devtoolsPerfStart, devtoolsPerfEnd, currentRenderingInstance, currentScopeId, withScopeId, accessedAttrs, getChildRoot, getFunctionalFallthrough, filterModelListeners, isElementRoot, isSuspense, SuspenseImpl, Suspense, hasWarned, INITIAL_WATCHER_VALUE, TransitionHookValidator, BaseTransitionImpl, BaseTransition, isAsyncWrapper, isKeepAlive, KeepAliveImpl, KeepAlive, createHook, onBeforeMount, onMounted2, onBeforeUpdate, onUpdated, onBeforeUnmount2, onUnmounted, onServerPrefetch, onRenderTriggered, onRenderTracked, COMPONENTS, DIRECTIVES, NULL_DYNAMIC_COMPONENT, getPublicInstance, publicPropertiesMap, isReservedPrefix, PublicInstanceProxyHandlers, RuntimeCompiledPublicInstanceProxyHandlers, shouldCacheAccess, internalOptionMergeStrats, isSimpleType, isInternalKey, normalizeSlotValue, normalizeSlot, normalizeObjectSlots, normalizeVNodeSlots, initSlots, updateSlots, uid, hasMismatch, isSVGContainer, isComment, supported, perf, queuePostRenderEffect, isTeleport, isTeleportDisabled, isTargetSVG, resolveTarget, TeleportImpl, Teleport, Fragment, Text, Comment, Static, blockStack, currentBlock, isBlockTreeEnabled, vnodeArgsTransformer, createVNodeWithArgsTransform, InternalObjectKey, normalizeKey, normalizeRef, createVNode, emptyAppContext, uid$1, currentInstance, getCurrentInstance, setCurrentInstance, unsetCurrentInstance, isBuiltInTag, isInSSRComponentSetup, compile2, installWithProxy, isRuntimeOnly, classifyRE, classify, computed3, warnRuntimeUsage, ssrContextKey, useSSRContext, version2, _ssrUtils, ssrUtils, resolveFilter, compatUtils;
  var init_runtime_core_esm_bundler = __esm({
    "node_modules/.pnpm/@vue+runtime-core@3.2.37/node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js"() {
      init_reactivity_esm_bundler();
      init_reactivity_esm_bundler();
      init_shared_esm_bundler();
      init_shared_esm_bundler();
      stack = [];
      ErrorTypeStrings = {
        ["sp"]: "serverPrefetch hook",
        ["bc"]: "beforeCreate hook",
        ["c"]: "created hook",
        ["bm"]: "beforeMount hook",
        ["m"]: "mounted hook",
        ["bu"]: "beforeUpdate hook",
        ["u"]: "updated",
        ["bum"]: "beforeUnmount hook",
        ["um"]: "unmounted hook",
        ["a"]: "activated hook",
        ["da"]: "deactivated hook",
        ["ec"]: "errorCaptured hook",
        ["rtc"]: "renderTracked hook",
        ["rtg"]: "renderTriggered hook",
        [0]: "setup function",
        [1]: "render function",
        [2]: "watcher getter",
        [3]: "watcher callback",
        [4]: "watcher cleanup function",
        [5]: "native event handler",
        [6]: "component event handler",
        [7]: "vnode hook",
        [8]: "directive hook",
        [9]: "transition hook",
        [10]: "app errorHandler",
        [11]: "app warnHandler",
        [12]: "ref function",
        [13]: "async component loader",
        [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
      };
      isFlushing = false;
      isFlushPending = false;
      queue = [];
      flushIndex = 0;
      pendingPreFlushCbs = [];
      activePreFlushCbs = null;
      preFlushIndex = 0;
      pendingPostFlushCbs = [];
      activePostFlushCbs = null;
      postFlushIndex = 0;
      resolvedPromise = /* @__PURE__ */ Promise.resolve();
      currentFlushPromise = null;
      currentPreFlushParentJob = null;
      RECURSION_LIMIT = 100;
      getId = (job) => job.id == null ? Infinity : job.id;
      isHmrUpdating = false;
      hmrDirtyComponents = /* @__PURE__ */ new Set();
      if (process.env.NODE_ENV !== "production") {
        getGlobalThis().__VUE_HMR_RUNTIME__ = {
          createRecord: tryWrap(createRecord),
          rerender: tryWrap(rerender),
          reload: tryWrap(reload)
        };
      }
      map = /* @__PURE__ */ new Map();
      buffer = [];
      devtoolsNotInstalled = false;
      devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
      devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
      devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed");
      devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
      devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
      currentRenderingInstance = null;
      currentScopeId = null;
      withScopeId = (_id) => withCtx;
      accessedAttrs = false;
      getChildRoot = (vnode) => {
        const rawChildren = vnode.children;
        const dynamicChildren = vnode.dynamicChildren;
        const childRoot = filterSingleRoot(rawChildren);
        if (!childRoot) {
          return [vnode, void 0];
        }
        const index15 = rawChildren.indexOf(childRoot);
        const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
        const setRoot = (updatedRoot) => {
          rawChildren[index15] = updatedRoot;
          if (dynamicChildren) {
            if (dynamicIndex > -1) {
              dynamicChildren[dynamicIndex] = updatedRoot;
            } else if (updatedRoot.patchFlag > 0) {
              vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
          }
        };
        return [normalizeVNode(childRoot), setRoot];
      };
      getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      filterModelListeners = (attrs, props) => {
        const res = {};
        for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      isElementRoot = (vnode) => {
        return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
      };
      isSuspense = (type) => type.__isSuspense;
      SuspenseImpl = {
        name: "Suspense",
        __isSuspense: true,
        process(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
          if (n1 == null) {
            mountSuspense(n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
          } else {
            patchSuspense(n1, n22, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
          }
        },
        hydrate: hydrateSuspense,
        create: createSuspenseBoundary,
        normalize: normalizeSuspenseChildren
      };
      Suspense = SuspenseImpl;
      hasWarned = false;
      INITIAL_WATCHER_VALUE = {};
      TransitionHookValidator = [Function, Array];
      BaseTransitionImpl = {
        name: `BaseTransition`,
        props: {
          mode: String,
          appear: Boolean,
          persisted: Boolean,
          onBeforeEnter: TransitionHookValidator,
          onEnter: TransitionHookValidator,
          onAfterEnter: TransitionHookValidator,
          onEnterCancelled: TransitionHookValidator,
          onBeforeLeave: TransitionHookValidator,
          onLeave: TransitionHookValidator,
          onAfterLeave: TransitionHookValidator,
          onLeaveCancelled: TransitionHookValidator,
          onBeforeAppear: TransitionHookValidator,
          onAppear: TransitionHookValidator,
          onAfterAppear: TransitionHookValidator,
          onAppearCancelled: TransitionHookValidator
        },
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevTransitionKey;
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            let child = children[0];
            if (children.length > 1) {
              let hasFound = false;
              for (const c6 of children) {
                if (c6.type !== Comment) {
                  if (process.env.NODE_ENV !== "production" && hasFound) {
                    warn3("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                    break;
                  }
                  child = c6;
                  hasFound = true;
                  if (!(process.env.NODE_ENV !== "production"))
                    break;
                }
              }
            }
            const rawProps = toRaw(props);
            const { mode: mode2 } = rawProps;
            if (process.env.NODE_ENV !== "production" && mode2 && mode2 !== "in-out" && mode2 !== "out-in" && mode2 !== "default") {
              warn3(`invalid <transition> mode: ${mode2}`);
            }
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
              const key = getTransitionKey();
              if (prevTransitionKey === void 0) {
                prevTransitionKey = key;
              } else if (key !== prevTransitionKey) {
                prevTransitionKey = key;
                transitionKeyChanged = true;
              }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
              const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode2 === "out-in") {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  instance.update();
                };
                return emptyPlaceholder(child);
              } else if (mode2 === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el._leaveCb = () => {
                    earlyRemove();
                    el._leaveCb = void 0;
                    delete enterHooks.delayedLeave;
                  };
                  enterHooks.delayedLeave = delayedLeave;
                };
              }
            }
            return child;
          };
        }
      };
      BaseTransition = BaseTransitionImpl;
      isAsyncWrapper = (i8) => !!i8.type.__asyncLoader;
      isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      KeepAliveImpl = {
        name: `KeepAlive`,
        __isKeepAlive: true,
        props: {
          include: [String, RegExp, Array],
          exclude: [String, RegExp, Array],
          max: [String, Number]
        },
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const sharedContext = instance.ctx;
          if (!sharedContext.renderer) {
            return () => {
              const children = slots.default && slots.default();
              return children && children.length === 1 ? children[0] : children;
            };
          }
          const cache4 = /* @__PURE__ */ new Map();
          const keys3 = /* @__PURE__ */ new Set();
          let current = null;
          if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
            instance.__v_cache = cache4;
          }
          const parentSuspense = instance.suspense;
          const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
          const storageContainer = createElement("div");
          sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
              instance2.isDeactivated = false;
              if (instance2.a) {
                invokeArrayFns(instance2.a);
              }
              const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
              if (vnodeHook) {
                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
              }
            }, parentSuspense);
            if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
              devtoolsComponentAdded(instance2);
            }
          };
          sharedContext.deactivate = (vnode) => {
            const instance2 = vnode.component;
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(() => {
              if (instance2.da) {
                invokeArrayFns(instance2.da);
              }
              const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
              if (vnodeHook) {
                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
              }
              instance2.isDeactivated = true;
            }, parentSuspense);
            if (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) {
              devtoolsComponentAdded(instance2);
            }
          };
          function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
          }
          function pruneCache(filter2) {
            cache4.forEach((vnode, key) => {
              const name2 = getComponentName(vnode.type);
              if (name2 && (!filter2 || !filter2(name2))) {
                pruneCacheEntry(key);
              }
            });
          }
          function pruneCacheEntry(key) {
            const cached = cache4.get(key);
            if (!current || cached.type !== current.type) {
              unmount(cached);
            } else if (current) {
              resetShapeFlag(current);
            }
            cache4.delete(key);
            keys3.delete(key);
          }
          watch2(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache((name2) => matches(include, name2));
            exclude && pruneCache((name2) => !matches(exclude, name2));
          }, { flush: "post", deep: true });
          let pendingCacheKey = null;
          const cacheSubtree = () => {
            if (pendingCacheKey != null) {
              cache4.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
          };
          onMounted2(cacheSubtree);
          onUpdated(cacheSubtree);
          onBeforeUnmount2(() => {
            cache4.forEach((cached) => {
              const { subTree, suspense } = instance;
              const vnode = getInnerChild(subTree);
              if (cached.type === vnode.type) {
                resetShapeFlag(vnode);
                const da = vnode.component.da;
                da && queuePostRenderEffect(da, suspense);
                return;
              }
              unmount(cached);
            });
          });
          return () => {
            pendingCacheKey = null;
            if (!slots.default) {
              return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
              if (process.env.NODE_ENV !== "production") {
                warn3(`KeepAlive should contain exactly one component child.`);
              }
              current = null;
              return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
              current = null;
              return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name2 = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
            const { include, exclude, max } = props;
            if (include && (!name2 || !matches(include, name2)) || exclude && name2 && matches(exclude, name2)) {
              current = vnode;
              return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache4.get(key);
            if (vnode.el) {
              vnode = cloneVNode(vnode);
              if (rawVNode.shapeFlag & 128) {
                rawVNode.ssContent = vnode;
              }
            }
            pendingCacheKey = key;
            if (cachedVNode) {
              vnode.el = cachedVNode.el;
              vnode.component = cachedVNode.component;
              if (vnode.transition) {
                setTransitionHooks(vnode, vnode.transition);
              }
              vnode.shapeFlag |= 512;
              keys3.delete(key);
              keys3.add(key);
            } else {
              keys3.add(key);
              if (max && keys3.size > parseInt(max, 10)) {
                pruneCacheEntry(keys3.values().next().value);
              }
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
          };
        }
      };
      KeepAlive = KeepAliveImpl;
      createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
      onBeforeMount = createHook("bm");
      onMounted2 = createHook("m");
      onBeforeUpdate = createHook("bu");
      onUpdated = createHook("u");
      onBeforeUnmount2 = createHook("bum");
      onUnmounted = createHook("um");
      onServerPrefetch = createHook("sp");
      onRenderTriggered = createHook("rtg");
      onRenderTracked = createHook("rtc");
      COMPONENTS = "components";
      DIRECTIVES = "directives";
      NULL_DYNAMIC_COMPONENT = Symbol();
      getPublicInstance = (i8) => {
        if (!i8)
          return null;
        if (isStatefulComponent(i8))
          return getExposeProxy(i8) || i8.proxy;
        return getPublicInstance(i8.parent);
      };
      publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i8) => i8,
        $el: (i8) => i8.vnode.el,
        $data: (i8) => i8.data,
        $props: (i8) => process.env.NODE_ENV !== "production" ? shallowReadonly(i8.props) : i8.props,
        $attrs: (i8) => process.env.NODE_ENV !== "production" ? shallowReadonly(i8.attrs) : i8.attrs,
        $slots: (i8) => process.env.NODE_ENV !== "production" ? shallowReadonly(i8.slots) : i8.slots,
        $refs: (i8) => process.env.NODE_ENV !== "production" ? shallowReadonly(i8.refs) : i8.refs,
        $parent: (i8) => getPublicInstance(i8.parent),
        $root: (i8) => getPublicInstance(i8.root),
        $emit: (i8) => i8.emit,
        $options: (i8) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i8) : i8.type,
        $forceUpdate: (i8) => i8.f || (i8.f = () => queueJob(i8.update)),
        $nextTick: (i8) => i8.n || (i8.n = nextTick2.bind(i8.proxy)),
        $watch: (i8) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i8) : NOOP
      });
      isReservedPrefix = (key) => key === "_" || key === "$";
      PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
          if (process.env.NODE_ENV !== "production" && key === "__isVue") {
            return true;
          }
          if (process.env.NODE_ENV !== "production" && setupState !== EMPTY_OBJ && setupState.__isScriptSetup && hasOwn(setupState, key)) {
            return setupState[key];
          }
          let normalizedProps;
          if (key[0] !== "$") {
            const n8 = accessCache[key];
            if (n8 !== void 0) {
              switch (n8) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props[key];
              }
            } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
              accessCache[key] = 3;
              return props[key];
            } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              track(instance, "get", key);
              process.env.NODE_ENV !== "production" && markAttrsAccessed();
            }
            return publicGetter(instance);
          } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
            return cssModule;
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
            {
              return globalProperties[key];
            }
          } else if (process.env.NODE_ENV !== "production" && currentRenderingInstance && (!isString2(key) || key.indexOf("__v") !== 0)) {
            if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
              warn3(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
            } else if (instance === currentRenderingInstance) {
              warn3(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
            }
          }
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            data[key] = value;
            return true;
          } else if (hasOwn(instance.props, key)) {
            process.env.NODE_ENV !== "production" && warn3(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            process.env.NODE_ENV !== "production" && warn3(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`, instance);
            return false;
          } else {
            if (process.env.NODE_ENV !== "production" && key in instance.appContext.config.globalProperties) {
              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                value
              });
            } else {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
          let normalizedProps;
          return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (hasOwn(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      if (process.env.NODE_ENV !== "production" && true) {
        PublicInstanceProxyHandlers.ownKeys = (target) => {
          warn3(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
          return Reflect.ownKeys(target);
        };
      }
      RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
        get(target, key) {
          if (key === Symbol.unscopables) {
            return;
          }
          return PublicInstanceProxyHandlers.get(target, key, target);
        },
        has(_, key) {
          const has2 = key[0] !== "_" && !isGloballyWhitelisted(key);
          if (process.env.NODE_ENV !== "production" && !has2 && PublicInstanceProxyHandlers.has(_, key)) {
            warn3(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
          }
          return has2;
        }
      });
      shouldCacheAccess = true;
      internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeObjectOptions,
        emits: mergeObjectOptions,
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        beforeCreate: mergeAsArray2,
        created: mergeAsArray2,
        beforeMount: mergeAsArray2,
        mounted: mergeAsArray2,
        beforeUpdate: mergeAsArray2,
        updated: mergeAsArray2,
        beforeDestroy: mergeAsArray2,
        beforeUnmount: mergeAsArray2,
        destroyed: mergeAsArray2,
        unmounted: mergeAsArray2,
        activated: mergeAsArray2,
        deactivated: mergeAsArray2,
        errorCaptured: mergeAsArray2,
        serverPrefetch: mergeAsArray2,
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        watch: mergeWatchOptions,
        provide: mergeDataFn,
        inject: mergeInject
      };
      isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
      isInternalKey = (key) => key[0] === "_" || key === "$stable";
      normalizeSlotValue = (value) => isArray2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (process.env.NODE_ENV !== "production" && currentInstance) {
            warn3(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
          }
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key))
            continue;
          const value = rawSlots[key];
          if (isFunction2(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            if (process.env.NODE_ENV !== "production" && true) {
              warn3(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      normalizeVNodeSlots = (instance, children) => {
        if (process.env.NODE_ENV !== "production" && !isKeepAlive(instance.vnode) && true) {
          warn3(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
        }
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      initSlots = (instance, children) => {
        if (instance.vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            instance.slots = toRaw(children);
            def(children, "_", type);
          } else {
            normalizeObjectSlots(children, instance.slots = {});
          }
        } else {
          instance.slots = {};
          if (children) {
            normalizeVNodeSlots(instance, children);
          }
        }
        def(instance.slots, InternalObjectKey, 1);
      };
      updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
              extend(slots, children);
            } else if (optimized && type === 1) {
              needDeletionCheck = false;
            } else {
              extend(slots, children);
              if (!optimized && type === 1) {
                delete slots._;
              }
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
              delete slots[key];
            }
          }
        }
      };
      uid = 0;
      hasMismatch = false;
      isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
      isComment = (node) => node.nodeType === 8;
      queuePostRenderEffect = queueEffectWithSuspense;
      isTeleport = (type) => type.__isTeleport;
      isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
      isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
      resolveTarget = (props, select) => {
        const targetSelector = props && props.to;
        if (isString2(targetSelector)) {
          if (!select) {
            process.env.NODE_ENV !== "production" && warn3(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
            return null;
          } else {
            const target = select(targetSelector);
            if (!target) {
              process.env.NODE_ENV !== "production" && warn3(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
            }
            return target;
          }
        } else {
          if (process.env.NODE_ENV !== "production" && !targetSelector && !isTeleportDisabled(props)) {
            warn3(`Invalid Teleport target: ${targetSelector}`);
          }
          return targetSelector;
        }
      };
      TeleportImpl = {
        __isTeleport: true,
        process(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
          const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
          const disabled = isTeleportDisabled(n22.props);
          let { shapeFlag, children, dynamicChildren } = n22;
          if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
          }
          if (n1 == null) {
            const placeholder = n22.el = process.env.NODE_ENV !== "production" ? createComment("teleport start") : createText("");
            const mainAnchor = n22.anchor = process.env.NODE_ENV !== "production" ? createComment("teleport end") : createText("");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n22.target = resolveTarget(n22.props, querySelector);
            const targetAnchor = n22.targetAnchor = createText("");
            if (target) {
              insert(targetAnchor, target);
              isSVG = isSVG || isTargetSVG(target);
            } else if (process.env.NODE_ENV !== "production" && !disabled) {
              warn3("Invalid Teleport target on mount:", target, `(${typeof target})`);
            }
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
            } else if (target) {
              mount(target, targetAnchor);
            }
          } else {
            n22.el = n1.el;
            const mainAnchor = n22.anchor = n1.anchor;
            const target = n22.target = n1.target;
            const targetAnchor = n22.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
              patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
              traverseStaticChildren(n1, n22, true);
            } else if (!optimized) {
              patchChildren(n1, n22, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(n22, container, mainAnchor, internals, 1);
              }
            } else {
              if ((n22.props && n22.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n22.target = resolveTarget(n22.props, querySelector);
                if (nextTarget) {
                  moveTeleport(n22, nextTarget, null, internals, 0);
                } else if (process.env.NODE_ENV !== "production") {
                  warn3("Invalid Teleport target on update:", target, `(${typeof target})`);
                }
              } else if (wasDisabled) {
                moveTeleport(n22, target, targetAnchor, internals, 1);
              }
            }
          }
        },
        remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
          if (target) {
            hostRemove(targetAnchor);
          }
          if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16) {
              for (let i8 = 0; i8 < children.length; i8++) {
                const child = children[i8];
                unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
              }
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      Teleport = TeleportImpl;
      Fragment = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0);
      Text = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0);
      Comment = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0);
      Static = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0);
      blockStack = [];
      currentBlock = null;
      isBlockTreeEnabled = 1;
      createVNodeWithArgsTransform = (...args) => {
        return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
      };
      InternalObjectKey = `__vInternal`;
      normalizeKey = ({ key }) => key != null ? key : null;
      normalizeRef = ({ ref: ref5, ref_key, ref_for }) => {
        return ref5 != null ? isString2(ref5) || isRef(ref5) || isFunction2(ref5) ? { i: currentRenderingInstance, r: ref5, k: ref_key, f: !!ref_for } : ref5 : null;
      };
      createVNode = process.env.NODE_ENV !== "production" ? createVNodeWithArgsTransform : _createVNode;
      emptyAppContext = createAppContext();
      uid$1 = 0;
      currentInstance = null;
      getCurrentInstance = () => currentInstance || currentRenderingInstance;
      setCurrentInstance = (instance) => {
        currentInstance = instance;
        instance.scope.on();
      };
      unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        currentInstance = null;
      };
      isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
      isInSSRComponentSetup = false;
      isRuntimeOnly = () => !compile2;
      classifyRE = /(?:^|[-_])(\w)/g;
      classify = (str) => str.replace(classifyRE, (c6) => c6.toUpperCase()).replace(/[-_]/g, "");
      computed3 = (getterOrOptions, debugOptions) => {
        return computed2(getterOrOptions, debugOptions, isInSSRComponentSetup);
      };
      warnRuntimeUsage = (method) => warn3(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
      ssrContextKey = Symbol(process.env.NODE_ENV !== "production" ? `ssrContext` : ``);
      useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          if (!ctx) {
            warn3(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
          }
          return ctx;
        }
      };
      version2 = "3.2.37";
      _ssrUtils = {
        createComponentInstance,
        setupComponent,
        renderComponentRoot,
        setCurrentRenderingInstance,
        isVNode,
        normalizeVNode
      };
      ssrUtils = _ssrUtils;
      resolveFilter = null;
      compatUtils = null;
    }
  });

  // node_modules/.pnpm/@vue+runtime-dom@3.2.37/node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
  var runtime_dom_esm_bundler_exports = {};
  __export(runtime_dom_esm_bundler_exports, {
    BaseTransition: () => BaseTransition,
    Comment: () => Comment,
    EffectScope: () => EffectScope,
    Fragment: () => Fragment,
    KeepAlive: () => KeepAlive,
    ReactiveEffect: () => ReactiveEffect,
    Static: () => Static,
    Suspense: () => Suspense,
    Teleport: () => Teleport,
    Text: () => Text,
    Transition: () => Transition,
    TransitionGroup: () => TransitionGroup,
    VueElement: () => VueElement,
    callWithAsyncErrorHandling: () => callWithAsyncErrorHandling,
    callWithErrorHandling: () => callWithErrorHandling,
    camelize: () => camelize,
    capitalize: () => capitalize,
    cloneVNode: () => cloneVNode,
    compatUtils: () => compatUtils,
    computed: () => computed3,
    createApp: () => createApp,
    createBlock: () => createBlock,
    createCommentVNode: () => createCommentVNode,
    createElementBlock: () => createElementBlock,
    createElementVNode: () => createBaseVNode,
    createHydrationRenderer: () => createHydrationRenderer,
    createPropsRestProxy: () => createPropsRestProxy,
    createRenderer: () => createRenderer,
    createSSRApp: () => createSSRApp,
    createSlots: () => createSlots,
    createStaticVNode: () => createStaticVNode,
    createTextVNode: () => createTextVNode,
    createVNode: () => createVNode,
    customRef: () => customRef,
    defineAsyncComponent: () => defineAsyncComponent,
    defineComponent: () => defineComponent,
    defineCustomElement: () => defineCustomElement,
    defineEmits: () => defineEmits,
    defineExpose: () => defineExpose,
    defineProps: () => defineProps,
    defineSSRCustomElement: () => defineSSRCustomElement,
    devtools: () => devtools,
    effect: () => effect,
    effectScope: () => effectScope,
    getCurrentInstance: () => getCurrentInstance,
    getCurrentScope: () => getCurrentScope,
    getTransitionRawChildren: () => getTransitionRawChildren,
    guardReactiveProps: () => guardReactiveProps,
    h: () => h,
    handleError: () => handleError,
    hydrate: () => hydrate,
    initCustomFormatter: () => initCustomFormatter,
    initDirectivesForSSR: () => initDirectivesForSSR,
    inject: () => inject,
    isMemoSame: () => isMemoSame,
    isProxy: () => isProxy,
    isReactive: () => isReactive,
    isReadonly: () => isReadonly,
    isRef: () => isRef,
    isRuntimeOnly: () => isRuntimeOnly,
    isShallow: () => isShallow,
    isVNode: () => isVNode,
    markRaw: () => markRaw,
    mergeDefaults: () => mergeDefaults,
    mergeProps: () => mergeProps,
    nextTick: () => nextTick2,
    normalizeClass: () => normalizeClass,
    normalizeProps: () => normalizeProps,
    normalizeStyle: () => normalizeStyle,
    onActivated: () => onActivated,
    onBeforeMount: () => onBeforeMount,
    onBeforeUnmount: () => onBeforeUnmount2,
    onBeforeUpdate: () => onBeforeUpdate,
    onDeactivated: () => onDeactivated,
    onErrorCaptured: () => onErrorCaptured,
    onMounted: () => onMounted2,
    onRenderTracked: () => onRenderTracked,
    onRenderTriggered: () => onRenderTriggered,
    onScopeDispose: () => onScopeDispose,
    onServerPrefetch: () => onServerPrefetch,
    onUnmounted: () => onUnmounted,
    onUpdated: () => onUpdated,
    openBlock: () => openBlock,
    popScopeId: () => popScopeId,
    provide: () => provide,
    proxyRefs: () => proxyRefs,
    pushScopeId: () => pushScopeId,
    queuePostFlushCb: () => queuePostFlushCb,
    reactive: () => reactive2,
    readonly: () => readonly,
    ref: () => ref2,
    registerRuntimeCompiler: () => registerRuntimeCompiler,
    render: () => render,
    renderList: () => renderList,
    renderSlot: () => renderSlot,
    resolveComponent: () => resolveComponent,
    resolveDirective: () => resolveDirective,
    resolveDynamicComponent: () => resolveDynamicComponent,
    resolveFilter: () => resolveFilter,
    resolveTransitionHooks: () => resolveTransitionHooks,
    setBlockTracking: () => setBlockTracking,
    setDevtoolsHook: () => setDevtoolsHook,
    setTransitionHooks: () => setTransitionHooks,
    shallowReactive: () => shallowReactive2,
    shallowReadonly: () => shallowReadonly,
    shallowRef: () => shallowRef2,
    ssrContextKey: () => ssrContextKey,
    ssrUtils: () => ssrUtils,
    stop: () => stop,
    toDisplayString: () => toDisplayString,
    toHandlerKey: () => toHandlerKey,
    toHandlers: () => toHandlers,
    toRaw: () => toRaw,
    toRef: () => toRef,
    toRefs: () => toRefs,
    transformVNodeArgs: () => transformVNodeArgs,
    triggerRef: () => triggerRef,
    unref: () => unref,
    useAttrs: () => useAttrs,
    useCssModule: () => useCssModule,
    useCssVars: () => useCssVars,
    useSSRContext: () => useSSRContext,
    useSlots: () => useSlots,
    useTransitionState: () => useTransitionState,
    vModelCheckbox: () => vModelCheckbox,
    vModelDynamic: () => vModelDynamic,
    vModelRadio: () => vModelRadio,
    vModelSelect: () => vModelSelect,
    vModelText: () => vModelText,
    vShow: () => vShow,
    version: () => version2,
    warn: () => warn3,
    watch: () => watch2,
    watchEffect: () => watchEffect2,
    watchPostEffect: () => watchPostEffect,
    watchSyncEffect: () => watchSyncEffect,
    withAsyncContext: () => withAsyncContext,
    withCtx: () => withCtx,
    withDefaults: () => withDefaults,
    withDirectives: () => withDirectives,
    withKeys: () => withKeys,
    withMemo: () => withMemo,
    withModifiers: () => withModifiers,
    withScopeId: () => withScopeId
  });
  function patchClass(el, value, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString2(next);
    if (next && !isCssString) {
      for (const key in next) {
        setStyle(style, key, next[key]);
      }
      if (prev && !isString2(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    } else {
      const currentDisplay = style.display;
      if (isCssString) {
        if (prev !== next) {
          style.cssText = next;
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
      if ("_vod" in el) {
        style.display = currentDisplay;
      }
    }
  }
  function setStyle(style, name2, val) {
    if (isArray2(val)) {
      val.forEach((v3) => setStyle(style, name2, v3));
    } else {
      if (val == null)
        val = "";
      if (name2.startsWith("--")) {
        style.setProperty(name2, val);
      } else {
        const prefixed = autoPrefix(style, name2);
        if (importantRE.test(val)) {
          style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name2 = camelize(rawName);
    if (name2 !== "filter" && name2 in style) {
      return prefixCache[rawName] = name2;
    }
    name2 = capitalize(name2);
    for (let i8 = 0; i8 < prefixes.length; i8++) {
      const prefixed = prefixes[i8] + name2;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      const isBoolean3 = isSpecialBooleanAttr(key);
      if (value == null || isBoolean3 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, isBoolean3 ? "" : value);
      }
    }
  }
  function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key] = value == null ? "" : value;
      return;
    }
    if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
      el._value = value;
      const newValue = value == null ? "" : value;
      if (el.value !== newValue || el.tagName === "OPTION") {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e8) {
      if (process.env.NODE_ENV !== "production") {
        warn3(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e8);
      }
    }
    needRemove && el.removeAttribute(key);
  }
  function addEventListener(el, event, handler2, options2) {
    el.addEventListener(event, handler2, options2);
  }
  function removeEventListener(el, event, handler2, options2) {
    el.removeEventListener(event, handler2, options2);
  }
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name2, options2] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
        addEventListener(el, name2, invoker, options2);
      } else if (existingInvoker) {
        removeEventListener(el, name2, existingInvoker, options2);
        invokers[rawName] = void 0;
      }
    }
  }
  function parseName(name2) {
    let options2;
    if (optionsModifierRE.test(name2)) {
      options2 = {};
      let m3;
      while (m3 = name2.match(optionsModifierRE)) {
        name2 = name2.slice(0, name2.length - m3[0].length);
        options2[m3[0].toLowerCase()] = true;
      }
    }
    return [hyphenate(name2.slice(2)), options2];
  }
  function createInvoker(initialValue, instance) {
    const invoker = (e8) => {
      const timeStamp = e8.timeStamp || _getNow();
      if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
        callWithAsyncErrorHandling(patchStopImmediatePropagation(e8, invoker.value), instance, 5, [e8]);
      }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e8, value) {
    if (isArray2(value)) {
      const originalStop = e8.stopImmediatePropagation;
      e8.stopImmediatePropagation = () => {
        originalStop.call(e8);
        e8._stopped = true;
      };
      return value.map((fn) => (e9) => !e9._stopped && fn && fn(e9));
    } else {
      return value;
    }
  }
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && nativeOnRE.test(key) && isFunction2(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (nativeOnRE.test(key) && isString2(value)) {
      return false;
    }
    return key in el;
  }
  function defineCustomElement(options2, hydrate2) {
    const Comp = defineComponent(options2);
    class VueCustomElement extends VueElement {
      constructor(initialProps) {
        super(Comp, initialProps, hydrate2);
      }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
  }
  function useCssModule(name2 = "$style") {
    {
      const instance = getCurrentInstance();
      if (!instance) {
        process.env.NODE_ENV !== "production" && warn3(`useCssModule must be called inside setup()`);
        return EMPTY_OBJ;
      }
      const modules = instance.type.__cssModules;
      if (!modules) {
        process.env.NODE_ENV !== "production" && warn3(`Current instance does not have CSS modules injected.`);
        return EMPTY_OBJ;
      }
      const mod2 = modules[name2];
      if (!mod2) {
        process.env.NODE_ENV !== "production" && warn3(`Current instance does not have CSS module named "${name2}".`);
        return EMPTY_OBJ;
      }
      return mod2;
    }
  }
  function useCssVars(getter) {
    const instance = getCurrentInstance();
    if (!instance) {
      process.env.NODE_ENV !== "production" && warn3(`useCssVars is called without current active component instance.`);
      return;
    }
    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
    watchPostEffect(setVars);
    onMounted2(() => {
      const ob = new MutationObserver(setVars);
      ob.observe(instance.subTree.el.parentNode, { childList: true });
      onUnmounted(() => ob.disconnect());
    });
  }
  function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
      const suspense = vnode.suspense;
      vnode = suspense.activeBranch;
      if (suspense.pendingBranch && !suspense.isHydrating) {
        suspense.effects.push(() => {
          setVarsOnVNode(suspense.activeBranch, vars);
        });
      }
    }
    while (vnode.component) {
      vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 && vnode.el) {
      setVarsOnNode(vnode.el, vars);
    } else if (vnode.type === Fragment) {
      vnode.children.forEach((c6) => setVarsOnVNode(c6, vars));
    } else if (vnode.type === Static) {
      let { el, anchor } = vnode;
      while (el) {
        setVarsOnNode(el, vars);
        if (el === anchor)
          break;
        el = el.nextSibling;
      }
    }
  }
  function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
      const style = el.style;
      for (const key in vars) {
        style.setProperty(`--${key}`, vars[key]);
      }
    }
  }
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const { name: name2 = "v", type, duration: duration2, enterFromClass = `${name2}-enter-from`, enterActiveClass = `${name2}-enter-active`, enterToClass = `${name2}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name2}-leave-from`, leaveActiveClass = `${name2}-leave-active`, leaveToClass = `${name2}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration2);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook2(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook2(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook2(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook2(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook2(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook2(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook2(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration2) {
    if (duration2 == null) {
      return null;
    } else if (isObject2(duration2)) {
      return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
    } else {
      const n8 = NumberOf(duration2);
      return [n8, n8];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    if (process.env.NODE_ENV !== "production")
      validateDuration(res);
    return res;
  }
  function validateDuration(val) {
    if (typeof val !== "number") {
      warn3(`<transition> explicit duration is not a valid number - got ${JSON.stringify(val)}.`);
    } else if (isNaN(val)) {
      warn3(`<transition> explicit duration is NaN - the duration expression might be incorrect.`);
    }
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c6) => c6 && el.classList.add(c6));
    (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c6) => c6 && el.classList.remove(c6));
    const { _vtc } = el;
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el._vtc = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e8) => {
      if (e8.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(TRANSITION2 + "Delay");
    const transitionDurations = getStyleProperties(TRANSITION2 + "Duration");
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + "Delay");
    const animationDurations = getStyleProperties(ANIMATION + "Duration");
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION2) {
      if (transitionTimeout > 0) {
        type = TRANSITION2;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION2 : ANIMATION : null;
      propCount = type ? type === TRANSITION2 ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION2 && /\b(transform|all)(,|$)/.test(styles[TRANSITION2 + "Property"]);
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d5, i8) => toMs(d5) + toMs(delays[i8])));
  }
  function toMs(s4) {
    return Number(s4.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function callPendingCbs(c6) {
    const el = c6.el;
    if (el._moveCb) {
      el._moveCb();
    }
    if (el._enterCb) {
      el._enterCb();
    }
  }
  function recordPosition(c6) {
    newPositionMap.set(c6, c6.el.getBoundingClientRect());
  }
  function applyTranslation(c6) {
    const oldPos = positionMap.get(c6);
    const newPos = newPositionMap.get(c6);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s4 = c6.el.style;
      s4.transform = s4.webkitTransform = `translate(${dx}px,${dy}px)`;
      s4.transitionDuration = "0s";
      return c6;
    }
  }
  function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    if (el._vtc) {
      el._vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c6) => c6 && clone.classList.remove(c6));
      });
    }
    moveClass.split(/\s+/).forEach((c6) => c6 && clone.classList.add(c6));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
  }
  function onCompositionStart(e8) {
    e8.target.composing = true;
  }
  function onCompositionEnd(e8) {
    const target = e8.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if (isArray2(value)) {
      el.checked = looseIndexOf(value, vnode.props.value) > -1;
    } else if (isSet(value)) {
      el.checked = value.has(vnode.props.value);
    } else if (value !== oldValue) {
      el.checked = looseEqual(value, getCheckboxValue(el, true));
    }
  }
  function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !isArray2(value) && !isSet(value)) {
      process.env.NODE_ENV !== "production" && warn3(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
      return;
    }
    for (let i8 = 0, l5 = el.options.length; i8 < l5; i8++) {
      const option = el.options[i8];
      const optionValue = getValue(option);
      if (isMultiple) {
        if (isArray2(value)) {
          option.selected = looseIndexOf(value, optionValue) > -1;
        } else {
          option.selected = value.has(optionValue);
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i8)
            el.selectedIndex = i8;
          return;
        }
      }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
      el.selectedIndex = -1;
    }
  }
  function getValue(el) {
    return "_value" in el ? el._value : el.value;
  }
  function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
  }
  function resolveDynamicModel(tagName, type) {
    switch (tagName) {
      case "SELECT":
        return vModelSelect;
      case "TEXTAREA":
        return vModelText;
      default:
        switch (type) {
          case "checkbox":
            return vModelCheckbox;
          case "radio":
            return vModelRadio;
          default:
            return vModelText;
        }
    }
  }
  function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
  }
  function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
      if (vnode.props && looseEqual(vnode.props.value, value)) {
        return { checked: true };
      }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
      if (isArray2(value)) {
        if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
          return { checked: true };
        }
      } else if (isSet(value)) {
        if (vnode.props && value.has(vnode.props.value)) {
          return { checked: true };
        }
      } else if (value) {
        return { checked: true };
      }
    };
    vModelDynamic.getSSRProps = (binding, vnode) => {
      if (typeof vnode.type !== "string") {
        return;
      }
      const modelToUse = resolveDynamicModel(vnode.type.toUpperCase(), vnode.props && vnode.props.type);
      if (modelToUse.getSSRProps) {
        return modelToUse.getSSRProps(binding, vnode);
      }
    };
  }
  function setDisplay(el, value) {
    el.style.display = value ? el._vod : "none";
  }
  function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
      if (!value) {
        return { style: { display: "none" } };
      }
    };
  }
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
    enabledHydration = true;
    return renderer;
  }
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    if (isRuntimeOnly()) {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn3(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn3(msg);
          return compilerOptions;
        },
        set() {
          warn3(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString2(container)) {
      const res = document.querySelector(container);
      if (process.env.NODE_ENV !== "production" && !res) {
        warn3(`Failed to mount app: mount target selector "${container}" returned null.`);
      }
      return res;
    }
    if (process.env.NODE_ENV !== "production" && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn3(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
  }
  var svgNS, doc, templateContainer, nodeOps, importantRE, prefixes, prefixCache, xlinkNS, _getNow, skipTimestampCheck, cachedNow, p, reset, getNow, optionsModifierRE, nativeOnRE, patchProp, defineSSRCustomElement, BaseClass, VueElement, TRANSITION2, ANIMATION, Transition, DOMTransitionPropsValidators, TransitionPropsValidators, callHook2, hasExplicitCallback, endId, positionMap, newPositionMap, TransitionGroupImpl, TransitionGroup, getModelAssigner, vModelText, vModelCheckbox, vModelRadio, vModelSelect, vModelDynamic, systemModifiers, modifierGuards, withModifiers, keyNames, withKeys, vShow, rendererOptions, renderer, enabledHydration, render, hydrate, createApp, createSSRApp, ssrDirectiveInitialized, initDirectivesForSSR;
  var init_runtime_dom_esm_bundler = __esm({
    "node_modules/.pnpm/@vue+runtime-dom@3.2.37/node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js"() {
      init_runtime_core_esm_bundler();
      init_runtime_core_esm_bundler();
      init_shared_esm_bundler();
      svgNS = "http://www.w3.org/2000/svg";
      doc = typeof document !== "undefined" ? document : null;
      templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, isSVG, is, props) => {
          const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
          if (tag === "select" && props && props.multiple != null) {
            el.setAttribute("multiple", props.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id) {
          el.setAttribute(id, "");
        },
        cloneNode(el) {
          const cloned = el.cloneNode(true);
          if (`_value` in el) {
            cloned._value = el._value;
          }
          return cloned;
        },
        insertStaticContent(content, parent, anchor, isSVG, start3, end) {
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          if (start3 && (start3 === end || start3.nextSibling)) {
            while (true) {
              parent.insertBefore(start3.cloneNode(true), anchor);
              if (start3 === end || !(start3 = start3.nextSibling))
                break;
            }
          } else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
              const wrapper = template.firstChild;
              while (wrapper.firstChild) {
                template.appendChild(wrapper.firstChild);
              }
              template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
          }
          return [
            before ? before.nextSibling : parent.firstChild,
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      importantRE = /\s*!important$/;
      prefixes = ["Webkit", "Moz", "ms"];
      prefixCache = {};
      xlinkNS = "http://www.w3.org/1999/xlink";
      [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
        let _getNow2 = Date.now;
        let skipTimestampCheck2 = false;
        if (typeof window !== "undefined") {
          if (Date.now() > document.createEvent("Event").timeStamp) {
            _getNow2 = performance.now.bind(performance);
          }
          const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
          skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
        }
        return [_getNow2, skipTimestampCheck2];
      })();
      cachedNow = 0;
      p = /* @__PURE__ */ Promise.resolve();
      reset = () => {
        cachedNow = 0;
      };
      getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
      optionsModifierRE = /(?:Once|Passive|Capture)$/;
      nativeOnRE = /^on[a-z]/;
      patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (isOn(key)) {
          if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      defineSSRCustomElement = (options2) => {
        return defineCustomElement(options2, hydrate);
      };
      BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
      };
      VueElement = class extends BaseClass {
        constructor(_def, _props = {}, hydrate2) {
          super();
          this._def = _def;
          this._props = _props;
          this._instance = null;
          this._connected = false;
          this._resolved = false;
          this._numberProps = null;
          if (this.shadowRoot && hydrate2) {
            hydrate2(this._createVNode(), this.shadowRoot);
          } else {
            if (process.env.NODE_ENV !== "production" && this.shadowRoot) {
              warn3(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
            }
            this.attachShadow({ mode: "open" });
          }
        }
        connectedCallback() {
          this._connected = true;
          if (!this._instance) {
            this._resolveDef();
          }
        }
        disconnectedCallback() {
          this._connected = false;
          nextTick2(() => {
            if (!this._connected) {
              render(null, this.shadowRoot);
              this._instance = null;
            }
          });
        }
        _resolveDef() {
          if (this._resolved) {
            return;
          }
          this._resolved = true;
          for (let i8 = 0; i8 < this.attributes.length; i8++) {
            this._setAttr(this.attributes[i8].name);
          }
          new MutationObserver((mutations) => {
            for (const m3 of mutations) {
              this._setAttr(m3.attributeName);
            }
          }).observe(this, { attributes: true });
          const resolve2 = (def2) => {
            const { props, styles } = def2;
            const hasOptions = !isArray2(props);
            const rawKeys = props ? hasOptions ? Object.keys(props) : props : [];
            let numberProps;
            if (hasOptions) {
              for (const key in this._props) {
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                  this._props[key] = toNumber(this._props[key]);
                  (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[key] = true;
                }
              }
            }
            this._numberProps = numberProps;
            for (const key of Object.keys(this)) {
              if (key[0] !== "_") {
                this._setProp(key, this[key], true, false);
              }
            }
            for (const key of rawKeys.map(camelize)) {
              Object.defineProperty(this, key, {
                get() {
                  return this._getProp(key);
                },
                set(val) {
                  this._setProp(key, val);
                }
              });
            }
            this._applyStyles(styles);
            this._update();
          };
          const asyncDef = this._def.__asyncLoader;
          if (asyncDef) {
            asyncDef().then(resolve2);
          } else {
            resolve2(this._def);
          }
        }
        _setAttr(key) {
          let value = this.getAttribute(key);
          if (this._numberProps && this._numberProps[key]) {
            value = toNumber(value);
          }
          this._setProp(camelize(key), value, false);
        }
        _getProp(key) {
          return this._props[key];
        }
        _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
          if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) {
              this._update();
            }
            if (shouldReflect) {
              if (val === true) {
                this.setAttribute(hyphenate(key), "");
              } else if (typeof val === "string" || typeof val === "number") {
                this.setAttribute(hyphenate(key), val + "");
              } else if (!val) {
                this.removeAttribute(hyphenate(key));
              }
            }
          }
        }
        _update() {
          render(this._createVNode(), this.shadowRoot);
        }
        _createVNode() {
          const vnode = createVNode(this._def, extend({}, this._props));
          if (!this._instance) {
            vnode.ce = (instance) => {
              this._instance = instance;
              instance.isCE = true;
              if (process.env.NODE_ENV !== "production") {
                instance.ceReload = (newStyles) => {
                  if (this._styles) {
                    this._styles.forEach((s4) => this.shadowRoot.removeChild(s4));
                    this._styles.length = 0;
                  }
                  this._applyStyles(newStyles);
                  if (!this._def.__asyncLoader) {
                    this._instance = null;
                    this._update();
                  }
                };
              }
              instance.emit = (event, ...args) => {
                this.dispatchEvent(new CustomEvent(event, {
                  detail: args
                }));
              };
              let parent = this;
              while (parent = parent && (parent.parentNode || parent.host)) {
                if (parent instanceof VueElement) {
                  instance.parent = parent._instance;
                  break;
                }
              }
            };
          }
          return vnode;
        }
        _applyStyles(styles) {
          if (styles) {
            styles.forEach((css) => {
              const s4 = document.createElement("style");
              s4.textContent = css;
              this.shadowRoot.appendChild(s4);
              if (process.env.NODE_ENV !== "production") {
                (this._styles || (this._styles = [])).push(s4);
              }
            });
          }
        }
      };
      TRANSITION2 = "transition";
      ANIMATION = "animation";
      Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
      Transition.displayName = "Transition";
      DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
      callHook2 = (hook, args = []) => {
        if (isArray2(hook)) {
          hook.forEach((h8) => h8(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      hasExplicitCallback = (hook) => {
        return hook ? isArray2(hook) ? hook.some((h8) => h8.length > 1) : hook.length > 1 : false;
      };
      endId = 0;
      positionMap = /* @__PURE__ */ new WeakMap();
      newPositionMap = /* @__PURE__ */ new WeakMap();
      TransitionGroupImpl = {
        name: "TransitionGroup",
        props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
          tag: String,
          moveClass: String
        }),
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevChildren;
          let children;
          onUpdated(() => {
            if (!prevChildren.length) {
              return;
            }
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
              return;
            }
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c6) => {
              const el = c6.el;
              const style = el.style;
              addTransitionClass(el, moveClass);
              style.transform = style.webkitTransform = style.transitionDuration = "";
              const cb = el._moveCb = (e8) => {
                if (e8 && e8.target !== el) {
                  return;
                }
                if (!e8 || /transform$/.test(e8.propertyName)) {
                  el.removeEventListener("transitionend", cb);
                  el._moveCb = null;
                  removeTransitionClass(el, moveClass);
                }
              };
              el.addEventListener("transitionend", cb);
            });
          });
          return () => {
            const rawProps = toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || Fragment;
            prevChildren = children;
            children = slots.default ? getTransitionRawChildren(slots.default()) : [];
            for (let i8 = 0; i8 < children.length; i8++) {
              const child = children[i8];
              if (child.key != null) {
                setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
              } else if (process.env.NODE_ENV !== "production") {
                warn3(`<TransitionGroup> children must be keyed.`);
              }
            }
            if (prevChildren) {
              for (let i8 = 0; i8 < prevChildren.length; i8++) {
                const child = prevChildren[i8];
                setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                positionMap.set(child, child.el.getBoundingClientRect());
              }
            }
            return createVNode(tag, null, children);
          };
        }
      };
      TransitionGroup = TransitionGroupImpl;
      getModelAssigner = (vnode) => {
        const fn = vnode.props["onUpdate:modelValue"] || false;
        return isArray2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
      };
      vModelText = {
        created(el, { modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          const castToNumber = number || vnode.props && vnode.props.type === "number";
          addEventListener(el, lazy ? "change" : "input", (e8) => {
            if (e8.target.composing)
              return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            }
            if (castToNumber) {
              domValue = toNumber(domValue);
            }
            el._assign(domValue);
          });
          if (trim) {
            addEventListener(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
          }
        },
        mounted(el, { value }) {
          el.value = value == null ? "" : value;
        },
        beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (el.composing)
            return;
          if (document.activeElement === el && el.type !== "range") {
            if (lazy) {
              return;
            }
            if (trim && el.value.trim() === value) {
              return;
            }
            if ((number || el.type === "number") && toNumber(el.value) === value) {
              return;
            }
          }
          const newValue = value == null ? "" : value;
          if (el.value !== newValue) {
            el.value = newValue;
          }
        }
      };
      vModelCheckbox = {
        deep: true,
        created(el, _, vnode) {
          el._assign = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if (isArray2(modelValue)) {
              const index15 = looseIndexOf(modelValue, elementValue);
              const found = index15 !== -1;
              if (checked && !found) {
                assign(modelValue.concat(elementValue));
              } else if (!checked && found) {
                const filtered = [...modelValue];
                filtered.splice(index15, 1);
                assign(filtered);
              }
            } else if (isSet(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign(cloned);
            } else {
              assign(getCheckboxValue(el, checked));
            }
          });
        },
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el._assign = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      vModelRadio = {
        created(el, { value }, vnode) {
          el.checked = looseEqual(value, vnode.props.value);
          el._assign = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            el._assign(getValue(el));
          });
        },
        beforeUpdate(el, { value, oldValue }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (value !== oldValue) {
            el.checked = looseEqual(value, vnode.props.value);
          }
        }
      };
      vModelSelect = {
        deep: true,
        created(el, { value, modifiers: { number } }, vnode) {
          const isSetModel = isSet(value);
          addEventListener(el, "change", () => {
            const selectedVal = Array.prototype.filter.call(el.options, (o8) => o8.selected).map((o8) => number ? toNumber(getValue(o8)) : getValue(o8));
            el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
          });
          el._assign = getModelAssigner(vnode);
        },
        mounted(el, { value }) {
          setSelected(el, value);
        },
        beforeUpdate(el, _binding, vnode) {
          el._assign = getModelAssigner(vnode);
        },
        updated(el, { value }) {
          setSelected(el, value);
        }
      };
      vModelDynamic = {
        created(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, "created");
        },
        mounted(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, "mounted");
        },
        beforeUpdate(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
        },
        updated(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, "updated");
        }
      };
      systemModifiers = ["ctrl", "shift", "alt", "meta"];
      modifierGuards = {
        stop: (e8) => e8.stopPropagation(),
        prevent: (e8) => e8.preventDefault(),
        self: (e8) => e8.target !== e8.currentTarget,
        ctrl: (e8) => !e8.ctrlKey,
        shift: (e8) => !e8.shiftKey,
        alt: (e8) => !e8.altKey,
        meta: (e8) => !e8.metaKey,
        left: (e8) => "button" in e8 && e8.button !== 0,
        middle: (e8) => "button" in e8 && e8.button !== 1,
        right: (e8) => "button" in e8 && e8.button !== 2,
        exact: (e8, modifiers) => systemModifiers.some((m3) => e8[`${m3}Key`] && !modifiers.includes(m3))
      };
      withModifiers = (fn, modifiers) => {
        return (event, ...args) => {
          for (let i8 = 0; i8 < modifiers.length; i8++) {
            const guard = modifierGuards[modifiers[i8]];
            if (guard && guard(event, modifiers))
              return;
          }
          return fn(event, ...args);
        };
      };
      keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      withKeys = (fn, modifiers) => {
        return (event) => {
          if (!("key" in event)) {
            return;
          }
          const eventKey = hyphenate(event.key);
          if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
            return fn(event);
          }
        };
      };
      vShow = {
        beforeMount(el, { value }, { transition }) {
          el._vod = el.style.display === "none" ? "" : el.style.display;
          if (transition && value) {
            transition.beforeEnter(el);
          } else {
            setDisplay(el, value);
          }
        },
        mounted(el, { value }, { transition }) {
          if (transition && value) {
            transition.enter(el);
          }
        },
        updated(el, { value, oldValue }, { transition }) {
          if (!value === !oldValue)
            return;
          if (transition) {
            if (value) {
              transition.beforeEnter(el);
              setDisplay(el, true);
              transition.enter(el);
            } else {
              transition.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value);
          }
        },
        beforeUnmount(el, { value }) {
          setDisplay(el, value);
        }
      };
      rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
      enabledHydration = false;
      render = (...args) => {
        ensureRenderer().render(...args);
      };
      hydrate = (...args) => {
        ensureHydrationRenderer().hydrate(...args);
      };
      createApp = (...args) => {
        const app = ensureRenderer().createApp(...args);
        if (process.env.NODE_ENV !== "production") {
          injectNativeTagCheck(app);
          injectCompilerOptionsCheck(app);
        }
        const { mount } = app;
        app.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
            return;
          const component = app._component;
          if (!isFunction2(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          container.innerHTML = "";
          const proxy = mount(container, false, container instanceof SVGElement);
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app;
      };
      createSSRApp = (...args) => {
        const app = ensureHydrationRenderer().createApp(...args);
        if (process.env.NODE_ENV !== "production") {
          injectNativeTagCheck(app);
          injectCompilerOptionsCheck(app);
        }
        const { mount } = app;
        app.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (container) {
            return mount(container, true, container instanceof SVGElement);
          }
        };
        return app;
      };
      ssrDirectiveInitialized = false;
      initDirectivesForSSR = () => {
        if (!ssrDirectiveInitialized) {
          ssrDirectiveInitialized = true;
          initVModelForSSR();
          initVShowForSSR();
        }
      };
    }
  });

  // node_modules/.pnpm/vue@3.2.37/node_modules/vue/dist/vue.cjs.prod.js
  var require_vue_cjs_prod = __commonJS({
    "node_modules/.pnpm/vue@3.2.37/node_modules/vue/dist/vue.cjs.prod.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var compilerDom = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
      var runtimeDom = (init_runtime_dom_esm_bundler(), __toCommonJS(runtime_dom_esm_bundler_exports));
      var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
      function _interopNamespace(e8) {
        if (e8 && e8.__esModule)
          return e8;
        var n8 = /* @__PURE__ */ Object.create(null);
        if (e8) {
          Object.keys(e8).forEach(function(k2) {
            n8[k2] = e8[k2];
          });
        }
        n8["default"] = e8;
        return Object.freeze(n8);
      }
      var runtimeDom__namespace = /* @__PURE__ */ _interopNamespace(runtimeDom);
      var compileCache = /* @__PURE__ */ Object.create(null);
      function compileToFunction(template, options2) {
        if (!shared.isString(template)) {
          if (template.nodeType) {
            template = template.innerHTML;
          } else {
            return shared.NOOP;
          }
        }
        const key = template;
        const cached = compileCache[key];
        if (cached) {
          return cached;
        }
        if (template[0] === "#") {
          const el = document.querySelector(template);
          template = el ? el.innerHTML : ``;
        }
        const { code } = compilerDom.compile(template, shared.extend({
          hoistStatic: true,
          onError: void 0,
          onWarn: shared.NOOP
        }, options2));
        const render2 = new Function("Vue", code)(runtimeDom__namespace);
        render2._rc = true;
        return compileCache[key] = render2;
      }
      runtimeDom.registerRuntimeCompiler(compileToFunction);
      Object.keys(runtimeDom).forEach(function(k2) {
        if (k2 !== "default")
          exports[k2] = runtimeDom[k2];
      });
      exports.compile = compileToFunction;
    }
  });

  // node_modules/.pnpm/vue@3.2.37/node_modules/vue/dist/vue.cjs.js
  var require_vue_cjs = __commonJS({
    "node_modules/.pnpm/vue@3.2.37/node_modules/vue/dist/vue.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var compilerDom = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
      var runtimeDom = (init_runtime_dom_esm_bundler(), __toCommonJS(runtime_dom_esm_bundler_exports));
      var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
      function _interopNamespace(e8) {
        if (e8 && e8.__esModule)
          return e8;
        var n8 = /* @__PURE__ */ Object.create(null);
        if (e8) {
          Object.keys(e8).forEach(function(k2) {
            n8[k2] = e8[k2];
          });
        }
        n8["default"] = e8;
        return Object.freeze(n8);
      }
      var runtimeDom__namespace = /* @__PURE__ */ _interopNamespace(runtimeDom);
      var compileCache = /* @__PURE__ */ Object.create(null);
      function compileToFunction(template, options2) {
        if (!shared.isString(template)) {
          if (template.nodeType) {
            template = template.innerHTML;
          } else {
            runtimeDom.warn(`invalid template option: `, template);
            return shared.NOOP;
          }
        }
        const key = template;
        const cached = compileCache[key];
        if (cached) {
          return cached;
        }
        if (template[0] === "#") {
          const el = document.querySelector(template);
          if (!el) {
            runtimeDom.warn(`Template element not found or is empty: ${template}`);
          }
          template = el ? el.innerHTML : ``;
        }
        const { code } = compilerDom.compile(template, shared.extend({
          hoistStatic: true,
          onError,
          onWarn: (e8) => onError(e8, true)
        }, options2));
        function onError(err, asWarning = false) {
          const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
          const codeFrame = err.loc && shared.generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
          runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
        }
        const render2 = new Function("Vue", code)(runtimeDom__namespace);
        render2._rc = true;
        return compileCache[key] = render2;
      }
      runtimeDom.registerRuntimeCompiler(compileToFunction);
      Object.keys(runtimeDom).forEach(function(k2) {
        if (k2 !== "default")
          exports[k2] = runtimeDom[k2];
      });
      exports.compile = compileToFunction;
    }
  });

  // node_modules/.pnpm/vue@3.2.37/node_modules/vue/index.js
  var require_vue = __commonJS({
    "node_modules/.pnpm/vue@3.2.37/node_modules/vue/index.js"(exports, module) {
      "use strict";
      if (process.env.NODE_ENV === "production") {
        module.exports = require_vue_cjs_prod();
      } else {
        module.exports = require_vue_cjs();
      }
    }
  });

  // node_modules/.pnpm/recordrtc@5.6.2/node_modules/recordrtc/RecordRTC.js
  var require_RecordRTC = __commonJS({
    "node_modules/.pnpm/recordrtc@5.6.2/node_modules/recordrtc/RecordRTC.js"(exports, module) {
      "use strict";
      function RecordRTC(mediaStream, config) {
        if (!mediaStream) {
          throw "First parameter is required.";
        }
        config = config || {
          type: "video"
        };
        config = new RecordRTCConfiguration(mediaStream, config);
        var self2 = this;
        function startRecording(config2) {
          if (!config.disableLogs) {
            console.log("RecordRTC version: ", self2.version);
          }
          if (!!config2) {
            config = new RecordRTCConfiguration(mediaStream, config2);
          }
          if (!config.disableLogs) {
            console.log("started recording " + config.type + " stream.");
          }
          if (mediaRecorder) {
            mediaRecorder.clearRecordedData();
            mediaRecorder.record();
            setState("recording");
            if (self2.recordingDuration) {
              handleRecordingDuration();
            }
            return self2;
          }
          initRecorder(function() {
            if (self2.recordingDuration) {
              handleRecordingDuration();
            }
          });
          return self2;
        }
        function initRecorder(initCallback) {
          if (initCallback) {
            config.initCallback = function() {
              initCallback();
              initCallback = config.initCallback = null;
            };
          }
          var Recorder2 = new GetRecorderType(mediaStream, config);
          mediaRecorder = new Recorder2(mediaStream, config);
          mediaRecorder.record();
          setState("recording");
          if (!config.disableLogs) {
            console.log("Initialized recorderType:", mediaRecorder.constructor.name, "for output-type:", config.type);
          }
        }
        function stopRecording(callback) {
          callback = callback || function() {
          };
          if (!mediaRecorder) {
            warningLog();
            return;
          }
          if (self2.state === "paused") {
            self2.resumeRecording();
            setTimeout(function() {
              stopRecording(callback);
            }, 1);
            return;
          }
          if (self2.state !== "recording" && !config.disableLogs) {
            console.warn('Recording state should be: "recording", however current state is: ', self2.state);
          }
          if (!config.disableLogs) {
            console.log("Stopped recording " + config.type + " stream.");
          }
          if (config.type !== "gif") {
            mediaRecorder.stop(_callback);
          } else {
            mediaRecorder.stop();
            _callback();
          }
          setState("stopped");
          function _callback(__blob) {
            if (!mediaRecorder) {
              if (typeof callback.call === "function") {
                callback.call(self2, "");
              } else {
                callback("");
              }
              return;
            }
            Object.keys(mediaRecorder).forEach(function(key) {
              if (typeof mediaRecorder[key] === "function") {
                return;
              }
              self2[key] = mediaRecorder[key];
            });
            var blob = mediaRecorder.blob;
            if (!blob) {
              if (__blob) {
                mediaRecorder.blob = blob = __blob;
              } else {
                throw "Recording failed.";
              }
            }
            if (blob && !config.disableLogs) {
              console.log(blob.type, "->", bytesToSize(blob.size));
            }
            if (callback) {
              var url;
              try {
                url = URL2.createObjectURL(blob);
              } catch (e8) {
              }
              if (typeof callback.call === "function") {
                callback.call(self2, url);
              } else {
                callback(url);
              }
            }
            if (!config.autoWriteToDisk) {
              return;
            }
            getDataURL(function(dataURL) {
              var parameter = {};
              parameter[config.type + "Blob"] = dataURL;
              DiskStorage.Store(parameter);
            });
          }
        }
        function pauseRecording() {
          if (!mediaRecorder) {
            warningLog();
            return;
          }
          if (self2.state !== "recording") {
            if (!config.disableLogs) {
              console.warn("Unable to pause the recording. Recording state: ", self2.state);
            }
            return;
          }
          setState("paused");
          mediaRecorder.pause();
          if (!config.disableLogs) {
            console.log("Paused recording.");
          }
        }
        function resumeRecording() {
          if (!mediaRecorder) {
            warningLog();
            return;
          }
          if (self2.state !== "paused") {
            if (!config.disableLogs) {
              console.warn("Unable to resume the recording. Recording state: ", self2.state);
            }
            return;
          }
          setState("recording");
          mediaRecorder.resume();
          if (!config.disableLogs) {
            console.log("Resumed recording.");
          }
        }
        function readFile(_blob) {
          postMessage(new FileReaderSync().readAsDataURL(_blob));
        }
        function getDataURL(callback, _mediaRecorder) {
          if (!callback) {
            throw "Pass a callback function over getDataURL.";
          }
          var blob = _mediaRecorder ? _mediaRecorder.blob : (mediaRecorder || {}).blob;
          if (!blob) {
            if (!config.disableLogs) {
              console.warn("Blob encoder did not finish its job yet.");
            }
            setTimeout(function() {
              getDataURL(callback, _mediaRecorder);
            }, 1e3);
            return;
          }
          if (typeof Worker !== "undefined" && !navigator.mozGetUserMedia) {
            var webWorker = processInWebWorker(readFile);
            webWorker.onmessage = function(event) {
              callback(event.data);
            };
            webWorker.postMessage(blob);
          } else {
            var reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onload = function(event) {
              callback(event.target.result);
            };
          }
          function processInWebWorker(_function) {
            try {
              var blob2 = URL2.createObjectURL(new Blob([
                _function.toString(),
                "this.onmessage =  function (eee) {" + _function.name + "(eee.data);}"
              ], {
                type: "application/javascript"
              }));
              var worker = new Worker(blob2);
              URL2.revokeObjectURL(blob2);
              return worker;
            } catch (e8) {
            }
          }
        }
        function handleRecordingDuration(counter) {
          counter = counter || 0;
          if (self2.state === "paused") {
            setTimeout(function() {
              handleRecordingDuration(counter);
            }, 1e3);
            return;
          }
          if (self2.state === "stopped") {
            return;
          }
          if (counter >= self2.recordingDuration) {
            stopRecording(self2.onRecordingStopped);
            return;
          }
          counter += 1e3;
          setTimeout(function() {
            handleRecordingDuration(counter);
          }, 1e3);
        }
        function setState(state) {
          if (!self2) {
            return;
          }
          self2.state = state;
          if (typeof self2.onStateChanged.call === "function") {
            self2.onStateChanged.call(self2, state);
          } else {
            self2.onStateChanged(state);
          }
        }
        var WARNING = 'It seems that recorder is destroyed or "startRecording" is not invoked for ' + config.type + " recorder.";
        function warningLog() {
          if (config.disableLogs === true) {
            return;
          }
          console.warn(WARNING);
        }
        var mediaRecorder;
        var returnObject = {
          startRecording,
          stopRecording,
          pauseRecording,
          resumeRecording,
          initRecorder,
          setRecordingDuration: function(recordingDuration, callback) {
            if (typeof recordingDuration === "undefined") {
              throw "recordingDuration is required.";
            }
            if (typeof recordingDuration !== "number") {
              throw "recordingDuration must be a number.";
            }
            self2.recordingDuration = recordingDuration;
            self2.onRecordingStopped = callback || function() {
            };
            return {
              onRecordingStopped: function(callback2) {
                self2.onRecordingStopped = callback2;
              }
            };
          },
          clearRecordedData: function() {
            if (!mediaRecorder) {
              warningLog();
              return;
            }
            mediaRecorder.clearRecordedData();
            if (!config.disableLogs) {
              console.log("Cleared old recorded data.");
            }
          },
          getBlob: function() {
            if (!mediaRecorder) {
              warningLog();
              return;
            }
            return mediaRecorder.blob;
          },
          getDataURL,
          toURL: function() {
            if (!mediaRecorder) {
              warningLog();
              return;
            }
            return URL2.createObjectURL(mediaRecorder.blob);
          },
          getInternalRecorder: function() {
            return mediaRecorder;
          },
          save: function(fileName) {
            if (!mediaRecorder) {
              warningLog();
              return;
            }
            invokeSaveAsDialog(mediaRecorder.blob, fileName);
          },
          getFromDisk: function(callback) {
            if (!mediaRecorder) {
              warningLog();
              return;
            }
            RecordRTC.getFromDisk(config.type, callback);
          },
          setAdvertisementArray: function(arrayOfWebPImages) {
            config.advertisement = [];
            var length = arrayOfWebPImages.length;
            for (var i8 = 0; i8 < length; i8++) {
              config.advertisement.push({
                duration: i8,
                image: arrayOfWebPImages[i8]
              });
            }
          },
          blob: null,
          bufferSize: 0,
          sampleRate: 0,
          buffer: null,
          reset: function() {
            if (self2.state === "recording" && !config.disableLogs) {
              console.warn("Stop an active recorder.");
            }
            if (mediaRecorder && typeof mediaRecorder.clearRecordedData === "function") {
              mediaRecorder.clearRecordedData();
            }
            mediaRecorder = null;
            setState("inactive");
            self2.blob = null;
          },
          onStateChanged: function(state) {
            if (!config.disableLogs) {
              console.log("Recorder state changed:", state);
            }
          },
          state: "inactive",
          getState: function() {
            return self2.state;
          },
          destroy: function() {
            var disableLogsCache = config.disableLogs;
            config = {
              disableLogs: true
            };
            self2.reset();
            setState("destroyed");
            returnObject = self2 = null;
            if (Storage.AudioContextConstructor) {
              Storage.AudioContextConstructor.close();
              Storage.AudioContextConstructor = null;
            }
            config.disableLogs = disableLogsCache;
            if (!config.disableLogs) {
              console.log("RecordRTC is destroyed.");
            }
          },
          version: "5.6.2"
        };
        if (!this) {
          self2 = returnObject;
          return returnObject;
        }
        for (var prop in returnObject) {
          this[prop] = returnObject[prop];
        }
        self2 = this;
        return returnObject;
      }
      RecordRTC.version = "5.6.2";
      if (typeof module !== "undefined") {
        module.exports = RecordRTC;
      }
      if (typeof define === "function" && define.amd) {
        define("RecordRTC", [], function() {
          return RecordRTC;
        });
      }
      RecordRTC.getFromDisk = function(type, callback) {
        if (!callback) {
          throw "callback is mandatory.";
        }
        console.log("Getting recorded " + (type === "all" ? "blobs" : type + " blob ") + " from disk!");
        DiskStorage.Fetch(function(dataURL, _type) {
          if (type !== "all" && _type === type + "Blob" && callback) {
            callback(dataURL);
          }
          if (type === "all" && callback) {
            callback(dataURL, _type.replace("Blob", ""));
          }
        });
      };
      RecordRTC.writeToDisk = function(options2) {
        console.log("Writing recorded blob(s) to disk!");
        options2 = options2 || {};
        if (options2.audio && options2.video && options2.gif) {
          options2.audio.getDataURL(function(audioDataURL) {
            options2.video.getDataURL(function(videoDataURL) {
              options2.gif.getDataURL(function(gifDataURL) {
                DiskStorage.Store({
                  audioBlob: audioDataURL,
                  videoBlob: videoDataURL,
                  gifBlob: gifDataURL
                });
              });
            });
          });
        } else if (options2.audio && options2.video) {
          options2.audio.getDataURL(function(audioDataURL) {
            options2.video.getDataURL(function(videoDataURL) {
              DiskStorage.Store({
                audioBlob: audioDataURL,
                videoBlob: videoDataURL
              });
            });
          });
        } else if (options2.audio && options2.gif) {
          options2.audio.getDataURL(function(audioDataURL) {
            options2.gif.getDataURL(function(gifDataURL) {
              DiskStorage.Store({
                audioBlob: audioDataURL,
                gifBlob: gifDataURL
              });
            });
          });
        } else if (options2.video && options2.gif) {
          options2.video.getDataURL(function(videoDataURL) {
            options2.gif.getDataURL(function(gifDataURL) {
              DiskStorage.Store({
                videoBlob: videoDataURL,
                gifBlob: gifDataURL
              });
            });
          });
        } else if (options2.audio) {
          options2.audio.getDataURL(function(audioDataURL) {
            DiskStorage.Store({
              audioBlob: audioDataURL
            });
          });
        } else if (options2.video) {
          options2.video.getDataURL(function(videoDataURL) {
            DiskStorage.Store({
              videoBlob: videoDataURL
            });
          });
        } else if (options2.gif) {
          options2.gif.getDataURL(function(gifDataURL) {
            DiskStorage.Store({
              gifBlob: gifDataURL
            });
          });
        }
      };
      function RecordRTCConfiguration(mediaStream, config) {
        if (!config.recorderType && !config.type) {
          if (!!config.audio && !!config.video) {
            config.type = "video";
          } else if (!!config.audio && !config.video) {
            config.type = "audio";
          }
        }
        if (config.recorderType && !config.type) {
          if (config.recorderType === WhammyRecorder || config.recorderType === CanvasRecorder || typeof WebAssemblyRecorder !== "undefined" && config.recorderType === WebAssemblyRecorder) {
            config.type = "video";
          } else if (config.recorderType === GifRecorder) {
            config.type = "gif";
          } else if (config.recorderType === StereoAudioRecorder) {
            config.type = "audio";
          } else if (config.recorderType === MediaStreamRecorder) {
            if (getTracks(mediaStream, "audio").length && getTracks(mediaStream, "video").length) {
              config.type = "video";
            } else if (!getTracks(mediaStream, "audio").length && getTracks(mediaStream, "video").length) {
              config.type = "video";
            } else if (getTracks(mediaStream, "audio").length && !getTracks(mediaStream, "video").length) {
              config.type = "audio";
            } else {
            }
          }
        }
        if (typeof MediaStreamRecorder !== "undefined" && typeof MediaRecorder !== "undefined" && "requestData" in MediaRecorder.prototype) {
          if (!config.mimeType) {
            config.mimeType = "video/webm";
          }
          if (!config.type) {
            config.type = config.mimeType.split("/")[0];
          }
          if (!config.bitsPerSecond) {
          }
        }
        if (!config.type) {
          if (config.mimeType) {
            config.type = config.mimeType.split("/")[0];
          }
          if (!config.type) {
            config.type = "audio";
          }
        }
        return config;
      }
      function GetRecorderType(mediaStream, config) {
        var recorder2;
        if (isChrome || isEdge || isOpera) {
          recorder2 = StereoAudioRecorder;
        }
        if (typeof MediaRecorder !== "undefined" && "requestData" in MediaRecorder.prototype && !isChrome) {
          recorder2 = MediaStreamRecorder;
        }
        if (config.type === "video" && (isChrome || isOpera)) {
          recorder2 = WhammyRecorder;
          if (typeof WebAssemblyRecorder !== "undefined" && typeof ReadableStream !== "undefined") {
            recorder2 = WebAssemblyRecorder;
          }
        }
        if (config.type === "gif") {
          recorder2 = GifRecorder;
        }
        if (config.type === "canvas") {
          recorder2 = CanvasRecorder;
        }
        if (isMediaRecorderCompatible() && recorder2 !== CanvasRecorder && recorder2 !== GifRecorder && typeof MediaRecorder !== "undefined" && "requestData" in MediaRecorder.prototype) {
          if (getTracks(mediaStream, "video").length || getTracks(mediaStream, "audio").length) {
            if (config.type === "audio") {
              if (typeof MediaRecorder.isTypeSupported === "function" && MediaRecorder.isTypeSupported("audio/webm")) {
                recorder2 = MediaStreamRecorder;
              }
            } else {
              if (typeof MediaRecorder.isTypeSupported === "function" && MediaRecorder.isTypeSupported("video/webm")) {
                recorder2 = MediaStreamRecorder;
              }
            }
          }
        }
        if (mediaStream instanceof Array && mediaStream.length) {
          recorder2 = MultiStreamRecorder;
        }
        if (config.recorderType) {
          recorder2 = config.recorderType;
        }
        if (!config.disableLogs && !!recorder2 && !!recorder2.name) {
          console.log("Using recorderType:", recorder2.name || recorder2.constructor.name);
        }
        if (!recorder2 && isSafari) {
          recorder2 = MediaStreamRecorder;
        }
        return recorder2;
      }
      function MRecordRTC(mediaStream) {
        this.addStream = function(_mediaStream) {
          if (_mediaStream) {
            mediaStream = _mediaStream;
          }
        };
        this.mediaType = {
          audio: true,
          video: true
        };
        this.startRecording = function() {
          var mediaType = this.mediaType;
          var recorderType;
          var mimeType2 = this.mimeType || {
            audio: null,
            video: null,
            gif: null
          };
          if (typeof mediaType.audio !== "function" && isMediaRecorderCompatible() && !getTracks(mediaStream, "audio").length) {
            mediaType.audio = false;
          }
          if (typeof mediaType.video !== "function" && isMediaRecorderCompatible() && !getTracks(mediaStream, "video").length) {
            mediaType.video = false;
          }
          if (typeof mediaType.gif !== "function" && isMediaRecorderCompatible() && !getTracks(mediaStream, "video").length) {
            mediaType.gif = false;
          }
          if (!mediaType.audio && !mediaType.video && !mediaType.gif) {
            throw "MediaStream must have either audio or video tracks.";
          }
          if (!!mediaType.audio) {
            recorderType = null;
            if (typeof mediaType.audio === "function") {
              recorderType = mediaType.audio;
            }
            this.audioRecorder = new RecordRTC(mediaStream, {
              type: "audio",
              bufferSize: this.bufferSize,
              sampleRate: this.sampleRate,
              numberOfAudioChannels: this.numberOfAudioChannels || 2,
              disableLogs: this.disableLogs,
              recorderType,
              mimeType: mimeType2.audio,
              timeSlice: this.timeSlice,
              onTimeStamp: this.onTimeStamp
            });
            if (!mediaType.video) {
              this.audioRecorder.startRecording();
            }
          }
          if (!!mediaType.video) {
            recorderType = null;
            if (typeof mediaType.video === "function") {
              recorderType = mediaType.video;
            }
            var newStream = mediaStream;
            if (isMediaRecorderCompatible() && !!mediaType.audio && typeof mediaType.audio === "function") {
              var videoTrack = getTracks(mediaStream, "video")[0];
              if (isFirefox) {
                newStream = new MediaStream2();
                newStream.addTrack(videoTrack);
                if (recorderType && recorderType === WhammyRecorder) {
                  recorderType = MediaStreamRecorder;
                }
              } else {
                newStream = new MediaStream2();
                newStream.addTrack(videoTrack);
              }
            }
            this.videoRecorder = new RecordRTC(newStream, {
              type: "video",
              video: this.video,
              canvas: this.canvas,
              frameInterval: this.frameInterval || 10,
              disableLogs: this.disableLogs,
              recorderType,
              mimeType: mimeType2.video,
              timeSlice: this.timeSlice,
              onTimeStamp: this.onTimeStamp,
              workerPath: this.workerPath,
              webAssemblyPath: this.webAssemblyPath,
              frameRate: this.frameRate,
              bitrate: this.bitrate
            });
            if (!mediaType.audio) {
              this.videoRecorder.startRecording();
            }
          }
          if (!!mediaType.audio && !!mediaType.video) {
            var self2 = this;
            var isSingleRecorder = isMediaRecorderCompatible() === true;
            if (mediaType.audio instanceof StereoAudioRecorder && !!mediaType.video) {
              isSingleRecorder = false;
            } else if (mediaType.audio !== true && mediaType.video !== true && mediaType.audio !== mediaType.video) {
              isSingleRecorder = false;
            }
            if (isSingleRecorder === true) {
              self2.audioRecorder = null;
              self2.videoRecorder.startRecording();
            } else {
              self2.videoRecorder.initRecorder(function() {
                self2.audioRecorder.initRecorder(function() {
                  self2.videoRecorder.startRecording();
                  self2.audioRecorder.startRecording();
                });
              });
            }
          }
          if (!!mediaType.gif) {
            recorderType = null;
            if (typeof mediaType.gif === "function") {
              recorderType = mediaType.gif;
            }
            this.gifRecorder = new RecordRTC(mediaStream, {
              type: "gif",
              frameRate: this.frameRate || 200,
              quality: this.quality || 10,
              disableLogs: this.disableLogs,
              recorderType,
              mimeType: mimeType2.gif
            });
            this.gifRecorder.startRecording();
          }
        };
        this.stopRecording = function(callback) {
          callback = callback || function() {
          };
          if (this.audioRecorder) {
            this.audioRecorder.stopRecording(function(blobURL) {
              callback(blobURL, "audio");
            });
          }
          if (this.videoRecorder) {
            this.videoRecorder.stopRecording(function(blobURL) {
              callback(blobURL, "video");
            });
          }
          if (this.gifRecorder) {
            this.gifRecorder.stopRecording(function(blobURL) {
              callback(blobURL, "gif");
            });
          }
        };
        this.pauseRecording = function() {
          if (this.audioRecorder) {
            this.audioRecorder.pauseRecording();
          }
          if (this.videoRecorder) {
            this.videoRecorder.pauseRecording();
          }
          if (this.gifRecorder) {
            this.gifRecorder.pauseRecording();
          }
        };
        this.resumeRecording = function() {
          if (this.audioRecorder) {
            this.audioRecorder.resumeRecording();
          }
          if (this.videoRecorder) {
            this.videoRecorder.resumeRecording();
          }
          if (this.gifRecorder) {
            this.gifRecorder.resumeRecording();
          }
        };
        this.getBlob = function(callback) {
          var output = {};
          if (this.audioRecorder) {
            output.audio = this.audioRecorder.getBlob();
          }
          if (this.videoRecorder) {
            output.video = this.videoRecorder.getBlob();
          }
          if (this.gifRecorder) {
            output.gif = this.gifRecorder.getBlob();
          }
          if (callback) {
            callback(output);
          }
          return output;
        };
        this.destroy = function() {
          if (this.audioRecorder) {
            this.audioRecorder.destroy();
            this.audioRecorder = null;
          }
          if (this.videoRecorder) {
            this.videoRecorder.destroy();
            this.videoRecorder = null;
          }
          if (this.gifRecorder) {
            this.gifRecorder.destroy();
            this.gifRecorder = null;
          }
        };
        this.getDataURL = function(callback) {
          this.getBlob(function(blob) {
            if (blob.audio && blob.video) {
              getDataURL(blob.audio, function(_audioDataURL) {
                getDataURL(blob.video, function(_videoDataURL) {
                  callback({
                    audio: _audioDataURL,
                    video: _videoDataURL
                  });
                });
              });
            } else if (blob.audio) {
              getDataURL(blob.audio, function(_audioDataURL) {
                callback({
                  audio: _audioDataURL
                });
              });
            } else if (blob.video) {
              getDataURL(blob.video, function(_videoDataURL) {
                callback({
                  video: _videoDataURL
                });
              });
            }
          });
          function getDataURL(blob, callback00) {
            if (typeof Worker !== "undefined") {
              var webWorker = processInWebWorker(function readFile(_blob) {
                postMessage(new FileReaderSync().readAsDataURL(_blob));
              });
              webWorker.onmessage = function(event) {
                callback00(event.data);
              };
              webWorker.postMessage(blob);
            } else {
              var reader = new FileReader();
              reader.readAsDataURL(blob);
              reader.onload = function(event) {
                callback00(event.target.result);
              };
            }
          }
          function processInWebWorker(_function) {
            var blob = URL2.createObjectURL(new Blob([
              _function.toString(),
              "this.onmessage =  function (eee) {" + _function.name + "(eee.data);}"
            ], {
              type: "application/javascript"
            }));
            var worker = new Worker(blob);
            var url;
            if (typeof URL2 !== "undefined") {
              url = URL2;
            } else if (typeof webkitURL !== "undefined") {
              url = webkitURL;
            } else {
              throw "Neither URL nor webkitURL detected.";
            }
            url.revokeObjectURL(blob);
            return worker;
          }
        };
        this.writeToDisk = function() {
          RecordRTC.writeToDisk({
            audio: this.audioRecorder,
            video: this.videoRecorder,
            gif: this.gifRecorder
          });
        };
        this.save = function(args) {
          args = args || {
            audio: true,
            video: true,
            gif: true
          };
          if (!!args.audio && this.audioRecorder) {
            this.audioRecorder.save(typeof args.audio === "string" ? args.audio : "");
          }
          if (!!args.video && this.videoRecorder) {
            this.videoRecorder.save(typeof args.video === "string" ? args.video : "");
          }
          if (!!args.gif && this.gifRecorder) {
            this.gifRecorder.save(typeof args.gif === "string" ? args.gif : "");
          }
        };
      }
      MRecordRTC.getFromDisk = RecordRTC.getFromDisk;
      MRecordRTC.writeToDisk = RecordRTC.writeToDisk;
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.MRecordRTC = MRecordRTC;
      }
      var browserFakeUserAgent = "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45";
      (function(that) {
        if (!that) {
          return;
        }
        if (typeof window !== "undefined") {
          return;
        }
        if (typeof global === "undefined") {
          return;
        }
        global.navigator = {
          userAgent: browserFakeUserAgent,
          getUserMedia: function() {
          }
        };
        if (!global.console) {
          global.console = {};
        }
        if (typeof global.console.log === "undefined" || typeof global.console.error === "undefined") {
          global.console.error = global.console.log = global.console.log || function() {
            console.log(arguments);
          };
        }
        if (typeof document === "undefined") {
          that.document = {
            documentElement: {
              appendChild: function() {
                return "";
              }
            }
          };
          document.createElement = document.captureStream = document.mozCaptureStream = function() {
            var obj = {
              getContext: function() {
                return obj;
              },
              play: function() {
              },
              pause: function() {
              },
              drawImage: function() {
              },
              toDataURL: function() {
                return "";
              },
              style: {}
            };
            return obj;
          };
          that.HTMLVideoElement = function() {
          };
        }
        if (typeof location === "undefined") {
          that.location = {
            protocol: "file:",
            href: "",
            hash: ""
          };
        }
        if (typeof screen === "undefined") {
          that.screen = {
            width: 0,
            height: 0
          };
        }
        if (typeof URL2 === "undefined") {
          that.URL = {
            createObjectURL: function() {
              return "";
            },
            revokeObjectURL: function() {
              return "";
            }
          };
        }
        that.window = global;
      })(typeof global !== "undefined" ? global : null);
      var requestAnimationFrame2 = window.requestAnimationFrame;
      if (typeof requestAnimationFrame2 === "undefined") {
        if (typeof webkitRequestAnimationFrame !== "undefined") {
          requestAnimationFrame2 = webkitRequestAnimationFrame;
        } else if (typeof mozRequestAnimationFrame !== "undefined") {
          requestAnimationFrame2 = mozRequestAnimationFrame;
        } else if (typeof msRequestAnimationFrame !== "undefined") {
          requestAnimationFrame2 = msRequestAnimationFrame;
        } else if (typeof requestAnimationFrame2 === "undefined") {
          lastTime = 0;
          requestAnimationFrame2 = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = setTimeout(function() {
              callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
          };
        }
      }
      var lastTime;
      var cancelAnimationFrame2 = window.cancelAnimationFrame;
      if (typeof cancelAnimationFrame2 === "undefined") {
        if (typeof webkitCancelAnimationFrame !== "undefined") {
          cancelAnimationFrame2 = webkitCancelAnimationFrame;
        } else if (typeof mozCancelAnimationFrame !== "undefined") {
          cancelAnimationFrame2 = mozCancelAnimationFrame;
        } else if (typeof msCancelAnimationFrame !== "undefined") {
          cancelAnimationFrame2 = msCancelAnimationFrame;
        } else if (typeof cancelAnimationFrame2 === "undefined") {
          cancelAnimationFrame2 = function(id) {
            clearTimeout(id);
          };
        }
      }
      var AudioContext = window.AudioContext;
      if (typeof AudioContext === "undefined") {
        if (typeof webkitAudioContext !== "undefined") {
          AudioContext = webkitAudioContext;
        }
        if (typeof mozAudioContext !== "undefined") {
          AudioContext = mozAudioContext;
        }
      }
      var URL2 = window.URL;
      if (typeof URL2 === "undefined" && typeof webkitURL !== "undefined") {
        URL2 = webkitURL;
      }
      if (typeof navigator !== "undefined" && typeof navigator.getUserMedia === "undefined") {
        if (typeof navigator.webkitGetUserMedia !== "undefined") {
          navigator.getUserMedia = navigator.webkitGetUserMedia;
        }
        if (typeof navigator.mozGetUserMedia !== "undefined") {
          navigator.getUserMedia = navigator.mozGetUserMedia;
        }
      }
      var isEdge = navigator.userAgent.indexOf("Edge") !== -1 && (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob);
      var isOpera = !!window.opera || navigator.userAgent.indexOf("OPR/") !== -1;
      var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && "netscape" in window && / rv:/.test(navigator.userAgent);
      var isChrome = !isOpera && !isEdge && !!navigator.webkitGetUserMedia || isElectron() || navigator.userAgent.toLowerCase().indexOf("chrome/") !== -1;
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (isSafari && !isChrome && navigator.userAgent.indexOf("CriOS") !== -1) {
        isSafari = false;
        isChrome = true;
      }
      var MediaStream2 = window.MediaStream;
      if (typeof MediaStream2 === "undefined" && typeof webkitMediaStream !== "undefined") {
        MediaStream2 = webkitMediaStream;
      }
      if (typeof MediaStream2 !== "undefined") {
        if (typeof MediaStream2.prototype.stop === "undefined") {
          MediaStream2.prototype.stop = function() {
            this.getTracks().forEach(function(track2) {
              track2.stop();
            });
          };
        }
      }
      function bytesToSize(bytes) {
        var k2 = 1e3;
        var sizes = ["Bytes", "KB", "MB", "GB", "TB"];
        if (bytes === 0) {
          return "0 Bytes";
        }
        var i8 = parseInt(Math.floor(Math.log(bytes) / Math.log(k2)), 10);
        return (bytes / Math.pow(k2, i8)).toPrecision(3) + " " + sizes[i8];
      }
      function invokeSaveAsDialog(file, fileName) {
        if (!file) {
          throw "Blob object is required.";
        }
        if (!file.type) {
          try {
            file.type = "video/webm";
          } catch (e8) {
          }
        }
        var fileExtension = (file.type || "video/webm").split("/")[1];
        if (fileExtension.indexOf(";") !== -1) {
          fileExtension = fileExtension.split(";")[0];
        }
        if (fileName && fileName.indexOf(".") !== -1) {
          var splitted = fileName.split(".");
          fileName = splitted[0];
          fileExtension = splitted[1];
        }
        var fileFullName = (fileName || Math.round(Math.random() * 9999999999) + 888888888) + "." + fileExtension;
        if (typeof navigator.msSaveOrOpenBlob !== "undefined") {
          return navigator.msSaveOrOpenBlob(file, fileFullName);
        } else if (typeof navigator.msSaveBlob !== "undefined") {
          return navigator.msSaveBlob(file, fileFullName);
        }
        var hyperlink = document.createElement("a");
        hyperlink.href = URL2.createObjectURL(file);
        hyperlink.download = fileFullName;
        hyperlink.style = "display:none;opacity:0;color:transparent;";
        (document.body || document.documentElement).appendChild(hyperlink);
        if (typeof hyperlink.click === "function") {
          hyperlink.click();
        } else {
          hyperlink.target = "_blank";
          hyperlink.dispatchEvent(new MouseEvent("click", {
            view: window,
            bubbles: true,
            cancelable: true
          }));
        }
        URL2.revokeObjectURL(hyperlink.href);
      }
      function isElectron() {
        if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
          return true;
        }
        if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
          return true;
        }
        if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
          return true;
        }
        return false;
      }
      function getTracks(stream, kind) {
        if (!stream || !stream.getTracks) {
          return [];
        }
        return stream.getTracks().filter(function(t8) {
          return t8.kind === (kind || "audio");
        });
      }
      function setSrcObject(stream, element) {
        if ("srcObject" in element) {
          element.srcObject = stream;
        } else if ("mozSrcObject" in element) {
          element.mozSrcObject = stream;
        } else {
          element.srcObject = stream;
        }
      }
      function getSeekableBlob(inputBlob, callback) {
        if (typeof EBML === "undefined") {
          throw new Error("Please link: https://www.webrtc-experiment.com/EBML.js");
        }
        var reader = new EBML.Reader();
        var decoder2 = new EBML.Decoder();
        var tools = EBML.tools;
        var fileReader = new FileReader();
        fileReader.onload = function(e8) {
          var ebmlElms = decoder2.decode(this.result);
          ebmlElms.forEach(function(element) {
            reader.read(element);
          });
          reader.stop();
          var refinedMetadataBuf = tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);
          var body = this.result.slice(reader.metadataSize);
          var newBlob = new Blob([refinedMetadataBuf, body], {
            type: "video/webm"
          });
          callback(newBlob);
        };
        fileReader.readAsArrayBuffer(inputBlob);
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.invokeSaveAsDialog = invokeSaveAsDialog;
        RecordRTC.getTracks = getTracks;
        RecordRTC.getSeekableBlob = getSeekableBlob;
        RecordRTC.bytesToSize = bytesToSize;
        RecordRTC.isElectron = isElectron;
      }
      var Storage = {};
      if (typeof AudioContext !== "undefined") {
        Storage.AudioContext = AudioContext;
      } else if (typeof webkitAudioContext !== "undefined") {
        Storage.AudioContext = webkitAudioContext;
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.Storage = Storage;
      }
      function isMediaRecorderCompatible() {
        if (isFirefox || isSafari || isEdge) {
          return true;
        }
        var nVer = navigator.appVersion;
        var nAgt = navigator.userAgent;
        var fullVersion = "" + parseFloat(navigator.appVersion);
        var majorVersion = parseInt(navigator.appVersion, 10);
        var nameOffset, verOffset, ix;
        if (isChrome || isOpera) {
          verOffset = nAgt.indexOf("Chrome");
          fullVersion = nAgt.substring(verOffset + 7);
        }
        if ((ix = fullVersion.indexOf(";")) !== -1) {
          fullVersion = fullVersion.substring(0, ix);
        }
        if ((ix = fullVersion.indexOf(" ")) !== -1) {
          fullVersion = fullVersion.substring(0, ix);
        }
        majorVersion = parseInt("" + fullVersion, 10);
        if (isNaN(majorVersion)) {
          fullVersion = "" + parseFloat(navigator.appVersion);
          majorVersion = parseInt(navigator.appVersion, 10);
        }
        return majorVersion >= 49;
      }
      function MediaStreamRecorder(mediaStream, config) {
        var self2 = this;
        if (typeof mediaStream === "undefined") {
          throw 'First argument "MediaStream" is required.';
        }
        if (typeof MediaRecorder === "undefined") {
          throw "Your browser does not support the Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.";
        }
        config = config || {
          mimeType: "video/webm"
        };
        if (config.type === "audio") {
          if (getTracks(mediaStream, "video").length && getTracks(mediaStream, "audio").length) {
            var stream;
            if (!!navigator.mozGetUserMedia) {
              stream = new MediaStream2();
              stream.addTrack(getTracks(mediaStream, "audio")[0]);
            } else {
              stream = new MediaStream2(getTracks(mediaStream, "audio"));
            }
            mediaStream = stream;
          }
          if (!config.mimeType || config.mimeType.toString().toLowerCase().indexOf("audio") === -1) {
            config.mimeType = isChrome ? "audio/webm" : "audio/ogg";
          }
          if (config.mimeType && config.mimeType.toString().toLowerCase() !== "audio/ogg" && !!navigator.mozGetUserMedia) {
            config.mimeType = "audio/ogg";
          }
        }
        var arrayOfBlobs = [];
        this.getArrayOfBlobs = function() {
          return arrayOfBlobs;
        };
        this.record = function() {
          self2.blob = null;
          self2.clearRecordedData();
          self2.timestamps = [];
          allStates = [];
          arrayOfBlobs = [];
          var recorderHints = config;
          if (!config.disableLogs) {
            console.log("Passing following config over MediaRecorder API.", recorderHints);
          }
          if (mediaRecorder) {
            mediaRecorder = null;
          }
          if (isChrome && !isMediaRecorderCompatible()) {
            recorderHints = "video/vp8";
          }
          if (typeof MediaRecorder.isTypeSupported === "function" && recorderHints.mimeType) {
            if (!MediaRecorder.isTypeSupported(recorderHints.mimeType)) {
              if (!config.disableLogs) {
                console.warn("MediaRecorder API seems unable to record mimeType:", recorderHints.mimeType);
              }
              recorderHints.mimeType = config.type === "audio" ? "audio/webm" : "video/webm";
            }
          }
          try {
            mediaRecorder = new MediaRecorder(mediaStream, recorderHints);
            config.mimeType = recorderHints.mimeType;
          } catch (e8) {
            mediaRecorder = new MediaRecorder(mediaStream);
          }
          if (recorderHints.mimeType && !MediaRecorder.isTypeSupported && "canRecordMimeType" in mediaRecorder && mediaRecorder.canRecordMimeType(recorderHints.mimeType) === false) {
            if (!config.disableLogs) {
              console.warn("MediaRecorder API seems unable to record mimeType:", recorderHints.mimeType);
            }
          }
          mediaRecorder.ondataavailable = function(e8) {
            if (e8.data) {
              allStates.push("ondataavailable: " + bytesToSize(e8.data.size));
            }
            if (typeof config.timeSlice === "number") {
              if (e8.data && e8.data.size) {
                arrayOfBlobs.push(e8.data);
                updateTimeStamp();
                if (typeof config.ondataavailable === "function") {
                  var blob = config.getNativeBlob ? e8.data : new Blob([e8.data], {
                    type: getMimeType(recorderHints)
                  });
                  config.ondataavailable(blob);
                }
              }
              return;
            }
            if (!e8.data || !e8.data.size || e8.data.size < 100 || self2.blob) {
              if (self2.recordingCallback) {
                self2.recordingCallback(new Blob([], {
                  type: getMimeType(recorderHints)
                }));
                self2.recordingCallback = null;
              }
              return;
            }
            self2.blob = config.getNativeBlob ? e8.data : new Blob([e8.data], {
              type: getMimeType(recorderHints)
            });
            if (self2.recordingCallback) {
              self2.recordingCallback(self2.blob);
              self2.recordingCallback = null;
            }
          };
          mediaRecorder.onstart = function() {
            allStates.push("started");
          };
          mediaRecorder.onpause = function() {
            allStates.push("paused");
          };
          mediaRecorder.onresume = function() {
            allStates.push("resumed");
          };
          mediaRecorder.onstop = function() {
            allStates.push("stopped");
          };
          mediaRecorder.onerror = function(error) {
            if (!error) {
              return;
            }
            if (!error.name) {
              error.name = "UnknownError";
            }
            allStates.push("error: " + error);
            if (!config.disableLogs) {
              if (error.name.toString().toLowerCase().indexOf("invalidstate") !== -1) {
                console.error("The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.", error);
              } else if (error.name.toString().toLowerCase().indexOf("notsupported") !== -1) {
                console.error("MIME type (", recorderHints.mimeType, ") is not supported.", error);
              } else if (error.name.toString().toLowerCase().indexOf("security") !== -1) {
                console.error("MediaRecorder security error", error);
              } else if (error.name === "OutOfMemory") {
                console.error("The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.", error);
              } else if (error.name === "IllegalStreamModification") {
                console.error("A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.", error);
              } else if (error.name === "OtherRecordingError") {
                console.error("Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.", error);
              } else if (error.name === "GenericError") {
                console.error("The UA cannot provide the codec or recording option that has been requested.", error);
              } else {
                console.error("MediaRecorder Error", error);
              }
            }
            (function(looper) {
              if (!self2.manuallyStopped && mediaRecorder && mediaRecorder.state === "inactive") {
                delete config.timeslice;
                mediaRecorder.start(10 * 60 * 1e3);
                return;
              }
              setTimeout(looper, 1e3);
            })();
            if (mediaRecorder.state !== "inactive" && mediaRecorder.state !== "stopped") {
              mediaRecorder.stop();
            }
          };
          if (typeof config.timeSlice === "number") {
            updateTimeStamp();
            mediaRecorder.start(config.timeSlice);
          } else {
            mediaRecorder.start(36e5);
          }
          if (config.initCallback) {
            config.initCallback();
          }
        };
        this.timestamps = [];
        function updateTimeStamp() {
          self2.timestamps.push(new Date().getTime());
          if (typeof config.onTimeStamp === "function") {
            config.onTimeStamp(self2.timestamps[self2.timestamps.length - 1], self2.timestamps);
          }
        }
        function getMimeType(secondObject) {
          if (mediaRecorder && mediaRecorder.mimeType) {
            return mediaRecorder.mimeType;
          }
          return secondObject.mimeType || "video/webm";
        }
        this.stop = function(callback) {
          callback = callback || function() {
          };
          self2.manuallyStopped = true;
          if (!mediaRecorder) {
            return;
          }
          this.recordingCallback = callback;
          if (mediaRecorder.state === "recording") {
            mediaRecorder.stop();
          }
          if (typeof config.timeSlice === "number") {
            setTimeout(function() {
              self2.blob = new Blob(arrayOfBlobs, {
                type: getMimeType(config)
              });
              self2.recordingCallback(self2.blob);
            }, 100);
          }
        };
        this.pause = function() {
          if (!mediaRecorder) {
            return;
          }
          if (mediaRecorder.state === "recording") {
            mediaRecorder.pause();
          }
        };
        this.resume = function() {
          if (!mediaRecorder) {
            return;
          }
          if (mediaRecorder.state === "paused") {
            mediaRecorder.resume();
          }
        };
        this.clearRecordedData = function() {
          if (mediaRecorder && mediaRecorder.state === "recording") {
            self2.stop(clearRecordedDataCB);
          }
          clearRecordedDataCB();
        };
        function clearRecordedDataCB() {
          arrayOfBlobs = [];
          mediaRecorder = null;
          self2.timestamps = [];
        }
        var mediaRecorder;
        this.getInternalRecorder = function() {
          return mediaRecorder;
        };
        function isMediaStreamActive() {
          if ("active" in mediaStream) {
            if (!mediaStream.active) {
              return false;
            }
          } else if ("ended" in mediaStream) {
            if (mediaStream.ended) {
              return false;
            }
          }
          return true;
        }
        this.blob = null;
        this.getState = function() {
          if (!mediaRecorder) {
            return "inactive";
          }
          return mediaRecorder.state || "inactive";
        };
        var allStates = [];
        this.getAllStates = function() {
          return allStates;
        };
        if (typeof config.checkForInactiveTracks === "undefined") {
          config.checkForInactiveTracks = false;
        }
        var self2 = this;
        (function looper() {
          if (!mediaRecorder || config.checkForInactiveTracks === false) {
            return;
          }
          if (isMediaStreamActive() === false) {
            if (!config.disableLogs) {
              console.log("MediaStream seems stopped.");
            }
            self2.stop();
            return;
          }
          setTimeout(looper, 1e3);
        })();
        this.name = "MediaStreamRecorder";
        this.toString = function() {
          return this.name;
        };
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.MediaStreamRecorder = MediaStreamRecorder;
      }
      function StereoAudioRecorder(mediaStream, config) {
        if (!getTracks(mediaStream, "audio").length) {
          throw "Your stream has no audio tracks.";
        }
        config = config || {};
        var self2 = this;
        var leftchannel = [];
        var rightchannel = [];
        var recording2 = false;
        var recordingLength = 0;
        var jsAudioNode;
        var numberOfAudioChannels = 2;
        var desiredSampRate = config.desiredSampRate;
        if (config.leftChannel === true) {
          numberOfAudioChannels = 1;
        }
        if (config.numberOfAudioChannels === 1) {
          numberOfAudioChannels = 1;
        }
        if (!numberOfAudioChannels || numberOfAudioChannels < 1) {
          numberOfAudioChannels = 2;
        }
        if (!config.disableLogs) {
          console.log("StereoAudioRecorder is set to record number of channels: " + numberOfAudioChannels);
        }
        if (typeof config.checkForInactiveTracks === "undefined") {
          config.checkForInactiveTracks = true;
        }
        function isMediaStreamActive() {
          if (config.checkForInactiveTracks === false) {
            return true;
          }
          if ("active" in mediaStream) {
            if (!mediaStream.active) {
              return false;
            }
          } else if ("ended" in mediaStream) {
            if (mediaStream.ended) {
              return false;
            }
          }
          return true;
        }
        this.record = function() {
          if (isMediaStreamActive() === false) {
            throw "Please make sure MediaStream is active.";
          }
          resetVariables();
          isAudioProcessStarted = isPaused = false;
          recording2 = true;
          if (typeof config.timeSlice !== "undefined") {
            looper();
          }
        };
        function mergeLeftRightBuffers(config2, callback) {
          function mergeAudioBuffers(config3, cb) {
            var numberOfAudioChannels2 = config3.numberOfAudioChannels;
            var leftBuffers = config3.leftBuffers.slice(0);
            var rightBuffers = config3.rightBuffers.slice(0);
            var sampleRate2 = config3.sampleRate;
            var internalInterleavedLength = config3.internalInterleavedLength;
            var desiredSampRate2 = config3.desiredSampRate;
            if (numberOfAudioChannels2 === 2) {
              leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);
              rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength);
              if (desiredSampRate2) {
                leftBuffers = interpolateArray(leftBuffers, desiredSampRate2, sampleRate2);
                rightBuffers = interpolateArray(rightBuffers, desiredSampRate2, sampleRate2);
              }
            }
            if (numberOfAudioChannels2 === 1) {
              leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);
              if (desiredSampRate2) {
                leftBuffers = interpolateArray(leftBuffers, desiredSampRate2, sampleRate2);
              }
            }
            if (desiredSampRate2) {
              sampleRate2 = desiredSampRate2;
            }
            function interpolateArray(data, newSampleRate, oldSampleRate) {
              var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));
              var newData = [];
              var springFactor = Number((data.length - 1) / (fitCount - 1));
              newData[0] = data[0];
              for (var i9 = 1; i9 < fitCount - 1; i9++) {
                var tmp = i9 * springFactor;
                var before = Number(Math.floor(tmp)).toFixed();
                var after = Number(Math.ceil(tmp)).toFixed();
                var atPoint = tmp - before;
                newData[i9] = linearInterpolate(data[before], data[after], atPoint);
              }
              newData[fitCount - 1] = data[data.length - 1];
              return newData;
            }
            function linearInterpolate(before, after, atPoint) {
              return before + (after - before) * atPoint;
            }
            function mergeBuffers(channelBuffer, rLength) {
              var result = new Float64Array(rLength);
              var offset = 0;
              var lng2 = channelBuffer.length;
              for (var i9 = 0; i9 < lng2; i9++) {
                var buffer3 = channelBuffer[i9];
                result.set(buffer3, offset);
                offset += buffer3.length;
              }
              return result;
            }
            function interleave(leftChannel, rightChannel) {
              var length = leftChannel.length + rightChannel.length;
              var result = new Float64Array(length);
              var inputIndex = 0;
              for (var index16 = 0; index16 < length; ) {
                result[index16++] = leftChannel[inputIndex];
                result[index16++] = rightChannel[inputIndex];
                inputIndex++;
              }
              return result;
            }
            function writeUTFBytes(view2, offset, string) {
              var lng2 = string.length;
              for (var i9 = 0; i9 < lng2; i9++) {
                view2.setUint8(offset + i9, string.charCodeAt(i9));
              }
            }
            var interleaved;
            if (numberOfAudioChannels2 === 2) {
              interleaved = interleave(leftBuffers, rightBuffers);
            }
            if (numberOfAudioChannels2 === 1) {
              interleaved = leftBuffers;
            }
            var interleavedLength = interleaved.length;
            var resultingBufferLength = 44 + interleavedLength * 2;
            var buffer2 = new ArrayBuffer(resultingBufferLength);
            var view = new DataView(buffer2);
            writeUTFBytes(view, 0, "RIFF");
            view.setUint32(4, 36 + interleavedLength * 2, true);
            writeUTFBytes(view, 8, "WAVE");
            writeUTFBytes(view, 12, "fmt ");
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfAudioChannels2, true);
            view.setUint32(24, sampleRate2, true);
            view.setUint32(28, sampleRate2 * numberOfAudioChannels2 * 2, true);
            view.setUint16(32, numberOfAudioChannels2 * 2, true);
            view.setUint16(34, 16, true);
            writeUTFBytes(view, 36, "data");
            view.setUint32(40, interleavedLength * 2, true);
            var lng = interleavedLength;
            var index15 = 44;
            var volume = 1;
            for (var i8 = 0; i8 < lng; i8++) {
              view.setInt16(index15, interleaved[i8] * (32767 * volume), true);
              index15 += 2;
            }
            if (cb) {
              return cb({
                buffer: buffer2,
                view
              });
            }
            postMessage({
              buffer: buffer2,
              view
            });
          }
          if (config2.noWorker) {
            mergeAudioBuffers(config2, function(data) {
              callback(data.buffer, data.view);
            });
            return;
          }
          var webWorker = processInWebWorker(mergeAudioBuffers);
          webWorker.onmessage = function(event) {
            callback(event.data.buffer, event.data.view);
            URL2.revokeObjectURL(webWorker.workerURL);
            webWorker.terminate();
          };
          webWorker.postMessage(config2);
        }
        function processInWebWorker(_function) {
          var workerURL = URL2.createObjectURL(new Blob([
            _function.toString(),
            ";this.onmessage =  function (eee) {" + _function.name + "(eee.data);}"
          ], {
            type: "application/javascript"
          }));
          var worker = new Worker(workerURL);
          worker.workerURL = workerURL;
          return worker;
        }
        this.stop = function(callback) {
          callback = callback || function() {
          };
          recording2 = false;
          mergeLeftRightBuffers({
            desiredSampRate,
            sampleRate,
            numberOfAudioChannels,
            internalInterleavedLength: recordingLength,
            leftBuffers: leftchannel,
            rightBuffers: numberOfAudioChannels === 1 ? [] : rightchannel,
            noWorker: config.noWorker
          }, function(buffer2, view) {
            self2.blob = new Blob([view], {
              type: "audio/wav"
            });
            self2.buffer = new ArrayBuffer(view.buffer.byteLength);
            self2.view = view;
            self2.sampleRate = desiredSampRate || sampleRate;
            self2.bufferSize = bufferSize;
            self2.length = recordingLength;
            isAudioProcessStarted = false;
            if (callback) {
              callback(self2.blob);
            }
          });
        };
        if (typeof RecordRTC.Storage === "undefined") {
          RecordRTC.Storage = {
            AudioContextConstructor: null,
            AudioContext: window.AudioContext || window.webkitAudioContext
          };
        }
        if (!RecordRTC.Storage.AudioContextConstructor || RecordRTC.Storage.AudioContextConstructor.state === "closed") {
          RecordRTC.Storage.AudioContextConstructor = new RecordRTC.Storage.AudioContext();
        }
        var context2 = RecordRTC.Storage.AudioContextConstructor;
        var audioInput = context2.createMediaStreamSource(mediaStream);
        var legalBufferValues = [0, 256, 512, 1024, 2048, 4096, 8192, 16384];
        var bufferSize = typeof config.bufferSize === "undefined" ? 4096 : config.bufferSize;
        if (legalBufferValues.indexOf(bufferSize) === -1) {
          if (!config.disableLogs) {
            console.log("Legal values for buffer-size are " + JSON.stringify(legalBufferValues, null, "	"));
          }
        }
        if (context2.createJavaScriptNode) {
          jsAudioNode = context2.createJavaScriptNode(bufferSize, numberOfAudioChannels, numberOfAudioChannels);
        } else if (context2.createScriptProcessor) {
          jsAudioNode = context2.createScriptProcessor(bufferSize, numberOfAudioChannels, numberOfAudioChannels);
        } else {
          throw "WebAudio API has no support on this browser.";
        }
        audioInput.connect(jsAudioNode);
        if (!config.bufferSize) {
          bufferSize = jsAudioNode.bufferSize;
        }
        var sampleRate = typeof config.sampleRate !== "undefined" ? config.sampleRate : context2.sampleRate || 44100;
        if (sampleRate < 22050 || sampleRate > 96e3) {
          if (!config.disableLogs) {
            console.log("sample-rate must be under range 22050 and 96000.");
          }
        }
        if (!config.disableLogs) {
          if (config.desiredSampRate) {
            console.log("Desired sample-rate: " + config.desiredSampRate);
          }
        }
        var isPaused = false;
        this.pause = function() {
          isPaused = true;
        };
        this.resume = function() {
          if (isMediaStreamActive() === false) {
            throw "Please make sure MediaStream is active.";
          }
          if (!recording2) {
            if (!config.disableLogs) {
              console.log("Seems recording has been restarted.");
            }
            this.record();
            return;
          }
          isPaused = false;
        };
        this.clearRecordedData = function() {
          config.checkForInactiveTracks = false;
          if (recording2) {
            this.stop(clearRecordedDataCB);
          }
          clearRecordedDataCB();
        };
        function resetVariables() {
          leftchannel = [];
          rightchannel = [];
          recordingLength = 0;
          isAudioProcessStarted = false;
          recording2 = false;
          isPaused = false;
          context2 = null;
          self2.leftchannel = leftchannel;
          self2.rightchannel = rightchannel;
          self2.numberOfAudioChannels = numberOfAudioChannels;
          self2.desiredSampRate = desiredSampRate;
          self2.sampleRate = sampleRate;
          self2.recordingLength = recordingLength;
          intervalsBasedBuffers = {
            left: [],
            right: [],
            recordingLength: 0
          };
        }
        function clearRecordedDataCB() {
          if (jsAudioNode) {
            jsAudioNode.onaudioprocess = null;
            jsAudioNode.disconnect();
            jsAudioNode = null;
          }
          if (audioInput) {
            audioInput.disconnect();
            audioInput = null;
          }
          resetVariables();
        }
        this.name = "StereoAudioRecorder";
        this.toString = function() {
          return this.name;
        };
        var isAudioProcessStarted = false;
        function onAudioProcessDataAvailable(e8) {
          if (isPaused) {
            return;
          }
          if (isMediaStreamActive() === false) {
            if (!config.disableLogs) {
              console.log("MediaStream seems stopped.");
            }
            jsAudioNode.disconnect();
            recording2 = false;
          }
          if (!recording2) {
            if (audioInput) {
              audioInput.disconnect();
              audioInput = null;
            }
            return;
          }
          if (!isAudioProcessStarted) {
            isAudioProcessStarted = true;
            if (config.onAudioProcessStarted) {
              config.onAudioProcessStarted();
            }
            if (config.initCallback) {
              config.initCallback();
            }
          }
          var left = e8.inputBuffer.getChannelData(0);
          var chLeft = new Float32Array(left);
          leftchannel.push(chLeft);
          if (numberOfAudioChannels === 2) {
            var right = e8.inputBuffer.getChannelData(1);
            var chRight = new Float32Array(right);
            rightchannel.push(chRight);
          }
          recordingLength += bufferSize;
          self2.recordingLength = recordingLength;
          if (typeof config.timeSlice !== "undefined") {
            intervalsBasedBuffers.recordingLength += bufferSize;
            intervalsBasedBuffers.left.push(chLeft);
            if (numberOfAudioChannels === 2) {
              intervalsBasedBuffers.right.push(chRight);
            }
          }
        }
        jsAudioNode.onaudioprocess = onAudioProcessDataAvailable;
        if (context2.createMediaStreamDestination) {
          jsAudioNode.connect(context2.createMediaStreamDestination());
        } else {
          jsAudioNode.connect(context2.destination);
        }
        this.leftchannel = leftchannel;
        this.rightchannel = rightchannel;
        this.numberOfAudioChannels = numberOfAudioChannels;
        this.desiredSampRate = desiredSampRate;
        this.sampleRate = sampleRate;
        self2.recordingLength = recordingLength;
        var intervalsBasedBuffers = {
          left: [],
          right: [],
          recordingLength: 0
        };
        function looper() {
          if (!recording2 || typeof config.ondataavailable !== "function" || typeof config.timeSlice === "undefined") {
            return;
          }
          if (intervalsBasedBuffers.left.length) {
            mergeLeftRightBuffers({
              desiredSampRate,
              sampleRate,
              numberOfAudioChannels,
              internalInterleavedLength: intervalsBasedBuffers.recordingLength,
              leftBuffers: intervalsBasedBuffers.left,
              rightBuffers: numberOfAudioChannels === 1 ? [] : intervalsBasedBuffers.right
            }, function(buffer2, view) {
              var blob = new Blob([view], {
                type: "audio/wav"
              });
              config.ondataavailable(blob);
              setTimeout(looper, config.timeSlice);
            });
            intervalsBasedBuffers = {
              left: [],
              right: [],
              recordingLength: 0
            };
          } else {
            setTimeout(looper, config.timeSlice);
          }
        }
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.StereoAudioRecorder = StereoAudioRecorder;
      }
      function CanvasRecorder(htmlElement, config) {
        if (typeof html2canvas === "undefined") {
          throw "Please link: https://www.webrtc-experiment.com/screenshot.js";
        }
        config = config || {};
        if (!config.frameInterval) {
          config.frameInterval = 10;
        }
        var isCanvasSupportsStreamCapturing = false;
        ["captureStream", "mozCaptureStream", "webkitCaptureStream"].forEach(function(item) {
          if (item in document.createElement("canvas")) {
            isCanvasSupportsStreamCapturing = true;
          }
        });
        var _isChrome = (!!window.webkitRTCPeerConnection || !!window.webkitGetUserMedia) && !!window.chrome;
        var chromeVersion = 50;
        var matchArray = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
        if (_isChrome && matchArray && matchArray[2]) {
          chromeVersion = parseInt(matchArray[2], 10);
        }
        if (_isChrome && chromeVersion < 52) {
          isCanvasSupportsStreamCapturing = false;
        }
        if (config.useWhammyRecorder) {
          isCanvasSupportsStreamCapturing = false;
        }
        var globalCanvas, mediaStreamRecorder;
        if (isCanvasSupportsStreamCapturing) {
          if (!config.disableLogs) {
            console.log("Your browser supports both MediRecorder API and canvas.captureStream!");
          }
          if (htmlElement instanceof HTMLCanvasElement) {
            globalCanvas = htmlElement;
          } else if (htmlElement instanceof CanvasRenderingContext2D) {
            globalCanvas = htmlElement.canvas;
          } else {
            throw "Please pass either HTMLCanvasElement or CanvasRenderingContext2D.";
          }
        } else if (!!navigator.mozGetUserMedia) {
          if (!config.disableLogs) {
            console.error("Canvas recording is NOT supported in Firefox.");
          }
        }
        var isRecording;
        this.record = function() {
          isRecording = true;
          if (isCanvasSupportsStreamCapturing && !config.useWhammyRecorder) {
            var canvasMediaStream;
            if ("captureStream" in globalCanvas) {
              canvasMediaStream = globalCanvas.captureStream(25);
            } else if ("mozCaptureStream" in globalCanvas) {
              canvasMediaStream = globalCanvas.mozCaptureStream(25);
            } else if ("webkitCaptureStream" in globalCanvas) {
              canvasMediaStream = globalCanvas.webkitCaptureStream(25);
            }
            try {
              var mdStream = new MediaStream2();
              mdStream.addTrack(getTracks(canvasMediaStream, "video")[0]);
              canvasMediaStream = mdStream;
            } catch (e8) {
            }
            if (!canvasMediaStream) {
              throw "captureStream API are NOT available.";
            }
            mediaStreamRecorder = new MediaStreamRecorder(canvasMediaStream, {
              mimeType: config.mimeType || "video/webm"
            });
            mediaStreamRecorder.record();
          } else {
            whammy.frames = [];
            lastTime2 = new Date().getTime();
            drawCanvasFrame();
          }
          if (config.initCallback) {
            config.initCallback();
          }
        };
        this.getWebPImages = function(callback) {
          if (htmlElement.nodeName.toLowerCase() !== "canvas") {
            callback();
            return;
          }
          var framesLength = whammy.frames.length;
          whammy.frames.forEach(function(frame, idx) {
            var framesRemaining = framesLength - idx;
            if (!config.disableLogs) {
              console.log(framesRemaining + "/" + framesLength + " frames remaining");
            }
            if (config.onEncodingCallback) {
              config.onEncodingCallback(framesRemaining, framesLength);
            }
            var webp = frame.image.toDataURL("image/webp", 1);
            whammy.frames[idx].image = webp;
          });
          if (!config.disableLogs) {
            console.log("Generating WebM");
          }
          callback();
        };
        this.stop = function(callback) {
          isRecording = false;
          var that = this;
          if (isCanvasSupportsStreamCapturing && mediaStreamRecorder) {
            mediaStreamRecorder.stop(callback);
            return;
          }
          this.getWebPImages(function() {
            whammy.compile(function(blob) {
              if (!config.disableLogs) {
                console.log("Recording finished!");
              }
              that.blob = blob;
              if (that.blob.forEach) {
                that.blob = new Blob([], {
                  type: "video/webm"
                });
              }
              if (callback) {
                callback(that.blob);
              }
              whammy.frames = [];
            });
          });
        };
        var isPausedRecording = false;
        this.pause = function() {
          isPausedRecording = true;
          if (mediaStreamRecorder instanceof MediaStreamRecorder) {
            mediaStreamRecorder.pause();
            return;
          }
        };
        this.resume = function() {
          isPausedRecording = false;
          if (mediaStreamRecorder instanceof MediaStreamRecorder) {
            mediaStreamRecorder.resume();
            return;
          }
          if (!isRecording) {
            this.record();
          }
        };
        this.clearRecordedData = function() {
          if (isRecording) {
            this.stop(clearRecordedDataCB);
          }
          clearRecordedDataCB();
        };
        function clearRecordedDataCB() {
          whammy.frames = [];
          isRecording = false;
          isPausedRecording = false;
        }
        this.name = "CanvasRecorder";
        this.toString = function() {
          return this.name;
        };
        function cloneCanvas() {
          var newCanvas = document.createElement("canvas");
          var context2 = newCanvas.getContext("2d");
          newCanvas.width = htmlElement.width;
          newCanvas.height = htmlElement.height;
          context2.drawImage(htmlElement, 0, 0);
          return newCanvas;
        }
        function drawCanvasFrame() {
          if (isPausedRecording) {
            lastTime2 = new Date().getTime();
            return setTimeout(drawCanvasFrame, 500);
          }
          if (htmlElement.nodeName.toLowerCase() === "canvas") {
            var duration2 = new Date().getTime() - lastTime2;
            lastTime2 = new Date().getTime();
            whammy.frames.push({
              image: cloneCanvas(),
              duration: duration2
            });
            if (isRecording) {
              setTimeout(drawCanvasFrame, config.frameInterval);
            }
            return;
          }
          html2canvas(htmlElement, {
            grabMouse: typeof config.showMousePointer === "undefined" || config.showMousePointer,
            onrendered: function(canvas) {
              var duration3 = new Date().getTime() - lastTime2;
              if (!duration3) {
                return setTimeout(drawCanvasFrame, config.frameInterval);
              }
              lastTime2 = new Date().getTime();
              whammy.frames.push({
                image: canvas.toDataURL("image/webp", 1),
                duration: duration3
              });
              if (isRecording) {
                setTimeout(drawCanvasFrame, config.frameInterval);
              }
            }
          });
        }
        var lastTime2 = new Date().getTime();
        var whammy = new Whammy.Video(100);
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.CanvasRecorder = CanvasRecorder;
      }
      function WhammyRecorder(mediaStream, config) {
        config = config || {};
        if (!config.frameInterval) {
          config.frameInterval = 10;
        }
        if (!config.disableLogs) {
          console.log("Using frames-interval:", config.frameInterval);
        }
        this.record = function() {
          if (!config.width) {
            config.width = 320;
          }
          if (!config.height) {
            config.height = 240;
          }
          if (!config.video) {
            config.video = {
              width: config.width,
              height: config.height
            };
          }
          if (!config.canvas) {
            config.canvas = {
              width: config.width,
              height: config.height
            };
          }
          canvas.width = config.canvas.width || 320;
          canvas.height = config.canvas.height || 240;
          context2 = canvas.getContext("2d");
          if (config.video && config.video instanceof HTMLVideoElement) {
            video = config.video.cloneNode();
            if (config.initCallback) {
              config.initCallback();
            }
          } else {
            video = document.createElement("video");
            setSrcObject(mediaStream, video);
            video.onloadedmetadata = function() {
              if (config.initCallback) {
                config.initCallback();
              }
            };
            video.width = config.video.width;
            video.height = config.video.height;
          }
          video.muted = true;
          video.play();
          lastTime2 = new Date().getTime();
          whammy = new Whammy.Video();
          if (!config.disableLogs) {
            console.log("canvas resolutions", canvas.width, "*", canvas.height);
            console.log("video width/height", video.width || canvas.width, "*", video.height || canvas.height);
          }
          drawFrames(config.frameInterval);
        };
        function drawFrames(frameInterval) {
          frameInterval = typeof frameInterval !== "undefined" ? frameInterval : 10;
          var duration2 = new Date().getTime() - lastTime2;
          if (!duration2) {
            return setTimeout(drawFrames, frameInterval, frameInterval);
          }
          if (isPausedRecording) {
            lastTime2 = new Date().getTime();
            return setTimeout(drawFrames, 100);
          }
          lastTime2 = new Date().getTime();
          if (video.paused) {
            video.play();
          }
          context2.drawImage(video, 0, 0, canvas.width, canvas.height);
          whammy.frames.push({
            duration: duration2,
            image: canvas.toDataURL("image/webp")
          });
          if (!isStopDrawing) {
            setTimeout(drawFrames, frameInterval, frameInterval);
          }
        }
        function asyncLoop(o8) {
          var i8 = -1, length = o8.length;
          (function loop() {
            i8++;
            if (i8 === length) {
              o8.callback();
              return;
            }
            setTimeout(function() {
              o8.functionToLoop(loop, i8);
            }, 1);
          })();
        }
        function dropBlackFrames(_frames, _framesToCheck, _pixTolerance, _frameTolerance, callback) {
          var localCanvas = document.createElement("canvas");
          localCanvas.width = canvas.width;
          localCanvas.height = canvas.height;
          var context2d = localCanvas.getContext("2d");
          var resultFrames = [];
          var checkUntilNotBlack = _framesToCheck === -1;
          var endCheckFrame = _framesToCheck && _framesToCheck > 0 && _framesToCheck <= _frames.length ? _framesToCheck : _frames.length;
          var sampleColor = {
            r: 0,
            g: 0,
            b: 0
          };
          var maxColorDifference = Math.sqrt(Math.pow(255, 2) + Math.pow(255, 2) + Math.pow(255, 2));
          var pixTolerance = _pixTolerance && _pixTolerance >= 0 && _pixTolerance <= 1 ? _pixTolerance : 0;
          var frameTolerance = _frameTolerance && _frameTolerance >= 0 && _frameTolerance <= 1 ? _frameTolerance : 0;
          var doNotCheckNext = false;
          asyncLoop({
            length: endCheckFrame,
            functionToLoop: function(loop, f4) {
              var matchPixCount, endPixCheck, maxPixCount;
              var finishImage = function() {
                if (!doNotCheckNext && maxPixCount - matchPixCount <= maxPixCount * frameTolerance) {
                } else {
                  if (checkUntilNotBlack) {
                    doNotCheckNext = true;
                  }
                  resultFrames.push(_frames[f4]);
                }
                loop();
              };
              if (!doNotCheckNext) {
                var image = new Image();
                image.onload = function() {
                  context2d.drawImage(image, 0, 0, canvas.width, canvas.height);
                  var imageData = context2d.getImageData(0, 0, canvas.width, canvas.height);
                  matchPixCount = 0;
                  endPixCheck = imageData.data.length;
                  maxPixCount = imageData.data.length / 4;
                  for (var pix = 0; pix < endPixCheck; pix += 4) {
                    var currentColor = {
                      r: imageData.data[pix],
                      g: imageData.data[pix + 1],
                      b: imageData.data[pix + 2]
                    };
                    var colorDifference = Math.sqrt(Math.pow(currentColor.r - sampleColor.r, 2) + Math.pow(currentColor.g - sampleColor.g, 2) + Math.pow(currentColor.b - sampleColor.b, 2));
                    if (colorDifference <= maxColorDifference * pixTolerance) {
                      matchPixCount++;
                    }
                  }
                  finishImage();
                };
                image.src = _frames[f4].image;
              } else {
                finishImage();
              }
            },
            callback: function() {
              resultFrames = resultFrames.concat(_frames.slice(endCheckFrame));
              if (resultFrames.length <= 0) {
                resultFrames.push(_frames[_frames.length - 1]);
              }
              callback(resultFrames);
            }
          });
        }
        var isStopDrawing = false;
        this.stop = function(callback) {
          callback = callback || function() {
          };
          isStopDrawing = true;
          var _this = this;
          setTimeout(function() {
            dropBlackFrames(whammy.frames, -1, null, null, function(frames) {
              whammy.frames = frames;
              if (config.advertisement && config.advertisement.length) {
                whammy.frames = config.advertisement.concat(whammy.frames);
              }
              whammy.compile(function(blob) {
                _this.blob = blob;
                if (_this.blob.forEach) {
                  _this.blob = new Blob([], {
                    type: "video/webm"
                  });
                }
                if (callback) {
                  callback(_this.blob);
                }
              });
            });
          }, 10);
        };
        var isPausedRecording = false;
        this.pause = function() {
          isPausedRecording = true;
        };
        this.resume = function() {
          isPausedRecording = false;
          if (isStopDrawing) {
            this.record();
          }
        };
        this.clearRecordedData = function() {
          if (!isStopDrawing) {
            this.stop(clearRecordedDataCB);
          }
          clearRecordedDataCB();
        };
        function clearRecordedDataCB() {
          whammy.frames = [];
          isStopDrawing = true;
          isPausedRecording = false;
        }
        this.name = "WhammyRecorder";
        this.toString = function() {
          return this.name;
        };
        var canvas = document.createElement("canvas");
        var context2 = canvas.getContext("2d");
        var video;
        var lastTime2;
        var whammy;
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.WhammyRecorder = WhammyRecorder;
      }
      var Whammy = function() {
        function WhammyVideo(duration2) {
          this.frames = [];
          this.duration = duration2 || 1;
          this.quality = 0.8;
        }
        WhammyVideo.prototype.add = function(frame, duration2) {
          if ("canvas" in frame) {
            frame = frame.canvas;
          }
          if ("toDataURL" in frame) {
            frame = frame.toDataURL("image/webp", this.quality);
          }
          if (!/^data:image\/webp;base64,/ig.test(frame)) {
            throw "Input must be formatted properly as a base64 encoded DataURI of type image/webp";
          }
          this.frames.push({
            image: frame,
            duration: duration2 || this.duration
          });
        };
        function processInWebWorker(_function) {
          var blob = URL2.createObjectURL(new Blob([
            _function.toString(),
            "this.onmessage =  function (eee) {" + _function.name + "(eee.data);}"
          ], {
            type: "application/javascript"
          }));
          var worker = new Worker(blob);
          URL2.revokeObjectURL(blob);
          return worker;
        }
        function whammyInWebWorker(frames) {
          function ArrayToWebM(frames2) {
            var info = checkFrames(frames2);
            if (!info) {
              return [];
            }
            var clusterMaxDuration = 3e4;
            var EBML2 = [{
              "id": 440786851,
              "data": [{
                "data": 1,
                "id": 17030
              }, {
                "data": 1,
                "id": 17143
              }, {
                "data": 4,
                "id": 17138
              }, {
                "data": 8,
                "id": 17139
              }, {
                "data": "webm",
                "id": 17026
              }, {
                "data": 2,
                "id": 17031
              }, {
                "data": 2,
                "id": 17029
              }]
            }, {
              "id": 408125543,
              "data": [{
                "id": 357149030,
                "data": [{
                  "data": 1e6,
                  "id": 2807729
                }, {
                  "data": "whammy",
                  "id": 19840
                }, {
                  "data": "whammy",
                  "id": 22337
                }, {
                  "data": doubleToString(info.duration),
                  "id": 17545
                }]
              }, {
                "id": 374648427,
                "data": [{
                  "id": 174,
                  "data": [{
                    "data": 1,
                    "id": 215
                  }, {
                    "data": 1,
                    "id": 29637
                  }, {
                    "data": 0,
                    "id": 156
                  }, {
                    "data": "und",
                    "id": 2274716
                  }, {
                    "data": "V_VP8",
                    "id": 134
                  }, {
                    "data": "VP8",
                    "id": 2459272
                  }, {
                    "data": 1,
                    "id": 131
                  }, {
                    "id": 224,
                    "data": [{
                      "data": info.width,
                      "id": 176
                    }, {
                      "data": info.height,
                      "id": 186
                    }]
                  }]
                }]
              }]
            }];
            var frameNumber = 0;
            var clusterTimecode = 0;
            while (frameNumber < frames2.length) {
              var clusterFrames = [];
              var clusterDuration = 0;
              do {
                clusterFrames.push(frames2[frameNumber]);
                clusterDuration += frames2[frameNumber].duration;
                frameNumber++;
              } while (frameNumber < frames2.length && clusterDuration < clusterMaxDuration);
              var clusterCounter = 0;
              var cluster = {
                "id": 524531317,
                "data": getClusterData(clusterTimecode, clusterCounter, clusterFrames)
              };
              EBML2[1].data.push(cluster);
              clusterTimecode += clusterDuration;
            }
            return generateEBML(EBML2);
          }
          function getClusterData(clusterTimecode, clusterCounter, clusterFrames) {
            return [{
              "data": clusterTimecode,
              "id": 231
            }].concat(clusterFrames.map(function(webp) {
              var block = makeSimpleBlock({
                discardable: 0,
                frame: webp.data.slice(4),
                invisible: 0,
                keyframe: 1,
                lacing: 0,
                trackNum: 1,
                timecode: Math.round(clusterCounter)
              });
              clusterCounter += webp.duration;
              return {
                data: block,
                id: 163
              };
            }));
          }
          function checkFrames(frames2) {
            if (!frames2[0]) {
              postMessage({
                error: "Something went wrong. Maybe WebP format is not supported in the current browser."
              });
              return;
            }
            var width = frames2[0].width, height = frames2[0].height, duration2 = frames2[0].duration;
            for (var i8 = 1; i8 < frames2.length; i8++) {
              duration2 += frames2[i8].duration;
            }
            return {
              duration: duration2,
              width,
              height
            };
          }
          function numToBuffer(num2) {
            var parts = [];
            while (num2 > 0) {
              parts.push(num2 & 255);
              num2 = num2 >> 8;
            }
            return new Uint8Array(parts.reverse());
          }
          function strToBuffer(str) {
            return new Uint8Array(str.split("").map(function(e8) {
              return e8.charCodeAt(0);
            }));
          }
          function bitsToBuffer(bits) {
            var data = [];
            var pad = bits.length % 8 ? new Array(1 + 8 - bits.length % 8).join("0") : "";
            bits = pad + bits;
            for (var i8 = 0; i8 < bits.length; i8 += 8) {
              data.push(parseInt(bits.substr(i8, 8), 2));
            }
            return new Uint8Array(data);
          }
          function generateEBML(json) {
            var ebml = [];
            for (var i8 = 0; i8 < json.length; i8++) {
              var data = json[i8].data;
              if (typeof data === "object") {
                data = generateEBML(data);
              }
              if (typeof data === "number") {
                data = bitsToBuffer(data.toString(2));
              }
              if (typeof data === "string") {
                data = strToBuffer(data);
              }
              var len = data.size || data.byteLength || data.length;
              var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);
              var sizeToString = len.toString(2);
              var padded = new Array(zeroes * 7 + 7 + 1 - sizeToString.length).join("0") + sizeToString;
              var size2 = new Array(zeroes).join("0") + "1" + padded;
              ebml.push(numToBuffer(json[i8].id));
              ebml.push(bitsToBuffer(size2));
              ebml.push(data);
            }
            return new Blob(ebml, {
              type: "video/webm"
            });
          }
          function toBinStrOld(bits) {
            var data = "";
            var pad = bits.length % 8 ? new Array(1 + 8 - bits.length % 8).join("0") : "";
            bits = pad + bits;
            for (var i8 = 0; i8 < bits.length; i8 += 8) {
              data += String.fromCharCode(parseInt(bits.substr(i8, 8), 2));
            }
            return data;
          }
          function makeSimpleBlock(data) {
            var flags = 0;
            if (data.keyframe) {
              flags |= 128;
            }
            if (data.invisible) {
              flags |= 8;
            }
            if (data.lacing) {
              flags |= data.lacing << 1;
            }
            if (data.discardable) {
              flags |= 1;
            }
            if (data.trackNum > 127) {
              throw "TrackNumber > 127 not supported";
            }
            var out = [data.trackNum | 128, data.timecode >> 8, data.timecode & 255, flags].map(function(e8) {
              return String.fromCharCode(e8);
            }).join("") + data.frame;
            return out;
          }
          function parseWebP(riff) {
            var VP8 = riff.RIFF[0].WEBP[0];
            var frameStart = VP8.indexOf("\x9D*");
            for (var i8 = 0, c6 = []; i8 < 4; i8++) {
              c6[i8] = VP8.charCodeAt(frameStart + 3 + i8);
            }
            var width, height, tmp;
            tmp = c6[1] << 8 | c6[0];
            width = tmp & 16383;
            tmp = c6[3] << 8 | c6[2];
            height = tmp & 16383;
            return {
              width,
              height,
              data: VP8,
              riff
            };
          }
          function getStrLength(string, offset) {
            return parseInt(string.substr(offset + 4, 4).split("").map(function(i8) {
              var unpadded = i8.charCodeAt(0).toString(2);
              return new Array(8 - unpadded.length + 1).join("0") + unpadded;
            }).join(""), 2);
          }
          function parseRIFF(string) {
            var offset = 0;
            var chunks = {};
            while (offset < string.length) {
              var id = string.substr(offset, 4);
              var len = getStrLength(string, offset);
              var data = string.substr(offset + 4 + 4, len);
              offset += 4 + 4 + len;
              chunks[id] = chunks[id] || [];
              if (id === "RIFF" || id === "LIST") {
                chunks[id].push(parseRIFF(data));
              } else {
                chunks[id].push(data);
              }
            }
            return chunks;
          }
          function doubleToString(num2) {
            return [].slice.call(new Uint8Array(new Float64Array([num2]).buffer), 0).map(function(e8) {
              return String.fromCharCode(e8);
            }).reverse().join("");
          }
          var webm = new ArrayToWebM(frames.map(function(frame) {
            var webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));
            webp.duration = frame.duration;
            return webp;
          }));
          postMessage(webm);
        }
        WhammyVideo.prototype.compile = function(callback) {
          var webWorker = processInWebWorker(whammyInWebWorker);
          webWorker.onmessage = function(event) {
            if (event.data.error) {
              console.error(event.data.error);
              return;
            }
            callback(event.data);
          };
          webWorker.postMessage(this.frames);
        };
        return {
          Video: WhammyVideo
        };
      }();
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.Whammy = Whammy;
      }
      var DiskStorage = {
        init: function() {
          var self2 = this;
          if (typeof indexedDB === "undefined" || typeof indexedDB.open === "undefined") {
            console.error("IndexedDB API are not available in this browser.");
            return;
          }
          var dbVersion = 1;
          var dbName = this.dbName || location.href.replace(/\/|:|#|%|\.|\[|\]/g, ""), db;
          var request = indexedDB.open(dbName, dbVersion);
          function createObjectStore(dataBase) {
            dataBase.createObjectStore(self2.dataStoreName);
          }
          function putInDB() {
            var transaction = db.transaction([self2.dataStoreName], "readwrite");
            if (self2.videoBlob) {
              transaction.objectStore(self2.dataStoreName).put(self2.videoBlob, "videoBlob");
            }
            if (self2.gifBlob) {
              transaction.objectStore(self2.dataStoreName).put(self2.gifBlob, "gifBlob");
            }
            if (self2.audioBlob) {
              transaction.objectStore(self2.dataStoreName).put(self2.audioBlob, "audioBlob");
            }
            function getFromStore(portionName) {
              transaction.objectStore(self2.dataStoreName).get(portionName).onsuccess = function(event) {
                if (self2.callback) {
                  self2.callback(event.target.result, portionName);
                }
              };
            }
            getFromStore("audioBlob");
            getFromStore("videoBlob");
            getFromStore("gifBlob");
          }
          request.onerror = self2.onError;
          request.onsuccess = function() {
            db = request.result;
            db.onerror = self2.onError;
            if (db.setVersion) {
              if (db.version !== dbVersion) {
                var setVersion = db.setVersion(dbVersion);
                setVersion.onsuccess = function() {
                  createObjectStore(db);
                  putInDB();
                };
              } else {
                putInDB();
              }
            } else {
              putInDB();
            }
          };
          request.onupgradeneeded = function(event) {
            createObjectStore(event.target.result);
          };
        },
        Fetch: function(callback) {
          this.callback = callback;
          this.init();
          return this;
        },
        Store: function(config) {
          this.audioBlob = config.audioBlob;
          this.videoBlob = config.videoBlob;
          this.gifBlob = config.gifBlob;
          this.init();
          return this;
        },
        onError: function(error) {
          console.error(JSON.stringify(error, null, "	"));
        },
        dataStoreName: "recordRTC",
        dbName: null
      };
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.DiskStorage = DiskStorage;
      }
      function GifRecorder(mediaStream, config) {
        if (typeof GIFEncoder === "undefined") {
          var script = document.createElement("script");
          script.src = "https://www.webrtc-experiment.com/gif-recorder.js";
          (document.body || document.documentElement).appendChild(script);
        }
        config = config || {};
        var isHTMLObject = mediaStream instanceof CanvasRenderingContext2D || mediaStream instanceof HTMLCanvasElement;
        this.record = function() {
          if (typeof GIFEncoder === "undefined") {
            setTimeout(self2.record, 1e3);
            return;
          }
          if (!isLoadedMetaData) {
            setTimeout(self2.record, 1e3);
            return;
          }
          if (!isHTMLObject) {
            if (!config.width) {
              config.width = video.offsetWidth || 320;
            }
            if (!config.height) {
              config.height = video.offsetHeight || 240;
            }
            if (!config.video) {
              config.video = {
                width: config.width,
                height: config.height
              };
            }
            if (!config.canvas) {
              config.canvas = {
                width: config.width,
                height: config.height
              };
            }
            canvas.width = config.canvas.width || 320;
            canvas.height = config.canvas.height || 240;
            video.width = config.video.width || 320;
            video.height = config.video.height || 240;
          }
          gifEncoder = new GIFEncoder();
          gifEncoder.setRepeat(0);
          gifEncoder.setDelay(config.frameRate || 200);
          gifEncoder.setQuality(config.quality || 10);
          gifEncoder.start();
          if (typeof config.onGifRecordingStarted === "function") {
            config.onGifRecordingStarted();
          }
          startTime = Date.now();
          function drawVideoFrame(time) {
            if (self2.clearedRecordedData === true) {
              return;
            }
            if (isPausedRecording) {
              return setTimeout(function() {
                drawVideoFrame(time);
              }, 100);
            }
            lastAnimationFrame = requestAnimationFrame2(drawVideoFrame);
            if (typeof lastFrameTime === void 0) {
              lastFrameTime = time;
            }
            if (time - lastFrameTime < 90) {
              return;
            }
            if (!isHTMLObject && video.paused) {
              video.play();
            }
            if (!isHTMLObject) {
              context2.drawImage(video, 0, 0, canvas.width, canvas.height);
            }
            if (config.onGifPreview) {
              config.onGifPreview(canvas.toDataURL("image/png"));
            }
            gifEncoder.addFrame(context2);
            lastFrameTime = time;
          }
          lastAnimationFrame = requestAnimationFrame2(drawVideoFrame);
          if (config.initCallback) {
            config.initCallback();
          }
        };
        this.stop = function(callback) {
          callback = callback || function() {
          };
          if (lastAnimationFrame) {
            cancelAnimationFrame2(lastAnimationFrame);
          }
          endTime = Date.now();
          this.blob = new Blob([new Uint8Array(gifEncoder.stream().bin)], {
            type: "image/gif"
          });
          callback(this.blob);
          gifEncoder.stream().bin = [];
        };
        var isPausedRecording = false;
        this.pause = function() {
          isPausedRecording = true;
        };
        this.resume = function() {
          isPausedRecording = false;
        };
        this.clearRecordedData = function() {
          self2.clearedRecordedData = true;
          clearRecordedDataCB();
        };
        function clearRecordedDataCB() {
          if (gifEncoder) {
            gifEncoder.stream().bin = [];
          }
        }
        this.name = "GifRecorder";
        this.toString = function() {
          return this.name;
        };
        var canvas = document.createElement("canvas");
        var context2 = canvas.getContext("2d");
        if (isHTMLObject) {
          if (mediaStream instanceof CanvasRenderingContext2D) {
            context2 = mediaStream;
            canvas = context2.canvas;
          } else if (mediaStream instanceof HTMLCanvasElement) {
            context2 = mediaStream.getContext("2d");
            canvas = mediaStream;
          }
        }
        var isLoadedMetaData = true;
        if (!isHTMLObject) {
          var video = document.createElement("video");
          video.muted = true;
          video.autoplay = true;
          video.playsInline = true;
          isLoadedMetaData = false;
          video.onloadedmetadata = function() {
            isLoadedMetaData = true;
          };
          setSrcObject(mediaStream, video);
          video.play();
        }
        var lastAnimationFrame = null;
        var startTime, endTime, lastFrameTime;
        var gifEncoder;
        var self2 = this;
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.GifRecorder = GifRecorder;
      }
      function MultiStreamsMixer(arrayOfMediaStreams, elementClass) {
        var browserFakeUserAgent2 = "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45";
        (function(that) {
          if (typeof RecordRTC !== "undefined") {
            return;
          }
          if (!that) {
            return;
          }
          if (typeof window !== "undefined") {
            return;
          }
          if (typeof global === "undefined") {
            return;
          }
          global.navigator = {
            userAgent: browserFakeUserAgent2,
            getUserMedia: function() {
            }
          };
          if (!global.console) {
            global.console = {};
          }
          if (typeof global.console.log === "undefined" || typeof global.console.error === "undefined") {
            global.console.error = global.console.log = global.console.log || function() {
              console.log(arguments);
            };
          }
          if (typeof document === "undefined") {
            that.document = {
              documentElement: {
                appendChild: function() {
                  return "";
                }
              }
            };
            document.createElement = document.captureStream = document.mozCaptureStream = function() {
              var obj = {
                getContext: function() {
                  return obj;
                },
                play: function() {
                },
                pause: function() {
                },
                drawImage: function() {
                },
                toDataURL: function() {
                  return "";
                },
                style: {}
              };
              return obj;
            };
            that.HTMLVideoElement = function() {
            };
          }
          if (typeof location === "undefined") {
            that.location = {
              protocol: "file:",
              href: "",
              hash: ""
            };
          }
          if (typeof screen === "undefined") {
            that.screen = {
              width: 0,
              height: 0
            };
          }
          if (typeof URL3 === "undefined") {
            that.URL = {
              createObjectURL: function() {
                return "";
              },
              revokeObjectURL: function() {
                return "";
              }
            };
          }
          that.window = global;
        })(typeof global !== "undefined" ? global : null);
        elementClass = elementClass || "multi-streams-mixer";
        var videos = [];
        var isStopDrawingFrames = false;
        var canvas = document.createElement("canvas");
        var context2 = canvas.getContext("2d");
        canvas.style.opacity = 0;
        canvas.style.position = "absolute";
        canvas.style.zIndex = -1;
        canvas.style.top = "-1000em";
        canvas.style.left = "-1000em";
        canvas.className = elementClass;
        (document.body || document.documentElement).appendChild(canvas);
        this.disableLogs = false;
        this.frameInterval = 10;
        this.width = 360;
        this.height = 240;
        this.useGainNode = true;
        var self2 = this;
        var AudioContext2 = window.AudioContext;
        if (typeof AudioContext2 === "undefined") {
          if (typeof webkitAudioContext !== "undefined") {
            AudioContext2 = webkitAudioContext;
          }
          if (typeof mozAudioContext !== "undefined") {
            AudioContext2 = mozAudioContext;
          }
        }
        var URL3 = window.URL;
        if (typeof URL3 === "undefined" && typeof webkitURL !== "undefined") {
          URL3 = webkitURL;
        }
        if (typeof navigator !== "undefined" && typeof navigator.getUserMedia === "undefined") {
          if (typeof navigator.webkitGetUserMedia !== "undefined") {
            navigator.getUserMedia = navigator.webkitGetUserMedia;
          }
          if (typeof navigator.mozGetUserMedia !== "undefined") {
            navigator.getUserMedia = navigator.mozGetUserMedia;
          }
        }
        var MediaStream3 = window.MediaStream;
        if (typeof MediaStream3 === "undefined" && typeof webkitMediaStream !== "undefined") {
          MediaStream3 = webkitMediaStream;
        }
        if (typeof MediaStream3 !== "undefined") {
          if (typeof MediaStream3.prototype.stop === "undefined") {
            MediaStream3.prototype.stop = function() {
              this.getTracks().forEach(function(track2) {
                track2.stop();
              });
            };
          }
        }
        var Storage2 = {};
        if (typeof AudioContext2 !== "undefined") {
          Storage2.AudioContext = AudioContext2;
        } else if (typeof webkitAudioContext !== "undefined") {
          Storage2.AudioContext = webkitAudioContext;
        }
        function setSrcObject2(stream, element) {
          if ("srcObject" in element) {
            element.srcObject = stream;
          } else if ("mozSrcObject" in element) {
            element.mozSrcObject = stream;
          } else {
            element.srcObject = stream;
          }
        }
        this.startDrawingFrames = function() {
          drawVideosToCanvas();
        };
        function drawVideosToCanvas() {
          if (isStopDrawingFrames) {
            return;
          }
          var videosLength = videos.length;
          var fullcanvas = false;
          var remaining = [];
          videos.forEach(function(video) {
            if (!video.stream) {
              video.stream = {};
            }
            if (video.stream.fullcanvas) {
              fullcanvas = video;
            } else {
              remaining.push(video);
            }
          });
          if (fullcanvas) {
            canvas.width = fullcanvas.stream.width;
            canvas.height = fullcanvas.stream.height;
          } else if (remaining.length) {
            canvas.width = videosLength > 1 ? remaining[0].width * 2 : remaining[0].width;
            var height = 1;
            if (videosLength === 3 || videosLength === 4) {
              height = 2;
            }
            if (videosLength === 5 || videosLength === 6) {
              height = 3;
            }
            if (videosLength === 7 || videosLength === 8) {
              height = 4;
            }
            if (videosLength === 9 || videosLength === 10) {
              height = 5;
            }
            canvas.height = remaining[0].height * height;
          } else {
            canvas.width = self2.width || 360;
            canvas.height = self2.height || 240;
          }
          if (fullcanvas && fullcanvas instanceof HTMLVideoElement) {
            drawImage(fullcanvas);
          }
          remaining.forEach(function(video, idx) {
            drawImage(video, idx);
          });
          setTimeout(drawVideosToCanvas, self2.frameInterval);
        }
        function drawImage(video, idx) {
          if (isStopDrawingFrames) {
            return;
          }
          var x4 = 0;
          var y3 = 0;
          var width = video.width;
          var height = video.height;
          if (idx === 1) {
            x4 = video.width;
          }
          if (idx === 2) {
            y3 = video.height;
          }
          if (idx === 3) {
            x4 = video.width;
            y3 = video.height;
          }
          if (idx === 4) {
            y3 = video.height * 2;
          }
          if (idx === 5) {
            x4 = video.width;
            y3 = video.height * 2;
          }
          if (idx === 6) {
            y3 = video.height * 3;
          }
          if (idx === 7) {
            x4 = video.width;
            y3 = video.height * 3;
          }
          if (typeof video.stream.left !== "undefined") {
            x4 = video.stream.left;
          }
          if (typeof video.stream.top !== "undefined") {
            y3 = video.stream.top;
          }
          if (typeof video.stream.width !== "undefined") {
            width = video.stream.width;
          }
          if (typeof video.stream.height !== "undefined") {
            height = video.stream.height;
          }
          context2.drawImage(video, x4, y3, width, height);
          if (typeof video.stream.onRender === "function") {
            video.stream.onRender(context2, x4, y3, width, height, idx);
          }
        }
        function getMixedStream() {
          isStopDrawingFrames = false;
          var mixedVideoStream = getMixedVideoStream();
          var mixedAudioStream = getMixedAudioStream();
          if (mixedAudioStream) {
            mixedAudioStream.getTracks().filter(function(t8) {
              return t8.kind === "audio";
            }).forEach(function(track2) {
              mixedVideoStream.addTrack(track2);
            });
          }
          var fullcanvas;
          arrayOfMediaStreams.forEach(function(stream) {
            if (stream.fullcanvas) {
              fullcanvas = true;
            }
          });
          return mixedVideoStream;
        }
        function getMixedVideoStream() {
          resetVideoStreams();
          var capturedStream;
          if ("captureStream" in canvas) {
            capturedStream = canvas.captureStream();
          } else if ("mozCaptureStream" in canvas) {
            capturedStream = canvas.mozCaptureStream();
          } else if (!self2.disableLogs) {
            console.error("Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features");
          }
          var videoStream = new MediaStream3();
          capturedStream.getTracks().filter(function(t8) {
            return t8.kind === "video";
          }).forEach(function(track2) {
            videoStream.addTrack(track2);
          });
          canvas.stream = videoStream;
          return videoStream;
        }
        function getMixedAudioStream() {
          if (!Storage2.AudioContextConstructor) {
            Storage2.AudioContextConstructor = new Storage2.AudioContext();
          }
          self2.audioContext = Storage2.AudioContextConstructor;
          self2.audioSources = [];
          if (self2.useGainNode === true) {
            self2.gainNode = self2.audioContext.createGain();
            self2.gainNode.connect(self2.audioContext.destination);
            self2.gainNode.gain.value = 0;
          }
          var audioTracksLength = 0;
          arrayOfMediaStreams.forEach(function(stream) {
            if (!stream.getTracks().filter(function(t8) {
              return t8.kind === "audio";
            }).length) {
              return;
            }
            audioTracksLength++;
            var audioSource = self2.audioContext.createMediaStreamSource(stream);
            if (self2.useGainNode === true) {
              audioSource.connect(self2.gainNode);
            }
            self2.audioSources.push(audioSource);
          });
          if (!audioTracksLength) {
            return;
          }
          self2.audioDestination = self2.audioContext.createMediaStreamDestination();
          self2.audioSources.forEach(function(audioSource) {
            audioSource.connect(self2.audioDestination);
          });
          return self2.audioDestination.stream;
        }
        function getVideo(stream) {
          var video = document.createElement("video");
          setSrcObject2(stream, video);
          video.className = elementClass;
          video.muted = true;
          video.volume = 0;
          video.width = stream.width || self2.width || 360;
          video.height = stream.height || self2.height || 240;
          video.play();
          return video;
        }
        this.appendStreams = function(streams) {
          if (!streams) {
            throw "First parameter is required.";
          }
          if (!(streams instanceof Array)) {
            streams = [streams];
          }
          streams.forEach(function(stream) {
            var newStream = new MediaStream3();
            if (stream.getTracks().filter(function(t8) {
              return t8.kind === "video";
            }).length) {
              var video = getVideo(stream);
              video.stream = stream;
              videos.push(video);
              newStream.addTrack(stream.getTracks().filter(function(t8) {
                return t8.kind === "video";
              })[0]);
            }
            if (stream.getTracks().filter(function(t8) {
              return t8.kind === "audio";
            }).length) {
              var audioSource = self2.audioContext.createMediaStreamSource(stream);
              self2.audioDestination = self2.audioContext.createMediaStreamDestination();
              audioSource.connect(self2.audioDestination);
              newStream.addTrack(self2.audioDestination.stream.getTracks().filter(function(t8) {
                return t8.kind === "audio";
              })[0]);
            }
            arrayOfMediaStreams.push(newStream);
          });
        };
        this.releaseStreams = function() {
          videos = [];
          isStopDrawingFrames = true;
          if (self2.gainNode) {
            self2.gainNode.disconnect();
            self2.gainNode = null;
          }
          if (self2.audioSources.length) {
            self2.audioSources.forEach(function(source) {
              source.disconnect();
            });
            self2.audioSources = [];
          }
          if (self2.audioDestination) {
            self2.audioDestination.disconnect();
            self2.audioDestination = null;
          }
          if (self2.audioContext) {
            self2.audioContext.close();
          }
          self2.audioContext = null;
          context2.clearRect(0, 0, canvas.width, canvas.height);
          if (canvas.stream) {
            canvas.stream.stop();
            canvas.stream = null;
          }
        };
        this.resetVideoStreams = function(streams) {
          if (streams && !(streams instanceof Array)) {
            streams = [streams];
          }
          resetVideoStreams(streams);
        };
        function resetVideoStreams(streams) {
          videos = [];
          streams = streams || arrayOfMediaStreams;
          streams.forEach(function(stream) {
            if (!stream.getTracks().filter(function(t8) {
              return t8.kind === "video";
            }).length) {
              return;
            }
            var video = getVideo(stream);
            video.stream = stream;
            videos.push(video);
          });
        }
        this.name = "MultiStreamsMixer";
        this.toString = function() {
          return this.name;
        };
        this.getMixedStream = getMixedStream;
      }
      if (typeof RecordRTC === "undefined") {
        if (typeof module !== "undefined") {
          module.exports = MultiStreamsMixer;
        }
        if (typeof define === "function" && define.amd) {
          define("MultiStreamsMixer", [], function() {
            return MultiStreamsMixer;
          });
        }
      }
      function MultiStreamRecorder(arrayOfMediaStreams, options2) {
        arrayOfMediaStreams = arrayOfMediaStreams || [];
        var self2 = this;
        var mixer;
        var mediaRecorder;
        options2 = options2 || {
          elementClass: "multi-streams-mixer",
          mimeType: "video/webm",
          video: {
            width: 360,
            height: 240
          }
        };
        if (!options2.frameInterval) {
          options2.frameInterval = 10;
        }
        if (!options2.video) {
          options2.video = {};
        }
        if (!options2.video.width) {
          options2.video.width = 360;
        }
        if (!options2.video.height) {
          options2.video.height = 240;
        }
        this.record = function() {
          mixer = new MultiStreamsMixer(arrayOfMediaStreams, options2.elementClass || "multi-streams-mixer");
          if (getAllVideoTracks().length) {
            mixer.frameInterval = options2.frameInterval || 10;
            mixer.width = options2.video.width || 360;
            mixer.height = options2.video.height || 240;
            mixer.startDrawingFrames();
          }
          if (options2.previewStream && typeof options2.previewStream === "function") {
            options2.previewStream(mixer.getMixedStream());
          }
          mediaRecorder = new MediaStreamRecorder(mixer.getMixedStream(), options2);
          mediaRecorder.record();
        };
        function getAllVideoTracks() {
          var tracks2 = [];
          arrayOfMediaStreams.forEach(function(stream) {
            getTracks(stream, "video").forEach(function(track2) {
              tracks2.push(track2);
            });
          });
          return tracks2;
        }
        this.stop = function(callback) {
          if (!mediaRecorder) {
            return;
          }
          mediaRecorder.stop(function(blob) {
            self2.blob = blob;
            callback(blob);
            self2.clearRecordedData();
          });
        };
        this.pause = function() {
          if (mediaRecorder) {
            mediaRecorder.pause();
          }
        };
        this.resume = function() {
          if (mediaRecorder) {
            mediaRecorder.resume();
          }
        };
        this.clearRecordedData = function() {
          if (mediaRecorder) {
            mediaRecorder.clearRecordedData();
            mediaRecorder = null;
          }
          if (mixer) {
            mixer.releaseStreams();
            mixer = null;
          }
        };
        this.addStreams = function(streams) {
          if (!streams) {
            throw "First parameter is required.";
          }
          if (!(streams instanceof Array)) {
            streams = [streams];
          }
          arrayOfMediaStreams.concat(streams);
          if (!mediaRecorder || !mixer) {
            return;
          }
          mixer.appendStreams(streams);
          if (options2.previewStream && typeof options2.previewStream === "function") {
            options2.previewStream(mixer.getMixedStream());
          }
        };
        this.resetVideoStreams = function(streams) {
          if (!mixer) {
            return;
          }
          if (streams && !(streams instanceof Array)) {
            streams = [streams];
          }
          mixer.resetVideoStreams(streams);
        };
        this.getMixer = function() {
          return mixer;
        };
        this.name = "MultiStreamRecorder";
        this.toString = function() {
          return this.name;
        };
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.MultiStreamRecorder = MultiStreamRecorder;
      }
      function RecordRTCPromisesHandler(mediaStream, options2) {
        if (!this) {
          throw 'Use "new RecordRTCPromisesHandler()"';
        }
        if (typeof mediaStream === "undefined") {
          throw 'First argument "MediaStream" is required.';
        }
        var self2 = this;
        self2.recordRTC = new RecordRTC(mediaStream, options2);
        this.startRecording = function() {
          return new Promise(function(resolve2, reject) {
            try {
              self2.recordRTC.startRecording();
              resolve2();
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.stopRecording = function() {
          return new Promise(function(resolve2, reject) {
            try {
              self2.recordRTC.stopRecording(function(url) {
                self2.blob = self2.recordRTC.getBlob();
                if (!self2.blob || !self2.blob.size) {
                  reject("Empty blob.", self2.blob);
                  return;
                }
                resolve2(url);
              });
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.pauseRecording = function() {
          return new Promise(function(resolve2, reject) {
            try {
              self2.recordRTC.pauseRecording();
              resolve2();
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.resumeRecording = function() {
          return new Promise(function(resolve2, reject) {
            try {
              self2.recordRTC.resumeRecording();
              resolve2();
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.getDataURL = function(callback) {
          return new Promise(function(resolve2, reject) {
            try {
              self2.recordRTC.getDataURL(function(dataURL) {
                resolve2(dataURL);
              });
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.getBlob = function() {
          return new Promise(function(resolve2, reject) {
            try {
              resolve2(self2.recordRTC.getBlob());
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.getInternalRecorder = function() {
          return new Promise(function(resolve2, reject) {
            try {
              resolve2(self2.recordRTC.getInternalRecorder());
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.reset = function() {
          return new Promise(function(resolve2, reject) {
            try {
              resolve2(self2.recordRTC.reset());
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.destroy = function() {
          return new Promise(function(resolve2, reject) {
            try {
              resolve2(self2.recordRTC.destroy());
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.getState = function() {
          return new Promise(function(resolve2, reject) {
            try {
              resolve2(self2.recordRTC.getState());
            } catch (e8) {
              reject(e8);
            }
          });
        };
        this.blob = null;
        this.version = "5.6.2";
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.RecordRTCPromisesHandler = RecordRTCPromisesHandler;
      }
      function WebAssemblyRecorder(stream, config) {
        if (typeof ReadableStream === "undefined" || typeof WritableStream === "undefined") {
          console.error("Following polyfill is strongly recommended: https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js");
        }
        config = config || {};
        config.width = config.width || 640;
        config.height = config.height || 480;
        config.frameRate = config.frameRate || 30;
        config.bitrate = config.bitrate || 1200;
        config.realtime = config.realtime || true;
        function createBufferURL(buffer2, type) {
          return URL2.createObjectURL(new Blob([buffer2], {
            type: type || ""
          }));
        }
        var finished;
        function cameraStream() {
          return new ReadableStream({
            start: function(controller) {
              var cvs = document.createElement("canvas");
              var video = document.createElement("video");
              var first = true;
              video.srcObject = stream;
              video.muted = true;
              video.height = config.height;
              video.width = config.width;
              video.volume = 0;
              video.onplaying = function() {
                cvs.width = config.width;
                cvs.height = config.height;
                var ctx = cvs.getContext("2d");
                var frameTimeout = 1e3 / config.frameRate;
                var cameraTimer = setInterval(function f4() {
                  if (finished) {
                    clearInterval(cameraTimer);
                    controller.close();
                  }
                  if (first) {
                    first = false;
                    if (config.onVideoProcessStarted) {
                      config.onVideoProcessStarted();
                    }
                  }
                  ctx.drawImage(video, 0, 0);
                  if (controller._controlledReadableStream.state !== "closed") {
                    try {
                      controller.enqueue(ctx.getImageData(0, 0, config.width, config.height));
                    } catch (e8) {
                    }
                  }
                }, frameTimeout);
              };
              video.play();
            }
          });
        }
        var worker;
        function startRecording(stream2, buffer2) {
          if (!config.workerPath && !buffer2) {
            finished = false;
            fetch("https://unpkg.com/webm-wasm@latest/dist/webm-worker.js").then(function(r8) {
              r8.arrayBuffer().then(function(buffer3) {
                startRecording(stream2, buffer3);
              });
            });
            return;
          }
          if (!config.workerPath && buffer2 instanceof ArrayBuffer) {
            var blob = new Blob([buffer2], {
              type: "text/javascript"
            });
            config.workerPath = URL2.createObjectURL(blob);
          }
          if (!config.workerPath) {
            console.error("workerPath parameter is missing.");
          }
          worker = new Worker(config.workerPath);
          worker.postMessage(config.webAssemblyPath || "https://unpkg.com/webm-wasm@latest/dist/webm-wasm.wasm");
          worker.addEventListener("message", function(event) {
            if (event.data === "READY") {
              worker.postMessage({
                width: config.width,
                height: config.height,
                bitrate: config.bitrate || 1200,
                timebaseDen: config.frameRate || 30,
                realtime: config.realtime
              });
              cameraStream().pipeTo(new WritableStream({
                write: function(image) {
                  if (finished) {
                    console.error("Got image, but recorder is finished!");
                    return;
                  }
                  worker.postMessage(image.data.buffer, [image.data.buffer]);
                }
              }));
            } else if (!!event.data) {
              if (!isPaused) {
                arrayOfBuffers.push(event.data);
              }
            }
          });
        }
        this.record = function() {
          arrayOfBuffers = [];
          isPaused = false;
          this.blob = null;
          startRecording(stream);
          if (typeof config.initCallback === "function") {
            config.initCallback();
          }
        };
        var isPaused;
        this.pause = function() {
          isPaused = true;
        };
        this.resume = function() {
          isPaused = false;
        };
        function terminate(callback) {
          if (!worker) {
            if (callback) {
              callback();
            }
            return;
          }
          worker.addEventListener("message", function(event) {
            if (event.data === null) {
              worker.terminate();
              worker = null;
              if (callback) {
                callback();
              }
            }
          });
          worker.postMessage(null);
        }
        var arrayOfBuffers = [];
        this.stop = function(callback) {
          finished = true;
          var recorder2 = this;
          terminate(function() {
            recorder2.blob = new Blob(arrayOfBuffers, {
              type: "video/webm"
            });
            callback(recorder2.blob);
          });
        };
        this.name = "WebAssemblyRecorder";
        this.toString = function() {
          return this.name;
        };
        this.clearRecordedData = function() {
          arrayOfBuffers = [];
          isPaused = false;
          this.blob = null;
        };
        this.blob = null;
      }
      if (typeof RecordRTC !== "undefined") {
        RecordRTC.WebAssemblyRecorder = WebAssemblyRecorder;
      }
    }
  });

  // node_modules/.pnpm/note-parser@2.0.1/node_modules/note-parser/index.js
  function isNum(x4) {
    return typeof x4 === "number";
  }
  function isStr(x4) {
    return typeof x4 === "string";
  }
  function isDef2(x4) {
    return typeof x4 !== "undefined";
  }
  function midiToFreq(midi4, tuning) {
    return Math.pow(2, (midi4 - 69) / 12) * (tuning || 440);
  }
  function parse4(str, isTonic, tuning) {
    if (typeof str !== "string")
      return null;
    var m3 = REGEX4.exec(str);
    if (!m3 || !isTonic && m3[4])
      return null;
    var p6 = { letter: m3[1].toUpperCase(), acc: m3[2].replace(/x/g, "##") };
    p6.pc = p6.letter + p6.acc;
    p6.step = (p6.letter.charCodeAt(0) + 3) % 7;
    p6.alt = p6.acc[0] === "b" ? -p6.acc.length : p6.acc.length;
    var pos = SEMITONES[p6.step] + p6.alt;
    p6.chroma = pos < 0 ? 12 + pos : pos % 12;
    if (m3[3]) {
      p6.oct = +m3[3];
      p6.midi = pos + 12 * (p6.oct + 1);
      p6.freq = midiToFreq(p6.midi, tuning);
    }
    if (isTonic)
      p6.tonicOf = m3[4];
    return p6;
  }
  function midi3(note3) {
    if ((isNum(note3) || isStr(note3)) && note3 >= 0 && note3 < 128)
      return +note3;
    var p6 = parse4(note3);
    return p6 && isDef2(p6.midi) ? p6.midi : null;
  }
  var REGEX4, SEMITONES;
  var init_note_parser = __esm({
    "node_modules/.pnpm/note-parser@2.0.1/node_modules/note-parser/index.js"() {
      "use strict";
      REGEX4 = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)\s*$/;
      SEMITONES = [0, 2, 4, 5, 7, 9, 11];
    }
  });

  // node_modules/.pnpm/tonal-midi@0.69.7/node_modules/tonal-midi/index.js
  var tonal_midi_exports = {};
  __export(tonal_midi_exports, {
    note: () => note2,
    toMidi: () => toMidi2
  });
  function toMidi2(val) {
    if (Array.isArray(val) && val.length === 2)
      return val[0] * 7 + val[1] * 12 + 12;
    return midi3(val);
  }
  function note2(num2, sharps2) {
    if (num2 === true || num2 === false)
      return function(m3) {
        return note2(m3, num2);
      };
    num2 = Math.round(num2);
    var pcs = sharps2 === true ? SHARPS2 : FLATS2;
    var pc = pcs[num2 % 12];
    var o8 = Math.floor(num2 / 12) - 1;
    return pc + o8;
  }
  var FLATS2, SHARPS2;
  var init_tonal_midi = __esm({
    "node_modules/.pnpm/tonal-midi@0.69.7/node_modules/tonal-midi/index.js"() {
      init_note_parser();
      FLATS2 = "C Db D Eb E F Gb G Ab A Bb B".split(" ");
      SHARPS2 = "C C# D D# E F F# G G# A A# B".split(" ");
    }
  });

  // node_modules/.pnpm/midi-writer-js@2.1.0/node_modules/midi-writer-js/build/index.js
  var require_build = __commonJS({
    "node_modules/.pnpm/midi-writer-js@2.1.0/node_modules/midi-writer-js/build/index.js"(exports, module) {
      "use strict";
      var tonalMidi = (init_tonal_midi(), __toCommonJS(tonal_midi_exports));
      var Constants = {
        VERSION: "2.1.0",
        HEADER_CHUNK_TYPE: [77, 84, 104, 100],
        HEADER_CHUNK_LENGTH: [0, 0, 0, 6],
        HEADER_CHUNK_FORMAT0: [0, 0],
        HEADER_CHUNK_FORMAT1: [0, 1],
        HEADER_CHUNK_DIVISION: [0, 128],
        TRACK_CHUNK_TYPE: [77, 84, 114, 107],
        META_EVENT_ID: 255,
        META_TEXT_ID: 1,
        META_COPYRIGHT_ID: 2,
        META_TRACK_NAME_ID: 3,
        META_INSTRUMENT_NAME_ID: 4,
        META_LYRIC_ID: 5,
        META_MARKER_ID: 6,
        META_CUE_POINT: 7,
        META_TEMPO_ID: 81,
        META_SMTPE_OFFSET: 84,
        META_TIME_SIGNATURE_ID: 88,
        META_KEY_SIGNATURE_ID: 89,
        META_END_OF_TRACK_ID: [47, 0],
        CONTROLLER_CHANGE_STATUS: 176,
        PROGRAM_CHANGE_STATUS: 192,
        PITCH_BEND_STATUS: 224
      };
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof(obj);
      }
      function _wrapRegExp() {
        _wrapRegExp = function(re, groups) {
          return new BabelRegExp(re, void 0, groups);
        };
        var _super = RegExp.prototype, _groups = /* @__PURE__ */ new WeakMap();
        function BabelRegExp(re, flags, groups) {
          var _this = new RegExp(re, flags);
          return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
        }
        function buildGroups(result, re) {
          var g2 = _groups.get(re);
          return Object.keys(g2).reduce(function(groups, name2) {
            return groups[name2] = result[g2[name2]], groups;
          }, /* @__PURE__ */ Object.create(null));
        }
        return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function(str) {
          var result = _super.exec.call(this, str);
          return result && (result.groups = buildGroups(result, this)), result;
        }, BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {
          if (typeof substitution == "string") {
            var groups = _groups.get(this);
            return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function(_, name2) {
              return "$" + groups[name2];
            }));
          }
          if (typeof substitution == "function") {
            var _this = this;
            return _super[Symbol.replace].call(this, str, function() {
              var args = arguments;
              return typeof args[args.length - 1] != "object" && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
            });
          }
          return _super[Symbol.replace].call(this, str, substitution);
        }, _wrapRegExp.apply(this, arguments);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i8 = 0; i8 < props.length; i8++) {
          var descriptor = props[i8];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        Object.defineProperty(subClass, "prototype", {
          writable: false
        });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o8, p6) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o9, p7) {
          o9.__proto__ = p7;
          return o9;
        };
        return _setPrototypeOf(o8, p6);
      }
      var Utils = /* @__PURE__ */ function() {
        function Utils2() {
          _classCallCheck(this, Utils2);
        }
        _createClass(Utils2, null, [{
          key: "version",
          value: function version3() {
            return Constants.VERSION;
          }
        }, {
          key: "stringToBytes",
          value: function stringToBytes(string) {
            return string.split("").map(function(_char) {
              return _char.charCodeAt();
            });
          }
        }, {
          key: "isNumeric",
          value: function isNumeric(n8) {
            return !isNaN(parseFloat(n8)) && isFinite(n8);
          }
        }, {
          key: "getPitch",
          value: function getPitch(pitch) {
            var middleC = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "C4";
            return 60 - tonalMidi.toMidi(middleC) + tonalMidi.toMidi(pitch);
          }
        }, {
          key: "numberToVariableLength",
          value: function numberToVariableLength(ticks) {
            ticks = Math.round(ticks);
            var buffer2 = ticks & 127;
            while (ticks = ticks >> 7) {
              buffer2 <<= 8;
              buffer2 |= ticks & 127 | 128;
            }
            var bList = [];
            while (true) {
              bList.push(buffer2 & 255);
              if (buffer2 & 128)
                buffer2 >>= 8;
              else {
                break;
              }
            }
            return bList;
          }
        }, {
          key: "stringByteCount",
          value: function stringByteCount(s4) {
            return encodeURI(s4).split(/%..|./).length - 1;
          }
        }, {
          key: "numberFromBytes",
          value: function numberFromBytes(bytes) {
            var hex = "";
            var stringResult;
            bytes.forEach(function(_byte) {
              stringResult = _byte.toString(16);
              if (stringResult.length == 1)
                stringResult = "0" + stringResult;
              hex += stringResult;
            });
            return parseInt(hex, 16);
          }
        }, {
          key: "numberToBytes",
          value: function numberToBytes(number, bytesNeeded) {
            bytesNeeded = bytesNeeded || 1;
            var hexString = number.toString(16);
            if (hexString.length & 1) {
              hexString = "0" + hexString;
            }
            var hexArray = hexString.match(/.{2}/g);
            hexArray = hexArray.map(function(item) {
              return parseInt(item, 16);
            });
            if (hexArray.length < bytesNeeded) {
              while (bytesNeeded - hexArray.length > 0) {
                hexArray.unshift(0);
              }
            }
            return hexArray;
          }
        }, {
          key: "toArray",
          value: function toArray(value) {
            if (Array.isArray(value))
              return value;
            return [value];
          }
        }, {
          key: "convertVelocity",
          value: function convertVelocity(velocity) {
            velocity = velocity > 100 ? 100 : velocity;
            return Math.round(velocity / 100 * 127);
          }
        }, {
          key: "getTickDuration",
          value: function getTickDuration(duration2) {
            if (Array.isArray(duration2)) {
              return duration2.map(function(value) {
                return Utils2.getTickDuration(value);
              }).reduce(function(a8, b5) {
                return a8 + b5;
              }, 0);
            }
            duration2 = duration2.toString();
            if (duration2.toLowerCase().charAt(0) === "t") {
              return parseInt(duration2.substring(1));
            }
            var quarterTicks = Utils2.numberFromBytes(Constants.HEADER_CHUNK_DIVISION);
            var tickDuration = quarterTicks * Utils2.getDurationMultiplier(duration2);
            return Utils2.getRoundedIfClose(tickDuration);
          }
        }, {
          key: "getRoundedIfClose",
          value: function getRoundedIfClose(tick) {
            var roundedTick = Math.round(tick);
            return Math.abs(roundedTick - tick) < 1e-6 ? roundedTick : tick;
          }
        }, {
          key: "getPrecisionLoss",
          value: function getPrecisionLoss(tick) {
            var roundedTick = Math.round(tick);
            return roundedTick - tick;
          }
        }, {
          key: "getDurationMultiplier",
          value: function getDurationMultiplier(duration2) {
            if (duration2 === "0")
              return 0;
            var match = duration2.match(/* @__PURE__ */ _wrapRegExp(/^(d+)?(\d+)(?:t(\d*))?/, {
              dotted: 1,
              base: 2,
              tuplet: 3
            }));
            if (match) {
              var base = Number(match.groups.base);
              var isValidBase = base === 1 || (base & base - 1) === 0;
              if (isValidBase) {
                var ratio = base / 4;
                var durationInQuarters = 1 / ratio;
                var _match$groups = match.groups, dotted = _match$groups.dotted, tuplet = _match$groups.tuplet;
                if (dotted) {
                  var thisManyDots = dotted.length;
                  var divisor = Math.pow(2, thisManyDots);
                  durationInQuarters = durationInQuarters + durationInQuarters * ((divisor - 1) / divisor);
                }
                if (typeof tuplet === "string") {
                  var fitInto = durationInQuarters * 2;
                  var thisManyNotes = Number(tuplet || "3");
                  durationInQuarters = fitInto / thisManyNotes;
                }
                return durationInQuarters;
              }
            }
            throw new Error(duration2 + " is not a valid duration.");
          }
        }]);
        return Utils2;
      }();
      var NoteOnEvent = /* @__PURE__ */ function() {
        function NoteOnEvent2(fields) {
          _classCallCheck(this, NoteOnEvent2);
          fields = Object.assign({
            channel: 1,
            startTick: null,
            velocity: 50,
            wait: 0
          }, fields);
          this.type = "note-on";
          this.channel = fields.channel;
          this.pitch = fields.pitch;
          this.wait = fields.wait;
          this.velocity = fields.velocity;
          this.startTick = fields.startTick;
          this.tick = null;
          this.delta = null;
          this.data = fields.data;
        }
        _createClass(NoteOnEvent2, [{
          key: "buildData",
          value: function buildData(track2, precisionDelta) {
            var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this.data = [];
            if (this.startTick) {
              this.tick = Utils.getRoundedIfClose(this.startTick);
              if (track2.tickPointer == 0) {
                this.delta = this.tick;
              }
            } else {
              this.delta = Utils.getTickDuration(this.wait);
              this.tick = Utils.getRoundedIfClose(track2.tickPointer + this.delta);
            }
            this.deltaWithPrecisionCorrection = Utils.getRoundedIfClose(this.delta - precisionDelta);
            this.data = Utils.numberToVariableLength(this.deltaWithPrecisionCorrection).concat(this.getStatusByte(), Utils.getPitch(this.pitch, options2.middleC), Utils.convertVelocity(this.velocity));
            return this;
          }
        }, {
          key: "getStatusByte",
          value: function getStatusByte() {
            return 144 + this.channel - 1;
          }
        }]);
        return NoteOnEvent2;
      }();
      var NoteOffEvent = /* @__PURE__ */ function() {
        function NoteOffEvent2(fields) {
          _classCallCheck(this, NoteOffEvent2);
          fields = Object.assign({
            channel: 1,
            velocity: 50,
            tick: null
          }, fields);
          this.type = "note-off";
          this.channel = fields.channel;
          this.pitch = fields.pitch;
          this.duration = fields.duration;
          this.velocity = fields.velocity;
          this.tick = fields.tick;
          this.delta = Utils.getTickDuration(this.duration);
          this.data = fields.data;
        }
        _createClass(NoteOffEvent2, [{
          key: "buildData",
          value: function buildData(track2, precisionDelta) {
            var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (this.tick === null) {
              this.tick = Utils.getRoundedIfClose(this.delta + track2.tickPointer);
            }
            this.deltaWithPrecisionCorrection = Utils.getRoundedIfClose(this.delta - precisionDelta);
            this.data = Utils.numberToVariableLength(this.deltaWithPrecisionCorrection).concat(this.getStatusByte(), Utils.getPitch(this.pitch, options2.middleC), Utils.convertVelocity(this.velocity));
            return this;
          }
        }, {
          key: "getStatusByte",
          value: function getStatusByte() {
            return 128 + this.channel - 1;
          }
        }]);
        return NoteOffEvent2;
      }();
      var NoteEvent3 = /* @__PURE__ */ function() {
        function NoteEvent4(fields) {
          _classCallCheck(this, NoteEvent4);
          fields = Object.assign({
            channel: 1,
            repeat: 1,
            sequential: false,
            startTick: null,
            velocity: 50,
            wait: 0
          }, fields);
          this.data = [];
          this.type = "note";
          this.pitch = Utils.toArray(fields.pitch);
          this.channel = fields.channel;
          this.duration = fields.duration;
          this.grace = fields.grace;
          this.repeat = fields.repeat;
          this.sequential = fields.sequential;
          this.startTick = fields.startTick;
          this.velocity = fields.velocity;
          this.wait = fields.wait;
          this.tickDuration = Utils.getTickDuration(this.duration);
          this.restDuration = Utils.getTickDuration(this.wait);
          this.events = [];
        }
        _createClass(NoteEvent4, [{
          key: "buildData",
          value: function buildData() {
            var _this = this;
            this.data = [];
            this.tickDuration;
            this.restDuration;
            if (this.grace) {
              var graceDuration = 1;
              this.grace = Utils.toArray(this.grace);
              this.grace.forEach(function(pitch) {
                var noteEvent = new NoteEvent4({
                  pitch: _this.grace,
                  duration: "T" + graceDuration
                });
                _this.data = _this.data.concat(noteEvent.data);
              });
            }
            if (!this.sequential) {
              for (var j2 = 0; j2 < this.repeat; j2++) {
                this.pitch.forEach(function(p6, i8) {
                  if (i8 == 0) {
                    var noteOnNew = new NoteOnEvent({
                      channel: _this.channel,
                      wait: _this.wait,
                      velocity: _this.velocity,
                      pitch: p6,
                      startTick: _this.startTick
                    });
                  } else {
                    var noteOnNew = new NoteOnEvent({
                      channel: _this.channel,
                      wait: 0,
                      velocity: _this.velocity,
                      pitch: p6,
                      startTick: _this.startTick
                    });
                  }
                  _this.events.push(noteOnNew);
                });
                this.pitch.forEach(function(p6, i8) {
                  if (i8 == 0) {
                    var noteOffNew = new NoteOffEvent({
                      channel: _this.channel,
                      duration: _this.duration,
                      velocity: _this.velocity,
                      pitch: p6,
                      tick: _this.startTick !== null ? Utils.getTickDuration(_this.duration) + _this.startTick : null
                    });
                  } else {
                    var noteOffNew = new NoteOffEvent({
                      channel: _this.channel,
                      duration: 0,
                      velocity: _this.velocity,
                      pitch: p6,
                      tick: _this.startTick !== null ? Utils.getTickDuration(_this.duration) + _this.startTick : null
                    });
                  }
                  _this.events.push(noteOffNew);
                });
              }
            } else {
              for (var j2 = 0; j2 < this.repeat; j2++) {
                this.pitch.forEach(function(p6, i8) {
                  var noteOnNew = new NoteOnEvent({
                    channel: _this.channel,
                    wait: i8 > 0 ? 0 : _this.wait,
                    velocity: _this.velocity,
                    pitch: p6,
                    startTick: _this.startTick
                  });
                  var noteOffNew = new NoteOffEvent({
                    channel: _this.channel,
                    duration: _this.duration,
                    velocity: _this.velocity,
                    pitch: p6
                  });
                  _this.events.push(noteOnNew, noteOffNew);
                });
              }
            }
            return this;
          }
        }]);
        return NoteEvent4;
      }();
      var scale14bits = function scale14bits2(zeroOne) {
        if (zeroOne <= 0) {
          return Math.floor(16384 * (zeroOne + 1) / 2);
        }
        return Math.floor(16383 * (zeroOne + 1) / 2);
      };
      var PitchBendEvent = /* @__PURE__ */ _createClass(function PitchBendEvent2(fields) {
        _classCallCheck(this, PitchBendEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "pitch-bend";
        var bend14 = scale14bits(fields.bend);
        var channel = fields.channel || 0;
        var lsbValue = bend14 & 127;
        var msbValue = bend14 >> 7 & 127;
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.PITCH_BEND_STATUS | channel, lsbValue, msbValue);
      });
      var ProgramChangeEvent = /* @__PURE__ */ _createClass(function ProgramChangeEvent2(fields) {
        _classCallCheck(this, ProgramChangeEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "program";
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.PROGRAM_CHANGE_STATUS, fields.instrument);
      });
      var ControllerChangeEvent = /* @__PURE__ */ _createClass(function ControllerChangeEvent2(fields) {
        _classCallCheck(this, ControllerChangeEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "controller";
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.CONTROLLER_CHANGE_STATUS, fields.controllerNumber, fields.controllerValue);
      });
      var CopyrightEvent = /* @__PURE__ */ _createClass(function CopyrightEvent2(fields) {
        _classCallCheck(this, CopyrightEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "copyright";
        var textBytes = Utils.stringToBytes(fields.text);
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, Constants.META_COPYRIGHT_ID, Utils.numberToVariableLength(textBytes.length), textBytes);
      });
      var CuePointEvent = /* @__PURE__ */ _createClass(function CuePointEvent2(fields) {
        _classCallCheck(this, CuePointEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "cue-point";
        var textBytes = Utils.stringToBytes(fields.text);
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, Constants.META_CUE_POINT, Utils.numberToVariableLength(textBytes.length), textBytes);
      });
      var EndTrackEvent = /* @__PURE__ */ _createClass(function EndTrackEvent2(fields) {
        _classCallCheck(this, EndTrackEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "end-track";
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, Constants.META_END_OF_TRACK_ID);
      });
      var InstrumentNameEvent = /* @__PURE__ */ _createClass(function InstrumentNameEvent2(fields) {
        _classCallCheck(this, InstrumentNameEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "instrument-name";
        var textBytes = Utils.stringToBytes(fields.text);
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, Constants.META_INSTRUMENT_NAME_ID, Utils.numberToVariableLength(textBytes.length), textBytes);
      });
      var KeySignatureEvent = /* @__PURE__ */ _createClass(function KeySignatureEvent2(sf, mi) {
        _classCallCheck(this, KeySignatureEvent2);
        this.type = "key-signature";
        var mode2 = mi || 0;
        sf = sf || 0;
        if (typeof mi === "undefined") {
          var fifths = [["Cb", "Gb", "Db", "Ab", "Eb", "Bb", "F", "C", "G", "D", "A", "E", "B", "F#", "C#"], ["ab", "eb", "bb", "f", "c", "g", "d", "a", "e", "b", "f#", "c#", "g#", "d#", "a#"]];
          var _sflen = sf.length;
          var note3 = sf || "C";
          if (sf[0] === sf[0].toLowerCase())
            mode2 = 1;
          if (_sflen > 1) {
            switch (sf.charAt(_sflen - 1)) {
              case "m":
                mode2 = 1;
                note3 = sf.charAt(0).toLowerCase();
                note3 = note3.concat(sf.substring(1, _sflen - 1));
                break;
              case "-":
                mode2 = 1;
                note3 = sf.charAt(0).toLowerCase();
                note3 = note3.concat(sf.substring(1, _sflen - 1));
                break;
              case "M":
                mode2 = 0;
                note3 = sf.charAt(0).toUpperCase();
                note3 = note3.concat(sf.substring(1, _sflen - 1));
                break;
              case "+":
                mode2 = 0;
                note3 = sf.charAt(0).toUpperCase();
                note3 = note3.concat(sf.substring(1, _sflen - 1));
                break;
            }
          }
          var fifthindex = fifths[mode2].indexOf(note3);
          sf = fifthindex === -1 ? 0 : fifthindex - 7;
        }
        this.data = Utils.numberToVariableLength(0).concat(Constants.META_EVENT_ID, Constants.META_KEY_SIGNATURE_ID, [2], Utils.numberToBytes(sf, 1), Utils.numberToBytes(mode2, 1));
      });
      var LyricEvent = /* @__PURE__ */ _createClass(function LyricEvent2(fields) {
        _classCallCheck(this, LyricEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "lyric";
        var textBytes = Utils.stringToBytes(fields.text);
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, Constants.META_LYRIC_ID, Utils.numberToVariableLength(textBytes.length), textBytes);
      });
      var MarkerEvent = /* @__PURE__ */ _createClass(function MarkerEvent2(fields) {
        _classCallCheck(this, MarkerEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "marker";
        var textBytes = Utils.stringToBytes(fields.text);
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, Constants.META_MARKER_ID, Utils.numberToVariableLength(textBytes.length), textBytes);
      });
      var TempoEvent = /* @__PURE__ */ _createClass(function TempoEvent2(fields) {
        _classCallCheck(this, TempoEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "tempo";
        this.tick = fields.tick;
        var tempo2 = Math.round(6e7 / fields.bpm);
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, Constants.META_TEMPO_ID, [3], Utils.numberToBytes(tempo2, 3));
      });
      var TextEvent = /* @__PURE__ */ _createClass(function TextEvent2(fields) {
        _classCallCheck(this, TextEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "text";
        var textBytes = Utils.stringToBytes(fields.text);
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, Constants.META_TEXT_ID, Utils.numberToVariableLength(textBytes.length), textBytes);
      });
      var TimeSignatureEvent = /* @__PURE__ */ _createClass(function TimeSignatureEvent2(numerator, denominator, midiclockspertick, notespermidiclock) {
        _classCallCheck(this, TimeSignatureEvent2);
        this.type = "time-signature";
        this.data = Utils.numberToVariableLength(0).concat(Constants.META_EVENT_ID, Constants.META_TIME_SIGNATURE_ID, [4], Utils.numberToBytes(numerator, 1), Utils.numberToBytes(Math.log2(denominator), 1), Utils.numberToBytes(midiclockspertick || 24, 1), Utils.numberToBytes(notespermidiclock || 8, 1));
      });
      var TrackNameEvent = /* @__PURE__ */ _createClass(function TrackNameEvent2(fields) {
        _classCallCheck(this, TrackNameEvent2);
        fields = Object.assign({
          delta: 0
        }, fields);
        this.type = "track-name";
        var textBytes = Utils.stringToBytes(fields.text);
        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, Constants.META_TRACK_NAME_ID, Utils.numberToVariableLength(textBytes.length), textBytes);
      });
      var Track3 = /* @__PURE__ */ function() {
        function Track4() {
          _classCallCheck(this, Track4);
          this.type = Constants.TRACK_CHUNK_TYPE;
          this.data = [];
          this.size = [];
          this.events = [];
          this.explicitTickEvents = [];
          this.tickPointer = 0;
        }
        _createClass(Track4, [{
          key: "addEvent",
          value: function addEvent(events, mapFunction) {
            var _this = this;
            Utils.toArray(events).forEach(function(event, i8) {
              if (event instanceof NoteEvent3) {
                if (typeof mapFunction === "function") {
                  var properties = mapFunction(i8, event);
                  if (_typeof(properties) === "object") {
                    for (var j2 in properties) {
                      switch (j2) {
                        case "channel":
                          event.channel = properties[j2];
                          break;
                        case "duration":
                          event.duration = properties[j2];
                          break;
                        case "sequential":
                          event.sequential = properties[j2];
                          break;
                        case "velocity":
                          event.velocity = Utils.convertVelocity(properties[j2]);
                          break;
                      }
                    }
                  }
                }
                if (event.startTick !== null) {
                  _this.explicitTickEvents.push(event);
                } else {
                  event.buildData().events.forEach(function(e8) {
                    return _this.events.push(e8);
                  });
                }
              } else {
                _this.events.push(event);
              }
            });
            return this;
          }
        }, {
          key: "buildData",
          value: function buildData() {
            var _this2 = this;
            var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.removeEventsByType("end-track").addEvent(new EndTrackEvent());
            this.data = [];
            this.size = [];
            this.tickPointer = 0;
            var precisionLoss = 0;
            this.events.forEach(function(event, eventIndex) {
              if (event instanceof NoteOnEvent || event instanceof NoteOffEvent) {
                var built = event.buildData(_this2, precisionLoss, options2);
                precisionLoss = Utils.getPrecisionLoss(event.deltaWithPrecisionCorrection || 0);
                _this2.data = _this2.data.concat(built.data);
                _this2.tickPointer = Utils.getRoundedIfClose(event.tick);
              } else if (event instanceof TempoEvent) {
                _this2.tickPointer = Utils.getRoundedIfClose(event.tick);
                _this2.data = _this2.data.concat(event.data);
              } else {
                _this2.data = _this2.data.concat(event.data);
              }
            });
            this.mergeExplicitTickEvents();
            this.size = Utils.numberToBytes(this.data.length, 4);
            return this;
          }
        }, {
          key: "mergeExplicitTickEvents",
          value: function mergeExplicitTickEvents() {
            var _this3 = this;
            if (!this.explicitTickEvents.length)
              return;
            this.explicitTickEvents.sort(function(a8, b5) {
              return a8.startTick - b5.startTick;
            });
            this.explicitTickEvents.forEach(function(noteEvent) {
              noteEvent.buildData().events.forEach(function(e8) {
                return e8.buildData(_this3);
              });
              noteEvent.events.forEach(function(event) {
                return _this3.mergeSingleEvent(event);
              });
            });
            this.explicitTickEvents = [];
            this.buildData();
          }
        }, {
          key: "mergeTrack",
          value: function mergeTrack(track2) {
            var _this4 = this;
            this.buildData();
            track2.buildData().events.forEach(function(event) {
              return _this4.mergeSingleEvent(event);
            });
          }
        }, {
          key: "mergeSingleEvent",
          value: function mergeSingleEvent(event) {
            var lastEventIndex = 0;
            for (var i8 = 0; i8 < this.events.length; i8++) {
              if (this.events[i8].tick > event.tick)
                break;
              lastEventIndex = i8;
            }
            var splicedEventIndex = lastEventIndex + 1;
            event.delta = event.tick - this.events[lastEventIndex].tick;
            this.events.splice(splicedEventIndex, 0, event);
            for (var i8 = splicedEventIndex + 1; i8 < this.events.length; i8++) {
              this.events[i8].delta = this.events[i8].tick - this.events[i8 - 1].tick;
            }
          }
        }, {
          key: "removeEventsByType",
          value: function removeEventsByType(eventType) {
            var _this5 = this;
            this.events.forEach(function(event, index15) {
              if (event.type === eventType) {
                _this5.events.splice(index15, 1);
              }
            });
            return this;
          }
        }, {
          key: "setTempo",
          value: function setTempo(bpm) {
            var tick = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            return this.addEvent(new TempoEvent({
              bpm,
              tick
            }));
          }
        }, {
          key: "setTimeSignature",
          value: function setTimeSignature(numerator, denominator, midiclockspertick, notespermidiclock) {
            return this.addEvent(new TimeSignatureEvent(numerator, denominator, midiclockspertick, notespermidiclock));
          }
        }, {
          key: "setKeySignature",
          value: function setKeySignature(sf, mi) {
            return this.addEvent(new KeySignatureEvent(sf, mi));
          }
        }, {
          key: "addText",
          value: function addText(text) {
            return this.addEvent(new TextEvent({
              text
            }));
          }
        }, {
          key: "addCopyright",
          value: function addCopyright(text) {
            return this.addEvent(new CopyrightEvent({
              text
            }));
          }
        }, {
          key: "addTrackName",
          value: function addTrackName(text) {
            return this.addEvent(new TrackNameEvent({
              text
            }));
          }
        }, {
          key: "addInstrumentName",
          value: function addInstrumentName(text) {
            return this.addEvent(new InstrumentNameEvent({
              text
            }));
          }
        }, {
          key: "addMarker",
          value: function addMarker(text) {
            return this.addEvent(new MarkerEvent({
              text
            }));
          }
        }, {
          key: "addCuePoint",
          value: function addCuePoint(text) {
            return this.addEvent(new CuePointEvent({
              text
            }));
          }
        }, {
          key: "addLyric",
          value: function addLyric(text) {
            return this.addEvent(new LyricEvent({
              text
            }));
          }
        }, {
          key: "polyModeOn",
          value: function polyModeOn() {
            var event = new NoteOnEvent({
              data: [0, 176, 126, 0]
            });
            return this.addEvent(event);
          }
        }, {
          key: "setPitchBend",
          value: function setPitchBend(bend) {
            return this.addEvent(new PitchBendEvent({
              bend
            }));
          }
        }, {
          key: "controllerChange",
          value: function controllerChange(number, value) {
            return this.addEvent(new ControllerChangeEvent({
              controllerNumber: number,
              controllerValue: value
            }));
          }
        }]);
        return Track4;
      }();
      var VexFlow = /* @__PURE__ */ function() {
        function VexFlow2() {
          _classCallCheck(this, VexFlow2);
        }
        _createClass(VexFlow2, [{
          key: "trackFromVoice",
          value: function trackFromVoice(voice) {
            var _this = this;
            var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
              addRenderedAccidentals: false
            };
            var track2 = new Track3();
            var wait = [];
            voice.tickables.forEach(function(tickable) {
              if (tickable.noteType === "n") {
                track2.addEvent(new NoteEvent3({
                  pitch: tickable.keys.map(function(pitch, index15) {
                    return _this.convertPitch(pitch, index15, tickable, options2.addRenderedAccidentals);
                  }),
                  duration: _this.convertDuration(tickable),
                  wait
                }));
                wait = [];
              } else if (tickable.noteType === "r") {
                wait.push(_this.convertDuration(tickable));
                return;
              }
            });
            if (wait.length > 0) {
              track2.addEvent(new NoteEvent3({
                pitch: "[c4]",
                duration: "0",
                wait,
                velocity: "0"
              }));
            }
            return track2;
          }
        }, {
          key: "convertPitch",
          value: function convertPitch(pitch, index15, note3) {
            var addRenderedAccidentals = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            var pitchParts = pitch.split("/");
            var accidentals2 = pitchParts[0].substring(1).replace("n", "");
            if (addRenderedAccidentals) {
              var _note$getAccidentals;
              (_note$getAccidentals = note3.getAccidentals()) === null || _note$getAccidentals === void 0 ? void 0 : _note$getAccidentals.forEach(function(accidental) {
                if (accidental.index === index15) {
                  if (accidental.type === "n") {
                    accidentals2 = "";
                  } else {
                    accidentals2 += accidental.type;
                  }
                }
              });
            }
            return pitchParts[0][0] + accidentals2 + pitchParts[1];
          }
        }, {
          key: "convertDuration",
          value: function convertDuration(note3) {
            return "d".repeat(note3.dots) + this.convertBaseDuration(note3.duration) + (note3.tuplet ? "t" + note3.tuplet.num_notes : "");
          }
        }, {
          key: "convertBaseDuration",
          value: function convertBaseDuration(duration2) {
            switch (duration2) {
              case "w":
                return "1";
              case "h":
                return "2";
              case "q":
                return "4";
              default:
                return duration2;
            }
          }
        }]);
        return VexFlow2;
      }();
      var HeaderChunk = /* @__PURE__ */ _createClass(function HeaderChunk2(numberOfTracks) {
        _classCallCheck(this, HeaderChunk2);
        this.type = Constants.HEADER_CHUNK_TYPE;
        var trackType = numberOfTracks > 1 ? Constants.HEADER_CHUNK_FORMAT1 : Constants.HEADER_CHUNK_FORMAT0;
        this.data = trackType.concat(Utils.numberToBytes(numberOfTracks, 2), Constants.HEADER_CHUNK_DIVISION);
        this.size = [0, 0, 0, this.data.length];
      });
      var Writer3 = /* @__PURE__ */ function() {
        function Writer4(tracks2) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          _classCallCheck(this, Writer4);
          this.tracks = Utils.toArray(tracks2);
          this.options = options2;
        }
        _createClass(Writer4, [{
          key: "buildData",
          value: function buildData() {
            var _this = this;
            var data = [];
            data.push(new HeaderChunk(this.tracks.length));
            this.tracks.forEach(function(track2, i8) {
              data.push(track2.buildData(_this.options));
            });
            return data;
          }
        }, {
          key: "buildFile",
          value: function buildFile() {
            var build = [];
            this.buildData().forEach(function(d5) {
              return build = build.concat(d5.type, d5.size, d5.data);
            });
            return new Uint8Array(build);
          }
        }, {
          key: "base64",
          value: function base64() {
            if (typeof btoa === "function")
              return btoa(String.fromCharCode.apply(null, this.buildFile()));
            return Buffer.from(this.buildFile()).toString("base64");
          }
        }, {
          key: "dataUri",
          value: function dataUri() {
            return "data:audio/midi;base64," + this.base64();
          }
        }, {
          key: "setOption",
          value: function setOption(key, value) {
            this.options[key] = value;
            return this;
          }
        }, {
          key: "stdout",
          value: function stdout() {
            return process.stdout.write(Buffer.from(this.buildFile()));
          }
        }]);
        return Writer4;
      }();
      var main = {
        Constants,
        NoteOnEvent,
        NoteOffEvent,
        NoteEvent: NoteEvent3,
        PitchBendEvent,
        ProgramChangeEvent,
        Track: Track3,
        Utils,
        VexFlow,
        Writer: Writer3
      };
      module.exports = main;
    }
  });

  // node_modules/.pnpm/midi-file@1.2.3/node_modules/midi-file/lib/midi-parser.js
  var require_midi_parser = __commonJS({
    "node_modules/.pnpm/midi-file@1.2.3/node_modules/midi-file/lib/midi-parser.js"(exports, module) {
      function parseMidi(data) {
        var p6 = new Parser(data);
        var headerChunk = p6.readChunk();
        if (headerChunk.id != "MThd")
          throw "Bad MIDI file.  Expected 'MHdr', got: '" + headerChunk.id + "'";
        var header = parseHeader(headerChunk.data);
        var tracks2 = [];
        for (var i8 = 0; !p6.eof() && i8 < header.numTracks; i8++) {
          var trackChunk = p6.readChunk();
          if (trackChunk.id != "MTrk")
            throw "Bad MIDI file.  Expected 'MTrk', got: '" + trackChunk.id + "'";
          var track2 = parseTrack(trackChunk.data);
          tracks2.push(track2);
        }
        return {
          header,
          tracks: tracks2
        };
      }
      function parseHeader(data) {
        var p6 = new Parser(data);
        var format = p6.readUInt16();
        var numTracks = p6.readUInt16();
        var result = {
          format,
          numTracks
        };
        var timeDivision = p6.readUInt16();
        if (timeDivision & 32768) {
          result.framesPerSecond = 256 - (timeDivision >> 8);
          result.ticksPerFrame = timeDivision & 255;
        } else {
          result.ticksPerBeat = timeDivision;
        }
        return result;
      }
      function parseTrack(data) {
        var p6 = new Parser(data);
        var events = [];
        while (!p6.eof()) {
          var event = readEvent();
          events.push(event);
        }
        return events;
        var lastEventTypeByte = null;
        function readEvent() {
          var event2 = {};
          event2.deltaTime = p6.readVarInt();
          var eventTypeByte = p6.readUInt8();
          if ((eventTypeByte & 240) === 240) {
            if (eventTypeByte === 255) {
              event2.meta = true;
              var metatypeByte = p6.readUInt8();
              var length = p6.readVarInt();
              switch (metatypeByte) {
                case 0:
                  event2.type = "sequenceNumber";
                  if (length !== 2)
                    throw "Expected length for sequenceNumber event is 2, got " + length;
                  event2.number = p6.readUInt16();
                  return event2;
                case 1:
                  event2.type = "text";
                  event2.text = p6.readString(length);
                  return event2;
                case 2:
                  event2.type = "copyrightNotice";
                  event2.text = p6.readString(length);
                  return event2;
                case 3:
                  event2.type = "trackName";
                  event2.text = p6.readString(length);
                  return event2;
                case 4:
                  event2.type = "instrumentName";
                  event2.text = p6.readString(length);
                  return event2;
                case 5:
                  event2.type = "lyrics";
                  event2.text = p6.readString(length);
                  return event2;
                case 6:
                  event2.type = "marker";
                  event2.text = p6.readString(length);
                  return event2;
                case 7:
                  event2.type = "cuePoint";
                  event2.text = p6.readString(length);
                  return event2;
                case 32:
                  event2.type = "channelPrefix";
                  if (length != 1)
                    throw "Expected length for channelPrefix event is 1, got " + length;
                  event2.channel = p6.readUInt8();
                  return event2;
                case 33:
                  event2.type = "portPrefix";
                  if (length != 1)
                    throw "Expected length for portPrefix event is 1, got " + length;
                  event2.port = p6.readUInt8();
                  return event2;
                case 47:
                  event2.type = "endOfTrack";
                  if (length != 0)
                    throw "Expected length for endOfTrack event is 0, got " + length;
                  return event2;
                case 81:
                  event2.type = "setTempo";
                  if (length != 3)
                    throw "Expected length for setTempo event is 3, got " + length;
                  event2.microsecondsPerBeat = p6.readUInt24();
                  return event2;
                case 84:
                  event2.type = "smpteOffset";
                  if (length != 5)
                    throw "Expected length for smpteOffset event is 5, got " + length;
                  var hourByte = p6.readUInt8();
                  var FRAME_RATES = { 0: 24, 32: 25, 64: 29, 96: 30 };
                  event2.frameRate = FRAME_RATES[hourByte & 96];
                  event2.hour = hourByte & 31;
                  event2.min = p6.readUInt8();
                  event2.sec = p6.readUInt8();
                  event2.frame = p6.readUInt8();
                  event2.subFrame = p6.readUInt8();
                  return event2;
                case 88:
                  event2.type = "timeSignature";
                  if (length != 2 && length != 4)
                    throw "Expected length for timeSignature event is 4 or 2, got " + length;
                  event2.numerator = p6.readUInt8();
                  event2.denominator = 1 << p6.readUInt8();
                  if (length === 4) {
                    event2.metronome = p6.readUInt8();
                    event2.thirtyseconds = p6.readUInt8();
                  } else {
                    event2.metronome = 36;
                    event2.thirtyseconds = 8;
                  }
                  return event2;
                case 89:
                  event2.type = "keySignature";
                  if (length != 2)
                    throw "Expected length for keySignature event is 2, got " + length;
                  event2.key = p6.readInt8();
                  event2.scale = p6.readUInt8();
                  return event2;
                case 127:
                  event2.type = "sequencerSpecific";
                  event2.data = p6.readBytes(length);
                  return event2;
                default:
                  event2.type = "unknownMeta";
                  event2.data = p6.readBytes(length);
                  event2.metatypeByte = metatypeByte;
                  return event2;
              }
            } else if (eventTypeByte == 240) {
              event2.type = "sysEx";
              var length = p6.readVarInt();
              event2.data = p6.readBytes(length);
              return event2;
            } else if (eventTypeByte == 247) {
              event2.type = "endSysEx";
              var length = p6.readVarInt();
              event2.data = p6.readBytes(length);
              return event2;
            } else {
              throw "Unrecognised MIDI event type byte: " + eventTypeByte;
            }
          } else {
            var param1;
            if ((eventTypeByte & 128) === 0) {
              if (lastEventTypeByte === null)
                throw "Running status byte encountered before status byte";
              param1 = eventTypeByte;
              eventTypeByte = lastEventTypeByte;
              event2.running = true;
            } else {
              param1 = p6.readUInt8();
              lastEventTypeByte = eventTypeByte;
            }
            var eventType = eventTypeByte >> 4;
            event2.channel = eventTypeByte & 15;
            switch (eventType) {
              case 8:
                event2.type = "noteOff";
                event2.noteNumber = param1;
                event2.velocity = p6.readUInt8();
                return event2;
              case 9:
                var velocity = p6.readUInt8();
                event2.type = velocity === 0 ? "noteOff" : "noteOn";
                event2.noteNumber = param1;
                event2.velocity = velocity;
                if (velocity === 0)
                  event2.byte9 = true;
                return event2;
              case 10:
                event2.type = "noteAftertouch";
                event2.noteNumber = param1;
                event2.amount = p6.readUInt8();
                return event2;
              case 11:
                event2.type = "controller";
                event2.controllerType = param1;
                event2.value = p6.readUInt8();
                return event2;
              case 12:
                event2.type = "programChange";
                event2.programNumber = param1;
                return event2;
              case 13:
                event2.type = "channelAftertouch";
                event2.amount = param1;
                return event2;
              case 14:
                event2.type = "pitchBend";
                event2.value = param1 + (p6.readUInt8() << 7) - 8192;
                return event2;
              default:
                throw "Unrecognised MIDI event type: " + eventType;
            }
          }
        }
      }
      function Parser(data) {
        this.buffer = data;
        this.bufferLen = this.buffer.length;
        this.pos = 0;
      }
      Parser.prototype.eof = function() {
        return this.pos >= this.bufferLen;
      };
      Parser.prototype.readUInt8 = function() {
        var result = this.buffer[this.pos];
        this.pos += 1;
        return result;
      };
      Parser.prototype.readInt8 = function() {
        var u7 = this.readUInt8();
        if (u7 & 128)
          return u7 - 256;
        else
          return u7;
      };
      Parser.prototype.readUInt16 = function() {
        var b0 = this.readUInt8(), b1 = this.readUInt8();
        return (b0 << 8) + b1;
      };
      Parser.prototype.readInt16 = function() {
        var u7 = this.readUInt16();
        if (u7 & 32768)
          return u7 - 65536;
        else
          return u7;
      };
      Parser.prototype.readUInt24 = function() {
        var b0 = this.readUInt8(), b1 = this.readUInt8(), b22 = this.readUInt8();
        return (b0 << 16) + (b1 << 8) + b22;
      };
      Parser.prototype.readInt24 = function() {
        var u7 = this.readUInt24();
        if (u7 & 8388608)
          return u7 - 16777216;
        else
          return u7;
      };
      Parser.prototype.readUInt32 = function() {
        var b0 = this.readUInt8(), b1 = this.readUInt8(), b22 = this.readUInt8(), b32 = this.readUInt8();
        return (b0 << 24) + (b1 << 16) + (b22 << 8) + b32;
      };
      Parser.prototype.readBytes = function(len) {
        var bytes = this.buffer.slice(this.pos, this.pos + len);
        this.pos += len;
        return bytes;
      };
      Parser.prototype.readString = function(len) {
        var bytes = this.readBytes(len);
        return String.fromCharCode.apply(null, bytes);
      };
      Parser.prototype.readVarInt = function() {
        var result = 0;
        while (!this.eof()) {
          var b5 = this.readUInt8();
          if (b5 & 128) {
            result += b5 & 127;
            result <<= 7;
          } else {
            return result + b5;
          }
        }
        return result;
      };
      Parser.prototype.readChunk = function() {
        var id = this.readString(4);
        var length = this.readUInt32();
        var data = this.readBytes(length);
        return {
          id,
          length,
          data
        };
      };
      module.exports = parseMidi;
    }
  });

  // node_modules/.pnpm/midi-file@1.2.3/node_modules/midi-file/lib/midi-writer.js
  var require_midi_writer = __commonJS({
    "node_modules/.pnpm/midi-file@1.2.3/node_modules/midi-file/lib/midi-writer.js"(exports, module) {
      function writeMidi(data, opts) {
        if (typeof data !== "object")
          throw "Invalid MIDI data";
        opts = opts || {};
        var header = data.header || {};
        var tracks2 = data.tracks || [];
        var i8, len = tracks2.length;
        var w3 = new Writer3();
        writeHeader(w3, header, len);
        for (i8 = 0; i8 < len; i8++) {
          writeTrack(w3, tracks2[i8], opts);
        }
        return w3.buffer;
      }
      function writeHeader(w3, header, numTracks) {
        var format = header.format == null ? 1 : header.format;
        var timeDivision = 128;
        if (header.timeDivision) {
          timeDivision = header.timeDivision;
        } else if (header.ticksPerFrame && header.framesPerSecond) {
          timeDivision = -(header.framesPerSecond & 255) << 8 | header.ticksPerFrame & 255;
        } else if (header.ticksPerBeat) {
          timeDivision = header.ticksPerBeat & 32767;
        }
        var h8 = new Writer3();
        h8.writeUInt16(format);
        h8.writeUInt16(numTracks);
        h8.writeUInt16(timeDivision);
        w3.writeChunk("MThd", h8.buffer);
      }
      function writeTrack(w3, track2, opts) {
        var t8 = new Writer3();
        var i8, len = track2.length;
        var eventTypeByte = null;
        for (i8 = 0; i8 < len; i8++) {
          if (opts.running === false || !opts.running && !track2[i8].running)
            eventTypeByte = null;
          eventTypeByte = writeEvent(t8, track2[i8], eventTypeByte, opts.useByte9ForNoteOff);
        }
        w3.writeChunk("MTrk", t8.buffer);
      }
      function writeEvent(w3, event, lastEventTypeByte, useByte9ForNoteOff) {
        var type = event.type;
        var deltaTime = event.deltaTime;
        var text = event.text || "";
        var data = event.data || [];
        var eventTypeByte = null;
        w3.writeVarInt(deltaTime);
        switch (type) {
          case "sequenceNumber":
            w3.writeUInt8(255);
            w3.writeUInt8(0);
            w3.writeVarInt(2);
            w3.writeUInt16(event.number);
            break;
          case "text":
            w3.writeUInt8(255);
            w3.writeUInt8(1);
            w3.writeVarInt(text.length);
            w3.writeString(text);
            break;
          case "copyrightNotice":
            w3.writeUInt8(255);
            w3.writeUInt8(2);
            w3.writeVarInt(text.length);
            w3.writeString(text);
            break;
          case "trackName":
            w3.writeUInt8(255);
            w3.writeUInt8(3);
            w3.writeVarInt(text.length);
            w3.writeString(text);
            break;
          case "instrumentName":
            w3.writeUInt8(255);
            w3.writeUInt8(4);
            w3.writeVarInt(text.length);
            w3.writeString(text);
            break;
          case "lyrics":
            w3.writeUInt8(255);
            w3.writeUInt8(5);
            w3.writeVarInt(text.length);
            w3.writeString(text);
            break;
          case "marker":
            w3.writeUInt8(255);
            w3.writeUInt8(6);
            w3.writeVarInt(text.length);
            w3.writeString(text);
            break;
          case "cuePoint":
            w3.writeUInt8(255);
            w3.writeUInt8(7);
            w3.writeVarInt(text.length);
            w3.writeString(text);
            break;
          case "channelPrefix":
            w3.writeUInt8(255);
            w3.writeUInt8(32);
            w3.writeVarInt(1);
            w3.writeUInt8(event.channel);
            break;
          case "portPrefix":
            w3.writeUInt8(255);
            w3.writeUInt8(33);
            w3.writeVarInt(1);
            w3.writeUInt8(event.port);
            break;
          case "endOfTrack":
            w3.writeUInt8(255);
            w3.writeUInt8(47);
            w3.writeVarInt(0);
            break;
          case "setTempo":
            w3.writeUInt8(255);
            w3.writeUInt8(81);
            w3.writeVarInt(3);
            w3.writeUInt24(event.microsecondsPerBeat);
            break;
          case "smpteOffset":
            w3.writeUInt8(255);
            w3.writeUInt8(84);
            w3.writeVarInt(5);
            var FRAME_RATES = { 24: 0, 25: 32, 29: 64, 30: 96 };
            var hourByte = event.hour & 31 | FRAME_RATES[event.frameRate];
            w3.writeUInt8(hourByte);
            w3.writeUInt8(event.min);
            w3.writeUInt8(event.sec);
            w3.writeUInt8(event.frame);
            w3.writeUInt8(event.subFrame);
            break;
          case "timeSignature":
            w3.writeUInt8(255);
            w3.writeUInt8(88);
            w3.writeVarInt(4);
            w3.writeUInt8(event.numerator);
            var denominator = Math.floor(Math.log(event.denominator) / Math.LN2) & 255;
            w3.writeUInt8(denominator);
            w3.writeUInt8(event.metronome);
            w3.writeUInt8(event.thirtyseconds || 8);
            break;
          case "keySignature":
            w3.writeUInt8(255);
            w3.writeUInt8(89);
            w3.writeVarInt(2);
            w3.writeInt8(event.key);
            w3.writeUInt8(event.scale);
            break;
          case "sequencerSpecific":
            w3.writeUInt8(255);
            w3.writeUInt8(127);
            w3.writeVarInt(data.length);
            w3.writeBytes(data);
            break;
          case "unknownMeta":
            if (event.metatypeByte != null) {
              w3.writeUInt8(255);
              w3.writeUInt8(event.metatypeByte);
              w3.writeVarInt(data.length);
              w3.writeBytes(data);
            }
            break;
          case "sysEx":
            w3.writeUInt8(240);
            w3.writeVarInt(data.length);
            w3.writeBytes(data);
            break;
          case "endSysEx":
            w3.writeUInt8(247);
            w3.writeVarInt(data.length);
            w3.writeBytes(data);
            break;
          case "noteOff":
            var noteByte = useByte9ForNoteOff !== false && event.byte9 || useByte9ForNoteOff && event.velocity == 0 ? 144 : 128;
            eventTypeByte = noteByte | event.channel;
            if (eventTypeByte !== lastEventTypeByte)
              w3.writeUInt8(eventTypeByte);
            w3.writeUInt8(event.noteNumber);
            w3.writeUInt8(event.velocity);
            break;
          case "noteOn":
            eventTypeByte = 144 | event.channel;
            if (eventTypeByte !== lastEventTypeByte)
              w3.writeUInt8(eventTypeByte);
            w3.writeUInt8(event.noteNumber);
            w3.writeUInt8(event.velocity);
            break;
          case "noteAftertouch":
            eventTypeByte = 160 | event.channel;
            if (eventTypeByte !== lastEventTypeByte)
              w3.writeUInt8(eventTypeByte);
            w3.writeUInt8(event.noteNumber);
            w3.writeUInt8(event.amount);
            break;
          case "controller":
            eventTypeByte = 176 | event.channel;
            if (eventTypeByte !== lastEventTypeByte)
              w3.writeUInt8(eventTypeByte);
            w3.writeUInt8(event.controllerType);
            w3.writeUInt8(event.value);
            break;
          case "programChange":
            eventTypeByte = 192 | event.channel;
            if (eventTypeByte !== lastEventTypeByte)
              w3.writeUInt8(eventTypeByte);
            w3.writeUInt8(event.programNumber);
            break;
          case "channelAftertouch":
            eventTypeByte = 208 | event.channel;
            if (eventTypeByte !== lastEventTypeByte)
              w3.writeUInt8(eventTypeByte);
            w3.writeUInt8(event.amount);
            break;
          case "pitchBend":
            eventTypeByte = 224 | event.channel;
            if (eventTypeByte !== lastEventTypeByte)
              w3.writeUInt8(eventTypeByte);
            var value14 = 8192 + event.value;
            var lsb14 = value14 & 127;
            var msb14 = value14 >> 7 & 127;
            w3.writeUInt8(lsb14);
            w3.writeUInt8(msb14);
            break;
          default:
            throw "Unrecognized event type: " + type;
        }
        return eventTypeByte;
      }
      function Writer3() {
        this.buffer = [];
      }
      Writer3.prototype.writeUInt8 = function(v3) {
        this.buffer.push(v3 & 255);
      };
      Writer3.prototype.writeInt8 = Writer3.prototype.writeUInt8;
      Writer3.prototype.writeUInt16 = function(v3) {
        var b0 = v3 >> 8 & 255, b1 = v3 & 255;
        this.writeUInt8(b0);
        this.writeUInt8(b1);
      };
      Writer3.prototype.writeInt16 = Writer3.prototype.writeUInt16;
      Writer3.prototype.writeUInt24 = function(v3) {
        var b0 = v3 >> 16 & 255, b1 = v3 >> 8 & 255, b22 = v3 & 255;
        this.writeUInt8(b0);
        this.writeUInt8(b1);
        this.writeUInt8(b22);
      };
      Writer3.prototype.writeInt24 = Writer3.prototype.writeUInt24;
      Writer3.prototype.writeUInt32 = function(v3) {
        var b0 = v3 >> 24 & 255, b1 = v3 >> 16 & 255, b22 = v3 >> 8 & 255, b32 = v3 & 255;
        this.writeUInt8(b0);
        this.writeUInt8(b1);
        this.writeUInt8(b22);
        this.writeUInt8(b32);
      };
      Writer3.prototype.writeInt32 = Writer3.prototype.writeUInt32;
      Writer3.prototype.writeBytes = function(arr) {
        this.buffer = this.buffer.concat(Array.prototype.slice.call(arr, 0));
      };
      Writer3.prototype.writeString = function(str) {
        var i8, len = str.length, arr = [];
        for (i8 = 0; i8 < len; i8++) {
          arr.push(str.codePointAt(i8));
        }
        this.writeBytes(arr);
      };
      Writer3.prototype.writeVarInt = function(v3) {
        if (v3 < 0)
          throw "Cannot write negative variable-length integer";
        if (v3 <= 127) {
          this.writeUInt8(v3);
        } else {
          var i8 = v3;
          var bytes = [];
          bytes.push(i8 & 127);
          i8 >>= 7;
          while (i8) {
            var b5 = i8 & 127 | 128;
            bytes.push(b5);
            i8 >>= 7;
          }
          this.writeBytes(bytes.reverse());
        }
      };
      Writer3.prototype.writeChunk = function(id, data) {
        this.writeString(id);
        this.writeUInt32(data.length);
        this.writeBytes(data);
      };
      module.exports = writeMidi;
    }
  });

  // node_modules/.pnpm/midi-file@1.2.3/node_modules/midi-file/index.js
  var require_midi_file = __commonJS({
    "node_modules/.pnpm/midi-file@1.2.3/node_modules/midi-file/index.js"(exports) {
      exports.parseMidi = require_midi_parser();
      exports.writeMidi = require_midi_writer();
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/BinarySearch.js
  var require_BinarySearch = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/BinarySearch.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.insert = exports.search = void 0;
      function search(array, value, prop) {
        if (prop === void 0) {
          prop = "ticks";
        }
        var beginning = 0;
        var len = array.length;
        var end = len;
        if (len > 0 && array[len - 1][prop] <= value) {
          return len - 1;
        }
        while (beginning < end) {
          var midPoint = Math.floor(beginning + (end - beginning) / 2);
          var event_1 = array[midPoint];
          var nextEvent = array[midPoint + 1];
          if (event_1[prop] === value) {
            for (var i8 = midPoint; i8 < array.length; i8++) {
              var testEvent = array[i8];
              if (testEvent[prop] === value) {
                midPoint = i8;
              }
            }
            return midPoint;
          } else if (event_1[prop] < value && nextEvent[prop] > value) {
            return midPoint;
          } else if (event_1[prop] > value) {
            end = midPoint;
          } else if (event_1[prop] < value) {
            beginning = midPoint + 1;
          }
        }
        return -1;
      }
      exports.search = search;
      function insert(array, event, prop) {
        if (prop === void 0) {
          prop = "ticks";
        }
        if (array.length) {
          var index15 = search(array, event[prop], prop);
          array.splice(index15 + 1, 0, event);
        } else {
          array.push(event);
        }
      }
      exports.insert = insert;
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Header.js
  var require_Header = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Header.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Header = exports.keySignatureKeys = void 0;
      var BinarySearch_1 = require_BinarySearch();
      var privatePPQMap = /* @__PURE__ */ new WeakMap();
      exports.keySignatureKeys = [
        "Cb",
        "Gb",
        "Db",
        "Ab",
        "Eb",
        "Bb",
        "F",
        "C",
        "G",
        "D",
        "A",
        "E",
        "B",
        "F#",
        "C#"
      ];
      var Header = function() {
        function Header2(midiData) {
          var _this = this;
          this.tempos = [];
          this.timeSignatures = [];
          this.keySignatures = [];
          this.meta = [];
          this.name = "";
          privatePPQMap.set(this, 480);
          if (midiData) {
            privatePPQMap.set(this, midiData.header.ticksPerBeat);
            midiData.tracks.forEach(function(track2) {
              track2.forEach(function(event) {
                if (event.meta) {
                  if (event.type === "timeSignature") {
                    _this.timeSignatures.push({
                      ticks: event.absoluteTime,
                      timeSignature: [
                        event.numerator,
                        event.denominator
                      ]
                    });
                  } else if (event.type === "setTempo") {
                    _this.tempos.push({
                      bpm: 6e7 / event.microsecondsPerBeat,
                      ticks: event.absoluteTime
                    });
                  } else if (event.type === "keySignature") {
                    _this.keySignatures.push({
                      key: exports.keySignatureKeys[event.key + 7],
                      scale: event.scale === 0 ? "major" : "minor",
                      ticks: event.absoluteTime
                    });
                  }
                }
              });
            });
            var firstTrackCurrentTicks_1 = 0;
            midiData.tracks[0].forEach(function(event) {
              firstTrackCurrentTicks_1 += event.deltaTime;
              if (event.meta) {
                if (event.type === "trackName") {
                  _this.name = event.text;
                } else if (event.type === "text" || event.type === "cuePoint" || event.type === "marker" || event.type === "lyrics") {
                  _this.meta.push({
                    text: event.text,
                    ticks: firstTrackCurrentTicks_1,
                    type: event.type
                  });
                }
              }
            });
            this.update();
          }
        }
        Header2.prototype.update = function() {
          var _this = this;
          var currentTime = 0;
          var lastEventBeats = 0;
          this.tempos.sort(function(a8, b5) {
            return a8.ticks - b5.ticks;
          });
          this.tempos.forEach(function(event, index15) {
            var lastBPM = index15 > 0 ? _this.tempos[index15 - 1].bpm : _this.tempos[0].bpm;
            var beats = event.ticks / _this.ppq - lastEventBeats;
            var elapsedSeconds = 60 / lastBPM * beats;
            event.time = elapsedSeconds + currentTime;
            currentTime = event.time;
            lastEventBeats += beats;
          });
          this.timeSignatures.sort(function(a8, b5) {
            return a8.ticks - b5.ticks;
          });
          this.timeSignatures.forEach(function(event, index15) {
            var lastEvent = index15 > 0 ? _this.timeSignatures[index15 - 1] : _this.timeSignatures[0];
            var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;
            var elapsedMeasures = elapsedBeats / lastEvent.timeSignature[0] / (lastEvent.timeSignature[1] / 4);
            lastEvent.measures = lastEvent.measures || 0;
            event.measures = elapsedMeasures + lastEvent.measures;
          });
        };
        Header2.prototype.ticksToSeconds = function(ticks) {
          var index15 = (0, BinarySearch_1.search)(this.tempos, ticks);
          if (index15 !== -1) {
            var tempo2 = this.tempos[index15];
            var tempoTime = tempo2.time;
            var elapsedBeats = (ticks - tempo2.ticks) / this.ppq;
            return tempoTime + 60 / tempo2.bpm * elapsedBeats;
          } else {
            var beats = ticks / this.ppq;
            return 60 / 120 * beats;
          }
        };
        Header2.prototype.ticksToMeasures = function(ticks) {
          var index15 = (0, BinarySearch_1.search)(this.timeSignatures, ticks);
          if (index15 !== -1) {
            var timeSigEvent = this.timeSignatures[index15];
            var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;
            return timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;
          } else {
            return ticks / this.ppq / 4;
          }
        };
        Object.defineProperty(Header2.prototype, "ppq", {
          get: function() {
            return privatePPQMap.get(this);
          },
          enumerable: false,
          configurable: true
        });
        Header2.prototype.secondsToTicks = function(seconds) {
          var index15 = (0, BinarySearch_1.search)(this.tempos, seconds, "time");
          if (index15 !== -1) {
            var tempo2 = this.tempos[index15];
            var tempoTime = tempo2.time;
            var elapsedTime = seconds - tempoTime;
            var elapsedBeats = elapsedTime / (60 / tempo2.bpm);
            return Math.round(tempo2.ticks + elapsedBeats * this.ppq);
          } else {
            var beats = seconds / (60 / 120);
            return Math.round(beats * this.ppq);
          }
        };
        Header2.prototype.toJSON = function() {
          return {
            keySignatures: this.keySignatures,
            meta: this.meta,
            name: this.name,
            ppq: this.ppq,
            tempos: this.tempos.map(function(t8) {
              return {
                bpm: t8.bpm,
                ticks: t8.ticks
              };
            }),
            timeSignatures: this.timeSignatures
          };
        };
        Header2.prototype.fromJSON = function(json) {
          this.name = json.name;
          this.tempos = json.tempos.map(function(t8) {
            return Object.assign({}, t8);
          });
          this.timeSignatures = json.timeSignatures.map(function(t8) {
            return Object.assign({}, t8);
          });
          this.keySignatures = json.keySignatures.map(function(t8) {
            return Object.assign({}, t8);
          });
          this.meta = json.meta.map(function(t8) {
            return Object.assign({}, t8);
          });
          privatePPQMap.set(this, json.ppq);
          this.update();
        };
        Header2.prototype.setTempo = function(bpm) {
          this.tempos = [
            {
              bpm,
              ticks: 0
            }
          ];
          this.update();
        };
        return Header2;
      }();
      exports.Header = Header;
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/ControlChange.js
  var require_ControlChange = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/ControlChange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ControlChange = exports.controlChangeIds = exports.controlChangeNames = void 0;
      exports.controlChangeNames = {
        1: "modulationWheel",
        2: "breath",
        4: "footController",
        5: "portamentoTime",
        7: "volume",
        8: "balance",
        10: "pan",
        64: "sustain",
        65: "portamentoTime",
        66: "sostenuto",
        67: "softPedal",
        68: "legatoFootswitch",
        84: "portamentoControl"
      };
      exports.controlChangeIds = Object.keys(exports.controlChangeNames).reduce(function(obj, key) {
        obj[exports.controlChangeNames[key]] = key;
        return obj;
      }, {});
      var privateHeaderMap = /* @__PURE__ */ new WeakMap();
      var privateCCNumberMap = /* @__PURE__ */ new WeakMap();
      var ControlChange = function() {
        function ControlChange2(event, header) {
          privateHeaderMap.set(this, header);
          privateCCNumberMap.set(this, event.controllerType);
          this.ticks = event.absoluteTime;
          this.value = event.value;
        }
        Object.defineProperty(ControlChange2.prototype, "number", {
          get: function() {
            return privateCCNumberMap.get(this);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ControlChange2.prototype, "name", {
          get: function() {
            if (exports.controlChangeNames[this.number]) {
              return exports.controlChangeNames[this.number];
            } else {
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ControlChange2.prototype, "time", {
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
          },
          set: function(t8) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t8);
          },
          enumerable: false,
          configurable: true
        });
        ControlChange2.prototype.toJSON = function() {
          return {
            number: this.number,
            ticks: this.ticks,
            time: this.time,
            value: this.value
          };
        };
        return ControlChange2;
      }();
      exports.ControlChange = ControlChange;
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/ControlChanges.js
  var require_ControlChanges = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/ControlChanges.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createControlChanges = void 0;
      var ControlChange_1 = require_ControlChange();
      function createControlChanges() {
        return new Proxy({}, {
          get: function(target, handler2) {
            if (target[handler2]) {
              return target[handler2];
            } else if (ControlChange_1.controlChangeIds.hasOwnProperty(handler2)) {
              return target[ControlChange_1.controlChangeIds[handler2]];
            }
          },
          set: function(target, handler2, value) {
            if (ControlChange_1.controlChangeIds.hasOwnProperty(handler2)) {
              target[ControlChange_1.controlChangeIds[handler2]] = value;
            } else {
              target[handler2] = value;
            }
            return true;
          }
        });
      }
      exports.createControlChanges = createControlChanges;
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/PitchBend.js
  var require_PitchBend = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/PitchBend.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PitchBend = void 0;
      var privateHeaderMap = /* @__PURE__ */ new WeakMap();
      var PitchBend = function() {
        function PitchBend2(event, header) {
          privateHeaderMap.set(this, header);
          this.ticks = event.absoluteTime;
          this.value = event.value;
        }
        Object.defineProperty(PitchBend2.prototype, "time", {
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
          },
          set: function(t8) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t8);
          },
          enumerable: false,
          configurable: true
        });
        PitchBend2.prototype.toJSON = function() {
          return {
            ticks: this.ticks,
            time: this.time,
            value: this.value
          };
        };
        return PitchBend2;
      }();
      exports.PitchBend = PitchBend;
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/InstrumentMaps.js
  var require_InstrumentMaps = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/InstrumentMaps.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DrumKitByPatchID = exports.InstrumentFamilyByID = exports.instrumentByPatchID = void 0;
      exports.instrumentByPatchID = [
        "acoustic grand piano",
        "bright acoustic piano",
        "electric grand piano",
        "honky-tonk piano",
        "electric piano 1",
        "electric piano 2",
        "harpsichord",
        "clavi",
        "celesta",
        "glockenspiel",
        "music box",
        "vibraphone",
        "marimba",
        "xylophone",
        "tubular bells",
        "dulcimer",
        "drawbar organ",
        "percussive organ",
        "rock organ",
        "church organ",
        "reed organ",
        "accordion",
        "harmonica",
        "tango accordion",
        "acoustic guitar (nylon)",
        "acoustic guitar (steel)",
        "electric guitar (jazz)",
        "electric guitar (clean)",
        "electric guitar (muted)",
        "overdriven guitar",
        "distortion guitar",
        "guitar harmonics",
        "acoustic bass",
        "electric bass (finger)",
        "electric bass (pick)",
        "fretless bass",
        "slap bass 1",
        "slap bass 2",
        "synth bass 1",
        "synth bass 2",
        "violin",
        "viola",
        "cello",
        "contrabass",
        "tremolo strings",
        "pizzicato strings",
        "orchestral harp",
        "timpani",
        "string ensemble 1",
        "string ensemble 2",
        "synthstrings 1",
        "synthstrings 2",
        "choir aahs",
        "voice oohs",
        "synth voice",
        "orchestra hit",
        "trumpet",
        "trombone",
        "tuba",
        "muted trumpet",
        "french horn",
        "brass section",
        "synthbrass 1",
        "synthbrass 2",
        "soprano sax",
        "alto sax",
        "tenor sax",
        "baritone sax",
        "oboe",
        "english horn",
        "bassoon",
        "clarinet",
        "piccolo",
        "flute",
        "recorder",
        "pan flute",
        "blown bottle",
        "shakuhachi",
        "whistle",
        "ocarina",
        "lead 1 (square)",
        "lead 2 (sawtooth)",
        "lead 3 (calliope)",
        "lead 4 (chiff)",
        "lead 5 (charang)",
        "lead 6 (voice)",
        "lead 7 (fifths)",
        "lead 8 (bass + lead)",
        "pad 1 (new age)",
        "pad 2 (warm)",
        "pad 3 (polysynth)",
        "pad 4 (choir)",
        "pad 5 (bowed)",
        "pad 6 (metallic)",
        "pad 7 (halo)",
        "pad 8 (sweep)",
        "fx 1 (rain)",
        "fx 2 (soundtrack)",
        "fx 3 (crystal)",
        "fx 4 (atmosphere)",
        "fx 5 (brightness)",
        "fx 6 (goblins)",
        "fx 7 (echoes)",
        "fx 8 (sci-fi)",
        "sitar",
        "banjo",
        "shamisen",
        "koto",
        "kalimba",
        "bag pipe",
        "fiddle",
        "shanai",
        "tinkle bell",
        "agogo",
        "steel drums",
        "woodblock",
        "taiko drum",
        "melodic tom",
        "synth drum",
        "reverse cymbal",
        "guitar fret noise",
        "breath noise",
        "seashore",
        "bird tweet",
        "telephone ring",
        "helicopter",
        "applause",
        "gunshot"
      ];
      exports.InstrumentFamilyByID = [
        "piano",
        "chromatic percussion",
        "organ",
        "guitar",
        "bass",
        "strings",
        "ensemble",
        "brass",
        "reed",
        "pipe",
        "synth lead",
        "synth pad",
        "synth effects",
        "world",
        "percussive",
        "sound effects"
      ];
      exports.DrumKitByPatchID = {
        0: "standard kit",
        8: "room kit",
        16: "power kit",
        24: "electronic kit",
        25: "tr-808 kit",
        32: "jazz kit",
        40: "brush kit",
        48: "orchestra kit",
        56: "sound fx kit"
      };
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Instrument.js
  var require_Instrument = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Instrument.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Instrument = void 0;
      var InstrumentMaps_1 = require_InstrumentMaps();
      var privateTrackMap = /* @__PURE__ */ new WeakMap();
      var Instrument2 = function() {
        function Instrument3(trackData, track2) {
          this.number = 0;
          privateTrackMap.set(this, track2);
          this.number = 0;
          if (trackData) {
            var programChange = trackData.find(function(e8) {
              return e8.type === "programChange";
            });
            if (programChange) {
              this.number = programChange.programNumber;
            }
          }
        }
        Object.defineProperty(Instrument3.prototype, "name", {
          get: function() {
            if (this.percussion) {
              return InstrumentMaps_1.DrumKitByPatchID[this.number];
            } else {
              return InstrumentMaps_1.instrumentByPatchID[this.number];
            }
          },
          set: function(n8) {
            var patchNumber = InstrumentMaps_1.instrumentByPatchID.indexOf(n8);
            if (patchNumber !== -1) {
              this.number = patchNumber;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Instrument3.prototype, "family", {
          get: function() {
            if (this.percussion) {
              return "drums";
            } else {
              return InstrumentMaps_1.InstrumentFamilyByID[Math.floor(this.number / 8)];
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Instrument3.prototype, "percussion", {
          get: function() {
            var track2 = privateTrackMap.get(this);
            return track2.channel === 9;
          },
          enumerable: false,
          configurable: true
        });
        Instrument3.prototype.toJSON = function() {
          return {
            family: this.family,
            number: this.number,
            name: this.name
          };
        };
        Instrument3.prototype.fromJSON = function(json) {
          this.number = json.number;
        };
        return Instrument3;
      }();
      exports.Instrument = Instrument2;
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Note.js
  var require_Note = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Note.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Note = void 0;
      function midiToPitch(midi4) {
        var octave2 = Math.floor(midi4 / 12) - 1;
        return midiToPitchClass(midi4) + octave2.toString();
      }
      function midiToPitchClass(midi4) {
        var scaleIndexToNote2 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        var note3 = midi4 % 12;
        return scaleIndexToNote2[note3];
      }
      function pitchClassToMidi(pitch) {
        var scaleIndexToNote2 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        return scaleIndexToNote2.indexOf(pitch);
      }
      var pitchToMidi = function() {
        var regexp = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;
        var noteToScaleIndex2 = {
          cbb: -2,
          cb: -1,
          c: 0,
          "c#": 1,
          cx: 2,
          dbb: 0,
          db: 1,
          d: 2,
          "d#": 3,
          dx: 4,
          ebb: 2,
          eb: 3,
          e: 4,
          "e#": 5,
          ex: 6,
          fbb: 3,
          fb: 4,
          f: 5,
          "f#": 6,
          fx: 7,
          gbb: 5,
          gb: 6,
          g: 7,
          "g#": 8,
          gx: 9,
          abb: 7,
          ab: 8,
          a: 9,
          "a#": 10,
          ax: 11,
          bbb: 9,
          bb: 10,
          b: 11,
          "b#": 12,
          bx: 13
        };
        return function(note3) {
          var split = regexp.exec(note3);
          var pitch = split[1];
          var octave2 = split[2];
          var index15 = noteToScaleIndex2[pitch.toLowerCase()];
          return index15 + (parseInt(octave2, 10) + 1) * 12;
        };
      }();
      var privateHeaderMap = /* @__PURE__ */ new WeakMap();
      var Note = function() {
        function Note2(noteOn, noteOff, header) {
          privateHeaderMap.set(this, header);
          this.midi = noteOn.midi;
          this.velocity = noteOn.velocity;
          this.noteOffVelocity = noteOff.velocity;
          this.ticks = noteOn.ticks;
          this.durationTicks = noteOff.ticks - noteOn.ticks;
        }
        Object.defineProperty(Note2.prototype, "name", {
          get: function() {
            return midiToPitch(this.midi);
          },
          set: function(n8) {
            this.midi = pitchToMidi(n8);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "octave", {
          get: function() {
            return Math.floor(this.midi / 12) - 1;
          },
          set: function(o8) {
            var diff = o8 - this.octave;
            this.midi += diff * 12;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "pitch", {
          get: function() {
            return midiToPitchClass(this.midi);
          },
          set: function(p6) {
            this.midi = 12 * (this.octave + 1) + pitchClassToMidi(p6);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "duration", {
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks + this.durationTicks) - header.ticksToSeconds(this.ticks);
          },
          set: function(d5) {
            var header = privateHeaderMap.get(this);
            var noteEndTicks = header.secondsToTicks(this.time + d5);
            this.durationTicks = noteEndTicks - this.ticks;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "time", {
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
          },
          set: function(t8) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t8);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "bars", {
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToMeasures(this.ticks);
          },
          enumerable: false,
          configurable: true
        });
        Note2.prototype.toJSON = function() {
          return {
            duration: this.duration,
            durationTicks: this.durationTicks,
            midi: this.midi,
            name: this.name,
            ticks: this.ticks,
            time: this.time,
            velocity: this.velocity
          };
        };
        return Note2;
      }();
      exports.Note = Note;
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Track.js
  var require_Track = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Track.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Track = void 0;
      var BinarySearch_1 = require_BinarySearch();
      var ControlChange_1 = require_ControlChange();
      var ControlChanges_1 = require_ControlChanges();
      var PitchBend_1 = require_PitchBend();
      var Instrument_1 = require_Instrument();
      var Note_1 = require_Note();
      var privateHeaderMap = /* @__PURE__ */ new WeakMap();
      var Track3 = function() {
        function Track4(trackData, header) {
          var _this = this;
          this.name = "";
          this.notes = [];
          this.controlChanges = (0, ControlChanges_1.createControlChanges)();
          this.pitchBends = [];
          privateHeaderMap.set(this, header);
          if (trackData) {
            var nameEvent = trackData.find(function(e8) {
              return e8.type === "trackName";
            });
            this.name = nameEvent ? nameEvent.text : "";
          }
          this.instrument = new Instrument_1.Instrument(trackData, this);
          this.channel = 0;
          if (trackData) {
            var noteOns = trackData.filter(function(event) {
              return event.type === "noteOn";
            });
            var noteOffs = trackData.filter(function(event) {
              return event.type === "noteOff";
            });
            var _loop_1 = function() {
              var currentNote = noteOns.shift();
              this_1.channel = currentNote.channel;
              var offIndex = noteOffs.findIndex(function(note3) {
                return note3.noteNumber === currentNote.noteNumber && note3.absoluteTime >= currentNote.absoluteTime;
              });
              if (offIndex !== -1) {
                var noteOff = noteOffs.splice(offIndex, 1)[0];
                this_1.addNote({
                  durationTicks: noteOff.absoluteTime - currentNote.absoluteTime,
                  midi: currentNote.noteNumber,
                  noteOffVelocity: noteOff.velocity / 127,
                  ticks: currentNote.absoluteTime,
                  velocity: currentNote.velocity / 127
                });
              }
            };
            var this_1 = this;
            while (noteOns.length) {
              _loop_1();
            }
            var controlChanges = trackData.filter(function(event) {
              return event.type === "controller";
            });
            controlChanges.forEach(function(event) {
              _this.addCC({
                number: event.controllerType,
                ticks: event.absoluteTime,
                value: event.value / 127
              });
            });
            var pitchBends = trackData.filter(function(event) {
              return event.type === "pitchBend";
            });
            pitchBends.forEach(function(event) {
              _this.addPitchBend({
                ticks: event.absoluteTime,
                value: event.value / Math.pow(2, 13)
              });
            });
            var endOfTrackEvent = trackData.find(function(event) {
              return event.type === "endOfTrack";
            });
            this.endOfTrackTicks = endOfTrackEvent !== void 0 ? endOfTrackEvent.absoluteTime : void 0;
          }
        }
        Track4.prototype.addNote = function(props) {
          var header = privateHeaderMap.get(this);
          var note3 = new Note_1.Note({
            midi: 0,
            ticks: 0,
            velocity: 1
          }, {
            ticks: 0,
            velocity: 0
          }, header);
          Object.assign(note3, props);
          (0, BinarySearch_1.insert)(this.notes, note3, "ticks");
          return this;
        };
        Track4.prototype.addCC = function(props) {
          var header = privateHeaderMap.get(this);
          var cc = new ControlChange_1.ControlChange({
            controllerType: props.number
          }, header);
          delete props.number;
          Object.assign(cc, props);
          if (!Array.isArray(this.controlChanges[cc.number])) {
            this.controlChanges[cc.number] = [];
          }
          (0, BinarySearch_1.insert)(this.controlChanges[cc.number], cc, "ticks");
          return this;
        };
        Track4.prototype.addPitchBend = function(props) {
          var header = privateHeaderMap.get(this);
          var pb = new PitchBend_1.PitchBend({}, header);
          Object.assign(pb, props);
          (0, BinarySearch_1.insert)(this.pitchBends, pb, "ticks");
          return this;
        };
        Object.defineProperty(Track4.prototype, "duration", {
          get: function() {
            if (!this.notes.length) {
              return 0;
            }
            var maxDuration = this.notes[this.notes.length - 1].time + this.notes[this.notes.length - 1].duration;
            for (var i8 = 0; i8 < this.notes.length - 1; i8++) {
              var duration2 = this.notes[i8].time + this.notes[i8].duration;
              if (maxDuration < duration2) {
                maxDuration = duration2;
              }
            }
            return maxDuration;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Track4.prototype, "durationTicks", {
          get: function() {
            if (!this.notes.length) {
              return 0;
            }
            var maxDuration = this.notes[this.notes.length - 1].ticks + this.notes[this.notes.length - 1].durationTicks;
            for (var i8 = 0; i8 < this.notes.length - 1; i8++) {
              var duration2 = this.notes[i8].ticks + this.notes[i8].durationTicks;
              if (maxDuration < duration2) {
                maxDuration = duration2;
              }
            }
            return maxDuration;
          },
          enumerable: false,
          configurable: true
        });
        Track4.prototype.fromJSON = function(json) {
          var _this = this;
          this.name = json.name;
          this.channel = json.channel;
          this.instrument = new Instrument_1.Instrument(void 0, this);
          this.instrument.fromJSON(json.instrument);
          if (json.endOfTrackTicks !== void 0) {
            this.endOfTrackTicks = json.endOfTrackTicks;
          }
          for (var number in json.controlChanges) {
            if (json.controlChanges[number]) {
              json.controlChanges[number].forEach(function(cc) {
                _this.addCC({
                  number: cc.number,
                  ticks: cc.ticks,
                  value: cc.value
                });
              });
            }
          }
          json.notes.forEach(function(n8) {
            _this.addNote({
              durationTicks: n8.durationTicks,
              midi: n8.midi,
              ticks: n8.ticks,
              velocity: n8.velocity
            });
          });
        };
        Track4.prototype.toJSON = function() {
          var controlChanges = {};
          for (var i8 = 0; i8 < 127; i8++) {
            if (this.controlChanges.hasOwnProperty(i8)) {
              controlChanges[i8] = this.controlChanges[i8].map(function(c6) {
                return c6.toJSON();
              });
            }
          }
          var json = {
            channel: this.channel,
            controlChanges,
            pitchBends: this.pitchBends.map(function(pb) {
              return pb.toJSON();
            }),
            instrument: this.instrument.toJSON(),
            name: this.name,
            notes: this.notes.map(function(n8) {
              return n8.toJSON();
            })
          };
          if (this.endOfTrackTicks !== void 0) {
            json.endOfTrackTicks = this.endOfTrackTicks;
          }
          return json;
        };
        return Track4;
      }();
      exports.Track = Track3;
    }
  });

  // node_modules/.pnpm/array-flatten@3.0.0/node_modules/array-flatten/dist.es2015/index.js
  var dist_exports = {};
  __export(dist_exports, {
    flatten: () => flatten
  });
  function flatten(array) {
    var result = [];
    $flatten(array, result);
    return result;
  }
  function $flatten(array, result) {
    for (var i8 = 0; i8 < array.length; i8++) {
      var value = array[i8];
      if (Array.isArray(value)) {
        $flatten(value, result);
      } else {
        result.push(value);
      }
    }
  }
  var init_dist = __esm({
    "node_modules/.pnpm/array-flatten@3.0.0/node_modules/array-flatten/dist.es2015/index.js"() {
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Encode.js
  var require_Encode = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Encode.js"(exports) {
      "use strict";
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i8 = 0, l5 = from.length, ar; i8 < l5; i8++) {
            if (ar || !(i8 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i8);
              ar[i8] = from[i8];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encode = void 0;
      var midi_file_1 = require_midi_file();
      var Header_1 = require_Header();
      var array_flatten_1 = (init_dist(), __toCommonJS(dist_exports));
      function encodeNote(note3, channel) {
        return [
          {
            absoluteTime: note3.ticks,
            channel,
            deltaTime: 0,
            noteNumber: note3.midi,
            type: "noteOn",
            velocity: Math.floor(note3.velocity * 127)
          },
          {
            absoluteTime: note3.ticks + note3.durationTicks,
            channel,
            deltaTime: 0,
            noteNumber: note3.midi,
            type: "noteOff",
            velocity: Math.floor(note3.noteOffVelocity * 127)
          }
        ];
      }
      function encodeNotes(track2) {
        return (0, array_flatten_1.flatten)(track2.notes.map(function(note3) {
          return encodeNote(note3, track2.channel);
        }));
      }
      function encodeControlChange(cc, channel) {
        return {
          absoluteTime: cc.ticks,
          channel,
          controllerType: cc.number,
          deltaTime: 0,
          type: "controller",
          value: Math.floor(cc.value * 127)
        };
      }
      function encodeControlChanges(track2) {
        var controlChanges = [];
        for (var i8 = 0; i8 < 127; i8++) {
          if (track2.controlChanges.hasOwnProperty(i8)) {
            track2.controlChanges[i8].forEach(function(cc) {
              controlChanges.push(encodeControlChange(cc, track2.channel));
            });
          }
        }
        return controlChanges;
      }
      function encodePitchBend(pb, channel) {
        return {
          absoluteTime: pb.ticks,
          channel,
          deltaTime: 0,
          type: "pitchBend",
          value: pb.value
        };
      }
      function encodePitchBends(track2) {
        var pitchBends = [];
        track2.pitchBends.forEach(function(pb) {
          pitchBends.push(encodePitchBend(pb, track2.channel));
        });
        return pitchBends;
      }
      function encodeInstrument(track2) {
        return {
          absoluteTime: 0,
          channel: track2.channel,
          deltaTime: 0,
          programNumber: track2.instrument.number,
          type: "programChange"
        };
      }
      function encodeTrackName(name2) {
        return {
          absoluteTime: 0,
          deltaTime: 0,
          meta: true,
          text: name2,
          type: "trackName"
        };
      }
      function encodeTempo(tempo2) {
        return {
          absoluteTime: tempo2.ticks,
          deltaTime: 0,
          meta: true,
          microsecondsPerBeat: Math.floor(6e7 / tempo2.bpm),
          type: "setTempo"
        };
      }
      function encodeTimeSignature(timeSig) {
        return {
          absoluteTime: timeSig.ticks,
          deltaTime: 0,
          denominator: timeSig.timeSignature[1],
          meta: true,
          metronome: 24,
          numerator: timeSig.timeSignature[0],
          thirtyseconds: 8,
          type: "timeSignature"
        };
      }
      function encodeKeySignature(keySig) {
        var keyIndex = Header_1.keySignatureKeys.indexOf(keySig.key);
        return {
          absoluteTime: keySig.ticks,
          deltaTime: 0,
          key: keyIndex + 7,
          meta: true,
          scale: keySig.scale === "major" ? 0 : 1,
          type: "keySignature"
        };
      }
      function encodeText(textEvent) {
        return {
          absoluteTime: textEvent.ticks,
          deltaTime: 0,
          meta: true,
          text: textEvent.text,
          type: textEvent.type
        };
      }
      function encode2(midi4) {
        var midiData = {
          header: {
            format: 1,
            numTracks: midi4.tracks.length + 1,
            ticksPerBeat: midi4.header.ppq
          },
          tracks: __spreadArray2([
            __spreadArray2(__spreadArray2(__spreadArray2(__spreadArray2([
              {
                absoluteTime: 0,
                deltaTime: 0,
                meta: true,
                text: midi4.header.name,
                type: "trackName"
              }
            ], midi4.header.keySignatures.map(function(keySig) {
              return encodeKeySignature(keySig);
            }), true), midi4.header.meta.map(function(e8) {
              return encodeText(e8);
            }), true), midi4.header.tempos.map(function(tempo2) {
              return encodeTempo(tempo2);
            }), true), midi4.header.timeSignatures.map(function(timeSig) {
              return encodeTimeSignature(timeSig);
            }), true)
          ], midi4.tracks.map(function(track2) {
            return __spreadArray2(__spreadArray2(__spreadArray2([
              encodeTrackName(track2.name),
              encodeInstrument(track2)
            ], encodeNotes(track2), true), encodeControlChanges(track2), true), encodePitchBends(track2), true);
          }), true)
        };
        midiData.tracks = midiData.tracks.map(function(track2) {
          track2 = track2.sort(function(a8, b5) {
            return a8.absoluteTime - b5.absoluteTime;
          });
          var lastTime = 0;
          track2.forEach(function(note3) {
            note3.deltaTime = note3.absoluteTime - lastTime;
            lastTime = note3.absoluteTime;
            delete note3.absoluteTime;
          });
          track2.push({
            deltaTime: 0,
            meta: true,
            type: "endOfTrack"
          });
          return track2;
        });
        return new Uint8Array((0, midi_file_1.writeMidi)(midiData));
      }
      exports.encode = encode2;
    }
  });

  // node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Midi.js
  var require_Midi = __commonJS({
    "node_modules/.pnpm/@tonejs+midi@2.0.28/node_modules/@tonejs/midi/dist/Midi.js"(exports) {
      "use strict";
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e8) {
              reject(e8);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e8) {
              reject(e8);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator2 = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t8[0] & 1)
            throw t8[1];
          return t8[1];
        }, trys: [], ops: [] }, f4, y3, t8, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n8) {
          return function(v3) {
            return step([n8, v3]);
          };
        }
        function step(op) {
          if (f4)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f4 = 1, y3 && (t8 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t8 = y3["return"]) && t8.call(y3), 0) : y3.next) && !(t8 = t8.call(y3, op[1])).done)
                return t8;
              if (y3 = 0, t8)
                op = [op[0] & 2, t8.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t8 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t8 = _.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t8[1]) {
                    _.label = t8[1];
                    t8 = op;
                    break;
                  }
                  if (t8 && _.label < t8[2]) {
                    _.label = t8[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t8[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e8) {
              op = [6, e8];
              y3 = 0;
            } finally {
              f4 = t8 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Header = exports.Track = exports.Midi = void 0;
      var midi_file_1 = require_midi_file();
      var Header_1 = require_Header();
      var Track_1 = require_Track();
      var Encode_1 = require_Encode();
      var Midi3 = function() {
        function Midi4(midiArray) {
          var _this = this;
          var midiData = null;
          if (midiArray) {
            var midiArrayLike = midiArray instanceof ArrayBuffer ? new Uint8Array(midiArray) : midiArray;
            midiData = (0, midi_file_1.parseMidi)(midiArrayLike);
            midiData.tracks.forEach(function(track2) {
              var currentTicks = 0;
              track2.forEach(function(event) {
                currentTicks += event.deltaTime;
                event.absoluteTime = currentTicks;
              });
            });
            midiData.tracks = splitTracks(midiData.tracks);
          }
          this.header = new Header_1.Header(midiData);
          this.tracks = [];
          if (midiArray) {
            this.tracks = midiData.tracks.map(function(trackData) {
              return new Track_1.Track(trackData, _this.header);
            });
            if (midiData.header.format === 1 && this.tracks[0].duration === 0) {
              this.tracks.shift();
            }
          }
        }
        Midi4.fromUrl = function(url) {
          return __awaiter2(this, void 0, void 0, function() {
            var response, arrayBuffer;
            return __generator2(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, fetch(url)];
                case 1:
                  response = _a3.sent();
                  if (!response.ok)
                    return [3, 3];
                  return [4, response.arrayBuffer()];
                case 2:
                  arrayBuffer = _a3.sent();
                  return [2, new Midi4(arrayBuffer)];
                case 3:
                  throw new Error("Could not load '".concat(url, "'"));
              }
            });
          });
        };
        Object.defineProperty(Midi4.prototype, "name", {
          get: function() {
            return this.header.name;
          },
          set: function(n8) {
            this.header.name = n8;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Midi4.prototype, "duration", {
          get: function() {
            var durations = this.tracks.map(function(t8) {
              return t8.duration;
            });
            return Math.max.apply(Math, durations);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Midi4.prototype, "durationTicks", {
          get: function() {
            var durationTicks = this.tracks.map(function(t8) {
              return t8.durationTicks;
            });
            return Math.max.apply(Math, durationTicks);
          },
          enumerable: false,
          configurable: true
        });
        Midi4.prototype.addTrack = function() {
          var track2 = new Track_1.Track(void 0, this.header);
          this.tracks.push(track2);
          return track2;
        };
        Midi4.prototype.toArray = function() {
          return (0, Encode_1.encode)(this);
        };
        Midi4.prototype.toJSON = function() {
          return {
            header: this.header.toJSON(),
            tracks: this.tracks.map(function(track2) {
              return track2.toJSON();
            })
          };
        };
        Midi4.prototype.fromJSON = function(json) {
          var _this = this;
          this.header = new Header_1.Header();
          this.header.fromJSON(json.header);
          this.tracks = json.tracks.map(function(trackJSON) {
            var track2 = new Track_1.Track(void 0, _this.header);
            track2.fromJSON(trackJSON);
            return track2;
          });
        };
        Midi4.prototype.clone = function() {
          var midi4 = new Midi4();
          midi4.fromJSON(this.toJSON());
          return midi4;
        };
        return Midi4;
      }();
      exports.Midi = Midi3;
      var Track_2 = require_Track();
      Object.defineProperty(exports, "Track", { enumerable: true, get: function() {
        return Track_2.Track;
      } });
      var Header_2 = require_Header();
      Object.defineProperty(exports, "Header", { enumerable: true, get: function() {
        return Header_2.Header;
      } });
      function splitTracks(tracks2) {
        var newTracks = [];
        for (var i8 = 0; i8 < tracks2.length; i8++) {
          var defaultTrack = newTracks.length;
          var trackMap = /* @__PURE__ */ new Map();
          var currentProgram = Array(16).fill(0);
          for (var _i = 0, _a3 = tracks2[i8]; _i < _a3.length; _i++) {
            var event_1 = _a3[_i];
            var targetTrack = defaultTrack;
            var channel = event_1.channel;
            if (channel !== void 0) {
              if (event_1.type === "programChange") {
                currentProgram[channel] = event_1.programNumber;
              }
              var program = currentProgram[channel];
              var trackKey = "".concat(program, " ").concat(channel);
              if (trackMap.has(trackKey)) {
                targetTrack = trackMap.get(trackKey);
              } else {
                targetTrack = defaultTrack + trackMap.size;
                trackMap.set(trackKey, targetTrack);
              }
            }
            if (!newTracks[targetTrack]) {
              newTracks.push([]);
            }
            newTracks[targetTrack].push(event_1);
          }
        }
        return newTracks;
      }
    }
  });

  // node_modules/.pnpm/meyda@5.5.1/node_modules/meyda/dist/node/main.js
  var require_main = __commonJS({
    "node_modules/.pnpm/meyda@5.5.1/node_modules/meyda/dist/node/main.js"(exports, module) {
      "use strict";
      function __spreadArray2(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i8 = 0, l5 = from.length, ar; i8 < l5; i8++) {
            if (ar || !(i8 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i8);
              ar[i8] = from[i8];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      }
      function blackman(size2) {
        var blackmanBuffer = new Float32Array(size2);
        var coeff1 = 2 * Math.PI / (size2 - 1);
        var coeff2 = 2 * coeff1;
        for (var i8 = 0; i8 < size2 / 2; i8++) {
          blackmanBuffer[i8] = 0.42 - 0.5 * Math.cos(i8 * coeff1) + 0.08 * Math.cos(i8 * coeff2);
        }
        for (var i8 = Math.ceil(size2 / 2); i8 > 0; i8--) {
          blackmanBuffer[size2 - i8] = blackmanBuffer[i8 - 1];
        }
        return blackmanBuffer;
      }
      function sine(size2) {
        var coeff = Math.PI / (size2 - 1);
        var sineBuffer = new Float32Array(size2);
        for (var i8 = 0; i8 < size2; i8++) {
          sineBuffer[i8] = Math.sin(coeff * i8);
        }
        return sineBuffer;
      }
      function hanning(size2) {
        var hanningBuffer = new Float32Array(size2);
        for (var i8 = 0; i8 < size2; i8++) {
          hanningBuffer[i8] = 0.5 - 0.5 * Math.cos(2 * Math.PI * i8 / (size2 - 1));
        }
        return hanningBuffer;
      }
      function hamming(size2) {
        var hammingBuffer = new Float32Array(size2);
        for (var i8 = 0; i8 < size2; i8++) {
          hammingBuffer[i8] = 0.54 - 0.46 * Math.cos(2 * Math.PI * (i8 / size2 - 1));
        }
        return hammingBuffer;
      }
      var windowing = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        blackman,
        sine,
        hanning,
        hamming
      });
      var windows = {};
      function isPowerOfTwo(num2) {
        while (num2 % 2 === 0 && num2 > 1) {
          num2 /= 2;
        }
        return num2 === 1;
      }
      function pointwiseBufferMult(a8, b5) {
        var c6 = [];
        for (var i8 = 0; i8 < Math.min(a8.length, b5.length); i8++) {
          c6[i8] = a8[i8] * b5[i8];
        }
        return c6;
      }
      function applyWindow(signal, windowname) {
        if (windowname !== "rect") {
          if (windowname === "" || !windowname)
            windowname = "hanning";
          if (!windows[windowname])
            windows[windowname] = {};
          if (!windows[windowname][signal.length]) {
            try {
              windows[windowname][signal.length] = windowing[windowname](signal.length);
            } catch (e8) {
              throw new Error("Invalid windowing function");
            }
          }
          signal = pointwiseBufferMult(signal, windows[windowname][signal.length]);
        }
        return signal;
      }
      function createBarkScale(length, sampleRate, bufferSize) {
        var barkScale = new Float32Array(length);
        for (var i8 = 0; i8 < barkScale.length; i8++) {
          barkScale[i8] = i8 * sampleRate / bufferSize;
          barkScale[i8] = 13 * Math.atan(barkScale[i8] / 1315.8) + 3.5 * Math.atan(Math.pow(barkScale[i8] / 7518, 2));
        }
        return barkScale;
      }
      function arrayToTyped(t8) {
        return Float32Array.from(t8);
      }
      function _melToFreq(melValue) {
        var freqValue = 700 * (Math.exp(melValue / 1125) - 1);
        return freqValue;
      }
      function _freqToMel(freqValue) {
        var melValue = 1125 * Math.log(1 + freqValue / 700);
        return melValue;
      }
      function createMelFilterBank(numFilters, sampleRate, bufferSize) {
        var melValues = new Float32Array(numFilters + 2);
        var melValuesInFreq = new Float32Array(numFilters + 2);
        var lowerLimitFreq = 0;
        var upperLimitFreq = sampleRate / 2;
        var lowerLimitMel = _freqToMel(lowerLimitFreq);
        var upperLimitMel = _freqToMel(upperLimitFreq);
        var range4 = upperLimitMel - lowerLimitMel;
        var valueToAdd = range4 / (numFilters + 1);
        var fftBinsOfFreq = new Array(numFilters + 2);
        for (var i8 = 0; i8 < melValues.length; i8++) {
          melValues[i8] = i8 * valueToAdd;
          melValuesInFreq[i8] = _melToFreq(melValues[i8]);
          fftBinsOfFreq[i8] = Math.floor((bufferSize + 1) * melValuesInFreq[i8] / sampleRate);
        }
        var filterBank = new Array(numFilters);
        for (var j2 = 0; j2 < filterBank.length; j2++) {
          filterBank[j2] = new Array(bufferSize / 2 + 1).fill(0);
          for (var i8 = fftBinsOfFreq[j2]; i8 < fftBinsOfFreq[j2 + 1]; i8++) {
            filterBank[j2][i8] = (i8 - fftBinsOfFreq[j2]) / (fftBinsOfFreq[j2 + 1] - fftBinsOfFreq[j2]);
          }
          for (var i8 = fftBinsOfFreq[j2 + 1]; i8 < fftBinsOfFreq[j2 + 2]; i8++) {
            filterBank[j2][i8] = (fftBinsOfFreq[j2 + 2] - i8) / (fftBinsOfFreq[j2 + 2] - fftBinsOfFreq[j2 + 1]);
          }
        }
        return filterBank;
      }
      function hzToOctaves(freq2, A440) {
        return Math.log2(16 * freq2 / A440);
      }
      function normalizeByColumn(a8) {
        var emptyRow = a8[0].map(function() {
          return 0;
        });
        var colDenominators = a8.reduce(function(acc, row) {
          row.forEach(function(cell, j2) {
            acc[j2] += Math.pow(cell, 2);
          });
          return acc;
        }, emptyRow).map(Math.sqrt);
        return a8.map(function(row, i8) {
          return row.map(function(v3, j2) {
            return v3 / (colDenominators[j2] || 1);
          });
        });
      }
      function createChromaFilterBank(numFilters, sampleRate, bufferSize, centerOctave, octaveWidth, baseC, A440) {
        if (centerOctave === void 0) {
          centerOctave = 5;
        }
        if (octaveWidth === void 0) {
          octaveWidth = 2;
        }
        if (baseC === void 0) {
          baseC = true;
        }
        if (A440 === void 0) {
          A440 = 440;
        }
        var numOutputBins = Math.floor(bufferSize / 2) + 1;
        var frequencyBins = new Array(bufferSize).fill(0).map(function(_, i8) {
          return numFilters * hzToOctaves(sampleRate * i8 / bufferSize, A440);
        });
        frequencyBins[0] = frequencyBins[1] - 1.5 * numFilters;
        var binWidthBins = frequencyBins.slice(1).map(function(v3, i8) {
          return Math.max(v3 - frequencyBins[i8]);
        }, 1).concat([1]);
        var halfNumFilters = Math.round(numFilters / 2);
        var filterPeaks = new Array(numFilters).fill(0).map(function(_, i8) {
          return frequencyBins.map(function(frq) {
            return (10 * numFilters + halfNumFilters + frq - i8) % numFilters - halfNumFilters;
          });
        });
        var weights = filterPeaks.map(function(row, i8) {
          return row.map(function(_, j2) {
            return Math.exp(-0.5 * Math.pow(2 * filterPeaks[i8][j2] / binWidthBins[j2], 2));
          });
        });
        weights = normalizeByColumn(weights);
        if (octaveWidth) {
          var octaveWeights = frequencyBins.map(function(v3) {
            return Math.exp(-0.5 * Math.pow((v3 / numFilters - centerOctave) / octaveWidth, 2));
          });
          weights = weights.map(function(row) {
            return row.map(function(cell, j2) {
              return cell * octaveWeights[j2];
            });
          });
        }
        if (baseC) {
          weights = __spreadArray2(__spreadArray2([], weights.slice(3), true), weights.slice(0, 3), true);
        }
        return weights.map(function(row) {
          return row.slice(0, numOutputBins);
        });
      }
      function frame(buffer3, frameLength, hopLength) {
        if (buffer3.length < frameLength) {
          throw new Error("Buffer is too short for frame length");
        }
        if (hopLength < 1) {
          throw new Error("Hop length cannot be less that 1");
        }
        if (frameLength < 1) {
          throw new Error("Frame length cannot be less that 1");
        }
        var numFrames = 1 + Math.floor((buffer3.length - frameLength) / hopLength);
        return new Array(numFrames).fill(0).map(function(_, i8) {
          return buffer3.slice(i8 * hopLength, i8 * hopLength + frameLength);
        });
      }
      function rms(_a3) {
        var signal = _a3.signal;
        if (typeof signal !== "object") {
          throw new TypeError();
        }
        var rms2 = 0;
        for (var i8 = 0; i8 < signal.length; i8++) {
          rms2 += Math.pow(signal[i8], 2);
        }
        rms2 = rms2 / signal.length;
        rms2 = Math.sqrt(rms2);
        return rms2;
      }
      function energy(_a3) {
        var signal = _a3.signal;
        if (typeof signal !== "object") {
          throw new TypeError();
        }
        var energy2 = 0;
        for (var i8 = 0; i8 < signal.length; i8++) {
          energy2 += Math.pow(Math.abs(signal[i8]), 2);
        }
        return energy2;
      }
      function spectralSlope(_a3) {
        var ampSpectrum = _a3.ampSpectrum, sampleRate = _a3.sampleRate, bufferSize = _a3.bufferSize;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError();
        }
        var ampSum = 0;
        var freqSum = 0;
        var freqs = new Float32Array(ampSpectrum.length);
        var powFreqSum = 0;
        var ampFreqSum = 0;
        for (var i8 = 0; i8 < ampSpectrum.length; i8++) {
          ampSum += ampSpectrum[i8];
          var curFreq = i8 * sampleRate / bufferSize;
          freqs[i8] = curFreq;
          powFreqSum += curFreq * curFreq;
          freqSum += curFreq;
          ampFreqSum += curFreq * ampSpectrum[i8];
        }
        return (ampSpectrum.length * ampFreqSum - freqSum * ampSum) / (ampSum * (powFreqSum - Math.pow(freqSum, 2)));
      }
      function mu(i8, amplitudeSpect) {
        var numerator = 0;
        var denominator = 0;
        for (var k2 = 0; k2 < amplitudeSpect.length; k2++) {
          numerator += Math.pow(k2, i8) * Math.abs(amplitudeSpect[k2]);
          denominator += amplitudeSpect[k2];
        }
        return numerator / denominator;
      }
      function spectralCentroid(_a3) {
        var ampSpectrum = _a3.ampSpectrum;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError();
        }
        return mu(1, ampSpectrum);
      }
      function spectralRolloff(_a3) {
        var ampSpectrum = _a3.ampSpectrum, sampleRate = _a3.sampleRate;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError();
        }
        var ampspec = ampSpectrum;
        var nyqBin = sampleRate / (2 * (ampspec.length - 1));
        var ec = 0;
        for (var i8 = 0; i8 < ampspec.length; i8++) {
          ec += ampspec[i8];
        }
        var threshold = 0.99 * ec;
        var n8 = ampspec.length - 1;
        while (ec > threshold && n8 >= 0) {
          ec -= ampspec[n8];
          --n8;
        }
        return (n8 + 1) * nyqBin;
      }
      function spectralFlatness(_a3) {
        var ampSpectrum = _a3.ampSpectrum;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError();
        }
        var numerator = 0;
        var denominator = 0;
        for (var i8 = 0; i8 < ampSpectrum.length; i8++) {
          numerator += Math.log(ampSpectrum[i8]);
          denominator += ampSpectrum[i8];
        }
        return Math.exp(numerator / ampSpectrum.length) * ampSpectrum.length / denominator;
      }
      function spectralSpread(_a3) {
        var ampSpectrum = _a3.ampSpectrum;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError();
        }
        return Math.sqrt(mu(2, ampSpectrum) - Math.pow(mu(1, ampSpectrum), 2));
      }
      function spectralSkewness(_a3) {
        var ampSpectrum = _a3.ampSpectrum;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError();
        }
        var mu1 = mu(1, ampSpectrum);
        var mu2 = mu(2, ampSpectrum);
        var mu3 = mu(3, ampSpectrum);
        var numerator = 2 * Math.pow(mu1, 3) - 3 * mu1 * mu2 + mu3;
        var denominator = Math.pow(Math.sqrt(mu2 - Math.pow(mu1, 2)), 3);
        return numerator / denominator;
      }
      function spectralKurtosis(_a3) {
        var ampSpectrum = _a3.ampSpectrum;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError();
        }
        var ampspec = ampSpectrum;
        var mu1 = mu(1, ampspec);
        var mu2 = mu(2, ampspec);
        var mu3 = mu(3, ampspec);
        var mu4 = mu(4, ampspec);
        var numerator = -3 * Math.pow(mu1, 4) + 6 * mu1 * mu2 - 4 * mu1 * mu3 + mu4;
        var denominator = Math.pow(Math.sqrt(mu2 - Math.pow(mu1, 2)), 4);
        return numerator / denominator;
      }
      function zcr(_a3) {
        var signal = _a3.signal;
        if (typeof signal !== "object") {
          throw new TypeError();
        }
        var zcr2 = 0;
        for (var i8 = 1; i8 < signal.length; i8++) {
          if (signal[i8 - 1] >= 0 && signal[i8] < 0 || signal[i8 - 1] < 0 && signal[i8] >= 0) {
            zcr2++;
          }
        }
        return zcr2;
      }
      function loudness(_a3) {
        var ampSpectrum = _a3.ampSpectrum, barkScale = _a3.barkScale, _b = _a3.numberOfBarkBands, numberOfBarkBands = _b === void 0 ? 24 : _b;
        if (typeof ampSpectrum !== "object" || typeof barkScale !== "object") {
          throw new TypeError();
        }
        var NUM_BARK_BANDS = numberOfBarkBands;
        var specific = new Float32Array(NUM_BARK_BANDS);
        var total = 0;
        var normalisedSpectrum = ampSpectrum;
        var bbLimits = new Int32Array(NUM_BARK_BANDS + 1);
        bbLimits[0] = 0;
        var currentBandEnd = barkScale[normalisedSpectrum.length - 1] / NUM_BARK_BANDS;
        var currentBand = 1;
        for (var i8 = 0; i8 < normalisedSpectrum.length; i8++) {
          while (barkScale[i8] > currentBandEnd) {
            bbLimits[currentBand++] = i8;
            currentBandEnd = currentBand * barkScale[normalisedSpectrum.length - 1] / NUM_BARK_BANDS;
          }
        }
        bbLimits[NUM_BARK_BANDS] = normalisedSpectrum.length - 1;
        for (var i8 = 0; i8 < NUM_BARK_BANDS; i8++) {
          var sum = 0;
          for (var j2 = bbLimits[i8]; j2 < bbLimits[i8 + 1]; j2++) {
            sum += normalisedSpectrum[j2];
          }
          specific[i8] = Math.pow(sum, 0.23);
        }
        for (var i8 = 0; i8 < specific.length; i8++) {
          total += specific[i8];
        }
        return {
          specific,
          total
        };
      }
      function perceptualSpread(_a3) {
        var ampSpectrum = _a3.ampSpectrum, barkScale = _a3.barkScale;
        var loudnessValue = loudness({ ampSpectrum, barkScale });
        var max = 0;
        for (var i8 = 0; i8 < loudnessValue.specific.length; i8++) {
          if (loudnessValue.specific[i8] > max) {
            max = loudnessValue.specific[i8];
          }
        }
        var spread = Math.pow((loudnessValue.total - max) / loudnessValue.total, 2);
        return spread;
      }
      function perceptualSharpness(_a3) {
        var ampSpectrum = _a3.ampSpectrum, barkScale = _a3.barkScale;
        var loudnessValue = loudness({ ampSpectrum, barkScale });
        var spec = loudnessValue.specific;
        var output = 0;
        for (var i8 = 0; i8 < spec.length; i8++) {
          if (i8 < 15) {
            output += (i8 + 1) * spec[i8 + 1];
          } else {
            output += 0.066 * Math.exp(0.171 * (i8 + 1));
          }
        }
        output *= 0.11 / loudnessValue.total;
        return output;
      }
      function extractPowerSpectrum(_a3) {
        var ampSpectrum = _a3.ampSpectrum;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError();
        }
        var powerSpectrum = new Float32Array(ampSpectrum.length);
        for (var i8 = 0; i8 < powerSpectrum.length; i8++) {
          powerSpectrum[i8] = Math.pow(ampSpectrum[i8], 2);
        }
        return powerSpectrum;
      }
      function extractMelBands(_a3) {
        var ampSpectrum = _a3.ampSpectrum, melFilterBank = _a3.melFilterBank, bufferSize = _a3.bufferSize;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError("Valid ampSpectrum is required to generate melBands");
        }
        if (typeof melFilterBank !== "object") {
          throw new TypeError("Valid melFilterBank is required to generate melBands");
        }
        var powSpec = extractPowerSpectrum({ ampSpectrum });
        var numFilters = melFilterBank.length;
        var filtered = Array(numFilters);
        var loggedMelBands = new Float32Array(numFilters);
        for (var i8 = 0; i8 < loggedMelBands.length; i8++) {
          filtered[i8] = new Float32Array(bufferSize / 2);
          loggedMelBands[i8] = 0;
          for (var j2 = 0; j2 < bufferSize / 2; j2++) {
            filtered[i8][j2] = melFilterBank[i8][j2] * powSpec[j2];
            loggedMelBands[i8] += filtered[i8][j2];
          }
          loggedMelBands[i8] = Math.log(loggedMelBands[i8] + 1);
        }
        return Array.prototype.slice.call(loggedMelBands);
      }
      function getDefaultExportFromCjs(x4) {
        return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, "default") ? x4["default"] : x4;
      }
      var dct$2 = { exports: {} };
      var cosMap = null;
      var memoizeCosines = function(N2) {
        cosMap = cosMap || {};
        cosMap[N2] = new Array(N2 * N2);
        var PI_N = Math.PI / N2;
        for (var k2 = 0; k2 < N2; k2++) {
          for (var n8 = 0; n8 < N2; n8++) {
            cosMap[N2][n8 + k2 * N2] = Math.cos(PI_N * (n8 + 0.5) * k2);
          }
        }
      };
      function dct$1(signal, scale2) {
        var L = signal.length;
        scale2 = scale2 || 2;
        if (!cosMap || !cosMap[L])
          memoizeCosines(L);
        var coefficients = signal.map(function() {
          return 0;
        });
        return coefficients.map(function(__, ix) {
          return scale2 * signal.reduce(function(prev, cur, ix_, arr) {
            return prev + cur * cosMap[L][ix_ + ix * L];
          }, 0);
        });
      }
      var dct_1 = dct$1;
      (function(module2) {
        module2.exports = dct_1;
      })(dct$2);
      var dct = /* @__PURE__ */ getDefaultExportFromCjs(dct$2.exports);
      function mfcc(_a3) {
        var ampSpectrum = _a3.ampSpectrum, melFilterBank = _a3.melFilterBank, numberOfMFCCCoefficients = _a3.numberOfMFCCCoefficients, bufferSize = _a3.bufferSize;
        var _numberOfMFCCCoefficients = Math.min(40, Math.max(1, numberOfMFCCCoefficients || 13));
        var numFilters = melFilterBank.length;
        if (numFilters < _numberOfMFCCCoefficients) {
          throw new Error("Insufficient filter bank for requested number of coefficients");
        }
        var loggedMelBandsArray = extractMelBands({
          ampSpectrum,
          melFilterBank,
          bufferSize
        });
        var mfccs = dct(loggedMelBandsArray).slice(0, _numberOfMFCCCoefficients);
        return mfccs;
      }
      function chroma3(_a3) {
        var ampSpectrum = _a3.ampSpectrum, chromaFilterBank = _a3.chromaFilterBank;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError("Valid ampSpectrum is required to generate chroma");
        }
        if (typeof chromaFilterBank !== "object") {
          throw new TypeError("Valid chromaFilterBank is required to generate chroma");
        }
        var chromagram = chromaFilterBank.map(function(row, i8) {
          return ampSpectrum.reduce(function(acc, v3, j2) {
            return acc + v3 * row[j2];
          }, 0);
        });
        var maxVal = Math.max.apply(Math, chromagram);
        return maxVal ? chromagram.map(function(v3) {
          return v3 / maxVal;
        }) : chromagram;
      }
      function spectralFlux(_a3) {
        var signal = _a3.signal, previousSignal = _a3.previousSignal, bufferSize = _a3.bufferSize;
        if (typeof signal !== "object" || typeof previousSignal != "object") {
          throw new TypeError();
        }
        var sf = 0;
        for (var i8 = -(bufferSize / 2); i8 < signal.length / 2 - 1; i8++) {
          x = Math.abs(signal[i8]) - Math.abs(previousSignal[i8]);
          sf += (x + Math.abs(x)) / 2;
        }
        return sf;
      }
      function spectralCrest(_a3) {
        var ampSpectrum = _a3.ampSpectrum;
        if (typeof ampSpectrum !== "object") {
          throw new TypeError();
        }
        var rms2 = 0;
        var peak = -Infinity;
        ampSpectrum.forEach(function(x4) {
          rms2 += Math.pow(x4, 2);
          peak = x4 > peak ? x4 : peak;
        });
        rms2 = rms2 / ampSpectrum.length;
        rms2 = Math.sqrt(rms2);
        return peak / rms2;
      }
      var buffer2 = function(args) {
        return args.signal;
      };
      var complexSpectrum = function(args) {
        return args.complexSpectrum;
      };
      var amplitudeSpectrum = function(args) {
        return args.ampSpectrum;
      };
      var extractors = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        buffer: buffer2,
        rms,
        energy,
        complexSpectrum,
        spectralSlope,
        spectralCentroid,
        spectralRolloff,
        spectralFlatness,
        spectralSpread,
        spectralSkewness,
        spectralKurtosis,
        amplitudeSpectrum,
        zcr,
        loudness,
        perceptualSpread,
        perceptualSharpness,
        powerSpectrum: extractPowerSpectrum,
        mfcc,
        chroma: chroma3,
        spectralFlux,
        spectralCrest,
        melBands: extractMelBands
      });
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i8 = 0, arr2 = Array(arr.length); i8 < arr.length; i8++) {
            arr2[i8] = arr[i8];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      var memoizedReversal = {};
      var memoizedZeroBuffers = {};
      var constructComplexArray = function constructComplexArray2(signal) {
        var complexSignal = {};
        complexSignal.real = signal.real === void 0 ? signal.slice() : signal.real.slice();
        var bufferSize = complexSignal.real.length;
        if (memoizedZeroBuffers[bufferSize] === void 0) {
          memoizedZeroBuffers[bufferSize] = Array.apply(null, Array(bufferSize)).map(Number.prototype.valueOf, 0);
        }
        complexSignal.imag = memoizedZeroBuffers[bufferSize].slice();
        return complexSignal;
      };
      var bitReverseArray = function bitReverseArray2(N2) {
        if (memoizedReversal[N2] === void 0) {
          var maxBinaryLength = (N2 - 1).toString(2).length;
          var templateBinary = "0".repeat(maxBinaryLength);
          var reversed = {};
          for (var n8 = 0; n8 < N2; n8++) {
            var currBinary = n8.toString(2);
            currBinary = templateBinary.substr(currBinary.length) + currBinary;
            currBinary = [].concat(_toConsumableArray(currBinary)).reverse().join("");
            reversed[n8] = parseInt(currBinary, 2);
          }
          memoizedReversal[N2] = reversed;
        }
        return memoizedReversal[N2];
      };
      var multiply2 = function multiply3(a8, b5) {
        return {
          "real": a8.real * b5.real - a8.imag * b5.imag,
          "imag": a8.real * b5.imag + a8.imag * b5.real
        };
      };
      var add6 = function add7(a8, b5) {
        return {
          "real": a8.real + b5.real,
          "imag": a8.imag + b5.imag
        };
      };
      var subtract = function subtract2(a8, b5) {
        return {
          "real": a8.real - b5.real,
          "imag": a8.imag - b5.imag
        };
      };
      var euler = function euler2(kn, N2) {
        var x4 = -2 * Math.PI * kn / N2;
        return { "real": Math.cos(x4), "imag": Math.sin(x4) };
      };
      var conj = function conj2(a8) {
        a8.imag *= -1;
        return a8;
      };
      var utils$1 = {
        bitReverseArray,
        multiply: multiply2,
        add: add6,
        subtract,
        euler,
        conj,
        constructComplexArray
      };
      var utils = utils$1;
      var fft = function fft2(signal) {
        var complexSignal = {};
        if (signal.real === void 0 || signal.imag === void 0) {
          complexSignal = utils.constructComplexArray(signal);
        } else {
          complexSignal.real = signal.real.slice();
          complexSignal.imag = signal.imag.slice();
        }
        var N2 = complexSignal.real.length;
        var logN = Math.log2(N2);
        if (Math.round(logN) != logN)
          throw new Error("Input size must be a power of 2.");
        if (complexSignal.real.length != complexSignal.imag.length) {
          throw new Error("Real and imaginary components must have the same length.");
        }
        var bitReversedIndices = utils.bitReverseArray(N2);
        var ordered = {
          "real": [],
          "imag": []
        };
        for (var i8 = 0; i8 < N2; i8++) {
          ordered.real[bitReversedIndices[i8]] = complexSignal.real[i8];
          ordered.imag[bitReversedIndices[i8]] = complexSignal.imag[i8];
        }
        for (var _i = 0; _i < N2; _i++) {
          complexSignal.real[_i] = ordered.real[_i];
          complexSignal.imag[_i] = ordered.imag[_i];
        }
        for (var n8 = 1; n8 <= logN; n8++) {
          var currN = Math.pow(2, n8);
          for (var k2 = 0; k2 < currN / 2; k2++) {
            var twiddle = utils.euler(k2, currN);
            for (var m3 = 0; m3 < N2 / currN; m3++) {
              var currEvenIndex = currN * m3 + k2;
              var currOddIndex = currN * m3 + k2 + currN / 2;
              var currEvenIndexSample = {
                "real": complexSignal.real[currEvenIndex],
                "imag": complexSignal.imag[currEvenIndex]
              };
              var currOddIndexSample = {
                "real": complexSignal.real[currOddIndex],
                "imag": complexSignal.imag[currOddIndex]
              };
              var odd = utils.multiply(twiddle, currOddIndexSample);
              var subtractionResult = utils.subtract(currEvenIndexSample, odd);
              complexSignal.real[currOddIndex] = subtractionResult.real;
              complexSignal.imag[currOddIndex] = subtractionResult.imag;
              var additionResult = utils.add(odd, currEvenIndexSample);
              complexSignal.real[currEvenIndex] = additionResult.real;
              complexSignal.imag[currEvenIndex] = additionResult.imag;
            }
          }
        }
        return complexSignal;
      };
      var ifft = function ifft2(signal) {
        if (signal.real === void 0 || signal.imag === void 0) {
          throw new Error("IFFT only accepts a complex input.");
        }
        var N2 = signal.real.length;
        var complexSignal = {
          "real": [],
          "imag": []
        };
        for (var i8 = 0; i8 < N2; i8++) {
          var currentSample = {
            "real": signal.real[i8],
            "imag": signal.imag[i8]
          };
          var conjugateSample = utils.conj(currentSample);
          complexSignal.real[i8] = conjugateSample.real;
          complexSignal.imag[i8] = conjugateSample.imag;
        }
        var X = fft(complexSignal);
        complexSignal.real = X.real.map(function(val) {
          return val / N2;
        });
        complexSignal.imag = X.imag.map(function(val) {
          return val / N2;
        });
        return complexSignal;
      };
      var fft_1 = {
        fft,
        ifft
      };
      var MeydaAnalyzer = function() {
        function MeydaAnalyzer2(options2, _this) {
          var _this_1 = this;
          this._m = _this;
          if (!options2.audioContext) {
            throw this._m.errors.noAC;
          } else if (options2.bufferSize && !isPowerOfTwo(options2.bufferSize)) {
            throw this._m._errors.notPow2;
          } else if (!options2.source) {
            throw this._m._errors.noSource;
          }
          this._m.audioContext = options2.audioContext;
          this._m.bufferSize = options2.bufferSize || this._m.bufferSize || 256;
          this._m.hopSize = options2.hopSize || this._m.hopSize || this._m.bufferSize;
          this._m.sampleRate = options2.sampleRate || this._m.audioContext.sampleRate || 44100;
          this._m.callback = options2.callback;
          this._m.windowingFunction = options2.windowingFunction || "hanning";
          this._m.featureExtractors = extractors;
          this._m.EXTRACTION_STARTED = options2.startImmediately || false;
          this._m.channel = typeof options2.channel === "number" ? options2.channel : 0;
          this._m.inputs = options2.inputs || 1;
          this._m.outputs = options2.outputs || 1;
          this._m.numberOfMFCCCoefficients = options2.numberOfMFCCCoefficients || this._m.numberOfMFCCCoefficients || 13;
          this._m.numberOfBarkBands = options2.numberOfBarkBands || this._m.numberOfBarkBands || 24;
          this._m.spn = this._m.audioContext.createScriptProcessor(this._m.bufferSize, this._m.inputs, this._m.outputs);
          this._m.spn.connect(this._m.audioContext.destination);
          this._m._featuresToExtract = options2.featureExtractors || [];
          this._m.barkScale = createBarkScale(this._m.bufferSize, this._m.sampleRate, this._m.bufferSize);
          this._m.melFilterBank = createMelFilterBank(Math.max(this._m.melBands, this._m.numberOfMFCCCoefficients), this._m.sampleRate, this._m.bufferSize);
          this._m.inputData = null;
          this._m.previousInputData = null;
          this._m.frame = null;
          this._m.previousFrame = null;
          this.setSource(options2.source);
          this._m.spn.onaudioprocess = function(e8) {
            var buffer3;
            if (_this_1._m.inputData !== null) {
              _this_1._m.previousInputData = _this_1._m.inputData;
            }
            _this_1._m.inputData = e8.inputBuffer.getChannelData(_this_1._m.channel);
            if (!_this_1._m.previousInputData) {
              buffer3 = _this_1._m.inputData;
            } else {
              buffer3 = new Float32Array(_this_1._m.previousInputData.length + _this_1._m.inputData.length - _this_1._m.hopSize);
              buffer3.set(_this_1._m.previousInputData.slice(_this_1._m.hopSize));
              buffer3.set(_this_1._m.inputData, _this_1._m.previousInputData.length - _this_1._m.hopSize);
            }
            var frames = frame(buffer3, _this_1._m.bufferSize, _this_1._m.hopSize);
            frames.forEach(function(f4) {
              _this_1._m.frame = f4;
              var features = _this_1._m.extract(_this_1._m._featuresToExtract, _this_1._m.frame, _this_1._m.previousFrame);
              if (typeof _this_1._m.callback === "function" && _this_1._m.EXTRACTION_STARTED) {
                _this_1._m.callback(features);
              }
              _this_1._m.previousFrame = _this_1._m.frame;
            });
          };
        }
        MeydaAnalyzer2.prototype.start = function(features) {
          this._m._featuresToExtract = features || this._m._featuresToExtract;
          this._m.EXTRACTION_STARTED = true;
        };
        MeydaAnalyzer2.prototype.stop = function() {
          this._m.EXTRACTION_STARTED = false;
        };
        MeydaAnalyzer2.prototype.setSource = function(source) {
          this._m.source && this._m.source.disconnect(this._m.spn);
          this._m.source = source;
          this._m.source.connect(this._m.spn);
        };
        MeydaAnalyzer2.prototype.setChannel = function(channel) {
          if (channel <= this._m.inputs) {
            this._m.channel = channel;
          } else {
            console.error("Channel ".concat(channel, " does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(channel, " when instantiating the MeydaAnalyzer"));
          }
        };
        MeydaAnalyzer2.prototype.get = function(features) {
          if (this._m.inputData) {
            return this._m.extract(features || this._m._featuresToExtract, this._m.inputData, this._m.previousInputData);
          } else {
            return null;
          }
        };
        return MeydaAnalyzer2;
      }();
      var Meyda2 = {
        audioContext: null,
        spn: null,
        bufferSize: 512,
        sampleRate: 44100,
        melBands: 26,
        chromaBands: 12,
        callback: null,
        windowingFunction: "hanning",
        featureExtractors: extractors,
        EXTRACTION_STARTED: false,
        numberOfMFCCCoefficients: 13,
        numberOfBarkBands: 24,
        _featuresToExtract: [],
        windowing: applyWindow,
        _errors: {
          notPow2: new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"),
          featureUndef: new Error("Meyda: No features defined."),
          invalidFeatureFmt: new Error("Meyda: Invalid feature format"),
          invalidInput: new Error("Meyda: Invalid input."),
          noAC: new Error("Meyda: No AudioContext specified."),
          noSource: new Error("Meyda: No source node specified.")
        },
        createMeydaAnalyzer,
        listAvailableFeatureExtractors,
        extract: function(feature, signal, previousSignal) {
          var _this = this;
          if (!signal)
            throw this._errors.invalidInput;
          else if (typeof signal != "object")
            throw this._errors.invalidInput;
          else if (!feature)
            throw this._errors.featureUndef;
          else if (!isPowerOfTwo(signal.length))
            throw this._errors.notPow2;
          if (typeof this.barkScale == "undefined" || this.barkScale.length != this.bufferSize) {
            this.barkScale = createBarkScale(this.bufferSize, this.sampleRate, this.bufferSize);
          }
          if (typeof this.melFilterBank == "undefined" || this.barkScale.length != this.bufferSize || this.melFilterBank.length != this.melBands) {
            this.melFilterBank = createMelFilterBank(Math.max(this.melBands, this.numberOfMFCCCoefficients), this.sampleRate, this.bufferSize);
          }
          if (typeof this.chromaFilterBank == "undefined" || this.chromaFilterBank.length != this.chromaBands) {
            this.chromaFilterBank = createChromaFilterBank(this.chromaBands, this.sampleRate, this.bufferSize);
          }
          if ("buffer" in signal && typeof signal.buffer == "undefined") {
            this.signal = arrayToTyped(signal);
          } else {
            this.signal = signal;
          }
          var preparedSignal = prepareSignalWithSpectrum(signal, this.windowingFunction, this.bufferSize);
          this.signal = preparedSignal.windowedSignal;
          this.complexSpectrum = preparedSignal.complexSpectrum;
          this.ampSpectrum = preparedSignal.ampSpectrum;
          if (previousSignal) {
            var preparedSignal_1 = prepareSignalWithSpectrum(previousSignal, this.windowingFunction, this.bufferSize);
            this.previousSignal = preparedSignal_1.windowedSignal;
            this.previousComplexSpectrum = preparedSignal_1.complexSpectrum;
            this.previousAmpSpectrum = preparedSignal_1.ampSpectrum;
          }
          var extract = function(feature2) {
            return _this.featureExtractors[feature2]({
              ampSpectrum: _this.ampSpectrum,
              chromaFilterBank: _this.chromaFilterBank,
              complexSpectrum: _this.complexSpectrum,
              signal: _this.signal,
              bufferSize: _this.bufferSize,
              sampleRate: _this.sampleRate,
              barkScale: _this.barkScale,
              melFilterBank: _this.melFilterBank,
              previousSignal: _this.previousSignal,
              previousAmpSpectrum: _this.previousAmpSpectrum,
              previousComplexSpectrum: _this.previousComplexSpectrum,
              numberOfMFCCCoefficients: _this.numberOfMFCCCoefficients,
              numberOfBarkBands: _this.numberOfBarkBands
            });
          };
          if (typeof feature === "object") {
            return feature.reduce(function(acc, el) {
              var _a3;
              return Object.assign({}, acc, (_a3 = {}, _a3[el] = extract(el), _a3));
            }, {});
          } else if (typeof feature === "string") {
            return extract(feature);
          } else {
            throw this._errors.invalidFeatureFmt;
          }
        }
      };
      var prepareSignalWithSpectrum = function(signal, windowingFunction, bufferSize) {
        var preparedSignal = {};
        if (typeof signal.buffer == "undefined") {
          preparedSignal.signal = arrayToTyped(signal);
        } else {
          preparedSignal.signal = signal;
        }
        preparedSignal.windowedSignal = applyWindow(preparedSignal.signal, windowingFunction);
        preparedSignal.complexSpectrum = fft_1.fft(preparedSignal.windowedSignal);
        preparedSignal.ampSpectrum = new Float32Array(bufferSize / 2);
        for (var i8 = 0; i8 < bufferSize / 2; i8++) {
          preparedSignal.ampSpectrum[i8] = Math.sqrt(Math.pow(preparedSignal.complexSpectrum.real[i8], 2) + Math.pow(preparedSignal.complexSpectrum.imag[i8], 2));
        }
        return preparedSignal;
      };
      function listAvailableFeatureExtractors() {
        return Object.keys(this.featureExtractors);
      }
      function createMeydaAnalyzer(options2) {
        return new MeydaAnalyzer(options2, Object.assign({}, Meyda2));
      }
      if (typeof window !== "undefined")
        window.Meyda = Meyda2;
      module.exports = Meyda2;
    }
  });

  // .vitepress/use/aubio.js
  var Aubio = function(Aubio2) {
    Aubio2 = Aubio2 || {};
    var c6;
    c6 || (c6 = typeof Aubio2 !== "undefined" ? Aubio2 : {});
    var n8 = {}, r8;
    for (r8 in c6)
      c6.hasOwnProperty(r8) && (n8[r8] = c6[r8]);
    c6.arguments = [];
    c6.thisProgram = "./this.program";
    c6.quit = function(a8, b5) {
      throw b5;
    };
    c6.preRun = [];
    c6.postRun = [];
    var u7 = false, v3 = false, aa = false, ba = false;
    u7 = typeof window === "object";
    v3 = typeof importScripts === "function";
    aa = typeof process === "object" && typeof __require === "function" && !u7 && !v3;
    ba = !u7 && !aa && !v3;
    var w3 = "";
    function ca(a8) {
      return c6.locateFile ? c6.locateFile(a8, w3) : w3 + a8;
    }
    if (aa) {
      w3 = __dirname + "/";
      var da, ea;
      c6.read = function(a8, b5) {
        da || (da = __require("fs"));
        ea || (ea = __require("path"));
        a8 = ea.normalize(a8);
        a8 = da.readFileSync(a8);
        return b5 ? a8 : a8.toString();
      };
      c6.readBinary = function(a8) {
        a8 = c6.read(a8, true);
        a8.buffer || (a8 = new Uint8Array(a8));
        assert3(a8.buffer);
        return a8;
      };
      1 < process.argv.length && (c6.thisProgram = process.argv[1].replace(/\\/g, "/"));
      c6.arguments = process.argv.slice(2);
      process.on("uncaughtException", function(a8) {
        throw a8;
      });
      process.on("unhandledRejection", function() {
        process.exit(1);
      });
      c6.quit = function(a8) {
        process.exit(a8);
      };
      c6.inspect = function() {
        return "[Emscripten Module object]";
      };
    } else if (ba)
      typeof read != "undefined" && (c6.read = function(a8) {
        return read(a8);
      }), c6.readBinary = function(a8) {
        if (typeof readbuffer === "function")
          return new Uint8Array(readbuffer(a8));
        a8 = read(a8, "binary");
        assert3(typeof a8 === "object");
        return a8;
      }, typeof scriptArgs != "undefined" ? c6.arguments = scriptArgs : typeof arguments != "undefined" && (c6.arguments = arguments), typeof quit === "function" && (c6.quit = function(a8) {
        quit(a8);
      });
    else if (u7 || v3) {
      if (u7) {
        var fa = this._currentScript;
        fa.src.indexOf("blob:") !== 0 && (w3 = "/");
      } else
        v3 && (w3 = "/");
      c6.read = function(a8) {
        var b5 = new XMLHttpRequest();
        b5.open("GET", a8, false);
        b5.send(null);
        return b5.responseText;
      };
      v3 && (c6.readBinary = function(a8) {
        var b5 = new XMLHttpRequest();
        b5.open("GET", a8, false);
        b5.responseType = "arraybuffer";
        b5.send(null);
        return new Uint8Array(b5.response);
      });
      c6.readAsync = function(a8, b5, d5) {
        var e8 = new XMLHttpRequest();
        e8.open("GET", a8, true);
        e8.responseType = "arraybuffer";
        e8.onload = function() {
          e8.status == 200 || e8.status == 0 && e8.response ? b5(e8.response) : d5();
        };
        e8.onerror = d5;
        e8.send(null);
      };
      c6.setWindowTitle = function(a8) {
        let title = a8;
      };
    }
    var ha = c6.print || (typeof console !== "undefined" ? console.log.bind(console) : typeof print !== "undefined" ? print : null), x4 = c6.printErr || (typeof printErr !== "undefined" ? printErr : typeof console !== "undefined" && console.warn.bind(console) || ha);
    for (r8 in n8)
      n8.hasOwnProperty(r8) && (c6[r8] = n8[r8]);
    n8 = void 0;
    function ia(a8) {
      var b5;
      b5 || (b5 = 16);
      return Math.ceil(a8 / b5) * b5;
    }
    var ja = {
      "f64-rem": function(a8, b5) {
        return a8 % b5;
      },
      debugger: function() {
        debugger;
      }
    }, ka = 0;
    function assert3(a8, b5) {
      a8 || y3("Assertion failed: " + b5);
    }
    var la = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
    typeof TextDecoder !== "undefined" && new TextDecoder("utf-16le");
    var buffer2, ma, z, na, oa, A, B, pa, qa;
    function ra() {
      c6.HEAP8 = ma = new Int8Array(buffer2);
      c6.HEAP16 = na = new Int16Array(buffer2);
      c6.HEAP32 = A = new Int32Array(buffer2);
      c6.HEAPU8 = z = new Uint8Array(buffer2);
      c6.HEAPU16 = oa = new Uint16Array(buffer2);
      c6.HEAPU32 = B = new Uint32Array(buffer2);
      c6.HEAPF32 = pa = new Float32Array(buffer2);
      c6.HEAPF64 = qa = new Float64Array(buffer2);
    }
    var sa, C, ta, ua, va, wa, xa;
    sa = C = ta = ua = va = wa = xa = 0;
    function ya() {
      y3("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + E + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
    }
    var za = c6.TOTAL_STACK || 5242880, E = c6.TOTAL_MEMORY || 16777216;
    E < za && x4("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + E + "! (TOTAL_STACK=" + za + ")");
    c6.buffer ? buffer2 = c6.buffer : (typeof WebAssembly === "object" && typeof WebAssembly.Memory === "function" ? (c6.wasmMemory = new WebAssembly.Memory({
      initial: E / 65536,
      maximum: E / 65536
    }), buffer2 = c6.wasmMemory.buffer) : buffer2 = new ArrayBuffer(E), c6.buffer = buffer2);
    ra();
    function Aa(a8) {
      for (; 0 < a8.length; ) {
        var b5 = a8.shift();
        if (typeof b5 == "function")
          b5();
        else {
          var d5 = b5.B;
          typeof d5 === "number" ? b5.F === void 0 ? c6.dynCall_v(d5) : c6.dynCall_vi(d5, b5.F) : d5(b5.F === void 0 ? null : b5.F);
        }
      }
    }
    var Ba = [], Ca = [], Da = [], Ea = [], Fa = false;
    function Ga() {
      var a8 = c6.preRun.shift();
      Ba.unshift(a8);
    }
    var Ha = Math.cos, Ia = Math.sin, F = 0, Ja = null, G = null;
    c6.preloadedImages = {};
    c6.preloadedAudios = {};
    function Ka(a8) {
      return String.prototype.startsWith ? a8.startsWith("data:application/octet-stream;base64,") : a8.indexOf("data:application/octet-stream;base64,") === 0;
    }
    ;
    (function() {
      function a8() {
        try {
          if (c6.wasmBinary)
            return new Uint8Array(c6.wasmBinary);
          if (c6.readBinary)
            return c6.readBinary(f4);
          throw "both async and sync fetching of the wasm failed";
        } catch (g2) {
          y3(g2);
        }
      }
      function b5() {
        return c6.wasmBinary || !u7 && !v3 || typeof fetch !== "function" ? new Promise(function(b6) {
          b6(a8());
        }) : fetch(f4, { credentials: "same-origin" }).then(function(a9) {
          if (!a9.ok)
            throw "failed to load wasm binary file at '" + f4 + "'";
          return a9.arrayBuffer();
        }).catch(function() {
          return a8();
        });
      }
      function d5(a9) {
        function d6(a10) {
          k2 = a10.exports;
          if (k2.memory) {
            a10 = k2.memory;
            var b6 = c6.buffer;
            a10.byteLength < b6.byteLength && x4("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");
            b6 = new Int8Array(b6);
            new Int8Array(a10).set(b6);
            c6.buffer = buffer2 = a10;
            ra();
          }
          c6.asm = k2;
          c6.usingWasm = true;
          F--;
          c6.monitorRunDependencies && c6.monitorRunDependencies(F);
          F == 0 && (Ja !== null && (clearInterval(Ja), Ja = null), G && (a10 = G, G = null, a10()));
        }
        function e9(a10) {
          d6(a10.instance);
        }
        function g2(a10) {
          b5().then(function(a11) {
            return WebAssembly.instantiate(a11, h8);
          }).then(a10).catch(function(a11) {
            x4("failed to asynchronously prepare wasm: " + a11);
            y3(a11);
          });
        }
        if (typeof WebAssembly !== "object")
          return x4("no native wasm support detected"), false;
        if (!(c6.wasmMemory instanceof WebAssembly.Memory))
          return x4("no native wasm Memory in use"), false;
        a9.memory = c6.wasmMemory;
        h8.global = { NaN: NaN, Infinity: Infinity };
        h8["global.Math"] = Math;
        h8.env = a9;
        F++;
        c6.monitorRunDependencies && c6.monitorRunDependencies(F);
        if (c6.instantiateWasm)
          try {
            return c6.instantiateWasm(h8, d6);
          } catch (vb) {
            return x4("Module.instantiateWasm callback failed with error: " + vb), false;
          }
        c6.wasmBinary || typeof WebAssembly.instantiateStreaming !== "function" || Ka(f4) || typeof fetch !== "function" ? g2(e9) : WebAssembly.instantiateStreaming(fetch(f4, { credentials: "same-origin" }), h8).then(e9).catch(function(a10) {
          x4("wasm streaming compile failed: " + a10);
          x4("falling back to ArrayBuffer instantiation");
          g2(e9);
        });
        return {};
      }
      var e8 = "aubio.wast", f4 = "aubio.wasm", l5 = "aubio.temp.asm.js";
      Ka(e8) || (e8 = ca(e8));
      Ka(f4) || (f4 = ca(f4));
      Ka(l5) || (l5 = ca(l5));
      var h8 = { global: null, env: null, asm2wasm: ja, parent: c6 }, k2 = null;
      c6.asmPreload = c6.asm;
      var m3 = c6.reallocBuffer;
      c6.reallocBuffer = function(a9) {
        if (p6 === "asmjs")
          var b6 = m3(a9);
        else
          a: {
            var d6 = c6.usingWasm ? 65536 : 16777216;
            0 < a9 % d6 && (a9 += d6 - a9 % d6);
            d6 = c6.buffer.byteLength;
            if (c6.usingWasm)
              try {
                b6 = c6.wasmMemory.grow((a9 - d6) / 65536) !== -1 ? c6.buffer = c6.wasmMemory.buffer : null;
                break a;
              } catch (t8) {
                b6 = null;
                break a;
              }
            b6 = void 0;
          }
        return b6;
      };
      var p6 = "";
      c6.asm = function(a9, b6) {
        if (!b6.table) {
          a9 = c6.wasmTableSize;
          a9 === void 0 && (a9 = 1024);
          var e9 = c6.wasmMaxTableSize;
          b6.table = typeof WebAssembly === "object" && typeof WebAssembly.Table === "function" ? e9 !== void 0 ? new WebAssembly.Table({
            initial: a9,
            maximum: e9,
            element: "anyfunc"
          }) : new WebAssembly.Table({ initial: a9, element: "anyfunc" }) : Array(a9);
          c6.wasmTable = b6.table;
        }
        b6.memoryBase || (b6.memoryBase = c6.STATIC_BASE);
        b6.tableBase || (b6.tableBase = 0);
        b6 = d5(b6);
        assert3(b6, "no binaryen method succeeded.");
        return b6;
      };
    })();
    sa = 1024;
    C = sa + 9312;
    Ca.push({
      B: function() {
        La();
      }
    }, {
      B: function() {
        Ma();
      }
    }, {
      B: function() {
        Na();
      }
    }, {
      B: function() {
        Oa();
      }
    });
    c6.STATIC_BASE = sa;
    c6.STATIC_BUMP = 9312;
    C += 16;
    var H2 = 0;
    function I() {
      H2 += 4;
      return A[H2 - 4 >> 2];
    }
    var Pa = {};
    function J(a8, b5) {
      H2 = b5;
      try {
        var d5 = I(), e8 = I(), f4 = I();
        a8 = 0;
        J.J || (J.J = [null, [], []], J.P = function(a9, b6) {
          var d6 = J.J[a9];
          assert3(d6);
          if (b6 === 0 || b6 === 10) {
            a9 = a9 === 1 ? ha : x4;
            a: {
              for (var e9 = b6 = 0; d6[e9]; )
                ++e9;
              if (16 < e9 - b6 && d6.subarray && la)
                b6 = la.decode(d6.subarray(b6, e9));
              else
                for (e9 = ""; ; ) {
                  var f5 = d6[b6++];
                  if (!f5) {
                    b6 = e9;
                    break a;
                  }
                  if (f5 & 128) {
                    var k3 = d6[b6++] & 63;
                    if ((f5 & 224) == 192)
                      e9 += String.fromCharCode((f5 & 31) << 6 | k3);
                    else {
                      var l6 = d6[b6++] & 63;
                      if ((f5 & 240) == 224)
                        f5 = (f5 & 15) << 12 | k3 << 6 | l6;
                      else {
                        var h9 = d6[b6++] & 63;
                        if ((f5 & 248) == 240)
                          f5 = (f5 & 7) << 18 | k3 << 12 | l6 << 6 | h9;
                        else {
                          var bb = d6[b6++] & 63;
                          if ((f5 & 252) == 248)
                            f5 = (f5 & 3) << 24 | k3 << 18 | l6 << 12 | h9 << 6 | bb;
                          else {
                            var m3 = d6[b6++] & 63;
                            f5 = (f5 & 1) << 30 | k3 << 24 | l6 << 18 | h9 << 12 | bb << 6 | m3;
                          }
                        }
                      }
                      65536 > f5 ? e9 += String.fromCharCode(f5) : (f5 -= 65536, e9 += String.fromCharCode(55296 | f5 >> 10, 56320 | f5 & 1023));
                    }
                  } else
                    e9 += String.fromCharCode(f5);
                }
            }
            a9(b6);
            d6.length = 0;
          } else
            d6.push(b6);
        });
        for (b5 = 0; b5 < f4; b5++) {
          for (var l5 = A[e8 + 8 * b5 >> 2], h8 = A[e8 + (8 * b5 + 4) >> 2], k2 = 0; k2 < h8; k2++)
            J.P(d5, z[l5 + k2]);
          a8 += h8;
        }
        return a8;
      } catch (m3) {
        return typeof FS !== "undefined" && m3 instanceof FS.I || y3(m3), -m3.L;
      }
    }
    function Qa(a8) {
      switch (a8) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a8);
      }
    }
    var Ra = void 0;
    function K(a8) {
      for (var b5 = ""; z[a8]; )
        b5 += Ra[z[a8++]];
      return b5;
    }
    var L = {}, M4 = {}, Sa = {};
    function Ta(a8) {
      if (a8 === void 0)
        return "_unknown";
      a8 = a8.replace(/[^a-zA-Z0-9_]/g, "$");
      var b5 = a8.charCodeAt(0);
      return 48 <= b5 && 57 >= b5 ? "_" + a8 : a8;
    }
    function Ua(a8, b5) {
      a8 = Ta(a8);
      return new Function("body", "return function " + a8 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(b5);
    }
    function Va(a8) {
      var b5 = Error, d5 = Ua(a8, function(b6) {
        this.name = a8;
        this.message = b6;
        b6 = Error(b6).stack;
        b6 !== void 0 && (this.stack = this.toString() + "\n" + b6.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      d5.prototype = Object.create(b5.prototype);
      d5.prototype.constructor = d5;
      d5.prototype.toString = function() {
        return this.message === void 0 ? this.name : this.name + ": " + this.message;
      };
      return d5;
    }
    var O = void 0;
    function P(a8) {
      throw new O(a8);
    }
    var Wa = void 0;
    function Xa(a8) {
      throw new Wa(a8);
    }
    function Ya(a8, b5, d5) {
      function e8(b6) {
        b6 = d5(b6);
        b6.length !== a8.length && Xa("Mismatched type converter count");
        for (var e9 = 0; e9 < a8.length; ++e9)
          Q(a8[e9], b6[e9]);
      }
      a8.forEach(function(a9) {
        Sa[a9] = b5;
      });
      var f4 = Array(b5.length), l5 = [], h8 = 0;
      b5.forEach(function(a9, b6) {
        M4.hasOwnProperty(a9) ? f4[b6] = M4[a9] : (l5.push(a9), L.hasOwnProperty(a9) || (L[a9] = []), L[a9].push(function() {
          f4[b6] = M4[a9];
          ++h8;
          h8 === l5.length && e8(f4);
        }));
      });
      l5.length === 0 && e8(f4);
    }
    function Q(a8, b5, d5) {
      d5 = d5 || {};
      if (!("argPackAdvance" in b5))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var e8 = b5.name;
      a8 || P('type "' + e8 + '" must have a positive integer typeid pointer');
      if (M4.hasOwnProperty(a8)) {
        if (d5.X)
          return;
        P("Cannot register type '" + e8 + "' twice");
      }
      M4[a8] = b5;
      delete Sa[a8];
      L.hasOwnProperty(a8) && (b5 = L[a8], delete L[a8], b5.forEach(function(a9) {
        a9();
      }));
    }
    function Za(a8) {
      P(a8.a.f.b.name + " instance already deleted");
    }
    var $a = void 0, ab = [];
    function cb() {
      for (; ab.length; ) {
        var a8 = ab.pop();
        a8.a.s = false;
        a8["delete"]();
      }
    }
    function R() {
    }
    var db = {};
    function eb(a8, b5, d5) {
      if (a8[b5].j === void 0) {
        var e8 = a8[b5];
        a8[b5] = function() {
          a8[b5].j.hasOwnProperty(arguments.length) || P("Function '" + d5 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a8[b5].j + ")!");
          return a8[b5].j[arguments.length].apply(this, arguments);
        };
        a8[b5].j = [];
        a8[b5].j[e8.A] = e8;
      }
    }
    function fb(a8, b5) {
      c6.hasOwnProperty(a8) ? (P("Cannot register public name '" + a8 + "' twice"), eb(c6, a8, a8), c6.hasOwnProperty(void 0) && P("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), c6[a8].j[void 0] = b5) : c6[a8] = b5;
    }
    function gb(a8, b5, d5, e8, f4, l5, h8, k2) {
      this.name = a8;
      this.constructor = b5;
      this.u = d5;
      this.o = e8;
      this.i = f4;
      this.T = l5;
      this.w = h8;
      this.S = k2;
      this.Z = [];
    }
    function hb(a8, b5, d5) {
      for (; b5 !== d5; )
        b5.w || P("Expected null or instance of " + d5.name + ", got an instance of " + b5.name), a8 = b5.w(a8), b5 = b5.i;
      return a8;
    }
    function ib(a8, b5) {
      if (b5 === null)
        return this.G && P("null is not a valid " + this.name), 0;
      b5.a || P('Cannot pass "' + S2(b5) + '" as a ' + this.name);
      b5.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
      return hb(b5.a.c, b5.a.f.b, this.b);
    }
    function jb(a8, b5) {
      if (b5 === null) {
        this.G && P("null is not a valid " + this.name);
        if (this.D) {
          var d5 = this.$();
          a8 !== null && a8.push(this.o, d5);
          return d5;
        }
        return 0;
      }
      b5.a || P('Cannot pass "' + S2(b5) + '" as a ' + this.name);
      b5.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
      !this.C && b5.a.f.C && P("Cannot convert argument of type " + (b5.a.h ? b5.a.h.name : b5.a.f.name) + " to parameter type " + this.name);
      d5 = hb(b5.a.c, b5.a.f.b, this.b);
      if (this.D)
        switch (b5.a.g === void 0 && P("Passing raw pointer to smart pointer is illegal"), this.ba) {
          case 0:
            b5.a.h === this ? d5 = b5.a.g : P("Cannot convert argument of type " + (b5.a.h ? b5.a.h.name : b5.a.f.name) + " to parameter type " + this.name);
            break;
          case 1:
            d5 = b5.a.g;
            break;
          case 2:
            if (b5.a.h === this)
              d5 = b5.a.g;
            else {
              var e8 = b5.clone();
              d5 = this.aa(d5, T(function() {
                e8["delete"]();
              }));
              a8 !== null && a8.push(this.o, d5);
            }
            break;
          default:
            P("Unsupporting sharing policy");
        }
      return d5;
    }
    function kb(a8, b5) {
      if (b5 === null)
        return this.G && P("null is not a valid " + this.name), 0;
      b5.a || P('Cannot pass "' + S2(b5) + '" as a ' + this.name);
      b5.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
      b5.a.f.C && P("Cannot convert argument of type " + b5.a.f.name + " to parameter type " + this.name);
      return hb(b5.a.c, b5.a.f.b, this.b);
    }
    function lb(a8) {
      return this.fromWireType(B[a8 >> 2]);
    }
    function ob(a8, b5, d5) {
      if (b5 === d5)
        return a8;
      if (d5.i === void 0)
        return null;
      a8 = ob(a8, b5, d5.i);
      return a8 === null ? null : d5.S(a8);
    }
    var pb = {};
    function qb(a8, b5) {
      for (b5 === void 0 && P("ptr should not be undefined"); a8.i; )
        b5 = a8.w(b5), a8 = a8.i;
      return pb[b5];
    }
    function rb(a8, b5) {
      ;
      b5.f && b5.c || Xa("makeClassHandle requires ptr and ptrType");
      !!b5.h !== !!b5.g && Xa("Both smartPtrType and smartPtr must be specified");
      b5.count = { value: 1 };
      return Object.create(a8, { a: { value: b5 } });
    }
    function U(a8, b5, d5, e8, f4, l5, h8, k2, m3, p6, g2) {
      this.name = a8;
      this.b = b5;
      this.G = d5;
      this.C = e8;
      this.D = f4;
      this.Y = l5;
      this.ba = h8;
      this.M = k2;
      this.$ = m3;
      this.aa = p6;
      this.o = g2;
      f4 || b5.i !== void 0 ? this.toWireType = jb : (this.toWireType = e8 ? ib : kb, this.l = null);
    }
    function sb(a8, b5) {
      c6.hasOwnProperty(a8) || Xa("Replacing nonexistant public symbol");
      c6[a8] = b5;
      c6[a8].A = void 0;
    }
    function V(a8, b5) {
      a8 = K(a8);
      if (c6["FUNCTION_TABLE_" + a8] !== void 0)
        var d5 = c6["FUNCTION_TABLE_" + a8][b5];
      else if (typeof FUNCTION_TABLE !== "undefined")
        d5 = FUNCTION_TABLE[b5];
      else {
        d5 = c6.asm["dynCall_" + a8];
        d5 === void 0 && (d5 = c6.asm["dynCall_" + a8.replace(/f/g, "d")], d5 === void 0 && P("No dynCall invoker for signature: " + a8));
        for (var e8 = [], f4 = 1; f4 < a8.length; ++f4)
          e8.push("a" + f4);
        f4 = "return function " + ("dynCall_" + a8 + "_" + b5) + "(" + e8.join(", ") + ") {\n";
        f4 += "    return dynCall(rawFunction" + (e8.length ? ", " : "") + e8.join(", ") + ");\n";
        d5 = new Function("dynCall", "rawFunction", f4 + "};\n")(d5, b5);
      }
      typeof d5 !== "function" && P("unknown function pointer with signature " + a8 + ": " + b5);
      return d5;
    }
    var tb = void 0;
    function ub(a8) {
      a8 = wb(a8);
      var b5 = K(a8);
      X(a8);
      return b5;
    }
    function xb(a8, b5) {
      function d5(a9) {
        f4[a9] || M4[a9] || (Sa[a9] ? Sa[a9].forEach(d5) : (e8.push(a9), f4[a9] = true));
      }
      var e8 = [], f4 = {};
      b5.forEach(d5);
      throw new tb(a8 + ": " + e8.map(ub).join([", "]));
    }
    function yb(a8, b5) {
      for (var d5 = [], e8 = 0; e8 < a8; e8++)
        d5.push(A[(b5 >> 2) + e8]);
      return d5;
    }
    function zb(a8) {
      for (; a8.length; ) {
        var b5 = a8.pop();
        a8.pop()(b5);
      }
    }
    function Ab(a8) {
      var b5 = Function;
      if (!(b5 instanceof Function))
        throw new TypeError("new_ called with constructor type " + typeof b5 + " which is not a function");
      var d5 = Ua(b5.name || "unknownFunctionName", function() {
      });
      d5.prototype = b5.prototype;
      d5 = new d5();
      a8 = b5.apply(d5, a8);
      return a8 instanceof Object ? a8 : d5;
    }
    var Bb = [], Y = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
    function Cb(a8) {
      4 < a8 && --Y[a8].H === 0 && (Y[a8] = void 0, Bb.push(a8));
    }
    function T(a8) {
      switch (a8) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          var b5 = Bb.length ? Bb.pop() : Y.length;
          Y[b5] = { H: 1, value: a8 };
          return b5;
      }
    }
    function S2(a8) {
      if (a8 === null)
        return "null";
      var b5 = typeof a8;
      return b5 === "object" || b5 === "array" || b5 === "function" ? a8.toString() : "" + a8;
    }
    function Db(a8, b5) {
      switch (b5) {
        case 2:
          return function(a9) {
            return this.fromWireType(pa[a9 >> 2]);
          };
        case 3:
          return function(a9) {
            return this.fromWireType(qa[a9 >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a8);
      }
    }
    function Eb(a8, b5, d5) {
      switch (b5) {
        case 0:
          return d5 ? function(a9) {
            return ma[a9];
          } : function(a9) {
            return z[a9];
          };
        case 1:
          return d5 ? function(a9) {
            return na[a9 >> 1];
          } : function(a9) {
            return oa[a9 >> 1];
          };
        case 2:
          return d5 ? function(a9) {
            return A[a9 >> 2];
          } : function(a9) {
            return B[a9 >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a8);
      }
    }
    function Z(a8) {
      a8 || P("Cannot use deleted val. handle = " + a8);
      return Y[a8].value;
    }
    function Fb(a8, b5) {
      var d5 = M4[a8];
      d5 === void 0 && P(b5 + " has unknown type " + ub(a8));
      return d5;
    }
    for (var Gb = {}, Hb = Array(256), Ib = 0; 256 > Ib; ++Ib)
      Hb[Ib] = String.fromCharCode(Ib);
    Ra = Hb;
    O = c6.BindingError = Va("BindingError");
    Wa = c6.InternalError = Va("InternalError");
    R.prototype.isAliasOf = function(a8) {
      if (!(this instanceof R && a8 instanceof R))
        return false;
      var b5 = this.a.f.b, d5 = this.a.c, e8 = a8.a.f.b;
      for (a8 = a8.a.c; b5.i; )
        d5 = b5.w(d5), b5 = b5.i;
      for (; e8.i; )
        a8 = e8.w(a8), e8 = e8.i;
      return b5 === e8 && d5 === a8;
    };
    R.prototype.clone = function() {
      this.a.c || Za(this);
      if (this.a.v)
        return this.a.count.value += 1, this;
      var a8 = this.a;
      a8 = Object.create(Object.getPrototypeOf(this), {
        a: {
          value: {
            count: a8.count,
            s: a8.s,
            v: a8.v,
            c: a8.c,
            f: a8.f,
            g: a8.g,
            h: a8.h
          }
        }
      });
      a8.a.count.value += 1;
      a8.a.s = false;
      return a8;
    };
    R.prototype["delete"] = function() {
      this.a.c || Za(this);
      this.a.s && !this.a.v && P("Object already scheduled for deletion");
      --this.a.count.value;
      if (this.a.count.value === 0) {
        var a8 = this.a;
        a8.g ? a8.h.o(a8.g) : a8.f.b.o(a8.c);
      }
      this.a.v || (this.a.g = void 0, this.a.c = void 0);
    };
    R.prototype.isDeleted = function() {
      return !this.a.c;
    };
    R.prototype.deleteLater = function() {
      this.a.c || Za(this);
      this.a.s && !this.a.v && P("Object already scheduled for deletion");
      ab.push(this);
      ab.length === 1 && $a && $a(cb);
      this.a.s = true;
      return this;
    };
    U.prototype.U = function(a8) {
      this.M && (a8 = this.M(a8));
      return a8;
    };
    U.prototype.K = function(a8) {
      this.o && this.o(a8);
    };
    U.prototype.argPackAdvance = 8;
    U.prototype.readValueFromPointer = lb;
    U.prototype.deleteObject = function(a8) {
      if (a8 !== null)
        a8["delete"]();
    };
    U.prototype.fromWireType = function(a8) {
      function b5() {
        return this.D ? rb(this.b.u, { f: this.Y, c: d5, h: this, g: a8 }) : rb(this.b.u, { f: this, c: a8 });
      }
      var d5 = this.U(a8);
      if (!d5)
        return this.K(a8), null;
      var e8 = qb(this.b, d5);
      if (e8 !== void 0) {
        if (e8.a.count.value === 0)
          return e8.a.c = d5, e8.a.g = a8, e8.clone();
        e8 = e8.clone();
        this.K(a8);
        return e8;
      }
      e8 = this.b.T(d5);
      e8 = db[e8];
      if (!e8)
        return b5.call(this);
      e8 = this.C ? e8.R : e8.pointerType;
      var f4 = ob(d5, this.b, e8.b);
      return f4 === null ? b5.call(this) : this.D ? rb(e8.b.u, { f: e8, c: f4, h: this, g: a8 }) : rb(e8.b.u, { f: e8, c: f4 });
    };
    c6.getInheritedInstanceCount = function() {
      return Object.keys(pb).length;
    };
    c6.getLiveInheritedInstances = function() {
      var a8 = [], b5;
      for (b5 in pb)
        pb.hasOwnProperty(b5) && a8.push(pb[b5]);
      return a8;
    };
    c6.flushPendingDeletes = cb;
    c6.setDelayFunction = function(a8) {
      $a = a8;
      ab.length && $a && $a(cb);
    };
    tb = c6.UnboundTypeError = Va("UnboundTypeError");
    c6.count_emval_handles = function() {
      for (var a8 = 0, b5 = 5; b5 < Y.length; ++b5)
        Y[b5] !== void 0 && ++a8;
      return a8;
    };
    c6.get_first_emval = function() {
      for (var a8 = 5; a8 < Y.length; ++a8)
        if (Y[a8] !== void 0)
          return Y[a8];
      return null;
    };
    var Jb = C;
    C = C + 4 + 15 & -16;
    xa = Jb;
    ta = ua = ia(C);
    va = ta + za;
    wa = ia(va);
    A[xa >> 2] = wa;
    c6.wasmTableSize = 83;
    c6.wasmMaxTableSize = 83;
    c6.N = {};
    c6.O = {
      abort: y3,
      enlargeMemory: function() {
        ya();
      },
      getTotalMemory: function() {
        return E;
      },
      abortOnCannotGrowMemory: ya,
      ___setErrNo: function(a8) {
        c6.___errno_location && (A[c6.___errno_location() >> 2] = a8);
        return a8;
      },
      ___syscall140: function(a8, b5) {
        H2 = b5;
        try {
          var d5 = Pa.V();
          I();
          var e8 = I(), f4 = I(), l5 = I();
          FS.ea(d5, e8, l5);
          A[f4 >> 2] = d5.position;
          d5.W && e8 === 0 && l5 === 0 && (d5.W = null);
          return 0;
        } catch (h8) {
          return typeof FS !== "undefined" && h8 instanceof FS.I || y3(h8), -h8.L;
        }
      },
      ___syscall146: J,
      ___syscall54: function(a8, b5) {
        H2 = b5;
        return 0;
      },
      ___syscall6: function(a8, b5) {
        H2 = b5;
        try {
          var d5 = Pa.V();
          FS.close(d5);
          return 0;
        } catch (e8) {
          return typeof FS !== "undefined" && e8 instanceof FS.I || y3(e8), -e8.L;
        }
      },
      __embind_register_bool: function(a8, b5, d5, e8, f4) {
        var l5 = Qa(d5);
        b5 = K(b5);
        Q(a8, {
          name: b5,
          fromWireType: function(a9) {
            return !!a9;
          },
          toWireType: function(a9, b6) {
            return b6 ? e8 : f4;
          },
          argPackAdvance: 8,
          readValueFromPointer: function(a9) {
            if (d5 === 1)
              var e9 = ma;
            else if (d5 === 2)
              e9 = na;
            else if (d5 === 4)
              e9 = A;
            else
              throw new TypeError("Unknown boolean type size: " + b5);
            return this.fromWireType(e9[a9 >> l5]);
          },
          l: null
        });
      },
      __embind_register_class: function(a8, b5, d5, e8, f4, l5, h8, k2, m3, p6, g2, q, D) {
        g2 = K(g2);
        l5 = V(f4, l5);
        k2 && (k2 = V(h8, k2));
        p6 && (p6 = V(m3, p6));
        D = V(q, D);
        var t8 = Ta(g2);
        fb(t8, function() {
          xb("Cannot construct " + g2 + " due to unbound types", [e8]);
        });
        Ya([a8, b5, d5], e8 ? [e8] : [], function(b6) {
          b6 = b6[0];
          if (e8) {
            var d6 = b6.b;
            var f5 = d6.u;
          } else
            f5 = R.prototype;
          b6 = Ua(t8, function() {
            if (Object.getPrototypeOf(this) !== h9)
              throw new O("Use 'new' to construct " + g2);
            if (m4.m === void 0)
              throw new O(g2 + " has no accessible constructor");
            var a9 = m4.m[arguments.length];
            if (a9 === void 0)
              throw new O("Tried to invoke ctor of " + g2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(m4.m).toString() + ") parameters instead!");
            return a9.apply(this, arguments);
          });
          var h9 = Object.create(f5, { constructor: { value: b6 } });
          b6.prototype = h9;
          var m4 = new gb(g2, b6, h9, D, d6, l5, k2, p6);
          d6 = new U(g2, m4, true, false, false);
          f5 = new U(g2 + "*", m4, false, false, false);
          var q2 = new U(g2 + " const*", m4, false, true, false);
          db[a8] = { pointerType: f5, R: q2 };
          sb(t8, b6);
          return [d6, f5, q2];
        });
      },
      __embind_register_class_constructor: function(a8, b5, d5, e8, f4, l5) {
        var h8 = yb(b5, d5);
        f4 = V(e8, f4);
        Ya([], [a8], function(a9) {
          a9 = a9[0];
          var d6 = "constructor " + a9.name;
          a9.b.m === void 0 && (a9.b.m = []);
          if (a9.b.m[b5 - 1] !== void 0)
            throw new O("Cannot register multiple constructors with identical number of parameters (" + (b5 - 1) + ") for class '" + a9.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          a9.b.m[b5 - 1] = function() {
            xb("Cannot construct " + a9.name + " due to unbound types", h8);
          };
          Ya([], h8, function(e9) {
            a9.b.m[b5 - 1] = function() {
              arguments.length !== b5 - 1 && P(d6 + " called with " + arguments.length + " arguments, expected " + (b5 - 1));
              var a10 = [], h9 = Array(b5);
              h9[0] = l5;
              for (var k2 = 1; k2 < b5; ++k2)
                h9[k2] = e9[k2].toWireType(a10, arguments[k2 - 1]);
              h9 = f4.apply(null, h9);
              zb(a10);
              return e9[0].fromWireType(h9);
            };
            return [];
          });
          return [];
        });
      },
      __embind_register_class_function: function(a8, b5, d5, e8, f4, l5, h8, k2) {
        var m3 = yb(d5, e8);
        b5 = K(b5);
        l5 = V(f4, l5);
        Ya([], [a8], function(a9) {
          function e9() {
            xb("Cannot call " + f5 + " due to unbound types", m3);
          }
          a9 = a9[0];
          var f5 = a9.name + "." + b5;
          k2 && a9.b.Z.push(b5);
          var p6 = a9.b.u, t8 = p6[b5];
          t8 === void 0 || t8.j === void 0 && t8.className !== a9.name && t8.A === d5 - 2 ? (e9.A = d5 - 2, e9.className = a9.name, p6[b5] = e9) : (eb(p6, b5, f5), p6[b5].j[d5 - 2] = e9);
          Ya([], m3, function(e10) {
            var k3 = f5, g2 = a9, m4 = l5, q = e10.length;
            2 > q && P("argTypes array size mismatch! Must at least get return value and 'this' types!");
            var t9 = e10[1] !== null && g2 !== null, D = false;
            for (g2 = 1; g2 < e10.length; ++g2)
              if (e10[g2] !== null && e10[g2].l === void 0) {
                D = true;
                break;
              }
            var mb = e10[0].name !== "void", N2 = "", W = "";
            for (g2 = 0; g2 < q - 2; ++g2)
              N2 += (g2 !== 0 ? ", " : "") + "arg" + g2, W += (g2 !== 0 ? ", " : "") + "arg" + g2 + "Wired";
            k3 = "return function " + Ta(k3) + "(" + N2 + ") {\nif (arguments.length !== " + (q - 2) + ") {\nthrowBindingError('function " + k3 + " called with ' + arguments.length + ' arguments, expected " + (q - 2) + " args!');\n}\n";
            D && (k3 += "var destructors = [];\n");
            var nb = D ? "destructors" : "null";
            N2 = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
            m4 = [P, m4, h8, zb, e10[0], e10[1]];
            t9 && (k3 += "var thisWired = classParam.toWireType(" + nb + ", this);\n");
            for (g2 = 0; g2 < q - 2; ++g2)
              k3 += "var arg" + g2 + "Wired = argType" + g2 + ".toWireType(" + nb + ", arg" + g2 + "); // " + e10[g2 + 2].name + "\n", N2.push("argType" + g2), m4.push(e10[g2 + 2]);
            t9 && (W = "thisWired" + (0 < W.length ? ", " : "") + W);
            k3 += (mb ? "var rv = " : "") + "invoker(fn" + (0 < W.length ? ", " : "") + W + ");\n";
            if (D)
              k3 += "runDestructors(destructors);\n";
            else
              for (g2 = t9 ? 1 : 2; g2 < e10.length; ++g2)
                q = g2 === 1 ? "thisWired" : "arg" + (g2 - 2) + "Wired", e10[g2].l !== null && (k3 += q + "_dtor(" + q + "); // " + e10[g2].name + "\n", N2.push(q + "_dtor"), m4.push(e10[g2].l));
            mb && (k3 += "var ret = retType.fromWireType(rv);\nreturn ret;\n");
            N2.push(k3 + "}\n");
            e10 = Ab(N2).apply(null, m4);
            p6[b5].j === void 0 ? (e10.A = d5 - 2, p6[b5] = e10) : p6[b5].j[d5 - 2] = e10;
            return [];
          });
          return [];
        });
      },
      __embind_register_emval: function(a8, b5) {
        b5 = K(b5);
        Q(a8, {
          name: b5,
          fromWireType: function(a9) {
            var b6 = Y[a9].value;
            Cb(a9);
            return b6;
          },
          toWireType: function(a9, b6) {
            return T(b6);
          },
          argPackAdvance: 8,
          readValueFromPointer: lb,
          l: null
        });
      },
      __embind_register_float: function(a8, b5, d5) {
        d5 = Qa(d5);
        b5 = K(b5);
        Q(a8, {
          name: b5,
          fromWireType: function(a9) {
            return a9;
          },
          toWireType: function(a9, b6) {
            if (typeof b6 !== "number" && typeof b6 !== "boolean")
              throw new TypeError('Cannot convert "' + S2(b6) + '" to ' + this.name);
            return b6;
          },
          argPackAdvance: 8,
          readValueFromPointer: Db(b5, d5),
          l: null
        });
      },
      __embind_register_integer: function(a8, b5, d5, e8, f4) {
        function l5(a9) {
          return a9;
        }
        b5 = K(b5);
        f4 === -1 && (f4 = 4294967295);
        var h8 = Qa(d5);
        if (e8 === 0) {
          var k2 = 32 - 8 * d5;
          l5 = function(a9) {
            return a9 << k2 >>> k2;
          };
        }
        var m3 = b5.indexOf("unsigned") != -1;
        Q(a8, {
          name: b5,
          fromWireType: l5,
          toWireType: function(a9, d6) {
            if (typeof d6 !== "number" && typeof d6 !== "boolean")
              throw new TypeError('Cannot convert "' + S2(d6) + '" to ' + this.name);
            if (d6 < e8 || d6 > f4)
              throw new TypeError('Passing a number "' + S2(d6) + '" from JS side to C/C++ side to an argument of type "' + b5 + '", which is outside the valid range [' + e8 + ", " + f4 + "]!");
            return m3 ? d6 >>> 0 : d6 | 0;
          },
          argPackAdvance: 8,
          readValueFromPointer: Eb(b5, h8, e8 !== 0),
          l: null
        });
      },
      __embind_register_memory_view: function(a8, b5, d5) {
        function e8(a9) {
          a9 >>= 2;
          var b6 = B;
          return new f4(b6.buffer, b6[a9 + 1], b6[a9]);
        }
        var f4 = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array
        ][b5];
        d5 = K(d5);
        Q(a8, {
          name: d5,
          fromWireType: e8,
          argPackAdvance: 8,
          readValueFromPointer: e8
        }, { X: true });
      },
      __embind_register_std_string: function(a8, b5) {
        b5 = K(b5);
        Q(a8, {
          name: b5,
          fromWireType: function(a9) {
            for (var b6 = B[a9 >> 2], d5 = Array(b6), l5 = 0; l5 < b6; ++l5)
              d5[l5] = String.fromCharCode(z[a9 + 4 + l5]);
            X(a9);
            return d5.join("");
          },
          toWireType: function(a9, b6) {
            function d5(a10, b7) {
              return a10[b7];
            }
            function e8(a10, b7) {
              return a10.charCodeAt(b7);
            }
            b6 instanceof ArrayBuffer && (b6 = new Uint8Array(b6));
            var h8;
            b6 instanceof Uint8Array ? h8 = d5 : b6 instanceof Uint8ClampedArray ? h8 = d5 : b6 instanceof Int8Array ? h8 = d5 : typeof b6 === "string" ? h8 = e8 : P("Cannot pass non-string to std::string");
            var k2 = b6.length, m3 = Kb(4 + k2);
            B[m3 >> 2] = k2;
            for (var p6 = 0; p6 < k2; ++p6) {
              var g2 = h8(b6, p6);
              255 < g2 && (X(m3), P("String has UTF-16 code units that do not fit in 8 bits"));
              z[m3 + 4 + p6] = g2;
            }
            a9 !== null && a9.push(X, m3);
            return m3;
          },
          argPackAdvance: 8,
          readValueFromPointer: lb,
          l: function(a9) {
            X(a9);
          }
        });
      },
      __embind_register_std_wstring: function(a8, b5, d5) {
        d5 = K(d5);
        if (b5 === 2) {
          var e8 = function() {
            return oa;
          };
          var f4 = 1;
        } else
          b5 === 4 && (e8 = function() {
            return B;
          }, f4 = 2);
        Q(a8, {
          name: d5,
          fromWireType: function(a9) {
            for (var b6 = e8(), d6 = B[a9 >> 2], l5 = Array(d6), p6 = a9 + 4 >> f4, g2 = 0; g2 < d6; ++g2)
              l5[g2] = String.fromCharCode(b6[p6 + g2]);
            X(a9);
            return l5.join("");
          },
          toWireType: function(a9, d6) {
            var k2 = e8(), h8 = d6.length, l5 = Kb(4 + h8 * b5);
            B[l5 >> 2] = h8;
            for (var g2 = l5 + 4 >> f4, q = 0; q < h8; ++q)
              k2[g2 + q] = d6.charCodeAt(q);
            a9 !== null && a9.push(X, l5);
            return l5;
          },
          argPackAdvance: 8,
          readValueFromPointer: lb,
          l: function(a9) {
            X(a9);
          }
        });
      },
      __embind_register_void: function(a8, b5) {
        b5 = K(b5);
        Q(a8, {
          da: true,
          name: b5,
          argPackAdvance: 0,
          fromWireType: function() {
          },
          toWireType: function() {
          }
        });
      },
      __emval_as: function(a8, b5, d5) {
        a8 = Z(a8);
        b5 = Fb(b5, "emval::as");
        var e8 = [], f4 = T(e8);
        A[d5 >> 2] = f4;
        return b5.toWireType(e8, a8);
      },
      __emval_decref: Cb,
      __emval_get_property: function(a8, b5) {
        a8 = Z(a8);
        b5 = Z(b5);
        return T(a8[b5]);
      },
      __emval_incref: function(a8) {
        4 < a8 && (Y[a8].H += 1);
      },
      __emval_new_array: function() {
        return T([]);
      },
      __emval_new_cstring: function(a8) {
        var b5 = Gb[a8];
        return T(b5 === void 0 ? K(a8) : b5);
      },
      __emval_new_object: function() {
        return T({});
      },
      __emval_run_destructors: function(a8) {
        zb(Y[a8].value);
        Cb(a8);
      },
      __emval_set_property: function(a8, b5, d5) {
        a8 = Z(a8);
        b5 = Z(b5);
        d5 = Z(d5);
        a8[b5] = d5;
      },
      __emval_take_value: function(a8, b5) {
        a8 = Fb(a8, "_emval_take_value");
        a8 = a8.readValueFromPointer(b5);
        return T(a8);
      },
      _abort: function() {
        c6.abort();
      },
      _emscripten_memcpy_big: function(a8, b5, d5) {
        z.set(z.subarray(b5, b5 + d5), a8);
        return a8;
      },
      _llvm_cos_f32: Ha,
      _llvm_log10_f32: function(a8) {
        return Math.log(a8) / Math.LN10;
      },
      _llvm_sin_f32: Ia,
      DYNAMICTOP_PTR: xa,
      STACKTOP: ua
    };
    var Lb = c6.asm(c6.N, c6.O, buffer2);
    c6.asm = Lb;
    var Oa = c6.__GLOBAL__sub_I_bind_cpp = function() {
      return c6.asm.__GLOBAL__sub_I_bind_cpp.apply(null, arguments);
    }, La = c6.__GLOBAL__sub_I_fft_cc = function() {
      return c6.asm.__GLOBAL__sub_I_fft_cc.apply(null, arguments);
    }, Na = c6.__GLOBAL__sub_I_pitch_cc = function() {
      return c6.asm.__GLOBAL__sub_I_pitch_cc.apply(null, arguments);
    }, Ma = c6.__GLOBAL__sub_I_tempo_cc = function() {
      return c6.asm.__GLOBAL__sub_I_tempo_cc.apply(null, arguments);
    }, wb = c6.___getTypeName = function() {
      return c6.asm.___getTypeName.apply(null, arguments);
    }, X = c6._free = function() {
      return c6.asm._free.apply(null, arguments);
    }, Kb = c6._malloc = function() {
      return c6.asm._malloc.apply(null, arguments);
    };
    c6.dynCall_ffii = function() {
      return c6.asm.dynCall_ffii.apply(null, arguments);
    };
    c6.dynCall_fi = function() {
      return c6.asm.dynCall_fi.apply(null, arguments);
    };
    c6.dynCall_fii = function() {
      return c6.asm.dynCall_fii.apply(null, arguments);
    };
    c6.dynCall_fiii = function() {
      return c6.asm.dynCall_fiii.apply(null, arguments);
    };
    c6.dynCall_ii = function() {
      return c6.asm.dynCall_ii.apply(null, arguments);
    };
    c6.dynCall_iii = function() {
      return c6.asm.dynCall_iii.apply(null, arguments);
    };
    c6.dynCall_iiii = function() {
      return c6.asm.dynCall_iiii.apply(null, arguments);
    };
    c6.dynCall_iiiii = function() {
      return c6.asm.dynCall_iiiii.apply(null, arguments);
    };
    c6.dynCall_iiiiii = function() {
      return c6.asm.dynCall_iiiiii.apply(null, arguments);
    };
    c6.dynCall_v = function() {
      return c6.asm.dynCall_v.apply(null, arguments);
    };
    c6.dynCall_vi = function() {
      return c6.asm.dynCall_vi.apply(null, arguments);
    };
    c6.dynCall_viii = function() {
      return c6.asm.dynCall_viii.apply(null, arguments);
    };
    c6.asm = Lb;
    c6.then = function(a8) {
      if (c6.calledRun)
        a8(c6);
      else {
        var b5 = c6.onRuntimeInitialized;
        c6.onRuntimeInitialized = function() {
          b5 && b5();
          a8(c6);
        };
      }
      return c6;
    };
    G = function Mb() {
      c6.calledRun || Nb();
      c6.calledRun || (G = Mb);
    };
    function Nb() {
      function a8() {
        if (!c6.calledRun && (c6.calledRun = true, !ka)) {
          Fa || (Fa = true, Aa(Ca));
          Aa(Da);
          if (c6.onRuntimeInitialized)
            c6.onRuntimeInitialized();
          if (c6.postRun)
            for (typeof c6.postRun == "function" && (c6.postRun = [c6.postRun]); c6.postRun.length; ) {
              var a9 = c6.postRun.shift();
              Ea.unshift(a9);
            }
          Aa(Ea);
        }
      }
      if (!(0 < F)) {
        if (c6.preRun)
          for (typeof c6.preRun == "function" && (c6.preRun = [c6.preRun]); c6.preRun.length; )
            Ga();
        Aa(Ba);
        0 < F || c6.calledRun || (c6.setStatus ? (c6.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            c6.setStatus("");
          }, 1);
          a8();
        }, 1)) : a8());
      }
    }
    c6.run = Nb;
    function y3(a8) {
      if (c6.onAbort)
        c6.onAbort(a8);
      a8 !== void 0 ? (ha(a8), x4(a8), a8 = JSON.stringify(a8)) : a8 = "";
      ka = true;
      throw "abort(" + a8 + "). Build with -s ASSERTIONS=1 for more info.";
    }
    c6.abort = y3;
    if (c6.preInit)
      for (typeof c6.preInit == "function" && (c6.preInit = [c6.preInit]); 0 < c6.preInit.length; )
        c6.preInit.pop()();
    c6.noExitRuntime = true;
    Nb();
    return Aubio2;
  };
  var aubio_default = Aubio.bind({
    _currentScript: {
      src: "/aubio.js"
    }
  });

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/version.js
  var version = "14.8.40";

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/create-extended-exponential-ramp-to-value-automation-event.js
  var createExtendedExponentialRampToValueAutomationEvent = (value, endTime, insertTime) => {
    return { endTime, insertTime, type: "exponentialRampToValue", value };
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/create-extended-linear-ramp-to-value-automation-event.js
  var createExtendedLinearRampToValueAutomationEvent = (value, endTime, insertTime) => {
    return { endTime, insertTime, type: "linearRampToValue", value };
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/create-set-value-automation-event.js
  var createSetValueAutomationEvent = (value, startTime) => {
    return { startTime, type: "setValue", value };
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/create-set-value-curve-automation-event.js
  var createSetValueCurveAutomationEvent = (values, startTime, duration2) => {
    return { duration: duration2, startTime, type: "setValueCurve", values };
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/get-target-value-at-time.js
  var getTargetValueAtTime = (time, valueAtStartTime, { startTime, target, timeConstant }) => {
    return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/guards/exponential-ramp-to-value-automation-event.js
  var isExponentialRampToValueAutomationEvent = (automationEvent) => {
    return automationEvent.type === "exponentialRampToValue";
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/guards/linear-ramp-to-value-automation-event.js
  var isLinearRampToValueAutomationEvent = (automationEvent) => {
    return automationEvent.type === "linearRampToValue";
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/guards/any-ramp-to-value-automation-event.js
  var isAnyRampToValueAutomationEvent = (automationEvent) => {
    return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/guards/set-value-automation-event.js
  var isSetValueAutomationEvent = (automationEvent) => {
    return automationEvent.type === "setValue";
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/guards/set-value-curve-automation-event.js
  var isSetValueCurveAutomationEvent = (automationEvent) => {
    return automationEvent.type === "setValueCurve";
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/get-value-of-automation-event-at-index-at-time.js
  var getValueOfAutomationEventAtIndexAtTime = (automationEvents, index15, time, defaultValue) => {
    const automationEvent = automationEvents[index15];
    return automationEvent === void 0 ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index15 - 1, automationEvent.startTime, defaultValue), automationEvent);
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/get-end-time-and-value-of-previous-automation-event.js
  var getEndTimeAndValueOfPreviousAutomationEvent = (automationEvents, index15, currentAutomationEvent, nextAutomationEvent, defaultValue) => {
    return currentAutomationEvent === void 0 ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [
      currentAutomationEvent.startTime + currentAutomationEvent.duration,
      currentAutomationEvent.values[currentAutomationEvent.values.length - 1]
    ] : [
      currentAutomationEvent.startTime,
      getValueOfAutomationEventAtIndexAtTime(automationEvents, index15 - 1, currentAutomationEvent.startTime, defaultValue)
    ];
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/guards/cancel-and-hold-automation-event.js
  var isCancelAndHoldAutomationEvent = (automationEvent) => {
    return automationEvent.type === "cancelAndHold";
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/guards/cancel-scheduled-values-automation-event.js
  var isCancelScheduledValuesAutomationEvent = (automationEvent) => {
    return automationEvent.type === "cancelScheduledValues";
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/get-event-time.js
  var getEventTime = (automationEvent) => {
    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
      return automationEvent.cancelTime;
    }
    if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {
      return automationEvent.endTime;
    }
    return automationEvent.startTime;
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/get-exponential-ramp-value-at-time.js
  var getExponentialRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {
    if (valueAtStartTime === value) {
      return value;
    }
    if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {
      return valueAtStartTime * (value / valueAtStartTime) ** ((time - startTime) / (endTime - startTime));
    }
    return 0;
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/get-linear-ramp-value-at-time.js
  var getLinearRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {
    return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/interpolate-value.js
  var interpolateValue = (values, theoreticIndex) => {
    const lowerIndex = Math.floor(theoreticIndex);
    const upperIndex = Math.ceil(theoreticIndex);
    if (lowerIndex === upperIndex) {
      return values[lowerIndex];
    }
    return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/get-value-curve-value-at-time.js
  var getValueCurveValueAtTime = (time, { duration: duration2, startTime, values }) => {
    const theoreticIndex = (time - startTime) / duration2 * (values.length - 1);
    return interpolateValue(values, theoreticIndex);
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/guards/set-target-automation-event.js
  var isSetTargetAutomationEvent = (automationEvent) => {
    return automationEvent.type === "setTarget";
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/classes/automation-event-list.js
  var AutomationEventList = class {
    constructor(defaultValue) {
      this._automationEvents = [];
      this._currenTime = 0;
      this._defaultValue = defaultValue;
    }
    [Symbol.iterator]() {
      return this._automationEvents[Symbol.iterator]();
    }
    add(automationEvent) {
      const eventTime = getEventTime(automationEvent);
      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
        const index15 = this._automationEvents.findIndex((currentAutomationEvent) => {
          if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {
            return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;
          }
          return getEventTime(currentAutomationEvent) >= eventTime;
        });
        const removedAutomationEvent = this._automationEvents[index15];
        if (index15 !== -1) {
          this._automationEvents = this._automationEvents.slice(0, index15);
        }
        if (isCancelAndHoldAutomationEvent(automationEvent)) {
          const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];
          if (removedAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {
            if (isSetTargetAutomationEvent(lastAutomationEvent)) {
              throw new Error("The internal list is malformed.");
            }
            const startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);
            const startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;
            const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);
            const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);
            this._automationEvents.push(truncatedAutomationEvent);
          }
          if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {
            this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));
          }
          if (lastAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {
            this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);
          }
        }
      } else {
        const index15 = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > eventTime);
        const previousAutomationEvent = index15 === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index15 - 1];
        if (previousAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {
          return false;
        }
        const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;
        if (index15 === -1) {
          this._automationEvents.push(persistentAutomationEvent);
        } else {
          if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[index15])) {
            return false;
          }
          this._automationEvents.splice(index15, 0, persistentAutomationEvent);
        }
      }
      return true;
    }
    flush(time) {
      const index15 = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > time);
      if (index15 > 1) {
        const remainingAutomationEvents = this._automationEvents.slice(index15 - 1);
        const firstRemainingAutomationEvent = remainingAutomationEvents[0];
        if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {
          remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index15 - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));
        }
        this._automationEvents = remainingAutomationEvents;
      }
    }
    getValue(time) {
      if (this._automationEvents.length === 0) {
        return this._defaultValue;
      }
      const indexOfNextEvent = this._automationEvents.findIndex((automationEvent) => getEventTime(automationEvent) > time);
      const nextAutomationEvent = this._automationEvents[indexOfNextEvent];
      const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;
      const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];
      if (currentAutomationEvent !== void 0 && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {
        return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);
      }
      if (currentAutomationEvent !== void 0 && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
        return currentAutomationEvent.value;
      }
      if (currentAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {
        if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {
          return getValueCurveValueAtTime(time, currentAutomationEvent);
        }
        return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];
      }
      if (currentAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
        return currentAutomationEvent.value;
      }
      if (nextAutomationEvent !== void 0 && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {
        const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);
        return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);
      }
      if (nextAutomationEvent !== void 0 && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {
        const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);
        return getLinearRampValueAtTime(time, startTime, value, nextAutomationEvent);
      }
      return this._defaultValue;
    }
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/create-cancel-and-hold-automation-event.js
  var createCancelAndHoldAutomationEvent = (cancelTime) => {
    return { cancelTime, type: "cancelAndHold" };
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/create-cancel-scheduled-values-automation-event.js
  var createCancelScheduledValuesAutomationEvent = (cancelTime) => {
    return { cancelTime, type: "cancelScheduledValues" };
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/create-exponential-ramp-to-value-automation-event.js
  var createExponentialRampToValueAutomationEvent = (value, endTime) => {
    return { endTime, type: "exponentialRampToValue", value };
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/create-linear-ramp-to-value-automation-event.js
  var createLinearRampToValueAutomationEvent = (value, endTime) => {
    return { endTime, type: "linearRampToValue", value };
  };

  // node_modules/.pnpm/automation-events@4.0.19/node_modules/automation-events/build/es2019/functions/create-set-target-automation-event.js
  var createSetTargetAutomationEvent = (target, startTime, timeConstant) => {
    return { startTime, target, timeConstant, type: "setTarget" };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/abort-error.js
  var createAbortError = () => new DOMException("", "AbortError");

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/add-active-input-connection-to-audio-node.js
  var createAddActiveInputConnectionToAudioNode = (insertElementInSet2) => {
    return (activeInputs, source, [output, input2, eventListener], ignoreDuplicates) => {
      insertElementInSet2(activeInputs[input2], [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js
  var createAddAudioNodeConnections = (audioNodeConnectionsStore) => {
    return (audioNode, audioNodeRenderer, nativeAudioNode) => {
      const activeInputs = [];
      for (let i8 = 0; i8 < nativeAudioNode.numberOfInputs; i8 += 1) {
        activeInputs.push(/* @__PURE__ */ new Set());
      }
      audioNodeConnectionsStore.set(audioNode, {
        activeInputs,
        outputs: /* @__PURE__ */ new Set(),
        passiveInputs: /* @__PURE__ */ new WeakMap(),
        renderer: audioNodeRenderer
      });
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js
  var createAddAudioParamConnections = (audioParamConnectionsStore) => {
    return (audioParam, audioParamRenderer) => {
      audioParamConnectionsStore.set(audioParam, { activeInputs: /* @__PURE__ */ new Set(), passiveInputs: /* @__PURE__ */ new WeakMap(), renderer: audioParamRenderer });
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/globals.js
  var ACTIVE_AUDIO_NODE_STORE = /* @__PURE__ */ new WeakSet();
  var AUDIO_NODE_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();
  var AUDIO_NODE_STORE = /* @__PURE__ */ new WeakMap();
  var AUDIO_PARAM_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();
  var AUDIO_PARAM_STORE = /* @__PURE__ */ new WeakMap();
  var CONTEXT_STORE = /* @__PURE__ */ new WeakMap();
  var EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();
  var CYCLE_COUNTERS = /* @__PURE__ */ new WeakMap();
  var NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = /* @__PURE__ */ new WeakMap();
  var NODE_TO_PROCESSOR_MAPS = /* @__PURE__ */ new WeakMap();

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js
  var handler = {
    construct() {
      return handler;
    }
  };
  var isConstructible = (constructible) => {
    try {
      const proxy = new Proxy(constructible, handler);
      new proxy();
    } catch {
      return false;
    }
    return true;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js
  var IMPORT_STATEMENT_REGEX = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/;
  var splitImportStatements = (source, url) => {
    const importStatements = [];
    let sourceWithoutImportStatements = source.replace(/^[\s]+/, "");
    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
    while (result !== null) {
      const unresolvedUrl = result[1].slice(1, -1);
      const importStatementWithResolvedUrl = result[0].replace(/([\s]+)?;?$/, "").replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());
      importStatements.push(importStatementWithResolvedUrl);
      sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\s]+/, "");
      result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
    }
    return [importStatements.join(";"), sourceWithoutImportStatements];
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js
  var verifyParameterDescriptors = (parameterDescriptors) => {
    if (parameterDescriptors !== void 0 && !Array.isArray(parameterDescriptors)) {
      throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.");
    }
  };
  var verifyProcessorCtor = (processorCtor) => {
    if (!isConstructible(processorCtor)) {
      throw new TypeError("The given value for processorCtor should be a constructor.");
    }
    if (processorCtor.prototype === null || typeof processorCtor.prototype !== "object") {
      throw new TypeError("The given value for processorCtor should have a prototype.");
    }
  };
  var createAddAudioWorkletModule = (cacheTestResult2, createNotSupportedError2, evaluateSource, exposeCurrentFrameAndCurrentTime2, fetchSource, getNativeContext2, getOrCreateBackupOfflineAudioContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window3) => {
    let index15 = 0;
    return (context2, moduleURL, options2 = { credentials: "omit" }) => {
      const resolvedRequestsOfContext = resolvedRequests.get(context2);
      if (resolvedRequestsOfContext !== void 0 && resolvedRequestsOfContext.has(moduleURL)) {
        return Promise.resolve();
      }
      const ongoingRequestsOfContext = ongoingRequests.get(context2);
      if (ongoingRequestsOfContext !== void 0) {
        const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);
        if (promiseOfOngoingRequest !== void 0) {
          return promiseOfOngoingRequest;
        }
      }
      const nativeContext = getNativeContext2(context2);
      const promise = nativeContext.audioWorklet === void 0 ? fetchSource(moduleURL).then(([source, absoluteUrl]) => {
        const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
        const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}
})})(window,'_AWGS')`;
        return evaluateSource(wrappedSource);
      }).then(() => {
        const evaluateAudioWorkletGlobalScope = window3._AWGS.pop();
        if (evaluateAudioWorkletGlobalScope === void 0) {
          throw new SyntaxError();
        }
        exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {
        }, void 0, (name2, processorCtor) => {
          if (name2.trim() === "") {
            throw createNotSupportedError2();
          }
          const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
          if (nodeNameToProcessorConstructorMap !== void 0) {
            if (nodeNameToProcessorConstructorMap.has(name2)) {
              throw createNotSupportedError2();
            }
            verifyProcessorCtor(processorCtor);
            verifyParameterDescriptors(processorCtor.parameterDescriptors);
            nodeNameToProcessorConstructorMap.set(name2, processorCtor);
          } else {
            verifyProcessorCtor(processorCtor);
            verifyParameterDescriptors(processorCtor.parameterDescriptors);
            NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, /* @__PURE__ */ new Map([[name2, processorCtor]]));
          }
        }, nativeContext.sampleRate, void 0, void 0));
      }) : Promise.all([
        fetchSource(moduleURL),
        Promise.resolve(cacheTestResult2(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))
      ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {
        const currentIndex = index15 + 1;
        index15 = currentIndex;
        const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
        const patchedAudioWorkletProcessor = isSupportingPostMessage ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}";
        const memberDefinition = isSupportingPostMessage ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));";
        const bufferRegistration = isSupportingPostMessage ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));";
        const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}
})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;
        const blob = new Blob([wrappedSource], { type: "application/javascript; charset=utf-8" });
        const url = URL.createObjectURL(blob);
        return nativeContext.audioWorklet.addModule(url, options2).then(() => {
          if (isNativeOfflineAudioContext2(nativeContext)) {
            return nativeContext;
          }
          const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext2(nativeContext);
          return backupOfflineAudioContext.audioWorklet.addModule(url, options2).then(() => backupOfflineAudioContext);
        }).then((nativeContextOrBackupOfflineAudioContext) => {
          if (nativeAudioWorkletNodeConstructor2 === null) {
            throw new SyntaxError();
          }
          try {
            new nativeAudioWorkletNodeConstructor2(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`);
          } catch {
            throw new SyntaxError();
          }
        }).finally(() => URL.revokeObjectURL(url));
      });
      if (ongoingRequestsOfContext === void 0) {
        ongoingRequests.set(context2, /* @__PURE__ */ new Map([[moduleURL, promise]]));
      } else {
        ongoingRequestsOfContext.set(moduleURL, promise);
      }
      promise.then(() => {
        const updatedResolvedRequestsOfContext = resolvedRequests.get(context2);
        if (updatedResolvedRequestsOfContext === void 0) {
          resolvedRequests.set(context2, /* @__PURE__ */ new Set([moduleURL]));
        } else {
          updatedResolvedRequestsOfContext.add(moduleURL);
        }
      }).finally(() => {
        const updatedOngoingRequestsOfContext = ongoingRequests.get(context2);
        if (updatedOngoingRequestsOfContext !== void 0) {
          updatedOngoingRequestsOfContext.delete(moduleURL);
        }
      });
      return promise;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js
  var getValueForKey = (map2, key) => {
    const value = map2.get(key);
    if (value === void 0) {
      throw new Error("A value with the given key could not be found.");
    }
    return value;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js
  var pickElementFromSet = (set3, predicate) => {
    const matchingElements = Array.from(set3).filter(predicate);
    if (matchingElements.length > 1) {
      throw Error("More than one element was found.");
    }
    if (matchingElements.length === 0) {
      throw Error("No element was found.");
    }
    const [matchingElement] = matchingElements;
    set3.delete(matchingElement);
    return matchingElement;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-node.js
  var deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input2) => {
    const passiveInputConnections = getValueForKey(passiveInputs, source);
    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input2);
    if (passiveInputConnections.size === 0) {
      passiveInputs.delete(source);
    }
    return matchingConnection;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js
  var getEventListenersOfAudioNode = (audioNode) => {
    return getValueForKey(EVENT_LISTENERS, audioNode);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js
  var setInternalStateToActive = (audioNode) => {
    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
      throw new Error("The AudioNode is already stored.");
    }
    ACTIVE_AUDIO_NODE_STORE.add(audioNode);
    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js
  var isAudioWorkletNode = (audioNode) => {
    return "port" in audioNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js
  var setInternalStateToPassive = (audioNode) => {
    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
      throw new Error("The AudioNode is not stored.");
    }
    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);
    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js
  var setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {
    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {
      setInternalStateToPassive(audioNode);
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/add-connection-to-audio-node.js
  var createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode2, addPassiveInputConnectionToAudioNode2, connectNativeAudioNodeToNativeAudioNode2, deleteActiveInputConnectionToAudioNode2, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getAudioNodeTailTime2, getEventListenersOfAudioNode2, getNativeAudioNode2, insertElementInSet2, isActiveAudioNode2, isPartOfACycle2, isPassiveAudioNode2) => {
    const tailTimeTimeoutIds = /* @__PURE__ */ new WeakMap();
    return (source, destination, output, input2, isOffline) => {
      const { activeInputs, passiveInputs } = getAudioNodeConnections2(destination);
      const { outputs } = getAudioNodeConnections2(source);
      const eventListeners = getEventListenersOfAudioNode2(source);
      const eventListener = (isActive) => {
        const nativeDestinationAudioNode = getNativeAudioNode2(destination);
        const nativeSourceAudioNode = getNativeAudioNode2(source);
        if (isActive) {
          const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input2);
          addActiveInputConnectionToAudioNode2(activeInputs, source, partialConnection, false);
          if (!isOffline && !isPartOfACycle2(source)) {
            connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input2);
          }
          if (isPassiveAudioNode2(destination)) {
            setInternalStateToActive(destination);
          }
        } else {
          const partialConnection = deleteActiveInputConnectionToAudioNode2(activeInputs, source, output, input2);
          addPassiveInputConnectionToAudioNode2(passiveInputs, input2, partialConnection, false);
          if (!isOffline && !isPartOfACycle2(source)) {
            disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input2);
          }
          const tailTime = getAudioNodeTailTime2(destination);
          if (tailTime === 0) {
            if (isActiveAudioNode2(destination)) {
              setInternalStateToPassiveWhenNecessary(destination, activeInputs);
            }
          } else {
            const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);
            if (tailTimeTimeoutId !== void 0) {
              clearTimeout(tailTimeTimeoutId);
            }
            tailTimeTimeoutIds.set(destination, setTimeout(() => {
              if (isActiveAudioNode2(destination)) {
                setInternalStateToPassiveWhenNecessary(destination, activeInputs);
              }
            }, tailTime * 1e3));
          }
        }
      };
      if (insertElementInSet2(outputs, [destination, output, input2], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input2, true)) {
        eventListeners.add(eventListener);
        if (isActiveAudioNode2(source)) {
          addActiveInputConnectionToAudioNode2(activeInputs, source, [output, input2, eventListener], true);
        } else {
          addPassiveInputConnectionToAudioNode2(passiveInputs, input2, [source, output, eventListener], true);
        }
        return true;
      }
      return false;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/add-passive-input-connection-to-audio-node.js
  var createAddPassiveInputConnectionToAudioNode = (insertElementInSet2) => {
    return (passiveInputs, input2, [source, output, eventListener], ignoreDuplicates) => {
      const passiveInputConnections = passiveInputs.get(source);
      if (passiveInputConnections === void 0) {
        passiveInputs.set(source, /* @__PURE__ */ new Set([[output, input2, eventListener]]));
      } else {
        insertElementInSet2(passiveInputConnections, [output, input2, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input2, ignoreDuplicates);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js
  var createAddSilentConnection = (createNativeGainNode2) => {
    return (nativeContext, nativeAudioScheduledSourceNode) => {
      const nativeGainNode = createNativeGainNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: 0
      });
      nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);
      const disconnect2 = () => {
        nativeAudioScheduledSourceNode.removeEventListener("ended", disconnect2);
        nativeAudioScheduledSourceNode.disconnect(nativeGainNode);
        nativeGainNode.disconnect();
      };
      nativeAudioScheduledSourceNode.addEventListener("ended", disconnect2);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js
  var createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
    return (nativeContext, audioWorkletNode) => {
      getUnrenderedAudioWorkletNodes2(nativeContext).add(audioWorkletNode);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js
  var DEFAULT_OPTIONS = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    fftSize: 2048,
    maxDecibels: -30,
    minDecibels: -100,
    smoothingTimeConstant: 0.8
  };
  var createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer2, createIndexSizeError2, createNativeAnalyserNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class AnalyserNode extends audionNodeConstructor {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS, ...options2 };
        const nativeAnalyserNode = createNativeAnalyserNode2(nativeContext, mergedOptions);
        const analyserNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createAnalyserNodeRenderer2() : null;
        super(context2, false, nativeAnalyserNode, analyserNodeRenderer);
        this._nativeAnalyserNode = nativeAnalyserNode;
      }
      get fftSize() {
        return this._nativeAnalyserNode.fftSize;
      }
      set fftSize(value) {
        this._nativeAnalyserNode.fftSize = value;
      }
      get frequencyBinCount() {
        return this._nativeAnalyserNode.frequencyBinCount;
      }
      get maxDecibels() {
        return this._nativeAnalyserNode.maxDecibels;
      }
      set maxDecibels(value) {
        const maxDecibels = this._nativeAnalyserNode.maxDecibels;
        this._nativeAnalyserNode.maxDecibels = value;
        if (!(value > this._nativeAnalyserNode.minDecibels)) {
          this._nativeAnalyserNode.maxDecibels = maxDecibels;
          throw createIndexSizeError2();
        }
      }
      get minDecibels() {
        return this._nativeAnalyserNode.minDecibels;
      }
      set minDecibels(value) {
        const minDecibels = this._nativeAnalyserNode.minDecibels;
        this._nativeAnalyserNode.minDecibels = value;
        if (!(this._nativeAnalyserNode.maxDecibels > value)) {
          this._nativeAnalyserNode.minDecibels = minDecibels;
          throw createIndexSizeError2();
        }
      }
      get smoothingTimeConstant() {
        return this._nativeAnalyserNode.smoothingTimeConstant;
      }
      set smoothingTimeConstant(value) {
        this._nativeAnalyserNode.smoothingTimeConstant = value;
      }
      getByteFrequencyData(array) {
        this._nativeAnalyserNode.getByteFrequencyData(array);
      }
      getByteTimeDomainData(array) {
        this._nativeAnalyserNode.getByteTimeDomainData(array);
      }
      getFloatFrequencyData(array) {
        this._nativeAnalyserNode.getFloatFrequencyData(array);
      }
      getFloatTimeDomainData(array) {
        this._nativeAnalyserNode.getFloatTimeDomainData(array);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js
  var isOwnedByContext = (nativeAudioNode, nativeContext) => {
    return nativeAudioNode.context === nativeContext;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js
  var createAnalyserNodeRendererFactory = (createNativeAnalyserNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeAnalyserNodes = /* @__PURE__ */ new WeakMap();
      const createAnalyserNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAnalyserNode = getNativeAudioNode2(proxy);
        const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);
        if (!nativeAnalyserNodeIsOwnedByContext) {
          const options2 = {
            channelCount: nativeAnalyserNode.channelCount,
            channelCountMode: nativeAnalyserNode.channelCountMode,
            channelInterpretation: nativeAnalyserNode.channelInterpretation,
            fftSize: nativeAnalyserNode.fftSize,
            maxDecibels: nativeAnalyserNode.maxDecibels,
            minDecibels: nativeAnalyserNode.minDecibels,
            smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant
          };
          nativeAnalyserNode = createNativeAnalyserNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAnalyserNode);
        return nativeAnalyserNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAnalyserNode !== void 0) {
            return Promise.resolve(renderedNativeAnalyserNode);
          }
          return createAnalyserNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js
  var testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {
    try {
      nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);
    } catch {
      return false;
    }
    return true;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js
  var createIndexSizeError = () => new DOMException("", "IndexSizeError");

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js
  var wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {
    audioBuffer.getChannelData = ((getChannelData) => {
      return (channel) => {
        try {
          return getChannelData.call(audioBuffer, channel);
        } catch (err) {
          if (err.code === 12) {
            throw createIndexSizeError();
          }
          throw err;
        }
      };
    })(audioBuffer.getChannelData);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js
  var DEFAULT_OPTIONS2 = {
    numberOfChannels: 1
  };
  var createAudioBufferConstructor = (audioBufferStore2, cacheTestResult2, createNotSupportedError2, nativeAudioBufferConstructor2, nativeOfflineAudioContextConstructor2, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
    let nativeOfflineAudioContext = null;
    return class AudioBuffer {
      constructor(options2) {
        if (nativeOfflineAudioContextConstructor2 === null) {
          throw new Error("Missing the native OfflineAudioContext constructor.");
        }
        const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS2, ...options2 };
        if (nativeOfflineAudioContext === null) {
          nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
        }
        const audioBuffer = nativeAudioBufferConstructor2 !== null && cacheTestResult2(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor2({ length, numberOfChannels, sampleRate }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);
        if (audioBuffer.numberOfChannels === 0) {
          throw createNotSupportedError2();
        }
        if (typeof audioBuffer.copyFromChannel !== "function") {
          wrapAudioBufferCopyChannelMethods2(audioBuffer);
          wrapAudioBufferGetChannelDataMethod(audioBuffer);
        } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {
          wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
        }
        audioBufferStore2.add(audioBuffer);
        return audioBuffer;
      }
      static [Symbol.hasInstance](instance) {
        return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore2.has(instance);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/constants.js
  var MOST_NEGATIVE_SINGLE_FLOAT = -34028234663852886e22;
  var MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js
  var isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js
  var DEFAULT_OPTIONS3 = {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: false,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  };
  var createAudioBufferSourceNodeConstructor = (audioNodeConstructor2, createAudioBufferSourceNodeRenderer2, createAudioParam2, createInvalidStateError2, createNativeAudioBufferSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
    return class AudioBufferSourceNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS3, ...options2 };
        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer2() : null;
        super(context2, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);
        this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;
        this._isBufferNullified = false;
        this._isBufferSet = mergedOptions.buffer !== null;
        this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;
        this._onended = null;
        this._playbackRate = createAudioParam2(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      }
      get buffer() {
        if (this._isBufferNullified) {
          return null;
        }
        return this._nativeAudioBufferSourceNode.buffer;
      }
      set buffer(value) {
        this._nativeAudioBufferSourceNode.buffer = value;
        if (value !== null) {
          if (this._isBufferSet) {
            throw createInvalidStateError2();
          }
          this._isBufferSet = true;
        }
      }
      get loop() {
        return this._nativeAudioBufferSourceNode.loop;
      }
      set loop(value) {
        this._nativeAudioBufferSourceNode.loop = value;
      }
      get loopEnd() {
        return this._nativeAudioBufferSourceNode.loopEnd;
      }
      set loopEnd(value) {
        this._nativeAudioBufferSourceNode.loopEnd = value;
      }
      get loopStart() {
        return this._nativeAudioBufferSourceNode.loopStart;
      }
      set loopStart(value) {
        this._nativeAudioBufferSourceNode.loopStart = value;
      }
      get onended() {
        return this._onended;
      }
      set onended(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeAudioBufferSourceNode.onended = wrappedListener;
        const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;
        this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
      }
      get playbackRate() {
        return this._playbackRate;
      }
      start(when = 0, offset = 0, duration2) {
        this._nativeAudioBufferSourceNode.start(when, offset, duration2);
        if (this._audioBufferSourceNodeRenderer !== null) {
          this._audioBufferSourceNodeRenderer.start = duration2 === void 0 ? [when, offset] : [when, offset, duration2];
        }
        if (this.context.state !== "closed") {
          setInternalStateToActive(this);
          const resetInternalStateToPassive = () => {
            this._nativeAudioBufferSourceNode.removeEventListener("ended", resetInternalStateToPassive);
            if (isActiveAudioNode(this)) {
              setInternalStateToPassive(this);
            }
          };
          this._nativeAudioBufferSourceNode.addEventListener("ended", resetInternalStateToPassive);
        }
      }
      stop(when = 0) {
        this._nativeAudioBufferSourceNode.stop(when);
        if (this._audioBufferSourceNodeRenderer !== null) {
          this._audioBufferSourceNodeRenderer.stop = when;
        }
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js
  var createAudioBufferSourceNodeRendererFactory = (connectAudioParam2, createNativeAudioBufferSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeAudioBufferSourceNodes = /* @__PURE__ */ new WeakMap();
      let start3 = null;
      let stop2 = null;
      const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioBufferSourceNode = getNativeAudioNode2(proxy);
        const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);
        if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
          const options2 = {
            buffer: nativeAudioBufferSourceNode.buffer,
            channelCount: nativeAudioBufferSourceNode.channelCount,
            channelCountMode: nativeAudioBufferSourceNode.channelCountMode,
            channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,
            loop: nativeAudioBufferSourceNode.loop,
            loopEnd: nativeAudioBufferSourceNode.loopEnd,
            loopStart: nativeAudioBufferSourceNode.loopStart,
            playbackRate: nativeAudioBufferSourceNode.playbackRate.value
          };
          nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, options2);
          if (start3 !== null) {
            nativeAudioBufferSourceNode.start(...start3);
          }
          if (stop2 !== null) {
            nativeAudioBufferSourceNode.stop(stop2);
          }
        }
        renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);
        if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);
        return nativeAudioBufferSourceNode;
      };
      return {
        set start(value) {
          start3 = value;
        },
        set stop(value) {
          stop2 = value;
        },
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioBufferSourceNode !== void 0) {
            return Promise.resolve(renderedNativeAudioBufferSourceNode);
          }
          return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/audio-buffer-source-node.js
  var isAudioBufferSourceNode = (audioNode) => {
    return "playbackRate" in audioNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/biquad-filter-node.js
  var isBiquadFilterNode = (audioNode) => {
    return "frequency" in audioNode && "gain" in audioNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/constant-source-node.js
  var isConstantSourceNode = (audioNode) => {
    return "offset" in audioNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/gain-node.js
  var isGainNode = (audioNode) => {
    return !("frequency" in audioNode) && "gain" in audioNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/oscillator-node.js
  var isOscillatorNode = (audioNode) => {
    return "detune" in audioNode && "frequency" in audioNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/stereo-panner-node.js
  var isStereoPannerNode = (audioNode) => {
    return "pan" in audioNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js
  var getAudioNodeConnections = (audioNode) => {
    return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js
  var getAudioParamConnections = (audioParam) => {
    return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/deactivate-active-audio-node-input-connections.js
  var deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {
    const { activeInputs } = getAudioNodeConnections(audioNode);
    activeInputs.forEach((connections) => connections.forEach(([source]) => {
      if (!trace.includes(audioNode)) {
        deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);
      }
    }));
    const audioParams = isAudioBufferSourceNode(audioNode) ? [
      audioNode.playbackRate
    ] : isAudioWorkletNode(audioNode) ? Array.from(audioNode.parameters.values()) : isBiquadFilterNode(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : isConstantSourceNode(audioNode) ? [audioNode.offset] : isGainNode(audioNode) ? [audioNode.gain] : isOscillatorNode(audioNode) ? [audioNode.detune, audioNode.frequency] : isStereoPannerNode(audioNode) ? [audioNode.pan] : [];
    for (const audioParam of audioParams) {
      const audioParamConnections = getAudioParamConnections(audioParam);
      if (audioParamConnections !== void 0) {
        audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));
      }
    }
    if (isActiveAudioNode(audioNode)) {
      setInternalStateToPassive(audioNode);
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js
  var deactivateAudioGraph = (context2) => {
    deactivateActiveAudioNodeInputConnections(context2.destination, []);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js
  var isValidLatencyHint = (latencyHint) => {
    return latencyHint === void 0 || typeof latencyHint === "number" || typeof latencyHint === "string" && (latencyHint === "balanced" || latencyHint === "interactive" || latencyHint === "playback");
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js
  var createAudioContextConstructor = (baseAudioContextConstructor2, createInvalidStateError2, createNotSupportedError2, createUnknownError2, mediaElementAudioSourceNodeConstructor2, mediaStreamAudioDestinationNodeConstructor2, mediaStreamAudioSourceNodeConstructor2, mediaStreamTrackAudioSourceNodeConstructor2, nativeAudioContextConstructor2) => {
    return class AudioContext extends baseAudioContextConstructor2 {
      constructor(options2 = {}) {
        if (nativeAudioContextConstructor2 === null) {
          throw new Error("Missing the native AudioContext constructor.");
        }
        let nativeAudioContext;
        try {
          nativeAudioContext = new nativeAudioContextConstructor2(options2);
        } catch (err) {
          if (err.code === 12 && err.message === "sampleRate is not in range") {
            throw createNotSupportedError2();
          }
          throw err;
        }
        if (nativeAudioContext === null) {
          throw createUnknownError2();
        }
        if (!isValidLatencyHint(options2.latencyHint)) {
          throw new TypeError(`The provided value '${options2.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
        }
        if (options2.sampleRate !== void 0 && nativeAudioContext.sampleRate !== options2.sampleRate) {
          throw createNotSupportedError2();
        }
        super(nativeAudioContext, 2);
        const { latencyHint } = options2;
        const { sampleRate } = nativeAudioContext;
        this._baseLatency = typeof nativeAudioContext.baseLatency === "number" ? nativeAudioContext.baseLatency : latencyHint === "balanced" ? 512 / sampleRate : latencyHint === "interactive" || latencyHint === void 0 ? 256 / sampleRate : latencyHint === "playback" ? 1024 / sampleRate : Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;
        this._nativeAudioContext = nativeAudioContext;
        if (nativeAudioContextConstructor2.name === "webkitAudioContext") {
          this._nativeGainNode = nativeAudioContext.createGain();
          this._nativeOscillatorNode = nativeAudioContext.createOscillator();
          this._nativeGainNode.gain.value = 1e-37;
          this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);
          this._nativeOscillatorNode.start();
        } else {
          this._nativeGainNode = null;
          this._nativeOscillatorNode = null;
        }
        this._state = null;
        if (nativeAudioContext.state === "running") {
          this._state = "suspended";
          const revokeState = () => {
            if (this._state === "suspended") {
              this._state = null;
            }
            nativeAudioContext.removeEventListener("statechange", revokeState);
          };
          nativeAudioContext.addEventListener("statechange", revokeState);
        }
      }
      get baseLatency() {
        return this._baseLatency;
      }
      get state() {
        return this._state !== null ? this._state : this._nativeAudioContext.state;
      }
      close() {
        if (this.state === "closed") {
          return this._nativeAudioContext.close().then(() => {
            throw createInvalidStateError2();
          });
        }
        if (this._state === "suspended") {
          this._state = null;
        }
        return this._nativeAudioContext.close().then(() => {
          if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
            this._nativeOscillatorNode.stop();
            this._nativeGainNode.disconnect();
            this._nativeOscillatorNode.disconnect();
          }
          deactivateAudioGraph(this);
        });
      }
      createMediaElementSource(mediaElement) {
        return new mediaElementAudioSourceNodeConstructor2(this, { mediaElement });
      }
      createMediaStreamDestination() {
        return new mediaStreamAudioDestinationNodeConstructor2(this);
      }
      createMediaStreamSource(mediaStream) {
        return new mediaStreamAudioSourceNodeConstructor2(this, { mediaStream });
      }
      createMediaStreamTrackSource(mediaStreamTrack) {
        return new mediaStreamTrackAudioSourceNodeConstructor2(this, { mediaStreamTrack });
      }
      resume() {
        if (this._state === "suspended") {
          return new Promise((resolve2, reject) => {
            const resolvePromise = () => {
              this._nativeAudioContext.removeEventListener("statechange", resolvePromise);
              if (this._nativeAudioContext.state === "running") {
                resolve2();
              } else {
                this.resume().then(resolve2, reject);
              }
            };
            this._nativeAudioContext.addEventListener("statechange", resolvePromise);
          });
        }
        return this._nativeAudioContext.resume().catch((err) => {
          if (err === void 0 || err.code === 15) {
            throw createInvalidStateError2();
          }
          throw err;
        });
      }
      suspend() {
        return this._nativeAudioContext.suspend().catch((err) => {
          if (err === void 0) {
            throw createInvalidStateError2();
          }
          throw err;
        });
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js
  var createAudioDestinationNodeConstructor = (audioNodeConstructor2, createAudioDestinationNodeRenderer2, createIndexSizeError2, createInvalidStateError2, createNativeAudioDestinationNode, getNativeContext2, isNativeOfflineAudioContext2, renderInputsOfAudioNode2) => {
    return class AudioDestinationNode extends audioNodeConstructor2 {
      constructor(context2, channelCount) {
        const nativeContext = getNativeContext2(context2);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);
        const audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer2(renderInputsOfAudioNode2) : null;
        super(context2, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);
        this._isNodeOfNativeOfflineAudioContext = isOffline;
        this._nativeAudioDestinationNode = nativeAudioDestinationNode;
      }
      get channelCount() {
        return this._nativeAudioDestinationNode.channelCount;
      }
      set channelCount(value) {
        if (this._isNodeOfNativeOfflineAudioContext) {
          throw createInvalidStateError2();
        }
        if (value > this._nativeAudioDestinationNode.maxChannelCount) {
          throw createIndexSizeError2();
        }
        this._nativeAudioDestinationNode.channelCount = value;
      }
      get channelCountMode() {
        return this._nativeAudioDestinationNode.channelCountMode;
      }
      set channelCountMode(value) {
        if (this._isNodeOfNativeOfflineAudioContext) {
          throw createInvalidStateError2();
        }
        this._nativeAudioDestinationNode.channelCountMode = value;
      }
      get maxChannelCount() {
        return this._nativeAudioDestinationNode.maxChannelCount;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js
  var createAudioDestinationNodeRenderer = (renderInputsOfAudioNode2) => {
    const renderedNativeAudioDestinationNodes = /* @__PURE__ */ new WeakMap();
    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {
      const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;
      renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);
      return nativeAudioDestinationNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioDestinationNode !== void 0) {
          return Promise.resolve(renderedNativeAudioDestinationNode);
        }
        return createAudioDestinationNode(proxy, nativeOfflineAudioContext);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js
  var createAudioListenerFactory = (createAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeScriptProcessorNode2, createNotSupportedError2, getFirstSample2, isNativeOfflineAudioContext2, overwriteAccessors2) => {
    return (context2, nativeContext) => {
      const nativeListener = nativeContext.listener;
      const createFakeAudioParams = () => {
        const buffer2 = new Float32Array(1);
        const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: 9
        });
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        let isScriptProcessorNodeCreated = false;
        let lastOrientation = [0, 0, -1, 0, 1, 0];
        let lastPosition = [0, 0, 0];
        const createScriptProcessorNode = () => {
          if (isScriptProcessorNodeCreated) {
            return;
          }
          isScriptProcessorNodeCreated = true;
          const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 9, 0);
          scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
            const orientation = [
              getFirstSample2(inputBuffer, buffer2, 0),
              getFirstSample2(inputBuffer, buffer2, 1),
              getFirstSample2(inputBuffer, buffer2, 2),
              getFirstSample2(inputBuffer, buffer2, 3),
              getFirstSample2(inputBuffer, buffer2, 4),
              getFirstSample2(inputBuffer, buffer2, 5)
            ];
            if (orientation.some((value, index15) => value !== lastOrientation[index15])) {
              nativeListener.setOrientation(...orientation);
              lastOrientation = orientation;
            }
            const positon = [
              getFirstSample2(inputBuffer, buffer2, 6),
              getFirstSample2(inputBuffer, buffer2, 7),
              getFirstSample2(inputBuffer, buffer2, 8)
            ];
            if (positon.some((value, index15) => value !== lastPosition[index15])) {
              nativeListener.setPosition(...positon);
              lastPosition = positon;
            }
          };
          channelMergerNode.connect(scriptProcessorNode);
        };
        const createSetOrientation = (index15) => (value) => {
          if (value !== lastOrientation[index15]) {
            lastOrientation[index15] = value;
            nativeListener.setOrientation(...lastOrientation);
          }
        };
        const createSetPosition = (index15) => (value) => {
          if (value !== lastPosition[index15]) {
            lastPosition[index15] = value;
            nativeListener.setPosition(...lastPosition);
          }
        };
        const createFakeAudioParam = (input2, initialValue, setValue) => {
          const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            offset: initialValue
          });
          constantSourceNode.connect(channelMergerNode, 0, input2);
          constantSourceNode.start();
          Object.defineProperty(constantSourceNode.offset, "defaultValue", {
            get() {
              return initialValue;
            }
          });
          const audioParam = createAudioParam2({ context: context2 }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          overwriteAccessors2(audioParam, "value", (get10) => () => get10.call(audioParam), (set3) => (value) => {
            try {
              set3.call(audioParam, value);
            } catch (err) {
              if (err.code !== 9) {
                throw err;
              }
            }
            createScriptProcessorNode();
            if (isOffline) {
              setValue(value);
            }
          });
          audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = cancelAndHoldAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.cancelAndHoldAtTime);
          audioParam.cancelScheduledValues = ((cancelScheduledValues) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = cancelScheduledValues.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.cancelScheduledValues);
          audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = exponentialRampToValueAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.exponentialRampToValueAtTime);
          audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = linearRampToValueAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.linearRampToValueAtTime);
          audioParam.setTargetAtTime = ((setTargetAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = setTargetAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.setTargetAtTime);
          audioParam.setValueAtTime = ((setValueAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = setValueAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.setValueAtTime);
          audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = setValueCurveAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.setValueCurveAtTime);
          return audioParam;
        };
        return {
          forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),
          forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),
          forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),
          positionX: createFakeAudioParam(6, 0, createSetPosition(0)),
          positionY: createFakeAudioParam(7, 0, createSetPosition(1)),
          positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),
          upX: createFakeAudioParam(3, 0, createSetOrientation(3)),
          upY: createFakeAudioParam(4, 1, createSetOrientation(4)),
          upZ: createFakeAudioParam(5, 0, createSetOrientation(5))
        };
      };
      const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === void 0 ? createFakeAudioParams() : nativeListener;
      return {
        get forwardX() {
          return forwardX;
        },
        get forwardY() {
          return forwardY;
        },
        get forwardZ() {
          return forwardZ;
        },
        get positionX() {
          return positionX;
        },
        get positionY() {
          return positionY;
        },
        get positionZ() {
          return positionZ;
        },
        get upX() {
          return upX;
        },
        get upY() {
          return upY;
        },
        get upZ() {
          return upZ;
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/audio-node.js
  var isAudioNode = (audioNodeOrAudioParam) => {
    return "context" in audioNodeOrAudioParam;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js
  var isAudioNodeOutputConnection = (outputConnection) => {
    return isAudioNode(outputConnection[0]);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js
  var insertElementInSet = (set3, element, predicate, ignoreDuplicates) => {
    for (const lmnt of set3) {
      if (predicate(lmnt)) {
        if (ignoreDuplicates) {
          return false;
        }
        throw Error("The set contains at least one similar element.");
      }
    }
    set3.add(element);
    return true;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/add-active-input-connection-to-audio-param.js
  var addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {
    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/add-passive-input-connection-to-audio-param.js
  var addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {
    const passiveInputConnections = passiveInputs.get(source);
    if (passiveInputConnections === void 0) {
      passiveInputs.set(source, /* @__PURE__ */ new Set([[output, eventListener]]));
    } else {
      insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output, ignoreDuplicates);
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js
  var isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {
    return "inputs" in nativeAudioNodeOrNativeAudioNodeFaker;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js
  var connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input2) => {
    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
      const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input2];
      nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);
      return [fakeNativeDestinationAudioNode, output, 0];
    }
    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input2);
    return [nativeDestinationAudioNode, output, input2];
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection.js
  var deleteActiveInputConnection = (activeInputConnections, source, output) => {
    for (const activeInputConnection of activeInputConnections) {
      if (activeInputConnection[0] === source && activeInputConnection[1] === output) {
        activeInputConnections.delete(activeInputConnection);
        return activeInputConnection;
      }
    }
    return null;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection-to-audio-param.js
  var deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {
    return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js
  var deleteEventListenerOfAudioNode = (audioNode, eventListener) => {
    const eventListeners = getEventListenersOfAudioNode(audioNode);
    if (!eventListeners.delete(eventListener)) {
      throw new Error("Missing the expected event listener.");
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-param.js
  var deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {
    const passiveInputConnections = getValueForKey(passiveInputs, source);
    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output);
    if (passiveInputConnections.size === 0) {
      passiveInputs.delete(source);
    }
    return matchingConnection;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js
  var disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input2) => {
    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
      nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input2], output, 0);
    } else {
      nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input2);
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js
  var getNativeAudioNode = (audioNode) => {
    return getValueForKey(AUDIO_NODE_STORE, audioNode);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js
  var getNativeAudioParam = (audioParam) => {
    return getValueForKey(AUDIO_PARAM_STORE, audioParam);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js
  var isPartOfACycle = (audioNode) => {
    return CYCLE_COUNTERS.has(audioNode);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js
  var isPassiveAudioNode = (audioNode) => {
    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js
  var testAudioNodeDisconnectMethodSupport = (nativeAudioContext, nativeAudioWorkletNodeConstructor2) => {
    return new Promise((resolve2) => {
      if (nativeAudioWorkletNodeConstructor2 !== null) {
        resolve2(true);
      } else {
        const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);
        const dummy = nativeAudioContext.createGain();
        const ones = nativeAudioContext.createBuffer(1, 2, 44100);
        const channelData = ones.getChannelData(0);
        channelData[0] = 1;
        channelData[1] = 1;
        const source = nativeAudioContext.createBufferSource();
        source.buffer = ones;
        source.loop = true;
        source.connect(analyzer).connect(nativeAudioContext.destination);
        source.connect(dummy);
        source.disconnect(dummy);
        analyzer.onaudioprocess = (event) => {
          const chnnlDt = event.inputBuffer.getChannelData(0);
          if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {
            resolve2(true);
          } else {
            resolve2(false);
          }
          source.stop();
          analyzer.onaudioprocess = null;
          source.disconnect(analyzer);
          analyzer.disconnect(nativeAudioContext.destination);
        };
        source.start();
      }
    });
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js
  var visitEachAudioNodeOnce = (cycles, visitor) => {
    const counts = /* @__PURE__ */ new Map();
    for (const cycle of cycles) {
      for (const audioNode of cycle) {
        const count = counts.get(audioNode);
        counts.set(audioNode, count === void 0 ? 1 : count + 1);
      }
    }
    counts.forEach((count, audioNode) => visitor(audioNode, count));
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js
  var isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {
    return "context" in nativeAudioNodeOrAudioParam;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js
  var wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {
    const connections = /* @__PURE__ */ new Map();
    nativeAudioNode.connect = ((connect2) => {
      return (destination, output = 0, input2 = 0) => {
        const returnValue = isNativeAudioNode(destination) ? connect2(destination, output, input2) : connect2(destination, output);
        const connectionsToDestination = connections.get(destination);
        if (connectionsToDestination === void 0) {
          connections.set(destination, [{ input: input2, output }]);
        } else {
          if (connectionsToDestination.every((connection) => connection.input !== input2 || connection.output !== output)) {
            connectionsToDestination.push({ input: input2, output });
          }
        }
        return returnValue;
      };
    })(nativeAudioNode.connect.bind(nativeAudioNode));
    nativeAudioNode.disconnect = ((disconnect2) => {
      return (destinationOrOutput, output, input2) => {
        disconnect2.apply(nativeAudioNode);
        if (destinationOrOutput === void 0) {
          connections.clear();
        } else if (typeof destinationOrOutput === "number") {
          for (const [destination, connectionsToDestination] of connections) {
            const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);
            if (filteredConnections.length === 0) {
              connections.delete(destination);
            } else {
              connections.set(destination, filteredConnections);
            }
          }
        } else if (connections.has(destinationOrOutput)) {
          if (output === void 0) {
            connections.delete(destinationOrOutput);
          } else {
            const connectionsToDestination = connections.get(destinationOrOutput);
            if (connectionsToDestination !== void 0) {
              const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input2 || input2 === void 0));
              if (filteredConnections.length === 0) {
                connections.delete(destinationOrOutput);
              } else {
                connections.set(destinationOrOutput, filteredConnections);
              }
            }
          }
        }
        for (const [destination, connectionsToDestination] of connections) {
          connectionsToDestination.forEach((connection) => {
            if (isNativeAudioNode(destination)) {
              nativeAudioNode.connect(destination, connection.output, connection.input);
            } else {
              nativeAudioNode.connect(destination, connection.output);
            }
          });
        }
      };
    })(nativeAudioNode.disconnect);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js
  var addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {
    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
    const { outputs } = getAudioNodeConnections(source);
    const eventListeners = getEventListenersOfAudioNode(source);
    const eventListener = (isActive) => {
      const nativeAudioNode = getNativeAudioNode(source);
      const nativeAudioParam = getNativeAudioParam(destination);
      if (isActive) {
        const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
        addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);
        if (!isOffline && !isPartOfACycle(source)) {
          nativeAudioNode.connect(nativeAudioParam, output);
        }
      } else {
        const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);
        addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);
        if (!isOffline && !isPartOfACycle(source)) {
          nativeAudioNode.disconnect(nativeAudioParam, output);
        }
      }
    };
    if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {
      eventListeners.add(eventListener);
      if (isActiveAudioNode(source)) {
        addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);
      } else {
        addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);
      }
      return true;
    }
    return false;
  };
  var deleteInputConnectionOfAudioNode = (source, destination, output, input2) => {
    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);
    const activeInputConnection = deleteActiveInputConnection(activeInputs[input2], source, output);
    if (activeInputConnection === null) {
      const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input2);
      return [passiveInputConnection[2], false];
    }
    return [activeInputConnection[2], true];
  };
  var deleteInputConnectionOfAudioParam = (source, destination, output) => {
    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);
    if (activeInputConnection === null) {
      const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
      return [passiveInputConnection[1], false];
    }
    return [activeInputConnection[2], true];
  };
  var deleteInputsOfAudioNode = (source, isOffline, destination, output, input2) => {
    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input2);
    if (listener !== null) {
      deleteEventListenerOfAudioNode(source, listener);
      if (isActive && !isOffline && !isPartOfACycle(source)) {
        disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input2);
      }
    }
    if (isActiveAudioNode(destination)) {
      const { activeInputs } = getAudioNodeConnections(destination);
      setInternalStateToPassiveWhenNecessary(destination, activeInputs);
    }
  };
  var deleteInputsOfAudioParam = (source, isOffline, destination, output) => {
    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);
    if (listener !== null) {
      deleteEventListenerOfAudioNode(source, listener);
      if (isActive && !isOffline && !isPartOfACycle(source)) {
        getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);
      }
    }
  };
  var deleteAnyConnection = (source, isOffline) => {
    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
    const destinations = [];
    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
      if (isAudioNodeOutputConnection(outputConnection)) {
        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
      } else {
        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
      }
      destinations.push(outputConnection[0]);
    }
    audioNodeConnectionsOfSource.outputs.clear();
    return destinations;
  };
  var deleteConnectionAtOutput = (source, isOffline, output) => {
    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
    const destinations = [];
    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
      if (outputConnection[1] === output) {
        if (isAudioNodeOutputConnection(outputConnection)) {
          deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
        } else {
          deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
        }
        destinations.push(outputConnection[0]);
        audioNodeConnectionsOfSource.outputs.delete(outputConnection);
      }
    }
    return destinations;
  };
  var deleteConnectionToDestination = (source, isOffline, destination, output, input2) => {
    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
    return Array.from(audioNodeConnectionsOfSource.outputs).filter((outputConnection) => outputConnection[0] === destination && (output === void 0 || outputConnection[1] === output) && (input2 === void 0 || outputConnection[2] === input2)).map((outputConnection) => {
      if (isAudioNodeOutputConnection(outputConnection)) {
        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
      } else {
        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
      }
      audioNodeConnectionsOfSource.outputs.delete(outputConnection);
      return outputConnection[0];
    });
  };
  var createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult2, createIncrementCycleCounter, createIndexSizeError2, createInvalidAccessError2, createNotSupportedError2, decrementCycleCounter, detectCycles, eventTargetConstructor2, getNativeContext2, isNativeAudioContext2, isNativeAudioNode3, isNativeAudioParam2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2) => {
    return class AudioNode extends eventTargetConstructor2 {
      constructor(context2, isActive, nativeAudioNode, audioNodeRenderer) {
        super(nativeAudioNode);
        this._context = context2;
        this._nativeAudioNode = nativeAudioNode;
        const nativeContext = getNativeContext2(context2);
        if (isNativeAudioContext2(nativeContext) && cacheTestResult2(testAudioNodeDisconnectMethodSupport, () => {
          return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor2);
        }) !== true) {
          wrapAudioNodeDisconnectMethod(nativeAudioNode);
        }
        AUDIO_NODE_STORE.set(this, nativeAudioNode);
        EVENT_LISTENERS.set(this, /* @__PURE__ */ new Set());
        if (context2.state !== "closed" && isActive) {
          setInternalStateToActive(this);
        }
        addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);
      }
      get channelCount() {
        return this._nativeAudioNode.channelCount;
      }
      set channelCount(value) {
        this._nativeAudioNode.channelCount = value;
      }
      get channelCountMode() {
        return this._nativeAudioNode.channelCountMode;
      }
      set channelCountMode(value) {
        this._nativeAudioNode.channelCountMode = value;
      }
      get channelInterpretation() {
        return this._nativeAudioNode.channelInterpretation;
      }
      set channelInterpretation(value) {
        this._nativeAudioNode.channelInterpretation = value;
      }
      get context() {
        return this._context;
      }
      get numberOfInputs() {
        return this._nativeAudioNode.numberOfInputs;
      }
      get numberOfOutputs() {
        return this._nativeAudioNode.numberOfOutputs;
      }
      connect(destination, output = 0, input2 = 0) {
        if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {
          throw createIndexSizeError2();
        }
        const nativeContext = getNativeContext2(this._context);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        if (isNativeAudioNode3(destination) || isNativeAudioParam2(destination)) {
          throw createInvalidAccessError2();
        }
        if (isAudioNode(destination)) {
          const nativeDestinationAudioNode = getNativeAudioNode(destination);
          try {
            const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input2);
            const isPassive = isPassiveAudioNode(this);
            if (isOffline || isPassive) {
              this._nativeAudioNode.disconnect(...connection);
            }
            if (this.context.state !== "closed" && !isPassive && isPassiveAudioNode(destination)) {
              setInternalStateToActive(destination);
            }
          } catch (err) {
            if (err.code === 12) {
              throw createInvalidAccessError2();
            }
            throw err;
          }
          const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input2, isOffline);
          if (isNewConnectionToAudioNode) {
            const cycles = detectCycles([this], destination);
            visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
          }
          return destination;
        }
        const nativeAudioParam = getNativeAudioParam(destination);
        if (nativeAudioParam.name === "playbackRate" && nativeAudioParam.maxValue === 1024) {
          throw createNotSupportedError2();
        }
        try {
          this._nativeAudioNode.connect(nativeAudioParam, output);
          if (isOffline || isPassiveAudioNode(this)) {
            this._nativeAudioNode.disconnect(nativeAudioParam, output);
          }
        } catch (err) {
          if (err.code === 12) {
            throw createInvalidAccessError2();
          }
          throw err;
        }
        const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);
        if (isNewConnectionToAudioParam) {
          const cycles = detectCycles([this], destination);
          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
        }
      }
      disconnect(destinationOrOutput, output, input2) {
        let destinations;
        const nativeContext = getNativeContext2(this._context);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        if (destinationOrOutput === void 0) {
          destinations = deleteAnyConnection(this, isOffline);
        } else if (typeof destinationOrOutput === "number") {
          if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {
            throw createIndexSizeError2();
          }
          destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);
        } else {
          if (output !== void 0 && (output < 0 || output >= this.numberOfOutputs)) {
            throw createIndexSizeError2();
          }
          if (isAudioNode(destinationOrOutput) && input2 !== void 0 && (input2 < 0 || input2 >= destinationOrOutput.numberOfInputs)) {
            throw createIndexSizeError2();
          }
          destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input2);
          if (destinations.length === 0) {
            throw createInvalidAccessError2();
          }
        }
        for (const destination of destinations) {
          const cycles = detectCycles([this], destination);
          visitEachAudioNodeOnce(cycles, decrementCycleCounter);
        }
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js
  var createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore2, audioParamStore, createAudioParamRenderer2, createCancelAndHoldAutomationEvent2, createCancelScheduledValuesAutomationEvent2, createExponentialRampToValueAutomationEvent2, createLinearRampToValueAutomationEvent2, createSetTargetAutomationEvent2, createSetValueAutomationEvent2, createSetValueCurveAutomationEvent2, nativeAudioContextConstructor2, setValueAtTimeUntilPossible2) => {
    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {
      const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);
      const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer2(automationEventList) : null;
      const audioParam = {
        get defaultValue() {
          return nativeAudioParam.defaultValue;
        },
        get maxValue() {
          return maxValue === null ? nativeAudioParam.maxValue : maxValue;
        },
        get minValue() {
          return minValue === null ? nativeAudioParam.minValue : minValue;
        },
        get value() {
          return nativeAudioParam.value;
        },
        set value(value) {
          nativeAudioParam.value = value;
          audioParam.setValueAtTime(value, audioNode.context.currentTime);
        },
        cancelAndHoldAtTime(cancelTime) {
          if (typeof nativeAudioParam.cancelAndHoldAtTime === "function") {
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
            nativeAudioParam.cancelAndHoldAtTime(cancelTime);
          } else {
            const previousLastEvent = Array.from(automationEventList).pop();
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
            const currentLastEvent = Array.from(automationEventList).pop();
            nativeAudioParam.cancelScheduledValues(cancelTime);
            if (previousLastEvent !== currentLastEvent && currentLastEvent !== void 0) {
              if (currentLastEvent.type === "exponentialRampToValue") {
                nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
              } else if (currentLastEvent.type === "linearRampToValue") {
                nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
              } else if (currentLastEvent.type === "setValue") {
                nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);
              } else if (currentLastEvent.type === "setValueCurve") {
                nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);
              }
            }
          }
          return audioParam;
        },
        cancelScheduledValues(cancelTime) {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createCancelScheduledValuesAutomationEvent2(cancelTime));
          nativeAudioParam.cancelScheduledValues(cancelTime);
          return audioParam;
        },
        exponentialRampToValueAtTime(value, endTime) {
          if (value === 0) {
            throw new RangeError();
          }
          if (!Number.isFinite(endTime) || endTime < 0) {
            throw new RangeError();
          }
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createExponentialRampToValueAutomationEvent2(value, endTime));
          nativeAudioParam.exponentialRampToValueAtTime(value, endTime);
          return audioParam;
        },
        linearRampToValueAtTime(value, endTime) {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createLinearRampToValueAutomationEvent2(value, endTime));
          nativeAudioParam.linearRampToValueAtTime(value, endTime);
          return audioParam;
        },
        setTargetAtTime(target, startTime, timeConstant) {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createSetTargetAutomationEvent2(target, startTime, timeConstant));
          nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);
          return audioParam;
        },
        setValueAtTime(value, startTime) {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createSetValueAutomationEvent2(value, startTime));
          nativeAudioParam.setValueAtTime(value, startTime);
          return audioParam;
        },
        setValueCurveAtTime(values, startTime, duration2) {
          const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);
          if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
            const endTime = startTime + duration2;
            const sampleRate = audioNode.context.sampleRate;
            const firstSample = Math.ceil(startTime * sampleRate);
            const lastSample = Math.floor(endTime * sampleRate);
            const numberOfInterpolatedValues = lastSample - firstSample;
            const interpolatedValues = new Float32Array(numberOfInterpolatedValues);
            for (let i8 = 0; i8 < numberOfInterpolatedValues; i8 += 1) {
              const theoreticIndex = (convertedValues.length - 1) / duration2 * ((firstSample + i8) / sampleRate - startTime);
              const lowerIndex = Math.floor(theoreticIndex);
              const upperIndex = Math.ceil(theoreticIndex);
              interpolatedValues[i8] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];
            }
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createSetValueCurveAutomationEvent2(interpolatedValues, startTime, duration2));
            nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration2);
            const timeOfLastSample = lastSample / sampleRate;
            if (timeOfLastSample < endTime) {
              setValueAtTimeUntilPossible2(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);
            }
            setValueAtTimeUntilPossible2(audioParam, convertedValues[convertedValues.length - 1], endTime);
          } else {
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createSetValueCurveAutomationEvent2(convertedValues, startTime, duration2));
            nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration2);
          }
          return audioParam;
        }
      };
      audioParamStore.set(audioParam, nativeAudioParam);
      audioParamAudioNodeStore2.set(audioParam, audioNode);
      addAudioParamConnections(audioParam, audioParamRenderer);
      return audioParam;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js
  var createAudioParamRenderer = (automationEventList) => {
    return {
      replay(audioParam) {
        for (const automationEvent of automationEventList) {
          if (automationEvent.type === "exponentialRampToValue") {
            const { endTime, value } = automationEvent;
            audioParam.exponentialRampToValueAtTime(value, endTime);
          } else if (automationEvent.type === "linearRampToValue") {
            const { endTime, value } = automationEvent;
            audioParam.linearRampToValueAtTime(value, endTime);
          } else if (automationEvent.type === "setTarget") {
            const { startTime, target, timeConstant } = automationEvent;
            audioParam.setTargetAtTime(target, startTime, timeConstant);
          } else if (automationEvent.type === "setValue") {
            const { startTime, value } = automationEvent;
            audioParam.setValueAtTime(value, startTime);
          } else if (automationEvent.type === "setValueCurve") {
            const { duration: duration2, startTime, values } = automationEvent;
            audioParam.setValueCurveAtTime(values, startTime, duration2);
          } else {
            throw new Error("Can't apply an unknown automation.");
          }
        }
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/read-only-map.js
  var ReadOnlyMap = class {
    constructor(parameters) {
      this._map = new Map(parameters);
    }
    get size() {
      return this._map.size;
    }
    entries() {
      return this._map.entries();
    }
    forEach(callback, thisArg = null) {
      return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));
    }
    get(name2) {
      return this._map.get(name2);
    }
    has(name2) {
      return this._map.has(name2);
    }
    keys() {
      return this._map.keys();
    }
    values() {
      return this._map.values();
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js
  var DEFAULT_OPTIONS4 = {
    channelCount: 2,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    numberOfInputs: 1,
    numberOfOutputs: 1,
    parameterData: {},
    processorOptions: {}
  };
  var createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode2, audioNodeConstructor2, createAudioParam2, createAudioWorkletNodeRenderer2, createNativeAudioWorkletNode2, getAudioNodeConnections2, getBackupOfflineAudioContext2, getNativeContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, sanitizeAudioWorkletNodeOptions2, setActiveAudioWorkletNodeInputs2, testAudioWorkletNodeOptionsClonability2, wrapEventListener2) => {
    return class AudioWorkletNode extends audioNodeConstructor2 {
      constructor(context2, name2, options2) {
        var _a3;
        const nativeContext = getNativeContext2(context2);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const mergedOptions = sanitizeAudioWorkletNodeOptions2({ ...DEFAULT_OPTIONS4, ...options2 });
        testAudioWorkletNodeOptionsClonability2(mergedOptions);
        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
        const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name2);
        const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== "closed" ? nativeContext : (_a3 = getBackupOfflineAudioContext2(nativeContext)) !== null && _a3 !== void 0 ? _a3 : nativeContext;
        const nativeAudioWorkletNode = createNativeAudioWorkletNode2(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context2.baseLatency, nativeAudioWorkletNodeConstructor2, name2, processorConstructor, mergedOptions);
        const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer2(name2, mergedOptions, processorConstructor) : null;
        super(context2, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);
        const parameters = [];
        nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {
          const audioParam = createAudioParam2(this, isOffline, nativeAudioParam);
          parameters.push([nm, audioParam]);
        });
        this._nativeAudioWorkletNode = nativeAudioWorkletNode;
        this._onprocessorerror = null;
        this._parameters = new ReadOnlyMap(parameters);
        if (isOffline) {
          addUnrenderedAudioWorkletNode2(nativeContext, this);
        }
        const { activeInputs } = getAudioNodeConnections2(this);
        setActiveAudioWorkletNodeInputs2(nativeAudioWorkletNode, activeInputs);
      }
      get onprocessorerror() {
        return this._onprocessorerror;
      }
      set onprocessorerror(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;
        const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;
        this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;
      }
      get parameters() {
        if (this._parameters === null) {
          return this._nativeAudioWorkletNode.parameters;
        }
        return this._parameters;
      }
      get port() {
        return this._nativeAudioWorkletNode.port;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js
  function copyFromChannel(audioBuffer, parent, key, channelNumber, bufferOffset) {
    if (typeof audioBuffer.copyFromChannel === "function") {
      if (parent[key].byteLength === 0) {
        parent[key] = new Float32Array(128);
      }
      audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);
    } else {
      const channelData = audioBuffer.getChannelData(channelNumber);
      if (parent[key].byteLength === 0) {
        parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);
      } else {
        const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);
        parent[key].set(slicedInput);
      }
    }
  }

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js
  var copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {
    if (typeof audioBuffer.copyToChannel === "function") {
      if (parent[key].byteLength !== 0) {
        audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);
      }
    } else {
      if (parent[key].byteLength !== 0) {
        audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);
      }
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js
  var createNestedArrays = (x4, y3) => {
    const arrays = [];
    for (let i8 = 0; i8 < x4; i8 += 1) {
      const array = [];
      const length = typeof y3 === "number" ? y3 : y3[i8];
      for (let j2 = 0; j2 < length; j2 += 1) {
        array.push(new Float32Array(128));
      }
      arrays.push(array);
    }
    return arrays;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js
  var getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {
    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);
    const nativeAudioWorkletNode = getNativeAudioNode(proxy);
    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js
  var processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options2, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2) => {
    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;
    const numberOfInputChannels = options2.channelCount * options2.numberOfInputs;
    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
    const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);
    if (processorConstructor === void 0) {
      throw new Error("Missing the processor constructor.");
    }
    const audioNodeConnections = getAudioNodeConnections(proxy);
    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);
    const inputs = createNestedArrays(options2.numberOfInputs, options2.channelCount);
    const outputs = createNestedArrays(options2.numberOfOutputs, outputChannelCount);
    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name2) => ({ ...prmtrs, [name2]: new Float32Array(128) }), {});
    for (let i8 = 0; i8 < length; i8 += 128) {
      if (options2.numberOfInputs > 0 && renderedBuffer !== null) {
        for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
          for (let k2 = 0; k2 < options2.channelCount; k2 += 1) {
            copyFromChannel(renderedBuffer, inputs[j2], k2, k2, i8);
          }
        }
      }
      if (processorConstructor.parameterDescriptors !== void 0 && renderedBuffer !== null) {
        processorConstructor.parameterDescriptors.forEach(({ name: name2 }, index15) => {
          copyFromChannel(renderedBuffer, parameters, name2, numberOfInputChannels + index15, i8);
        });
      }
      for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
        for (let k2 = 0; k2 < outputChannelCount[j2]; k2 += 1) {
          if (outputs[j2][k2].byteLength === 0) {
            outputs[j2][k2] = new Float32Array(128);
          }
        }
      }
      try {
        const potentiallyEmptyInputs = inputs.map((input2, index15) => {
          if (audioNodeConnections.activeInputs[index15].size === 0) {
            return [];
          }
          return input2;
        });
        const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(i8 / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));
        if (processedBuffer !== null) {
          for (let j2 = 0, outputChannelSplitterNodeOutput = 0; j2 < options2.numberOfOutputs; j2 += 1) {
            for (let k2 = 0; k2 < outputChannelCount[j2]; k2 += 1) {
              copyToChannel(processedBuffer, outputs[j2], k2, outputChannelSplitterNodeOutput + k2, i8);
            }
            outputChannelSplitterNodeOutput += outputChannelCount[j2];
          }
        }
        if (!activeSourceFlag) {
          break;
        }
      } catch (error) {
        proxy.dispatchEvent(new ErrorEvent("processorerror", {
          colno: error.colno,
          filename: error.filename,
          lineno: error.lineno,
          message: error.message
        }));
        break;
      }
    }
    return processedBuffer;
  };
  var createAudioWorkletNodeRendererFactory = (connectAudioParam2, connectMultipleOutputs2, createNativeAudioBufferSourceNode2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, deleteUnrenderedAudioWorkletNode2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getNativeAudioNode2, nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
    return (name2, options2, processorConstructor) => {
      const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
      let processedBufferPromise = null;
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioWorkletNode = getNativeAudioNode2(proxy);
        let nativeOutputNodes = null;
        const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);
        const outputChannelCount = Array.isArray(options2.outputChannelCount) ? options2.outputChannelCount : Array.from(options2.outputChannelCount);
        if (nativeAudioWorkletNodeConstructor2 === null) {
          const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
          const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, {
            channelCount: Math.max(1, numberOfOutputChannels),
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            numberOfOutputs: Math.max(1, numberOfOutputChannels)
          });
          const outputChannelMergerNodes = [];
          for (let i8 = 0; i8 < proxy.numberOfOutputs; i8 += 1) {
            outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeOfflineAudioContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "speakers",
              numberOfInputs: outputChannelCount[i8]
            }));
          }
          const outputGainNode = createNativeGainNode2(nativeOfflineAudioContext, {
            channelCount: options2.channelCount,
            channelCountMode: options2.channelCountMode,
            channelInterpretation: options2.channelInterpretation,
            gain: 1
          });
          outputGainNode.connect = connectMultipleOutputs2.bind(null, outputChannelMergerNodes);
          outputGainNode.disconnect = disconnectMultipleOutputs2.bind(null, outputChannelMergerNodes);
          nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];
        } else if (!nativeAudioWorkletNodeIsOwnedByContext) {
          nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeOfflineAudioContext, name2);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);
        if (nativeOutputNodes !== null) {
          if (processedBufferPromise === null) {
            if (processorConstructor === void 0) {
              throw new Error("Missing the processor constructor.");
            }
            if (nativeOfflineAudioContextConstructor2 === null) {
              throw new Error("Missing the native OfflineAudioContext constructor.");
            }
            const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;
            const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
            const numberOfChannels = numberOfInputChannels + numberOfParameters;
            const renderBuffer = async () => {
              const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(numberOfChannels, Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);
              const gainNodes = [];
              const inputChannelSplitterNodes = [];
              for (let i8 = 0; i8 < options2.numberOfInputs; i8 += 1) {
                gainNodes.push(createNativeGainNode2(partialOfflineAudioContext, {
                  channelCount: options2.channelCount,
                  channelCountMode: options2.channelCountMode,
                  channelInterpretation: options2.channelInterpretation,
                  gain: 1
                }));
                inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(partialOfflineAudioContext, {
                  channelCount: options2.channelCount,
                  channelCountMode: "explicit",
                  channelInterpretation: "discrete",
                  numberOfOutputs: options2.channelCount
                }));
              }
              const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {
                const constantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                  channelCount: 1,
                  channelCountMode: "explicit",
                  channelInterpretation: "discrete",
                  offset: audioParam.value
                });
                await renderAutomation2(partialOfflineAudioContext, audioParam, constantSourceNode.offset);
                return constantSourceNode;
              }));
              const inputChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "speakers",
                numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
              });
              for (let i8 = 0; i8 < options2.numberOfInputs; i8 += 1) {
                gainNodes[i8].connect(inputChannelSplitterNodes[i8]);
                for (let j2 = 0; j2 < options2.channelCount; j2 += 1) {
                  inputChannelSplitterNodes[i8].connect(inputChannelMergerNode, j2, i8 * options2.channelCount + j2);
                }
              }
              for (const [index15, constantSourceNode] of constantSourceNodes.entries()) {
                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index15);
                constantSourceNode.start(0);
              }
              inputChannelMergerNode.connect(partialOfflineAudioContext.destination);
              await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, gainNode)));
              return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
            };
            processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options2, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2);
          }
          const processedBuffer = await processedBufferPromise;
          const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
            buffer: null,
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            loop: false,
            loopEnd: 0,
            loopStart: 0,
            playbackRate: 1
          });
          const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;
          if (processedBuffer !== null) {
            audioBufferSourceNode.buffer = processedBuffer;
            audioBufferSourceNode.start(0);
          }
          audioBufferSourceNode.connect(outputChannelSplitterNode);
          for (let i8 = 0, outputChannelSplitterNodeOutput = 0; i8 < proxy.numberOfOutputs; i8 += 1) {
            const outputChannelMergerNode = outputChannelMergerNodes[i8];
            for (let j2 = 0; j2 < outputChannelCount[i8]; j2 += 1) {
              outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
            }
            outputChannelSplitterNodeOutput += outputChannelCount[i8];
          }
          return outputGainNode;
        }
        if (!nativeAudioWorkletNodeIsOwnedByContext) {
          for (const [nm, audioParam] of proxy.parameters.entries()) {
            await renderAutomation2(nativeOfflineAudioContext, audioParam, nativeAudioWorkletNode.parameters.get(nm));
          }
        } else {
          for (const [nm, audioParam] of proxy.parameters.entries()) {
            await connectAudioParam2(nativeOfflineAudioContext, audioParam, nativeAudioWorkletNode.parameters.get(nm));
          }
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);
        return nativeAudioWorkletNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          deleteUnrenderedAudioWorkletNode2(nativeOfflineAudioContext, proxy);
          const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioWorkletNodeOrGainNode !== void 0) {
            return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js
  var createBaseAudioContextConstructor = (addAudioWorkletModule2, analyserNodeConstructor2, audioBufferConstructor2, audioBufferSourceNodeConstructor2, biquadFilterNodeConstructor2, channelMergerNodeConstructor2, channelSplitterNodeConstructor2, constantSourceNodeConstructor2, convolverNodeConstructor2, decodeAudioData2, delayNodeConstructor2, dynamicsCompressorNodeConstructor2, gainNodeConstructor2, iIRFilterNodeConstructor2, minimalBaseAudioContextConstructor2, oscillatorNodeConstructor2, pannerNodeConstructor2, periodicWaveConstructor2, stereoPannerNodeConstructor2, waveShaperNodeConstructor2) => {
    return class BaseAudioContext extends minimalBaseAudioContextConstructor2 {
      constructor(_nativeContext, numberOfChannels) {
        super(_nativeContext, numberOfChannels);
        this._nativeContext = _nativeContext;
        this._audioWorklet = addAudioWorkletModule2 === void 0 ? void 0 : {
          addModule: (moduleURL, options2) => {
            return addAudioWorkletModule2(this, moduleURL, options2);
          }
        };
      }
      get audioWorklet() {
        return this._audioWorklet;
      }
      createAnalyser() {
        return new analyserNodeConstructor2(this);
      }
      createBiquadFilter() {
        return new biquadFilterNodeConstructor2(this);
      }
      createBuffer(numberOfChannels, length, sampleRate) {
        return new audioBufferConstructor2({ length, numberOfChannels, sampleRate });
      }
      createBufferSource() {
        return new audioBufferSourceNodeConstructor2(this);
      }
      createChannelMerger(numberOfInputs = 6) {
        return new channelMergerNodeConstructor2(this, { numberOfInputs });
      }
      createChannelSplitter(numberOfOutputs = 6) {
        return new channelSplitterNodeConstructor2(this, { numberOfOutputs });
      }
      createConstantSource() {
        return new constantSourceNodeConstructor2(this);
      }
      createConvolver() {
        return new convolverNodeConstructor2(this);
      }
      createDelay(maxDelayTime = 1) {
        return new delayNodeConstructor2(this, { maxDelayTime });
      }
      createDynamicsCompressor() {
        return new dynamicsCompressorNodeConstructor2(this);
      }
      createGain() {
        return new gainNodeConstructor2(this);
      }
      createIIRFilter(feedforward, feedback) {
        return new iIRFilterNodeConstructor2(this, { feedback, feedforward });
      }
      createOscillator() {
        return new oscillatorNodeConstructor2(this);
      }
      createPanner() {
        return new pannerNodeConstructor2(this);
      }
      createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {
        return new periodicWaveConstructor2(this, { ...constraints, imag, real });
      }
      createStereoPanner() {
        return new stereoPannerNodeConstructor2(this);
      }
      createWaveShaper() {
        return new waveShaperNodeConstructor2(this);
      }
      decodeAudioData(audioData, successCallback, errorCallback) {
        return decodeAudioData2(this._nativeContext, audioData).then((audioBuffer) => {
          if (typeof successCallback === "function") {
            successCallback(audioBuffer);
          }
          return audioBuffer;
        }, (err) => {
          if (typeof errorCallback === "function") {
            errorCallback(err);
          }
          throw err;
        });
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js
  var DEFAULT_OPTIONS5 = {
    Q: 1,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    detune: 0,
    frequency: 350,
    gain: 0,
    type: "lowpass"
  };
  var createBiquadFilterNodeConstructor = (audioNodeConstructor2, createAudioParam2, createBiquadFilterNodeRenderer2, createInvalidAccessError2, createNativeBiquadFilterNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class BiquadFilterNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS5, ...options2 };
        const nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer2() : null;
        super(context2, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);
        this._Q = createAudioParam2(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._detune = createAudioParam2(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));
        this._frequency = createAudioParam2(this, isOffline, nativeBiquadFilterNode.frequency, context2.sampleRate / 2, 0);
        this._gain = createAudioParam2(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);
        this._nativeBiquadFilterNode = nativeBiquadFilterNode;
        setAudioNodeTailTime2(this, 1);
      }
      get detune() {
        return this._detune;
      }
      get frequency() {
        return this._frequency;
      }
      get gain() {
        return this._gain;
      }
      get Q() {
        return this._Q;
      }
      get type() {
        return this._nativeBiquadFilterNode.type;
      }
      set type(value) {
        this._nativeBiquadFilterNode.type = value;
      }
      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
        try {
          this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
        } catch (err) {
          if (err.code === 11) {
            throw createInvalidAccessError2();
          }
          throw err;
        }
        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
          throw createInvalidAccessError2();
        }
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js
  var createBiquadFilterNodeRendererFactory = (connectAudioParam2, createNativeBiquadFilterNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeBiquadFilterNodes = /* @__PURE__ */ new WeakMap();
      const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeBiquadFilterNode = getNativeAudioNode2(proxy);
        const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);
        if (!nativeBiquadFilterNodeIsOwnedByContext) {
          const options2 = {
            Q: nativeBiquadFilterNode.Q.value,
            channelCount: nativeBiquadFilterNode.channelCount,
            channelCountMode: nativeBiquadFilterNode.channelCountMode,
            channelInterpretation: nativeBiquadFilterNode.channelInterpretation,
            detune: nativeBiquadFilterNode.detune.value,
            frequency: nativeBiquadFilterNode.frequency.value,
            gain: nativeBiquadFilterNode.gain.value,
            type: nativeBiquadFilterNode.type
          };
          nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);
        if (!nativeBiquadFilterNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
          await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
          await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
          await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);
        return nativeBiquadFilterNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);
          if (renderedNativeBiquadFilterNode !== void 0) {
            return Promise.resolve(renderedNativeBiquadFilterNode);
          }
          return createBiquadFilterNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js
  var createCacheTestResult = (ongoingTests, testResults) => {
    return (tester, test) => {
      const cachedTestResult = testResults.get(tester);
      if (cachedTestResult !== void 0) {
        return cachedTestResult;
      }
      const ongoingTest = ongoingTests.get(tester);
      if (ongoingTest !== void 0) {
        return ongoingTest;
      }
      try {
        const synchronousTestResult = test();
        if (synchronousTestResult instanceof Promise) {
          ongoingTests.set(tester, synchronousTestResult);
          return synchronousTestResult.catch(() => false).then((finalTestResult) => {
            ongoingTests.delete(tester);
            testResults.set(tester, finalTestResult);
            return finalTestResult;
          });
        }
        testResults.set(tester, synchronousTestResult);
        return synchronousTestResult;
      } catch {
        testResults.set(tester, false);
        return false;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js
  var DEFAULT_OPTIONS6 = {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    numberOfInputs: 6
  };
  var createChannelMergerNodeConstructor = (audioNodeConstructor2, createChannelMergerNodeRenderer2, createNativeChannelMergerNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class ChannelMergerNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS6, ...options2 };
        const nativeChannelMergerNode = createNativeChannelMergerNode2(nativeContext, mergedOptions);
        const channelMergerNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelMergerNodeRenderer2() : null;
        super(context2, false, nativeChannelMergerNode, channelMergerNodeRenderer);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js
  var createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioNode = getNativeAudioNode2(proxy);
        const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
        if (!nativeAudioNodeIsOwnedByContext) {
          const options2 = {
            channelCount: nativeAudioNode.channelCount,
            channelCountMode: nativeAudioNode.channelCountMode,
            channelInterpretation: nativeAudioNode.channelInterpretation,
            numberOfInputs: nativeAudioNode.numberOfInputs
          };
          nativeAudioNode = createNativeChannelMergerNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
        return nativeAudioNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioNode !== void 0) {
            return Promise.resolve(renderedNativeAudioNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js
  var DEFAULT_OPTIONS7 = {
    channelCount: 6,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    numberOfOutputs: 6
  };
  var createChannelSplitterNodeConstructor = (audioNodeConstructor2, createChannelSplitterNodeRenderer2, createNativeChannelSplitterNode2, getNativeContext2, isNativeOfflineAudioContext2, sanitizeChannelSplitterOptions2) => {
    return class ChannelSplitterNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = sanitizeChannelSplitterOptions2({ ...DEFAULT_OPTIONS7, ...options2 });
        const nativeChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, mergedOptions);
        const channelSplitterNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelSplitterNodeRenderer2() : null;
        super(context2, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js
  var createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioNode = getNativeAudioNode2(proxy);
        const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
        if (!nativeAudioNodeIsOwnedByContext) {
          const options2 = {
            channelCount: nativeAudioNode.channelCount,
            channelCountMode: nativeAudioNode.channelCountMode,
            channelInterpretation: nativeAudioNode.channelInterpretation,
            numberOfOutputs: nativeAudioNode.numberOfOutputs
          };
          nativeAudioNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
        return nativeAudioNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioNode !== void 0) {
            return Promise.resolve(renderedNativeAudioNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js
  var createConnectAudioParam = (renderInputsOfAudioParam2) => {
    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
      return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js
  var createConnectMultipleOutputs = (createIndexSizeError2) => {
    return (outputAudioNodes, destination, output = 0, input2 = 0) => {
      const outputAudioNode = outputAudioNodes[output];
      if (outputAudioNode === void 0) {
        throw createIndexSizeError2();
      }
      if (isNativeAudioNode(destination)) {
        return outputAudioNode.connect(destination, 0, input2);
      }
      return outputAudioNode.connect(destination, 0);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js
  var createConnectedNativeAudioBufferSourceNodeFactory = (createNativeAudioBufferSourceNode2) => {
    return (nativeContext, nativeAudioNode) => {
      const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
        buffer: null,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        loop: false,
        loopEnd: 0,
        loopStart: 0,
        playbackRate: 1
      });
      const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);
      nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
      nativeAudioBufferSourceNode.loop = true;
      nativeAudioBufferSourceNode.connect(nativeAudioNode);
      nativeAudioBufferSourceNode.start();
      return () => {
        nativeAudioBufferSourceNode.stop();
        nativeAudioBufferSourceNode.disconnect(nativeAudioNode);
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js
  var DEFAULT_OPTIONS8 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    offset: 1
  };
  var createConstantSourceNodeConstructor = (audioNodeConstructor2, createAudioParam2, createConstantSourceNodeRendererFactory2, createNativeConstantSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
    return class ConstantSourceNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS8, ...options2 };
        const nativeConstantSourceNode = createNativeConstantSourceNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory2() : null;
        super(context2, false, nativeConstantSourceNode, constantSourceNodeRenderer);
        this._constantSourceNodeRenderer = constantSourceNodeRenderer;
        this._nativeConstantSourceNode = nativeConstantSourceNode;
        this._offset = createAudioParam2(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._onended = null;
      }
      get offset() {
        return this._offset;
      }
      get onended() {
        return this._onended;
      }
      set onended(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeConstantSourceNode.onended = wrappedListener;
        const nativeOnEnded = this._nativeConstantSourceNode.onended;
        this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
      }
      start(when = 0) {
        this._nativeConstantSourceNode.start(when);
        if (this._constantSourceNodeRenderer !== null) {
          this._constantSourceNodeRenderer.start = when;
        }
        if (this.context.state !== "closed") {
          setInternalStateToActive(this);
          const resetInternalStateToPassive = () => {
            this._nativeConstantSourceNode.removeEventListener("ended", resetInternalStateToPassive);
            if (isActiveAudioNode(this)) {
              setInternalStateToPassive(this);
            }
          };
          this._nativeConstantSourceNode.addEventListener("ended", resetInternalStateToPassive);
        }
      }
      stop(when = 0) {
        this._nativeConstantSourceNode.stop(when);
        if (this._constantSourceNodeRenderer !== null) {
          this._constantSourceNodeRenderer.stop = when;
        }
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js
  var createConstantSourceNodeRendererFactory = (connectAudioParam2, createNativeConstantSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeConstantSourceNodes = /* @__PURE__ */ new WeakMap();
      let start3 = null;
      let stop2 = null;
      const createConstantSourceNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeConstantSourceNode = getNativeAudioNode2(proxy);
        const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);
        if (!nativeConstantSourceNodeIsOwnedByContext) {
          const options2 = {
            channelCount: nativeConstantSourceNode.channelCount,
            channelCountMode: nativeConstantSourceNode.channelCountMode,
            channelInterpretation: nativeConstantSourceNode.channelInterpretation,
            offset: nativeConstantSourceNode.offset.value
          };
          nativeConstantSourceNode = createNativeConstantSourceNode2(nativeOfflineAudioContext, options2);
          if (start3 !== null) {
            nativeConstantSourceNode.start(start3);
          }
          if (stop2 !== null) {
            nativeConstantSourceNode.stop(stop2);
          }
        }
        renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);
        if (!nativeConstantSourceNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);
        return nativeConstantSourceNode;
      };
      return {
        set start(value) {
          start3 = value;
        },
        set stop(value) {
          stop2 = value;
        },
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);
          if (renderedNativeConstantSourceNode !== void 0) {
            return Promise.resolve(renderedNativeConstantSourceNode);
          }
          return createConstantSourceNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js
  var createConvertNumberToUnsignedLong = (unit32Array) => {
    return (value) => {
      unit32Array[0] = value;
      return unit32Array[0];
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js
  var DEFAULT_OPTIONS9 = {
    buffer: null,
    channelCount: 2,
    channelCountMode: "clamped-max",
    channelInterpretation: "speakers",
    disableNormalization: false
  };
  var createConvolverNodeConstructor = (audioNodeConstructor2, createConvolverNodeRenderer2, createNativeConvolverNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class ConvolverNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS9, ...options2 };
        const nativeConvolverNode = createNativeConvolverNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const convolverNodeRenderer = isOffline ? createConvolverNodeRenderer2() : null;
        super(context2, false, nativeConvolverNode, convolverNodeRenderer);
        this._isBufferNullified = false;
        this._nativeConvolverNode = nativeConvolverNode;
        if (mergedOptions.buffer !== null) {
          setAudioNodeTailTime2(this, mergedOptions.buffer.duration);
        }
      }
      get buffer() {
        if (this._isBufferNullified) {
          return null;
        }
        return this._nativeConvolverNode.buffer;
      }
      set buffer(value) {
        this._nativeConvolverNode.buffer = value;
        if (value === null && this._nativeConvolverNode.buffer !== null) {
          const nativeContext = this._nativeConvolverNode.context;
          this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, 44100);
          this._isBufferNullified = true;
          setAudioNodeTailTime2(this, 0);
        } else {
          this._isBufferNullified = false;
          setAudioNodeTailTime2(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
        }
      }
      get normalize() {
        return this._nativeConvolverNode.normalize;
      }
      set normalize(value) {
        this._nativeConvolverNode.normalize = value;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js
  var createConvolverNodeRendererFactory = (createNativeConvolverNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeConvolverNodes = /* @__PURE__ */ new WeakMap();
      const createConvolverNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeConvolverNode = getNativeAudioNode2(proxy);
        const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);
        if (!nativeConvolverNodeIsOwnedByContext) {
          const options2 = {
            buffer: nativeConvolverNode.buffer,
            channelCount: nativeConvolverNode.channelCount,
            channelCountMode: nativeConvolverNode.channelCountMode,
            channelInterpretation: nativeConvolverNode.channelInterpretation,
            disableNormalization: !nativeConvolverNode.normalize
          };
          nativeConvolverNode = createNativeConvolverNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);
        if (isNativeAudioNodeFaker(nativeConvolverNode)) {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);
        } else {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode);
        }
        return nativeConvolverNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);
          if (renderedNativeConvolverNode !== void 0) {
            return Promise.resolve(renderedNativeConvolverNode);
          }
          return createConvolverNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js
  var createCreateNativeOfflineAudioContext = (createNotSupportedError2, nativeOfflineAudioContextConstructor2) => {
    return (numberOfChannels, length, sampleRate) => {
      if (nativeOfflineAudioContextConstructor2 === null) {
        throw new Error("Missing the native OfflineAudioContext constructor.");
      }
      try {
        return new nativeOfflineAudioContextConstructor2(numberOfChannels, length, sampleRate);
      } catch (err) {
        if (err.name === "SyntaxError") {
          throw createNotSupportedError2();
        }
        throw err;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js
  var createDataCloneError = () => new DOMException("", "DataCloneError");

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js
  var detachArrayBuffer = (arrayBuffer) => {
    const { port1, port2 } = new MessageChannel();
    return new Promise((resolve2) => {
      const closeAndResolve = () => {
        port2.onmessage = null;
        port1.close();
        port2.close();
        resolve2();
      };
      port2.onmessage = () => closeAndResolve();
      try {
        port1.postMessage(arrayBuffer, [arrayBuffer]);
      } finally {
        closeAndResolve();
      }
    });
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js
  var createDecodeAudioData = (audioBufferStore2, cacheTestResult2, createDataCloneError2, createEncodingError2, detachedArrayBuffers, getNativeContext2, isNativeContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, testPromiseSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
    return (anyContext, audioData) => {
      const nativeContext = isNativeContext2(anyContext) ? anyContext : getNativeContext2(anyContext);
      if (detachedArrayBuffers.has(audioData)) {
        const err = createDataCloneError2();
        return Promise.reject(err);
      }
      try {
        detachedArrayBuffers.add(audioData);
      } catch {
      }
      if (cacheTestResult2(testPromiseSupport2, () => testPromiseSupport2(nativeContext))) {
        return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {
          detachArrayBuffer(audioData).catch(() => {
          });
          if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
            wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
          }
          audioBufferStore2.add(audioBuffer);
          return audioBuffer;
        });
      }
      return new Promise((resolve2, reject) => {
        const complete = async () => {
          try {
            await detachArrayBuffer(audioData);
          } catch {
          }
        };
        const fail = (err) => {
          reject(err);
          complete();
        };
        try {
          nativeContext.decodeAudioData(audioData, (audioBuffer) => {
            if (typeof audioBuffer.copyFromChannel !== "function") {
              wrapAudioBufferCopyChannelMethods2(audioBuffer);
              wrapAudioBufferGetChannelDataMethod(audioBuffer);
            }
            audioBufferStore2.add(audioBuffer);
            complete().then(() => resolve2(audioBuffer));
          }, (err) => {
            if (err === null) {
              fail(createEncodingError2());
            } else {
              fail(err);
            }
          });
        } catch (err) {
          fail(err);
        }
      });
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js
  var createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode2, cycleCounters, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, getNativeContext2, isActiveAudioNode2, isNativeOfflineAudioContext2) => {
    return (audioNode, count) => {
      const cycleCounter = cycleCounters.get(audioNode);
      if (cycleCounter === void 0) {
        throw new Error("Missing the expected cycle count.");
      }
      const nativeContext = getNativeContext2(audioNode.context);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      if (cycleCounter === count) {
        cycleCounters.delete(audioNode);
        if (!isOffline && isActiveAudioNode2(audioNode)) {
          const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
          const { outputs } = getAudioNodeConnections2(audioNode);
          for (const output of outputs) {
            if (isAudioNodeOutputConnection(output)) {
              const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);
              connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
            } else {
              const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);
              nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);
            }
          }
        }
      } else {
        cycleCounters.set(audioNode, cycleCounter - count);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js
  var DEFAULT_OPTIONS10 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    delayTime: 0,
    maxDelayTime: 1
  };
  var createDelayNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDelayNodeRenderer2, createNativeDelayNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class DelayNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS10, ...options2 };
        const nativeDelayNode = createNativeDelayNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const delayNodeRenderer = isOffline ? createDelayNodeRenderer2(mergedOptions.maxDelayTime) : null;
        super(context2, false, nativeDelayNode, delayNodeRenderer);
        this._delayTime = createAudioParam2(this, isOffline, nativeDelayNode.delayTime);
        setAudioNodeTailTime2(this, mergedOptions.maxDelayTime);
      }
      get delayTime() {
        return this._delayTime;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js
  var createDelayNodeRendererFactory = (connectAudioParam2, createNativeDelayNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return (maxDelayTime) => {
      const renderedNativeDelayNodes = /* @__PURE__ */ new WeakMap();
      const createDelayNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeDelayNode = getNativeAudioNode2(proxy);
        const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);
        if (!nativeDelayNodeIsOwnedByContext) {
          const options2 = {
            channelCount: nativeDelayNode.channelCount,
            channelCountMode: nativeDelayNode.channelCountMode,
            channelInterpretation: nativeDelayNode.channelInterpretation,
            delayTime: nativeDelayNode.delayTime.value,
            maxDelayTime
          };
          nativeDelayNode = createNativeDelayNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);
        if (!nativeDelayNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDelayNode);
        return nativeDelayNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);
          if (renderedNativeDelayNode !== void 0) {
            return Promise.resolve(renderedNativeDelayNode);
          }
          return createDelayNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/delete-active-input-connection-to-audio-node.js
  var createDeleteActiveInputConnectionToAudioNode = (pickElementFromSet2) => {
    return (activeInputs, source, output, input2) => {
      return pickElementFromSet2(activeInputs[input2], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js
  var createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
    return (nativeContext, audioWorkletNode) => {
      getUnrenderedAudioWorkletNodes2(nativeContext).delete(audioWorkletNode);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/guards/delay-node.js
  var isDelayNode = (audioNode) => {
    return "delayTime" in audioNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js
  var createDetectCycles = (audioParamAudioNodeStore2, getAudioNodeConnections2, getValueForKey2) => {
    return function detectCycles(chain2, nextLink) {
      const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey2(audioParamAudioNodeStore2, nextLink);
      if (isDelayNode(audioNode)) {
        return [];
      }
      if (chain2[0] === audioNode) {
        return [chain2];
      }
      if (chain2.includes(audioNode)) {
        return [];
      }
      const { outputs } = getAudioNodeConnections2(audioNode);
      return Array.from(outputs).map((outputConnection) => detectCycles([...chain2, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js
  var getOutputAudioNodeAtIndex = (createIndexSizeError2, outputAudioNodes, output) => {
    const outputAudioNode = outputAudioNodes[output];
    if (outputAudioNode === void 0) {
      throw createIndexSizeError2();
    }
    return outputAudioNode;
  };
  var createDisconnectMultipleOutputs = (createIndexSizeError2) => {
    return (outputAudioNodes, destinationOrOutput = void 0, output = void 0, input2 = 0) => {
      if (destinationOrOutput === void 0) {
        return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());
      }
      if (typeof destinationOrOutput === "number") {
        return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, destinationOrOutput).disconnect();
      }
      if (isNativeAudioNode(destinationOrOutput)) {
        if (output === void 0) {
          return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
        }
        if (input2 === void 0) {
          return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
        }
        return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input2);
      }
      if (output === void 0) {
        return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
      }
      return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js
  var DEFAULT_OPTIONS11 = {
    attack: 3e-3,
    channelCount: 2,
    channelCountMode: "clamped-max",
    channelInterpretation: "speakers",
    knee: 30,
    ratio: 12,
    release: 0.25,
    threshold: -24
  };
  var createDynamicsCompressorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDynamicsCompressorNodeRenderer2, createNativeDynamicsCompressorNode2, createNotSupportedError2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class DynamicsCompressorNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS11, ...options2 };
        const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer2() : null;
        super(context2, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);
        this._attack = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.attack);
        this._knee = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.knee);
        this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;
        this._ratio = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.ratio);
        this._release = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.release);
        this._threshold = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.threshold);
        setAudioNodeTailTime2(this, 6e-3);
      }
      get attack() {
        return this._attack;
      }
      get channelCount() {
        return this._nativeDynamicsCompressorNode.channelCount;
      }
      set channelCount(value) {
        const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;
        this._nativeDynamicsCompressorNode.channelCount = value;
        if (value > 2) {
          this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;
          throw createNotSupportedError2();
        }
      }
      get channelCountMode() {
        return this._nativeDynamicsCompressorNode.channelCountMode;
      }
      set channelCountMode(value) {
        const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;
        this._nativeDynamicsCompressorNode.channelCountMode = value;
        if (value === "max") {
          this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;
          throw createNotSupportedError2();
        }
      }
      get knee() {
        return this._knee;
      }
      get ratio() {
        return this._ratio;
      }
      get reduction() {
        if (typeof this._nativeDynamicsCompressorNode.reduction.value === "number") {
          return this._nativeDynamicsCompressorNode.reduction.value;
        }
        return this._nativeDynamicsCompressorNode.reduction;
      }
      get release() {
        return this._release;
      }
      get threshold() {
        return this._threshold;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js
  var createDynamicsCompressorNodeRendererFactory = (connectAudioParam2, createNativeDynamicsCompressorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeDynamicsCompressorNodes = /* @__PURE__ */ new WeakMap();
      const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeDynamicsCompressorNode = getNativeAudioNode2(proxy);
        const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);
        if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
          const options2 = {
            attack: nativeDynamicsCompressorNode.attack.value,
            channelCount: nativeDynamicsCompressorNode.channelCount,
            channelCountMode: nativeDynamicsCompressorNode.channelCountMode,
            channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,
            knee: nativeDynamicsCompressorNode.knee.value,
            ratio: nativeDynamicsCompressorNode.ratio.value,
            release: nativeDynamicsCompressorNode.release.value,
            threshold: nativeDynamicsCompressorNode.threshold.value
          };
          nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);
        if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
          await renderAutomation2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
          await renderAutomation2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
          await renderAutomation2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
          await renderAutomation2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);
        return nativeDynamicsCompressorNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);
          if (renderedNativeDynamicsCompressorNode !== void 0) {
            return Promise.resolve(renderedNativeDynamicsCompressorNode);
          }
          return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js
  var createEncodingError = () => new DOMException("", "EncodingError");

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js
  var createEvaluateSource = (window3) => {
    return (source) => new Promise((resolve2, reject) => {
      if (window3 === null) {
        reject(new SyntaxError());
        return;
      }
      const head = window3.document.head;
      if (head === null) {
        reject(new SyntaxError());
      } else {
        const script = window3.document.createElement("script");
        const blob = new Blob([source], { type: "application/javascript" });
        const url = URL.createObjectURL(blob);
        const originalOnErrorHandler = window3.onerror;
        const removeErrorEventListenerAndRevokeUrl = () => {
          window3.onerror = originalOnErrorHandler;
          URL.revokeObjectURL(url);
        };
        window3.onerror = (message, src, lineno, colno, error) => {
          if (src === url || src === window3.location.href && lineno === 1 && colno === 1) {
            removeErrorEventListenerAndRevokeUrl();
            reject(error);
            return false;
          }
          if (originalOnErrorHandler !== null) {
            return originalOnErrorHandler(message, src, lineno, colno, error);
          }
        };
        script.onerror = () => {
          removeErrorEventListenerAndRevokeUrl();
          reject(new SyntaxError());
        };
        script.onload = () => {
          removeErrorEventListenerAndRevokeUrl();
          resolve2();
        };
        script.src = url;
        script.type = "module";
        head.appendChild(script);
      }
    });
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js
  var createEventTargetConstructor = (wrapEventListener2) => {
    return class EventTarget {
      constructor(_nativeEventTarget) {
        this._nativeEventTarget = _nativeEventTarget;
        this._listeners = /* @__PURE__ */ new WeakMap();
      }
      addEventListener(type, listener, options2) {
        if (listener !== null) {
          let wrappedEventListener = this._listeners.get(listener);
          if (wrappedEventListener === void 0) {
            wrappedEventListener = wrapEventListener2(this, listener);
            if (typeof listener === "function") {
              this._listeners.set(listener, wrappedEventListener);
            }
          }
          this._nativeEventTarget.addEventListener(type, wrappedEventListener, options2);
        }
      }
      dispatchEvent(event) {
        return this._nativeEventTarget.dispatchEvent(event);
      }
      removeEventListener(type, listener, options2) {
        const wrappedEventListener = listener === null ? void 0 : this._listeners.get(listener);
        this._nativeEventTarget.removeEventListener(type, wrappedEventListener === void 0 ? null : wrappedEventListener, options2);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js
  var createExposeCurrentFrameAndCurrentTime = (window3) => {
    return (currentTime, sampleRate, fn) => {
      Object.defineProperties(window3, {
        currentFrame: {
          configurable: true,
          get() {
            return Math.round(currentTime * sampleRate);
          }
        },
        currentTime: {
          configurable: true,
          get() {
            return currentTime;
          }
        }
      });
      try {
        return fn();
      } finally {
        if (window3 !== null) {
          delete window3.currentFrame;
          delete window3.currentTime;
        }
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js
  var createFetchSource = (createAbortError2) => {
    return async (url) => {
      try {
        const response = await fetch(url);
        if (response.ok) {
          return [await response.text(), response.url];
        }
      } catch {
      }
      throw createAbortError2();
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js
  var DEFAULT_OPTIONS12 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    gain: 1
  };
  var createGainNodeConstructor = (audioNodeConstructor2, createAudioParam2, createGainNodeRenderer2, createNativeGainNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class GainNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS12, ...options2 };
        const nativeGainNode = createNativeGainNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const gainNodeRenderer = isOffline ? createGainNodeRenderer2() : null;
        super(context2, false, nativeGainNode, gainNodeRenderer);
        this._gain = createAudioParam2(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      }
      get gain() {
        return this._gain;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js
  var createGainNodeRendererFactory = (connectAudioParam2, createNativeGainNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeGainNodes = /* @__PURE__ */ new WeakMap();
      const createGainNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeGainNode = getNativeAudioNode2(proxy);
        const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);
        if (!nativeGainNodeIsOwnedByContext) {
          const options2 = {
            channelCount: nativeGainNode.channelCount,
            channelCountMode: nativeGainNode.channelCountMode,
            channelInterpretation: nativeGainNode.channelInterpretation,
            gain: nativeGainNode.gain.value
          };
          nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);
        if (!nativeGainNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeGainNode);
        return nativeGainNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);
          if (renderedNativeGainNode !== void 0) {
            return Promise.resolve(renderedNativeGainNode);
          }
          return createGainNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/get-active-audio-worklet-node-inputs.js
  var createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2, getValueForKey2) => {
    return (nativeAudioWorkletNode) => getValueForKey2(activeAudioWorkletNodeInputsStore2, nativeAudioWorkletNode);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js
  var createGetAudioNodeRenderer = (getAudioNodeConnections2) => {
    return (audioNode) => {
      const audioNodeConnections = getAudioNodeConnections2(audioNode);
      if (audioNodeConnections.renderer === null) {
        throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
      }
      return audioNodeConnections.renderer;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-tail-time.js
  var createGetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
    return (audioNode) => {
      var _a3;
      return (_a3 = audioNodeTailTimeStore2.get(audioNode)) !== null && _a3 !== void 0 ? _a3 : 0;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js
  var createGetAudioParamRenderer = (getAudioParamConnections2) => {
    return (audioParam) => {
      const audioParamConnections = getAudioParamConnections2(audioParam);
      if (audioParamConnections.renderer === null) {
        throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
      }
      return audioParamConnections.renderer;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/get-backup-offline-audio-context.js
  var createGetBackupOfflineAudioContext = (backupOfflineAudioContextStore2) => {
    return (nativeContext) => {
      return backupOfflineAudioContextStore2.get(nativeContext);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js
  var createInvalidStateError = () => new DOMException("", "InvalidStateError");

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js
  var createGetNativeContext = (contextStore) => {
    return (context2) => {
      const nativeContext = contextStore.get(context2);
      if (nativeContext === void 0) {
        throw createInvalidStateError();
      }
      return nativeContext;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/get-or-create-backup-offline-audio-context.js
  var createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore2, nativeOfflineAudioContextConstructor2) => {
    return (nativeContext) => {
      let backupOfflineAudioContext = backupOfflineAudioContextStore2.get(nativeContext);
      if (backupOfflineAudioContext !== void 0) {
        return backupOfflineAudioContext;
      }
      if (nativeOfflineAudioContextConstructor2 === null) {
        throw new Error("Missing the native OfflineAudioContext constructor.");
      }
      backupOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
      backupOfflineAudioContextStore2.set(nativeContext, backupOfflineAudioContext);
      return backupOfflineAudioContext;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js
  var createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore2) => {
    return (nativeContext) => {
      const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore2.get(nativeContext);
      if (unrenderedAudioWorkletNodes === void 0) {
        throw new Error("The context has no set of AudioWorkletNodes.");
      }
      return unrenderedAudioWorkletNodes;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js
  var createInvalidAccessError = () => new DOMException("", "InvalidAccessError");

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js
  var wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {
    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {
      return (frequencyHz, magResponse, phaseResponse) => {
        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
          throw createInvalidAccessError();
        }
        return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);
      };
    })(nativeIIRFilterNode.getFrequencyResponse);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js
  var DEFAULT_OPTIONS13 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers"
  };
  var createIIRFilterNodeConstructor = (audioNodeConstructor2, createNativeIIRFilterNode2, createIIRFilterNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class IIRFilterNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const mergedOptions = { ...DEFAULT_OPTIONS13, ...options2 };
        const nativeIIRFilterNode = createNativeIIRFilterNode2(nativeContext, isOffline ? null : context2.baseLatency, mergedOptions);
        const iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer2(mergedOptions.feedback, mergedOptions.feedforward) : null;
        super(context2, false, nativeIIRFilterNode, iirFilterNodeRenderer);
        wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);
        this._nativeIIRFilterNode = nativeIIRFilterNode;
        setAudioNodeTailTime2(this, 1);
      }
      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
        return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js
  var filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input2, output) => {
    const inputLength = input2.length;
    let i8 = bufferIndex;
    for (let j2 = 0; j2 < inputLength; j2 += 1) {
      let y3 = feedforward[0] * input2[j2];
      for (let k2 = 1; k2 < minLength; k2 += 1) {
        const x4 = i8 - k2 & bufferLength - 1;
        y3 += feedforward[k2] * xBuffer[x4];
        y3 -= feedback[k2] * yBuffer[x4];
      }
      for (let k2 = minLength; k2 < feedforwardLength; k2 += 1) {
        y3 += feedforward[k2] * xBuffer[i8 - k2 & bufferLength - 1];
      }
      for (let k2 = minLength; k2 < feedbackLength; k2 += 1) {
        y3 -= feedback[k2] * yBuffer[i8 - k2 & bufferLength - 1];
      }
      xBuffer[i8] = input2[j2];
      yBuffer[i8] = y3;
      i8 = i8 + 1 & bufferLength - 1;
      output[j2] = y3;
    }
    return i8;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js
  var filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {
    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
    const feedbackLength = convertedFeedback.length;
    const feedforwardLength = convertedFeedforward.length;
    const minLength = Math.min(feedbackLength, feedforwardLength);
    if (convertedFeedback[0] !== 1) {
      for (let i8 = 0; i8 < feedbackLength; i8 += 1) {
        convertedFeedforward[i8] /= convertedFeedback[0];
      }
      for (let i8 = 1; i8 < feedforwardLength; i8 += 1) {
        convertedFeedback[i8] /= convertedFeedback[0];
      }
    }
    const bufferLength = 32;
    const xBuffer = new Float32Array(bufferLength);
    const yBuffer = new Float32Array(bufferLength);
    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
    const numberOfChannels = renderedBuffer.numberOfChannels;
    for (let i8 = 0; i8 < numberOfChannels; i8 += 1) {
      const input2 = renderedBuffer.getChannelData(i8);
      const output = filteredBuffer.getChannelData(i8);
      xBuffer.fill(0);
      yBuffer.fill(0);
      filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input2, output);
    }
    return filteredBuffer;
  };
  var createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
    return (feedback, feedforward) => {
      const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
      let filteredBufferPromise = null;
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioBufferSourceNode = null;
        let nativeIIRFilterNode = getNativeAudioNode2(proxy);
        const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);
        if (nativeOfflineAudioContext.createIIRFilter === void 0) {
          nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
            buffer: null,
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            loop: false,
            loopEnd: 0,
            loopStart: 0,
            playbackRate: 1
          });
        } else if (!nativeIIRFilterNodeIsOwnedByContext) {
          nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);
        if (nativeAudioBufferSourceNode !== null) {
          if (filteredBufferPromise === null) {
            if (nativeOfflineAudioContextConstructor2 === null) {
              throw new Error("Missing the native OfflineAudioContext constructor.");
            }
            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(proxy.context.destination.channelCount, proxy.context.length, nativeOfflineAudioContext.sampleRate);
            filteredBufferPromise = (async () => {
              await renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);
              const renderedBuffer = await renderNativeOfflineAudioContext2(partialOfflineAudioContext);
              return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);
            })();
          }
          const filteredBuffer = await filteredBufferPromise;
          nativeAudioBufferSourceNode.buffer = filteredBuffer;
          nativeAudioBufferSourceNode.start(0);
          return nativeAudioBufferSourceNode;
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);
        return nativeIIRFilterNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioNode !== void 0) {
            return Promise.resolve(renderedNativeAudioNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js
  var createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, isActiveAudioNode2) => {
    return (isOffline) => {
      return (audioNode, count) => {
        const cycleCounter = cycleCounters.get(audioNode);
        if (cycleCounter === void 0) {
          if (!isOffline && isActiveAudioNode2(audioNode)) {
            const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
            const { outputs } = getAudioNodeConnections2(audioNode);
            for (const output of outputs) {
              if (isAudioNodeOutputConnection(output)) {
                const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);
                disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
              } else {
                const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);
                nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);
              }
            }
          }
          cycleCounters.set(audioNode, count);
        } else {
          cycleCounters.set(audioNode, cycleCounter + count);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js
  var createIsAnyAudioContext = (contextStore, isNativeAudioContext2) => {
    return (anything) => {
      const nativeContext = contextStore.get(anything);
      return isNativeAudioContext2(nativeContext) || isNativeAudioContext2(anything);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js
  var createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode3) => {
    return (anything) => audioNodeStore.has(anything) || isNativeAudioNode3(anything);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js
  var createIsAnyAudioParam = (audioParamStore, isNativeAudioParam2) => {
    return (anything) => audioParamStore.has(anything) || isNativeAudioParam2(anything);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js
  var createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext2) => {
    return (anything) => {
      const nativeContext = contextStore.get(anything);
      return isNativeOfflineAudioContext2(nativeContext) || isNativeOfflineAudioContext2(anything);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js
  var createIsNativeAudioContext = (nativeAudioContextConstructor2) => {
    return (anything) => {
      return nativeAudioContextConstructor2 !== null && anything instanceof nativeAudioContextConstructor2;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js
  var createIsNativeAudioNode = (window3) => {
    return (anything) => {
      return window3 !== null && typeof window3.AudioNode === "function" && anything instanceof window3.AudioNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js
  var createIsNativeAudioParam = (window3) => {
    return (anything) => {
      return window3 !== null && typeof window3.AudioParam === "function" && anything instanceof window3.AudioParam;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js
  var createIsNativeContext = (isNativeAudioContext2, isNativeOfflineAudioContext2) => {
    return (anything) => {
      return isNativeAudioContext2(anything) || isNativeOfflineAudioContext2(anything);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js
  var createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor2) => {
    return (anything) => {
      return nativeOfflineAudioContextConstructor2 !== null && anything instanceof nativeOfflineAudioContextConstructor2;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js
  var createIsSecureContext = (window3) => window3 !== null && window3.isSecureContext;

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js
  var createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaElementAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class MediaElementAudioSourceNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode2(nativeContext, options2);
        if (isNativeOfflineAudioContext2(nativeContext)) {
          throw TypeError();
        }
        super(context2, true, nativeMediaElementAudioSourceNode, null);
        this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;
      }
      get mediaElement() {
        return this._nativeMediaElementAudioSourceNode.mediaElement;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js
  var DEFAULT_OPTIONS14 = {
    channelCount: 2,
    channelCountMode: "explicit",
    channelInterpretation: "speakers"
  };
  var createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioDestinationNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class MediaStreamAudioDestinationNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        if (isNativeOfflineAudioContext2(nativeContext)) {
          throw new TypeError();
        }
        const mergedOptions = { ...DEFAULT_OPTIONS14, ...options2 };
        const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode2(nativeContext, mergedOptions);
        super(context2, false, nativeMediaStreamAudioDestinationNode, null);
        this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;
      }
      get stream() {
        return this._nativeMediaStreamAudioDestinationNode.stream;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js
  var createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class MediaStreamAudioSourceNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode2(nativeContext, options2);
        if (isNativeOfflineAudioContext2(nativeContext)) {
          throw new TypeError();
        }
        super(context2, true, nativeMediaStreamAudioSourceNode, null);
        this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;
      }
      get mediaStream() {
        return this._nativeMediaStreamAudioSourceNode.mediaStream;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js
  var createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamTrackAudioSourceNode2, getNativeContext2) => {
    return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode2(nativeContext, options2);
        super(context2, true, nativeMediaStreamTrackAudioSourceNode, null);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js
  var createMinimalAudioContextConstructor = (createInvalidStateError2, createNotSupportedError2, createUnknownError2, minimalBaseAudioContextConstructor2, nativeAudioContextConstructor2) => {
    return class MinimalAudioContext extends minimalBaseAudioContextConstructor2 {
      constructor(options2 = {}) {
        if (nativeAudioContextConstructor2 === null) {
          throw new Error("Missing the native AudioContext constructor.");
        }
        let nativeAudioContext;
        try {
          nativeAudioContext = new nativeAudioContextConstructor2(options2);
        } catch (err) {
          if (err.code === 12 && err.message === "sampleRate is not in range") {
            throw createNotSupportedError2();
          }
          throw err;
        }
        if (nativeAudioContext === null) {
          throw createUnknownError2();
        }
        if (!isValidLatencyHint(options2.latencyHint)) {
          throw new TypeError(`The provided value '${options2.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
        }
        if (options2.sampleRate !== void 0 && nativeAudioContext.sampleRate !== options2.sampleRate) {
          throw createNotSupportedError2();
        }
        super(nativeAudioContext, 2);
        const { latencyHint } = options2;
        const { sampleRate } = nativeAudioContext;
        this._baseLatency = typeof nativeAudioContext.baseLatency === "number" ? nativeAudioContext.baseLatency : latencyHint === "balanced" ? 512 / sampleRate : latencyHint === "interactive" || latencyHint === void 0 ? 256 / sampleRate : latencyHint === "playback" ? 1024 / sampleRate : Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;
        this._nativeAudioContext = nativeAudioContext;
        if (nativeAudioContextConstructor2.name === "webkitAudioContext") {
          this._nativeGainNode = nativeAudioContext.createGain();
          this._nativeOscillatorNode = nativeAudioContext.createOscillator();
          this._nativeGainNode.gain.value = 1e-37;
          this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);
          this._nativeOscillatorNode.start();
        } else {
          this._nativeGainNode = null;
          this._nativeOscillatorNode = null;
        }
        this._state = null;
        if (nativeAudioContext.state === "running") {
          this._state = "suspended";
          const revokeState = () => {
            if (this._state === "suspended") {
              this._state = null;
            }
            nativeAudioContext.removeEventListener("statechange", revokeState);
          };
          nativeAudioContext.addEventListener("statechange", revokeState);
        }
      }
      get baseLatency() {
        return this._baseLatency;
      }
      get state() {
        return this._state !== null ? this._state : this._nativeAudioContext.state;
      }
      close() {
        if (this.state === "closed") {
          return this._nativeAudioContext.close().then(() => {
            throw createInvalidStateError2();
          });
        }
        if (this._state === "suspended") {
          this._state = null;
        }
        return this._nativeAudioContext.close().then(() => {
          if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
            this._nativeOscillatorNode.stop();
            this._nativeGainNode.disconnect();
            this._nativeOscillatorNode.disconnect();
          }
          deactivateAudioGraph(this);
        });
      }
      resume() {
        if (this._state === "suspended") {
          return new Promise((resolve2, reject) => {
            const resolvePromise = () => {
              this._nativeAudioContext.removeEventListener("statechange", resolvePromise);
              if (this._nativeAudioContext.state === "running") {
                resolve2();
              } else {
                this.resume().then(resolve2, reject);
              }
            };
            this._nativeAudioContext.addEventListener("statechange", resolvePromise);
          });
        }
        return this._nativeAudioContext.resume().catch((err) => {
          if (err === void 0 || err.code === 15) {
            throw createInvalidStateError2();
          }
          throw err;
        });
      }
      suspend() {
        return this._nativeAudioContext.suspend().catch((err) => {
          if (err === void 0) {
            throw createInvalidStateError2();
          }
          throw err;
        });
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js
  var createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor2, createAudioListener2, eventTargetConstructor2, isNativeOfflineAudioContext2, unrenderedAudioWorkletNodeStore2, wrapEventListener2) => {
    return class MinimalBaseAudioContext extends eventTargetConstructor2 {
      constructor(_nativeContext, numberOfChannels) {
        super(_nativeContext);
        this._nativeContext = _nativeContext;
        CONTEXT_STORE.set(this, _nativeContext);
        if (isNativeOfflineAudioContext2(_nativeContext)) {
          unrenderedAudioWorkletNodeStore2.set(_nativeContext, /* @__PURE__ */ new Set());
        }
        this._destination = new audioDestinationNodeConstructor2(this, numberOfChannels);
        this._listener = createAudioListener2(this, _nativeContext);
        this._onstatechange = null;
      }
      get currentTime() {
        return this._nativeContext.currentTime;
      }
      get destination() {
        return this._destination;
      }
      get listener() {
        return this._listener;
      }
      get onstatechange() {
        return this._onstatechange;
      }
      set onstatechange(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeContext.onstatechange = wrappedListener;
        const nativeOnStateChange = this._nativeContext.onstatechange;
        this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;
      }
      get sampleRate() {
        return this._nativeContext.sampleRate;
      }
      get state() {
        return this._nativeContext.state;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js
  var testPromiseSupport = (nativeContext) => {
    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
    try {
      const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {
      });
      if (promise === void 0) {
        return false;
      }
      promise.catch(() => {
      });
      return true;
    } catch {
    }
    return false;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js
  var DEFAULT_OPTIONS15 = {
    numberOfChannels: 1
  };
  var createMinimalOfflineAudioContextConstructor = (cacheTestResult2, createInvalidStateError2, createNativeOfflineAudioContext2, minimalBaseAudioContextConstructor2, startRendering2) => {
    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor2 {
      constructor(options2) {
        const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS15, ...options2 };
        const nativeOfflineAudioContext = createNativeOfflineAudioContext2(numberOfChannels, length, sampleRate);
        if (!cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
          nativeOfflineAudioContext.addEventListener("statechange", (() => {
            let i8 = 0;
            const delayStateChangeEvent = (event) => {
              if (this._state === "running") {
                if (i8 > 0) {
                  nativeOfflineAudioContext.removeEventListener("statechange", delayStateChangeEvent);
                  event.stopImmediatePropagation();
                  this._waitForThePromiseToSettle(event);
                } else {
                  i8 += 1;
                }
              }
            };
            return delayStateChangeEvent;
          })());
        }
        super(nativeOfflineAudioContext, numberOfChannels);
        this._length = length;
        this._nativeOfflineAudioContext = nativeOfflineAudioContext;
        this._state = null;
      }
      get length() {
        if (this._nativeOfflineAudioContext.length === void 0) {
          return this._length;
        }
        return this._nativeOfflineAudioContext.length;
      }
      get state() {
        return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
      }
      startRendering() {
        if (this._state === "running") {
          return Promise.reject(createInvalidStateError2());
        }
        this._state = "running";
        return startRendering2(this.destination, this._nativeOfflineAudioContext).finally(() => {
          this._state = null;
          deactivateAudioGraph(this);
        });
      }
      _waitForThePromiseToSettle(event) {
        if (this._state === null) {
          this._nativeOfflineAudioContext.dispatchEvent(event);
        } else {
          setTimeout(() => this._waitForThePromiseToSettle(event));
        }
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js
  var createMonitorConnections = (insertElementInSet2, isNativeAudioNode3) => {
    return (nativeAudioNode, whenConnected, whenDisconnected) => {
      const connections = /* @__PURE__ */ new Set();
      nativeAudioNode.connect = ((connect2) => {
        return (destination, output = 0, input2 = 0) => {
          const wasDisconnected = connections.size === 0;
          if (isNativeAudioNode3(destination)) {
            connect2.call(nativeAudioNode, destination, output, input2);
            insertElementInSet2(connections, [destination, output, input2], (connection) => connection[0] === destination && connection[1] === output && connection[2] === input2, true);
            if (wasDisconnected) {
              whenConnected();
            }
            return destination;
          }
          connect2.call(nativeAudioNode, destination, output);
          insertElementInSet2(connections, [destination, output], (connection) => connection[0] === destination && connection[1] === output, true);
          if (wasDisconnected) {
            whenConnected();
          }
          return;
        };
      })(nativeAudioNode.connect);
      nativeAudioNode.disconnect = ((disconnect2) => {
        return (destinationOrOutput, output, input2) => {
          const wasConnected = connections.size > 0;
          if (destinationOrOutput === void 0) {
            disconnect2.apply(nativeAudioNode);
            connections.clear();
          } else if (typeof destinationOrOutput === "number") {
            disconnect2.call(nativeAudioNode, destinationOrOutput);
            for (const connection of connections) {
              if (connection[1] === destinationOrOutput) {
                connections.delete(connection);
              }
            }
          } else {
            if (isNativeAudioNode3(destinationOrOutput)) {
              disconnect2.call(nativeAudioNode, destinationOrOutput, output, input2);
            } else {
              disconnect2.call(nativeAudioNode, destinationOrOutput, output);
            }
            for (const connection of connections) {
              if (connection[0] === destinationOrOutput && (output === void 0 || connection[1] === output) && (input2 === void 0 || connection[2] === input2)) {
                connections.delete(connection);
              }
            }
          }
          const isDisconnected = connections.size === 0;
          if (wasConnected && isDisconnected) {
            whenDisconnected();
          }
        };
      })(nativeAudioNode.disconnect);
      return nativeAudioNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js
  var assignNativeAudioNodeOption = (nativeAudioNode, options2, option) => {
    const value = options2[option];
    if (value !== void 0 && value !== nativeAudioNode[option]) {
      nativeAudioNode[option] = value;
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js
  var assignNativeAudioNodeOptions = (nativeAudioNode, options2) => {
    assignNativeAudioNodeOption(nativeAudioNode, options2, "channelCount");
    assignNativeAudioNodeOption(nativeAudioNode, options2, "channelCountMode");
    assignNativeAudioNodeOption(nativeAudioNode, options2, "channelInterpretation");
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js
  var testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {
    return typeof nativeAnalyserNode.getFloatTimeDomainData === "function";
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js
  var wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {
    nativeAnalyserNode.getFloatTimeDomainData = (array) => {
      const byteTimeDomainData = new Uint8Array(array.length);
      nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);
      const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);
      for (let i8 = 0; i8 < length; i8 += 1) {
        array[i8] = (byteTimeDomainData[i8] - 128) * 78125e-7;
      }
      return array;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js
  var createNativeAnalyserNodeFactory = (cacheTestResult2, createIndexSizeError2) => {
    return (nativeContext, options2) => {
      const nativeAnalyserNode = nativeContext.createAnalyser();
      assignNativeAudioNodeOptions(nativeAnalyserNode, options2);
      if (!(options2.maxDecibels > options2.minDecibels)) {
        throw createIndexSizeError2();
      }
      assignNativeAudioNodeOption(nativeAnalyserNode, options2, "fftSize");
      assignNativeAudioNodeOption(nativeAnalyserNode, options2, "maxDecibels");
      assignNativeAudioNodeOption(nativeAnalyserNode, options2, "minDecibels");
      assignNativeAudioNodeOption(nativeAnalyserNode, options2, "smoothingTimeConstant");
      if (!cacheTestResult2(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {
        wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);
      }
      return nativeAnalyserNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js
  var createNativeAudioBufferConstructor = (window3) => {
    if (window3 === null) {
      return null;
    }
    if (window3.hasOwnProperty("AudioBuffer")) {
      return window3.AudioBuffer;
    }
    return null;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js
  var assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options2, audioParam) => {
    const value = options2[audioParam];
    if (value !== void 0 && value !== nativeAudioNode[audioParam].value) {
      nativeAudioNode[audioParam].value = value;
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js
  var wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {
    nativeAudioBufferSourceNode.start = ((start3) => {
      let isScheduled = false;
      return (when = 0, offset = 0, duration2) => {
        if (isScheduled) {
          throw createInvalidStateError();
        }
        start3.call(nativeAudioBufferSourceNode, when, offset, duration2);
        isScheduled = true;
      };
    })(nativeAudioBufferSourceNode.start);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js
  var wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
    nativeAudioScheduledSourceNode.start = ((start3) => {
      return (when = 0, offset = 0, duration2) => {
        if (typeof duration2 === "number" && duration2 < 0 || offset < 0 || when < 0) {
          throw new RangeError("The parameters can't be negative.");
        }
        start3.call(nativeAudioScheduledSourceNode, when, offset, duration2);
      };
    })(nativeAudioScheduledSourceNode.start);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js
  var wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
    nativeAudioScheduledSourceNode.stop = ((stop2) => {
      return (when = 0) => {
        if (when < 0) {
          throw new RangeError("The parameter can't be negative.");
        }
        stop2.call(nativeAudioScheduledSourceNode, when);
      };
    })(nativeAudioScheduledSourceNode.stop);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js
  var createNativeAudioBufferSourceNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
    return (nativeContext, options2) => {
      const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
      assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options2);
      assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options2, "playbackRate");
      assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "buffer");
      assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "loop");
      assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "loopEnd");
      assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "loopStart");
      if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2(nativeContext))) {
        wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);
      }
      if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport2(nativeContext))) {
        wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);
      }
      if (!cacheTestResult2(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2(nativeContext))) {
        wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeAudioBufferSourceNode, nativeContext);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);
      }
      addSilentConnection2(nativeContext, nativeAudioBufferSourceNode);
      return nativeAudioBufferSourceNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js
  var createNativeAudioContextConstructor = (window3) => {
    if (window3 === null) {
      return null;
    }
    if (window3.hasOwnProperty("AudioContext")) {
      return window3.AudioContext;
    }
    return window3.hasOwnProperty("webkitAudioContext") ? window3.webkitAudioContext : null;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js
  var createNativeAudioDestinationNodeFactory = (createNativeGainNode2, overwriteAccessors2) => {
    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {
      const nativeAudioDestinationNode = nativeContext.destination;
      if (nativeAudioDestinationNode.channelCount !== channelCount) {
        try {
          nativeAudioDestinationNode.channelCount = channelCount;
        } catch {
        }
      }
      if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== "explicit") {
        nativeAudioDestinationNode.channelCountMode = "explicit";
      }
      if (nativeAudioDestinationNode.maxChannelCount === 0) {
        Object.defineProperty(nativeAudioDestinationNode, "maxChannelCount", {
          value: channelCount
        });
      }
      const gainNode = createNativeGainNode2(nativeContext, {
        channelCount,
        channelCountMode: nativeAudioDestinationNode.channelCountMode,
        channelInterpretation: nativeAudioDestinationNode.channelInterpretation,
        gain: 1
      });
      overwriteAccessors2(gainNode, "channelCount", (get10) => () => get10.call(gainNode), (set3) => (value) => {
        set3.call(gainNode, value);
        try {
          nativeAudioDestinationNode.channelCount = value;
        } catch (err) {
          if (value > nativeAudioDestinationNode.maxChannelCount) {
            throw err;
          }
        }
      });
      overwriteAccessors2(gainNode, "channelCountMode", (get10) => () => get10.call(gainNode), (set3) => (value) => {
        set3.call(gainNode, value);
        nativeAudioDestinationNode.channelCountMode = value;
      });
      overwriteAccessors2(gainNode, "channelInterpretation", (get10) => () => get10.call(gainNode), (set3) => (value) => {
        set3.call(gainNode, value);
        nativeAudioDestinationNode.channelInterpretation = value;
      });
      Object.defineProperty(gainNode, "maxChannelCount", {
        get: () => nativeAudioDestinationNode.maxChannelCount
      });
      gainNode.connect(nativeAudioDestinationNode);
      return gainNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js
  var createNativeAudioWorkletNodeConstructor = (window3) => {
    if (window3 === null) {
      return null;
    }
    return window3.hasOwnProperty("AudioWorkletNode") ? window3.AudioWorkletNode : null;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js
  var testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
    const { port1 } = new MessageChannel();
    try {
      port1.postMessage(audioWorkletNodeOptions);
    } finally {
      port1.close();
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js
  var createNativeAudioWorkletNodeFactory = (createInvalidStateError2, createNativeAudioWorkletNodeFaker2, createNativeGainNode2, createNotSupportedError2, monitorConnections2) => {
    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor2, name2, processorConstructor, options2) => {
      if (nativeAudioWorkletNodeConstructor2 !== null) {
        try {
          const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeContext, name2, options2);
          const patchedEventListeners = /* @__PURE__ */ new Map();
          let onprocessorerror = null;
          Object.defineProperties(nativeAudioWorkletNode, {
            channelCount: {
              get: () => options2.channelCount,
              set: () => {
                throw createInvalidStateError2();
              }
            },
            channelCountMode: {
              get: () => "explicit",
              set: () => {
                throw createInvalidStateError2();
              }
            },
            onprocessorerror: {
              get: () => onprocessorerror,
              set: (value) => {
                if (typeof onprocessorerror === "function") {
                  nativeAudioWorkletNode.removeEventListener("processorerror", onprocessorerror);
                }
                onprocessorerror = typeof value === "function" ? value : null;
                if (typeof onprocessorerror === "function") {
                  nativeAudioWorkletNode.addEventListener("processorerror", onprocessorerror);
                }
              }
            }
          });
          nativeAudioWorkletNode.addEventListener = ((addEventListener2) => {
            return (...args) => {
              if (args[0] === "processorerror") {
                const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
                if (unpatchedEventListener !== null) {
                  const patchedEventListener = patchedEventListeners.get(args[1]);
                  if (patchedEventListener !== void 0) {
                    args[1] = patchedEventListener;
                  } else {
                    args[1] = (event) => {
                      if (event.type === "error") {
                        Object.defineProperties(event, {
                          type: { value: "processorerror" }
                        });
                        unpatchedEventListener(event);
                      } else {
                        unpatchedEventListener(new ErrorEvent(args[0], { ...event }));
                      }
                    };
                    patchedEventListeners.set(unpatchedEventListener, args[1]);
                  }
                }
              }
              addEventListener2.call(nativeAudioWorkletNode, "error", args[1], args[2]);
              return addEventListener2.call(nativeAudioWorkletNode, ...args);
            };
          })(nativeAudioWorkletNode.addEventListener);
          nativeAudioWorkletNode.removeEventListener = ((removeEventListener2) => {
            return (...args) => {
              if (args[0] === "processorerror") {
                const patchedEventListener = patchedEventListeners.get(args[1]);
                if (patchedEventListener !== void 0) {
                  patchedEventListeners.delete(args[1]);
                  args[1] = patchedEventListener;
                }
              }
              removeEventListener2.call(nativeAudioWorkletNode, "error", args[1], args[2]);
              return removeEventListener2.call(nativeAudioWorkletNode, args[0], args[1], args[2]);
            };
          })(nativeAudioWorkletNode.removeEventListener);
          if (options2.numberOfOutputs !== 0) {
            const nativeGainNode = createNativeGainNode2(nativeContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              gain: 0
            });
            nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);
            const whenConnected = () => nativeGainNode.disconnect();
            const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);
            return monitorConnections2(nativeAudioWorkletNode, whenConnected, whenDisconnected);
          }
          return nativeAudioWorkletNode;
        } catch (err) {
          if (err.code === 11) {
            throw createNotSupportedError2();
          }
          throw err;
        }
      }
      if (processorConstructor === void 0) {
        throw createNotSupportedError2();
      }
      testClonabilityOfAudioWorkletNodeOptions(options2);
      return createNativeAudioWorkletNodeFaker2(nativeContext, baseLatency, processorConstructor, options2);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js
  var computeBufferSize = (baseLatency, sampleRate) => {
    if (baseLatency === null) {
      return 512;
    }
    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js
  var cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
    return new Promise((resolve2, reject) => {
      const { port1, port2 } = new MessageChannel();
      port1.onmessage = ({ data }) => {
        port1.close();
        port2.close();
        resolve2(data);
      };
      port1.onmessageerror = ({ data }) => {
        port1.close();
        port2.close();
        reject(data);
      };
      port2.postMessage(audioWorkletNodeOptions);
    });
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js
  var createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {
    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);
    return new processorConstructor(clonedAudioWorkletNodeOptions);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js
  var createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {
    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);
    if (nodeToProcessorMap === void 0) {
      nodeToProcessorMap = /* @__PURE__ */ new WeakMap();
      NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);
    }
    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);
    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);
    return audioWorkletProcessorPromise;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js
  var createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs2, createIndexSizeError2, createInvalidStateError2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNotSupportedError2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getActiveAudioWorkletNodeInputs2, monitorConnections2) => {
    return (nativeContext, baseLatency, processorConstructor, options2) => {
      if (options2.numberOfInputs === 0 && options2.numberOfOutputs === 0) {
        throw createNotSupportedError2();
      }
      const outputChannelCount = Array.isArray(options2.outputChannelCount) ? options2.outputChannelCount : Array.from(options2.outputChannelCount);
      if (outputChannelCount.some((channelCount) => channelCount < 1)) {
        throw createNotSupportedError2();
      }
      if (outputChannelCount.length !== options2.numberOfOutputs) {
        throw createIndexSizeError2();
      }
      if (options2.channelCountMode !== "explicit") {
        throw createNotSupportedError2();
      }
      const numberOfInputChannels = options2.channelCount * options2.numberOfInputs;
      const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
      const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
      if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {
        throw createNotSupportedError2();
      }
      const messageChannel = new MessageChannel();
      const gainNodes = [];
      const inputChannelSplitterNodes = [];
      for (let i8 = 0; i8 < options2.numberOfInputs; i8 += 1) {
        gainNodes.push(createNativeGainNode2(nativeContext, {
          channelCount: options2.channelCount,
          channelCountMode: options2.channelCountMode,
          channelInterpretation: options2.channelInterpretation,
          gain: 1
        }));
        inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(nativeContext, {
          channelCount: options2.channelCount,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          numberOfOutputs: options2.channelCount
        }));
      }
      const constantSourceNodes = [];
      if (processorConstructor.parameterDescriptors !== void 0) {
        for (const { defaultValue, maxValue, minValue, name: name2 } of processorConstructor.parameterDescriptors) {
          const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            offset: options2.parameterData[name2] !== void 0 ? options2.parameterData[name2] : defaultValue === void 0 ? 0 : defaultValue
          });
          Object.defineProperties(constantSourceNode.offset, {
            defaultValue: {
              get: () => defaultValue === void 0 ? 0 : defaultValue
            },
            maxValue: {
              get: () => maxValue === void 0 ? MOST_POSITIVE_SINGLE_FLOAT : maxValue
            },
            minValue: {
              get: () => minValue === void 0 ? MOST_NEGATIVE_SINGLE_FLOAT : minValue
            }
          });
          constantSourceNodes.push(constantSourceNode);
        }
      }
      const inputChannelMergerNode = createNativeChannelMergerNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "speakers",
        numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
      });
      const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
      const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, Math.max(1, numberOfOutputChannels));
      const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
        channelCount: Math.max(1, numberOfOutputChannels),
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: Math.max(1, numberOfOutputChannels)
      });
      const outputChannelMergerNodes = [];
      for (let i8 = 0; i8 < options2.numberOfOutputs; i8 += 1) {
        outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: outputChannelCount[i8]
        }));
      }
      for (let i8 = 0; i8 < options2.numberOfInputs; i8 += 1) {
        gainNodes[i8].connect(inputChannelSplitterNodes[i8]);
        for (let j2 = 0; j2 < options2.channelCount; j2 += 1) {
          inputChannelSplitterNodes[i8].connect(inputChannelMergerNode, j2, i8 * options2.channelCount + j2);
        }
      }
      const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.map(({ name: name2 }, index15) => {
        const constantSourceNode = constantSourceNodes[index15];
        constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index15);
        constantSourceNode.start(0);
        return [name2, constantSourceNode.offset];
      }));
      inputChannelMergerNode.connect(scriptProcessorNode);
      let channelInterpretation = options2.channelInterpretation;
      let onprocessorerror = null;
      const outputAudioNodes = options2.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;
      const nativeAudioWorkletNodeFaker = {
        get bufferSize() {
          return bufferSize;
        },
        get channelCount() {
          return options2.channelCount;
        },
        set channelCount(_) {
          throw createInvalidStateError2();
        },
        get channelCountMode() {
          return options2.channelCountMode;
        },
        set channelCountMode(_) {
          throw createInvalidStateError2();
        },
        get channelInterpretation() {
          return channelInterpretation;
        },
        set channelInterpretation(value) {
          for (const gainNode of gainNodes) {
            gainNode.channelInterpretation = value;
          }
          channelInterpretation = value;
        },
        get context() {
          return scriptProcessorNode.context;
        },
        get inputs() {
          return gainNodes;
        },
        get numberOfInputs() {
          return options2.numberOfInputs;
        },
        get numberOfOutputs() {
          return options2.numberOfOutputs;
        },
        get onprocessorerror() {
          return onprocessorerror;
        },
        set onprocessorerror(value) {
          if (typeof onprocessorerror === "function") {
            nativeAudioWorkletNodeFaker.removeEventListener("processorerror", onprocessorerror);
          }
          onprocessorerror = typeof value === "function" ? value : null;
          if (typeof onprocessorerror === "function") {
            nativeAudioWorkletNodeFaker.addEventListener("processorerror", onprocessorerror);
          }
        },
        get parameters() {
          return parameterMap;
        },
        get port() {
          return messageChannel.port2;
        },
        addEventListener(...args) {
          return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
        },
        connect: connectMultipleOutputs2.bind(null, outputAudioNodes),
        disconnect: disconnectMultipleOutputs2.bind(null, outputAudioNodes),
        dispatchEvent(...args) {
          return scriptProcessorNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      const patchedEventListeners = /* @__PURE__ */ new Map();
      messageChannel.port1.addEventListener = ((addEventListener2) => {
        return (...args) => {
          if (args[0] === "message") {
            const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
            if (unpatchedEventListener !== null) {
              const patchedEventListener = patchedEventListeners.get(args[1]);
              if (patchedEventListener !== void 0) {
                args[1] = patchedEventListener;
              } else {
                args[1] = (event) => {
                  exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));
                };
                patchedEventListeners.set(unpatchedEventListener, args[1]);
              }
            }
          }
          return addEventListener2.call(messageChannel.port1, args[0], args[1], args[2]);
        };
      })(messageChannel.port1.addEventListener);
      messageChannel.port1.removeEventListener = ((removeEventListener2) => {
        return (...args) => {
          if (args[0] === "message") {
            const patchedEventListener = patchedEventListeners.get(args[1]);
            if (patchedEventListener !== void 0) {
              patchedEventListeners.delete(args[1]);
              args[1] = patchedEventListener;
            }
          }
          return removeEventListener2.call(messageChannel.port1, args[0], args[1], args[2]);
        };
      })(messageChannel.port1.removeEventListener);
      let onmessage = null;
      Object.defineProperty(messageChannel.port1, "onmessage", {
        get: () => onmessage,
        set: (value) => {
          if (typeof onmessage === "function") {
            messageChannel.port1.removeEventListener("message", onmessage);
          }
          onmessage = typeof value === "function" ? value : null;
          if (typeof onmessage === "function") {
            messageChannel.port1.addEventListener("message", onmessage);
            messageChannel.port1.start();
          }
        }
      });
      processorConstructor.prototype.port = messageChannel.port1;
      let audioWorkletProcessor = null;
      const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options2);
      audioWorkletProcessorPromise.then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);
      const inputs = createNestedArrays(options2.numberOfInputs, options2.channelCount);
      const outputs = createNestedArrays(options2.numberOfOutputs, outputChannelCount);
      const parameters = processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, { name: name2 }) => ({ ...prmtrs, [name2]: new Float32Array(128) }), {});
      let isActive = true;
      const disconnectOutputsGraph = () => {
        if (options2.numberOfOutputs > 0) {
          scriptProcessorNode.disconnect(outputChannelSplitterNode);
        }
        for (let i8 = 0, outputChannelSplitterNodeOutput = 0; i8 < options2.numberOfOutputs; i8 += 1) {
          const outputChannelMergerNode = outputChannelMergerNodes[i8];
          for (let j2 = 0; j2 < outputChannelCount[i8]; j2 += 1) {
            outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
          }
          outputChannelSplitterNodeOutput += outputChannelCount[i8];
        }
      };
      const activeInputIndexes = /* @__PURE__ */ new Map();
      scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {
        if (audioWorkletProcessor !== null) {
          const activeInputs = getActiveAudioWorkletNodeInputs2(nativeAudioWorkletNodeFaker);
          for (let i8 = 0; i8 < bufferSize; i8 += 128) {
            for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
              for (let k2 = 0; k2 < options2.channelCount; k2 += 1) {
                copyFromChannel(inputBuffer, inputs[j2], k2, k2, i8);
              }
            }
            if (processorConstructor.parameterDescriptors !== void 0) {
              processorConstructor.parameterDescriptors.forEach(({ name: name2 }, index15) => {
                copyFromChannel(inputBuffer, parameters, name2, numberOfInputChannels + index15, i8);
              });
            }
            for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
              for (let k2 = 0; k2 < outputChannelCount[j2]; k2 += 1) {
                if (outputs[j2][k2].byteLength === 0) {
                  outputs[j2][k2] = new Float32Array(128);
                }
              }
            }
            try {
              const potentiallyEmptyInputs = inputs.map((input2, index15) => {
                const activeInput = activeInputs[index15];
                if (activeInput.size > 0) {
                  activeInputIndexes.set(index15, bufferSize / 128);
                  return input2;
                }
                const count = activeInputIndexes.get(index15);
                if (count === void 0) {
                  return [];
                }
                if (input2.every((channelData) => channelData.every((sample) => sample === 0))) {
                  if (count === 1) {
                    activeInputIndexes.delete(index15);
                  } else {
                    activeInputIndexes.set(index15, count - 1);
                  }
                }
                return input2;
              });
              const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime + i8 / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));
              isActive = activeSourceFlag;
              for (let j2 = 0, outputChannelSplitterNodeOutput = 0; j2 < options2.numberOfOutputs; j2 += 1) {
                for (let k2 = 0; k2 < outputChannelCount[j2]; k2 += 1) {
                  copyToChannel(outputBuffer, outputs[j2], k2, outputChannelSplitterNodeOutput + k2, i8);
                }
                outputChannelSplitterNodeOutput += outputChannelCount[j2];
              }
            } catch (error) {
              isActive = false;
              nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent("processorerror", {
                colno: error.colno,
                filename: error.filename,
                lineno: error.lineno,
                message: error.message
              }));
            }
            if (!isActive) {
              for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
                gainNodes[j2].disconnect(inputChannelSplitterNodes[j2]);
                for (let k2 = 0; k2 < options2.channelCount; k2 += 1) {
                  inputChannelSplitterNodes[i8].disconnect(inputChannelMergerNode, k2, j2 * options2.channelCount + k2);
                }
              }
              if (processorConstructor.parameterDescriptors !== void 0) {
                const length = processorConstructor.parameterDescriptors.length;
                for (let j2 = 0; j2 < length; j2 += 1) {
                  const constantSourceNode = constantSourceNodes[j2];
                  constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j2);
                  constantSourceNode.stop();
                }
              }
              inputChannelMergerNode.disconnect(scriptProcessorNode);
              scriptProcessorNode.onaudioprocess = null;
              if (isConnected) {
                disconnectOutputsGraph();
              } else {
                disconnectFakeGraph();
              }
              break;
            }
          }
        }
      };
      let isConnected = false;
      const nativeGainNode = createNativeGainNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: 0
      });
      const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);
      const disconnectFakeGraph = () => {
        scriptProcessorNode.disconnect(nativeGainNode);
        nativeGainNode.disconnect();
      };
      const whenConnected = () => {
        if (isActive) {
          disconnectFakeGraph();
          if (options2.numberOfOutputs > 0) {
            scriptProcessorNode.connect(outputChannelSplitterNode);
          }
          for (let i8 = 0, outputChannelSplitterNodeOutput = 0; i8 < options2.numberOfOutputs; i8 += 1) {
            const outputChannelMergerNode = outputChannelMergerNodes[i8];
            for (let j2 = 0; j2 < outputChannelCount[i8]; j2 += 1) {
              outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
            }
            outputChannelSplitterNodeOutput += outputChannelCount[i8];
          }
        }
        isConnected = true;
      };
      const whenDisconnected = () => {
        if (isActive) {
          connectFakeGraph();
          disconnectOutputsGraph();
        }
        isConnected = false;
      };
      connectFakeGraph();
      return monitorConnections2(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node.js
  var createNativeBiquadFilterNode = (nativeContext, options2) => {
    const nativeBiquadFilterNode = nativeContext.createBiquadFilter();
    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "Q");
    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "detune");
    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "frequency");
    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "gain");
    assignNativeAudioNodeOption(nativeBiquadFilterNode, options2, "type");
    return nativeBiquadFilterNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js
  var createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor2, wrapChannelMergerNode2) => {
    return (nativeContext, options2) => {
      const nativeChannelMergerNode = nativeContext.createChannelMerger(options2.numberOfInputs);
      if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
        wrapChannelMergerNode2(nativeContext, nativeChannelMergerNode);
      }
      assignNativeAudioNodeOptions(nativeChannelMergerNode, options2);
      return nativeChannelMergerNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js
  var wrapChannelSplitterNode = (channelSplitterNode) => {
    const channelCount = channelSplitterNode.numberOfOutputs;
    Object.defineProperty(channelSplitterNode, "channelCount", {
      get: () => channelCount,
      set: (value) => {
        if (value !== channelCount) {
          throw createInvalidStateError();
        }
      }
    });
    Object.defineProperty(channelSplitterNode, "channelCountMode", {
      get: () => "explicit",
      set: (value) => {
        if (value !== "explicit") {
          throw createInvalidStateError();
        }
      }
    });
    Object.defineProperty(channelSplitterNode, "channelInterpretation", {
      get: () => "discrete",
      set: (value) => {
        if (value !== "discrete") {
          throw createInvalidStateError();
        }
      }
    });
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node.js
  var createNativeChannelSplitterNode = (nativeContext, options2) => {
    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options2.numberOfOutputs);
    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options2);
    wrapChannelSplitterNode(nativeChannelSplitterNode);
    return nativeChannelSplitterNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js
  var createNativeConstantSourceNodeFactory = (addSilentConnection2, cacheTestResult2, createNativeConstantSourceNodeFaker2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2) => {
    return (nativeContext, options2) => {
      if (nativeContext.createConstantSource === void 0) {
        return createNativeConstantSourceNodeFaker2(nativeContext, options2);
      }
      const nativeConstantSourceNode = nativeContext.createConstantSource();
      assignNativeAudioNodeOptions(nativeConstantSourceNode, options2);
      assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options2, "offset");
      if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);
      }
      addSilentConnection2(nativeContext, nativeConstantSourceNode);
      return nativeConstantSourceNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js
  var interceptConnections = (original, interceptor) => {
    original.connect = interceptor.connect.bind(interceptor);
    original.disconnect = interceptor.disconnect.bind(interceptor);
    return original;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js
  var createNativeConstantSourceNodeFakerFactory = (addSilentConnection2, createNativeAudioBufferSourceNode2, createNativeGainNode2, monitorConnections2) => {
    return (nativeContext, { offset, ...audioNodeOptions }) => {
      const audioBuffer = nativeContext.createBuffer(1, 2, 44100);
      const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
        buffer: null,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        loop: false,
        loopEnd: 0,
        loopStart: 0,
        playbackRate: 1
      });
      const gainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: offset });
      const channelData = audioBuffer.getChannelData(0);
      channelData[0] = 1;
      channelData[1] = 1;
      audioBufferSourceNode.buffer = audioBuffer;
      audioBufferSourceNode.loop = true;
      const nativeConstantSourceNodeFaker = {
        get bufferSize() {
          return void 0;
        },
        get channelCount() {
          return gainNode.channelCount;
        },
        set channelCount(value) {
          gainNode.channelCount = value;
        },
        get channelCountMode() {
          return gainNode.channelCountMode;
        },
        set channelCountMode(value) {
          gainNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return gainNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          gainNode.channelInterpretation = value;
        },
        get context() {
          return gainNode.context;
        },
        get inputs() {
          return [];
        },
        get numberOfInputs() {
          return audioBufferSourceNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return gainNode.numberOfOutputs;
        },
        get offset() {
          return gainNode.gain;
        },
        get onended() {
          return audioBufferSourceNode.onended;
        },
        set onended(value) {
          audioBufferSourceNode.onended = value;
        },
        addEventListener(...args) {
          return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return audioBufferSourceNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);
        },
        start(when = 0) {
          audioBufferSourceNode.start.call(audioBufferSourceNode, when);
        },
        stop(when = 0) {
          audioBufferSourceNode.stop.call(audioBufferSourceNode, when);
        }
      };
      const whenConnected = () => audioBufferSourceNode.connect(gainNode);
      const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);
      addSilentConnection2(nativeContext, audioBufferSourceNode);
      return monitorConnections2(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js
  var createNativeConvolverNodeFactory = (createNotSupportedError2, overwriteAccessors2) => {
    return (nativeContext, options2) => {
      const nativeConvolverNode = nativeContext.createConvolver();
      assignNativeAudioNodeOptions(nativeConvolverNode, options2);
      if (options2.disableNormalization === nativeConvolverNode.normalize) {
        nativeConvolverNode.normalize = !options2.disableNormalization;
      }
      assignNativeAudioNodeOption(nativeConvolverNode, options2, "buffer");
      if (options2.channelCount > 2) {
        throw createNotSupportedError2();
      }
      overwriteAccessors2(nativeConvolverNode, "channelCount", (get10) => () => get10.call(nativeConvolverNode), (set3) => (value) => {
        if (value > 2) {
          throw createNotSupportedError2();
        }
        return set3.call(nativeConvolverNode, value);
      });
      if (options2.channelCountMode === "max") {
        throw createNotSupportedError2();
      }
      overwriteAccessors2(nativeConvolverNode, "channelCountMode", (get10) => () => get10.call(nativeConvolverNode), (set3) => (value) => {
        if (value === "max") {
          throw createNotSupportedError2();
        }
        return set3.call(nativeConvolverNode, value);
      });
      return nativeConvolverNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-delay-node.js
  var createNativeDelayNode = (nativeContext, options2) => {
    const nativeDelayNode = nativeContext.createDelay(options2.maxDelayTime);
    assignNativeAudioNodeOptions(nativeDelayNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options2, "delayTime");
    return nativeDelayNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js
  var createNativeDynamicsCompressorNodeFactory = (createNotSupportedError2) => {
    return (nativeContext, options2) => {
      const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();
      assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options2);
      if (options2.channelCount > 2) {
        throw createNotSupportedError2();
      }
      if (options2.channelCountMode === "max") {
        throw createNotSupportedError2();
      }
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "attack");
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "knee");
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "ratio");
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "release");
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "threshold");
      return nativeDynamicsCompressorNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-gain-node.js
  var createNativeGainNode = (nativeContext, options2) => {
    const nativeGainNode = nativeContext.createGain();
    assignNativeAudioNodeOptions(nativeGainNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeGainNode, options2, "gain");
    return nativeGainNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js
  var createNativeIIRFilterNodeFactory = (createNativeIIRFilterNodeFaker2) => {
    return (nativeContext, baseLatency, options2) => {
      if (nativeContext.createIIRFilter === void 0) {
        return createNativeIIRFilterNodeFaker2(nativeContext, baseLatency, options2);
      }
      const nativeIIRFilterNode = nativeContext.createIIRFilter(options2.feedforward, options2.feedback);
      assignNativeAudioNodeOptions(nativeIIRFilterNode, options2);
      return nativeIIRFilterNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js
  function divide(a8, b5) {
    const denominator = b5[0] * b5[0] + b5[1] * b5[1];
    return [(a8[0] * b5[0] + a8[1] * b5[1]) / denominator, (a8[1] * b5[0] - a8[0] * b5[1]) / denominator];
  }
  function multiply(a8, b5) {
    return [a8[0] * b5[0] - a8[1] * b5[1], a8[0] * b5[1] + a8[1] * b5[0]];
  }
  function evaluatePolynomial(coefficient, z) {
    let result = [0, 0];
    for (let i8 = coefficient.length - 1; i8 >= 0; i8 -= 1) {
      result = multiply(result, z);
      result[0] += coefficient[i8];
    }
    return result;
  }
  var createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError2, createInvalidStateError2, createNativeScriptProcessorNode2, createNotSupportedError2) => {
    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {
      const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
      const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
      const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
      const feedbackLength = convertedFeedback.length;
      const feedforwardLength = convertedFeedforward.length;
      const minLength = Math.min(feedbackLength, feedforwardLength);
      if (feedbackLength === 0 || feedbackLength > 20) {
        throw createNotSupportedError2();
      }
      if (convertedFeedback[0] === 0) {
        throw createInvalidStateError2();
      }
      if (feedforwardLength === 0 || feedforwardLength > 20) {
        throw createNotSupportedError2();
      }
      if (convertedFeedforward[0] === 0) {
        throw createInvalidStateError2();
      }
      if (convertedFeedback[0] !== 1) {
        for (let i8 = 0; i8 < feedforwardLength; i8 += 1) {
          convertedFeedforward[i8] /= convertedFeedback[0];
        }
        for (let i8 = 1; i8 < feedbackLength; i8 += 1) {
          convertedFeedback[i8] /= convertedFeedback[0];
        }
      }
      const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, bufferSize, channelCount, channelCount);
      scriptProcessorNode.channelCount = channelCount;
      scriptProcessorNode.channelCountMode = channelCountMode;
      scriptProcessorNode.channelInterpretation = channelInterpretation;
      const bufferLength = 32;
      const bufferIndexes = [];
      const xBuffers = [];
      const yBuffers = [];
      for (let i8 = 0; i8 < channelCount; i8 += 1) {
        bufferIndexes.push(0);
        const xBuffer = new Float32Array(bufferLength);
        const yBuffer = new Float32Array(bufferLength);
        xBuffer.fill(0);
        yBuffer.fill(0);
        xBuffers.push(xBuffer);
        yBuffers.push(yBuffer);
      }
      scriptProcessorNode.onaudioprocess = (event) => {
        const inputBuffer = event.inputBuffer;
        const outputBuffer = event.outputBuffer;
        const numberOfChannels = inputBuffer.numberOfChannels;
        for (let i8 = 0; i8 < numberOfChannels; i8 += 1) {
          const input2 = inputBuffer.getChannelData(i8);
          const output = outputBuffer.getChannelData(i8);
          bufferIndexes[i8] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[i8], yBuffers[i8], bufferIndexes[i8], bufferLength, input2, output);
        }
      };
      const nyquist = nativeContext.sampleRate / 2;
      const nativeIIRFilterNodeFaker = {
        get bufferSize() {
          return bufferSize;
        },
        get channelCount() {
          return scriptProcessorNode.channelCount;
        },
        set channelCount(value) {
          scriptProcessorNode.channelCount = value;
        },
        get channelCountMode() {
          return scriptProcessorNode.channelCountMode;
        },
        set channelCountMode(value) {
          scriptProcessorNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return scriptProcessorNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          scriptProcessorNode.channelInterpretation = value;
        },
        get context() {
          return scriptProcessorNode.context;
        },
        get inputs() {
          return [scriptProcessorNode];
        },
        get numberOfInputs() {
          return scriptProcessorNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return scriptProcessorNode.numberOfOutputs;
        },
        addEventListener(...args) {
          return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return scriptProcessorNode.dispatchEvent(args[0]);
        },
        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
          if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
            throw createInvalidAccessError2();
          }
          const length = frequencyHz.length;
          for (let i8 = 0; i8 < length; i8 += 1) {
            const omega = -Math.PI * (frequencyHz[i8] / nyquist);
            const z = [Math.cos(omega), Math.sin(omega)];
            const numerator = evaluatePolynomial(convertedFeedforward, z);
            const denominator = evaluatePolynomial(convertedFeedback, z);
            const response = divide(numerator, denominator);
            magResponse[i8] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
            phaseResponse[i8] = Math.atan2(response[1], response[0]);
          }
        },
        removeEventListener(...args) {
          return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node.js
  var createNativeMediaElementAudioSourceNode = (nativeAudioContext, options2) => {
    return nativeAudioContext.createMediaElementSource(options2.mediaElement);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node.js
  var createNativeMediaStreamAudioDestinationNode = (nativeAudioContext, options2) => {
    const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();
    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options2);
    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {
      Object.defineProperty(nativeMediaStreamAudioDestinationNode, "numberOfOutputs", { get: () => 0 });
    }
    return nativeMediaStreamAudioDestinationNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node.js
  var createNativeMediaStreamAudioSourceNode = (nativeAudioContext, { mediaStream }) => {
    const audioStreamTracks = mediaStream.getAudioTracks();
    audioStreamTracks.sort((a8, b5) => a8.id < b5.id ? -1 : a8.id > b5.id ? 1 : 0);
    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);
    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));
    Object.defineProperty(nativeMediaStreamAudioSourceNode, "mediaStream", { value: mediaStream });
    return nativeMediaStreamAudioSourceNode;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js
  var createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError2, isNativeOfflineAudioContext2) => {
    return (nativeAudioContext, { mediaStreamTrack }) => {
      if (typeof nativeAudioContext.createMediaStreamTrackSource === "function") {
        return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);
      }
      const mediaStream = new MediaStream([mediaStreamTrack]);
      const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);
      if (mediaStreamTrack.kind !== "audio") {
        throw createInvalidStateError2();
      }
      if (isNativeOfflineAudioContext2(nativeAudioContext)) {
        throw new TypeError();
      }
      return nativeMediaStreamAudioSourceNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js
  var createNativeOfflineAudioContextConstructor = (window3) => {
    if (window3 === null) {
      return null;
    }
    if (window3.hasOwnProperty("OfflineAudioContext")) {
      return window3.OfflineAudioContext;
    }
    return window3.hasOwnProperty("webkitOfflineAudioContext") ? window3.webkitOfflineAudioContext : null;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js
  var createNativeOscillatorNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
    return (nativeContext, options2) => {
      const nativeOscillatorNode = nativeContext.createOscillator();
      assignNativeAudioNodeOptions(nativeOscillatorNode, options2);
      assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options2, "detune");
      assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options2, "frequency");
      if (options2.periodicWave !== void 0) {
        nativeOscillatorNode.setPeriodicWave(options2.periodicWave);
      } else {
        assignNativeAudioNodeOption(nativeOscillatorNode, options2, "type");
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeOscillatorNode, nativeContext);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);
      }
      addSilentConnection2(nativeContext, nativeOscillatorNode);
      return nativeOscillatorNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js
  var createNativePannerNodeFactory = (createNativePannerNodeFaker2) => {
    return (nativeContext, options2) => {
      const nativePannerNode = nativeContext.createPanner();
      if (nativePannerNode.orientationX === void 0) {
        return createNativePannerNodeFaker2(nativeContext, options2);
      }
      assignNativeAudioNodeOptions(nativePannerNode, options2);
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "orientationX");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "orientationY");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "orientationZ");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "positionX");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "positionY");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "positionZ");
      assignNativeAudioNodeOption(nativePannerNode, options2, "coneInnerAngle");
      assignNativeAudioNodeOption(nativePannerNode, options2, "coneOuterAngle");
      assignNativeAudioNodeOption(nativePannerNode, options2, "coneOuterGain");
      assignNativeAudioNodeOption(nativePannerNode, options2, "distanceModel");
      assignNativeAudioNodeOption(nativePannerNode, options2, "maxDistance");
      assignNativeAudioNodeOption(nativePannerNode, options2, "panningModel");
      assignNativeAudioNodeOption(nativePannerNode, options2, "refDistance");
      assignNativeAudioNodeOption(nativePannerNode, options2, "rolloffFactor");
      return nativePannerNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js
  var createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode2, createInvalidStateError2, createNativeChannelMergerNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNativeWaveShaperNode2, createNotSupportedError2, disconnectNativeAudioNodeFromNativeAudioNode2, getFirstSample2, monitorConnections2) => {
    return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {
      const pannerNode = nativeContext.createPanner();
      if (audioNodeOptions.channelCount > 2) {
        throw createNotSupportedError2();
      }
      if (audioNodeOptions.channelCountMode === "max") {
        throw createNotSupportedError2();
      }
      assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);
      const SINGLE_CHANNEL_OPTIONS = {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete"
      };
      const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
        ...SINGLE_CHANNEL_OPTIONS,
        channelInterpretation: "speakers",
        numberOfInputs: 6
      });
      const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
      const orientationXGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });
      const orientationYGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const orientationZGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const positionXGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const positionYGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const positionZGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 6, 1);
      const waveShaperNode = createNativeWaveShaperNode2(nativeContext, {
        ...SINGLE_CHANNEL_OPTIONS,
        curve: new Float32Array([1, 1]),
        oversample: "none"
      });
      let lastOrientation = [orientationX, orientationY, orientationZ];
      let lastPosition = [positionX, positionY, positionZ];
      const buffer2 = new Float32Array(1);
      scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
        const orientation = [
          getFirstSample2(inputBuffer, buffer2, 0),
          getFirstSample2(inputBuffer, buffer2, 1),
          getFirstSample2(inputBuffer, buffer2, 2)
        ];
        if (orientation.some((value, index15) => value !== lastOrientation[index15])) {
          pannerNode.setOrientation(...orientation);
          lastOrientation = orientation;
        }
        const positon = [
          getFirstSample2(inputBuffer, buffer2, 3),
          getFirstSample2(inputBuffer, buffer2, 4),
          getFirstSample2(inputBuffer, buffer2, 5)
        ];
        if (positon.some((value, index15) => value !== lastPosition[index15])) {
          pannerNode.setPosition(...positon);
          lastPosition = positon;
        }
      };
      Object.defineProperty(orientationYGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(orientationZGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(positionXGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(positionYGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(positionZGainNode.gain, "defaultValue", { get: () => 0 });
      const nativePannerNodeFaker = {
        get bufferSize() {
          return void 0;
        },
        get channelCount() {
          return pannerNode.channelCount;
        },
        set channelCount(value) {
          if (value > 2) {
            throw createNotSupportedError2();
          }
          inputGainNode.channelCount = value;
          pannerNode.channelCount = value;
        },
        get channelCountMode() {
          return pannerNode.channelCountMode;
        },
        set channelCountMode(value) {
          if (value === "max") {
            throw createNotSupportedError2();
          }
          inputGainNode.channelCountMode = value;
          pannerNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return pannerNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          inputGainNode.channelInterpretation = value;
          pannerNode.channelInterpretation = value;
        },
        get coneInnerAngle() {
          return pannerNode.coneInnerAngle;
        },
        set coneInnerAngle(value) {
          pannerNode.coneInnerAngle = value;
        },
        get coneOuterAngle() {
          return pannerNode.coneOuterAngle;
        },
        set coneOuterAngle(value) {
          pannerNode.coneOuterAngle = value;
        },
        get coneOuterGain() {
          return pannerNode.coneOuterGain;
        },
        set coneOuterGain(value) {
          if (value < 0 || value > 1) {
            throw createInvalidStateError2();
          }
          pannerNode.coneOuterGain = value;
        },
        get context() {
          return pannerNode.context;
        },
        get distanceModel() {
          return pannerNode.distanceModel;
        },
        set distanceModel(value) {
          pannerNode.distanceModel = value;
        },
        get inputs() {
          return [inputGainNode];
        },
        get maxDistance() {
          return pannerNode.maxDistance;
        },
        set maxDistance(value) {
          if (value < 0) {
            throw new RangeError();
          }
          pannerNode.maxDistance = value;
        },
        get numberOfInputs() {
          return pannerNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return pannerNode.numberOfOutputs;
        },
        get orientationX() {
          return orientationXGainNode.gain;
        },
        get orientationY() {
          return orientationYGainNode.gain;
        },
        get orientationZ() {
          return orientationZGainNode.gain;
        },
        get panningModel() {
          return pannerNode.panningModel;
        },
        set panningModel(value) {
          pannerNode.panningModel = value;
        },
        get positionX() {
          return positionXGainNode.gain;
        },
        get positionY() {
          return positionYGainNode.gain;
        },
        get positionZ() {
          return positionZGainNode.gain;
        },
        get refDistance() {
          return pannerNode.refDistance;
        },
        set refDistance(value) {
          if (value < 0) {
            throw new RangeError();
          }
          pannerNode.refDistance = value;
        },
        get rolloffFactor() {
          return pannerNode.rolloffFactor;
        },
        set rolloffFactor(value) {
          if (value < 0) {
            throw new RangeError();
          }
          pannerNode.rolloffFactor = value;
        },
        addEventListener(...args) {
          return inputGainNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return inputGainNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return inputGainNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {
        nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;
      }
      if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {
        nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;
      }
      if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {
        nativePannerNodeFaker.coneOuterGain = coneOuterGain;
      }
      if (distanceModel !== nativePannerNodeFaker.distanceModel) {
        nativePannerNodeFaker.distanceModel = distanceModel;
      }
      if (maxDistance !== nativePannerNodeFaker.maxDistance) {
        nativePannerNodeFaker.maxDistance = maxDistance;
      }
      if (orientationX !== nativePannerNodeFaker.orientationX.value) {
        nativePannerNodeFaker.orientationX.value = orientationX;
      }
      if (orientationY !== nativePannerNodeFaker.orientationY.value) {
        nativePannerNodeFaker.orientationY.value = orientationY;
      }
      if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {
        nativePannerNodeFaker.orientationZ.value = orientationZ;
      }
      if (panningModel !== nativePannerNodeFaker.panningModel) {
        nativePannerNodeFaker.panningModel = panningModel;
      }
      if (positionX !== nativePannerNodeFaker.positionX.value) {
        nativePannerNodeFaker.positionX.value = positionX;
      }
      if (positionY !== nativePannerNodeFaker.positionY.value) {
        nativePannerNodeFaker.positionY.value = positionY;
      }
      if (positionZ !== nativePannerNodeFaker.positionZ.value) {
        nativePannerNodeFaker.positionZ.value = positionZ;
      }
      if (refDistance !== nativePannerNodeFaker.refDistance) {
        nativePannerNodeFaker.refDistance = refDistance;
      }
      if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {
        nativePannerNodeFaker.rolloffFactor = rolloffFactor;
      }
      if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {
        pannerNode.setOrientation(...lastOrientation);
      }
      if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {
        pannerNode.setPosition(...lastPosition);
      }
      const whenConnected = () => {
        inputGainNode.connect(pannerNode);
        connectNativeAudioNodeToNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
        waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);
        waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);
        waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);
        waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);
        waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);
        waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);
        channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);
      };
      const whenDisconnected = () => {
        inputGainNode.disconnect(pannerNode);
        disconnectNativeAudioNodeFromNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
        waveShaperNode.disconnect(orientationXGainNode);
        orientationXGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(orientationYGainNode);
        orientationYGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(orientationZGainNode);
        orientationZGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(positionXGainNode);
        positionXGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(positionYGainNode);
        positionYGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(positionZGainNode);
        positionZGainNode.disconnect(channelMergerNode);
        channelMergerNode.disconnect(scriptProcessorNode);
        scriptProcessorNode.disconnect(nativeContext.destination);
      };
      return monitorConnections2(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js
  var createNativePeriodicWaveFactory = (createIndexSizeError2) => {
    return (nativeContext, { disableNormalization, imag, real }) => {
      const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);
      const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);
      const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });
      if (Array.from(imag).length < 2) {
        throw createIndexSizeError2();
      }
      return nativePeriodicWave;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node.js
  var createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {
    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js
  var createNativeStereoPannerNodeFactory = (createNativeStereoPannerNodeFaker, createNotSupportedError2) => {
    return (nativeContext, options2) => {
      const channelCountMode = options2.channelCountMode;
      if (channelCountMode === "clamped-max") {
        throw createNotSupportedError2();
      }
      if (nativeContext.createStereoPanner === void 0) {
        return createNativeStereoPannerNodeFaker(nativeContext, options2);
      }
      const nativeStereoPannerNode = nativeContext.createStereoPanner();
      assignNativeAudioNodeOptions(nativeStereoPannerNode, options2);
      assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options2, "pan");
      Object.defineProperty(nativeStereoPannerNode, "channelCountMode", {
        get: () => channelCountMode,
        set: (value) => {
          if (value !== channelCountMode) {
            throw createNotSupportedError2();
          }
        }
      });
      return nativeStereoPannerNode;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js
  var createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeGainNode2, createNativeWaveShaperNode2, createNotSupportedError2, monitorConnections2) => {
    const CURVE_SIZE = 16385;
    const DC_CURVE = new Float32Array([1, 1]);
    const HALF_PI = Math.PI / 2;
    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" };
    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: "none" };
    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
      const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);
      for (let i8 = 0; i8 < CURVE_SIZE; i8 += 1) {
        const x4 = i8 / (CURVE_SIZE - 1) * HALF_PI;
        leftWaveShaperCurve[i8] = Math.cos(x4);
        rightWaveShaperCurve[i8] = Math.sin(x4);
      }
      const leftGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const leftWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve });
      const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });
      const rightGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const rightWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve });
      return {
        connectGraph() {
          inputGainNode.connect(leftGainNode);
          inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
          inputGainNode.connect(rightGainNode);
          panWaveShaperNode.connect(panGainNode);
          panGainNode.connect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
          panGainNode.connect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
          leftWaveShaperNode.connect(leftGainNode.gain);
          rightWaveShaperNode.connect(rightGainNode.gain);
          leftGainNode.connect(channelMergerNode, 0, 0);
          rightGainNode.connect(channelMergerNode, 0, 1);
        },
        disconnectGraph() {
          inputGainNode.disconnect(leftGainNode);
          inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
          inputGainNode.disconnect(rightGainNode);
          panWaveShaperNode.disconnect(panGainNode);
          panGainNode.disconnect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
          panGainNode.disconnect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
          leftWaveShaperNode.disconnect(leftGainNode.gain);
          rightWaveShaperNode.disconnect(rightGainNode.gain);
          leftGainNode.disconnect(channelMergerNode, 0, 0);
          rightGainNode.disconnect(channelMergerNode, 0, 1);
        }
      };
    };
    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
      const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const centerIndex = Math.floor(CURVE_SIZE / 2);
      for (let i8 = 0; i8 < CURVE_SIZE; i8 += 1) {
        if (i8 > centerIndex) {
          const x4 = (i8 - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;
          leftInputForLeftOutputWaveShaperCurve[i8] = Math.cos(x4);
          leftInputForRightOutputWaveShaperCurve[i8] = Math.sin(x4);
          rightInputForLeftOutputWaveShaperCurve[i8] = 0;
          rightInputForRightOutputWaveShaperCurve[i8] = 1;
        } else {
          const x4 = i8 / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;
          leftInputForLeftOutputWaveShaperCurve[i8] = 1;
          leftInputForRightOutputWaveShaperCurve[i8] = 0;
          rightInputForLeftOutputWaveShaperCurve[i8] = Math.cos(x4);
          rightInputForRightOutputWaveShaperCurve[i8] = Math.sin(x4);
        }
      }
      const channelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
        channelCount: 2,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: 2
      });
      const leftInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
        ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
        curve: leftInputForLeftOutputWaveShaperCurve
      });
      const leftInputForRightOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
        ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
        curve: leftInputForRightOutputWaveShaperCurve
      });
      const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });
      const rightInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
        ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
        curve: rightInputForLeftOutputWaveShaperCurve
      });
      const rightInputForRightOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
      const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
        ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
        curve: rightInputForRightOutputWaveShaperCurve
      });
      return {
        connectGraph() {
          inputGainNode.connect(channelSplitterNode);
          inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
          channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);
          channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);
          channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);
          channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);
          panWaveShaperNode.connect(panGainNode);
          panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
          panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
          panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
          panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
          leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);
          leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);
          rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);
          rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);
          leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
          rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
          leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
          rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
        },
        disconnectGraph() {
          inputGainNode.disconnect(channelSplitterNode);
          inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
          channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);
          channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);
          channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);
          channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);
          panWaveShaperNode.disconnect(panGainNode);
          panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
          panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
          panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
          panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
          leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);
          leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);
          rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);
          rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);
          leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
          rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
          leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
          rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
        }
      };
    };
    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {
      if (channelCount === 1) {
        return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);
      }
      if (channelCount === 2) {
        return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);
      }
      throw createNotSupportedError2();
    };
    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {
      if (channelCountMode === "max") {
        throw createNotSupportedError2();
      }
      const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
        ...audioNodeOptions,
        channelCount: 1,
        channelCountMode,
        numberOfInputs: 2
      });
      const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });
      const panGainNode = createNativeGainNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: pan
      });
      let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);
      Object.defineProperty(panGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(panGainNode.gain, "maxValue", { get: () => 1 });
      Object.defineProperty(panGainNode.gain, "minValue", { get: () => -1 });
      const nativeStereoPannerNodeFakerFactory2 = {
        get bufferSize() {
          return void 0;
        },
        get channelCount() {
          return inputGainNode.channelCount;
        },
        set channelCount(value) {
          if (inputGainNode.channelCount !== value) {
            if (isConnected) {
              disconnectGraph();
            }
            ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));
            if (isConnected) {
              connectGraph();
            }
          }
          inputGainNode.channelCount = value;
        },
        get channelCountMode() {
          return inputGainNode.channelCountMode;
        },
        set channelCountMode(value) {
          if (value === "clamped-max" || value === "max") {
            throw createNotSupportedError2();
          }
          inputGainNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return inputGainNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          inputGainNode.channelInterpretation = value;
        },
        get context() {
          return inputGainNode.context;
        },
        get inputs() {
          return [inputGainNode];
        },
        get numberOfInputs() {
          return inputGainNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return inputGainNode.numberOfOutputs;
        },
        get pan() {
          return panGainNode.gain;
        },
        addEventListener(...args) {
          return inputGainNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return inputGainNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return inputGainNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      let isConnected = false;
      const whenConnected = () => {
        connectGraph();
        isConnected = true;
      };
      const whenDisconnected = () => {
        disconnectGraph();
        isConnected = false;
      };
      return monitorConnections2(interceptConnections(nativeStereoPannerNodeFakerFactory2, channelMergerNode), whenConnected, whenDisconnected);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js
  var createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError2, createNativeWaveShaperNodeFaker2, isDCCurve2, monitorConnections2, nativeAudioContextConstructor2, overwriteAccessors2) => {
    return (nativeContext, options2) => {
      const nativeWaveShaperNode = nativeContext.createWaveShaper();
      if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext" && nativeContext.createGain().gain.automationRate === void 0) {
        return createNativeWaveShaperNodeFaker2(nativeContext, options2);
      }
      assignNativeAudioNodeOptions(nativeWaveShaperNode, options2);
      const curve = options2.curve === null || options2.curve instanceof Float32Array ? options2.curve : new Float32Array(options2.curve);
      if (curve !== null && curve.length < 2) {
        throw createInvalidStateError2();
      }
      assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, "curve");
      assignNativeAudioNodeOption(nativeWaveShaperNode, options2, "oversample");
      let disconnectNativeAudioBufferSourceNode = null;
      let isConnected = false;
      overwriteAccessors2(nativeWaveShaperNode, "curve", (get10) => () => get10.call(nativeWaveShaperNode), (set3) => (value) => {
        set3.call(nativeWaveShaperNode, value);
        if (isConnected) {
          if (isDCCurve2(value) && disconnectNativeAudioBufferSourceNode === null) {
            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
          } else if (!isDCCurve2(value) && disconnectNativeAudioBufferSourceNode !== null) {
            disconnectNativeAudioBufferSourceNode();
            disconnectNativeAudioBufferSourceNode = null;
          }
        }
        return value;
      });
      const whenConnected = () => {
        isConnected = true;
        if (isDCCurve2(nativeWaveShaperNode.curve)) {
          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
        }
      };
      const whenDisconnected = () => {
        isConnected = false;
        if (disconnectNativeAudioBufferSourceNode !== null) {
          disconnectNativeAudioBufferSourceNode();
          disconnectNativeAudioBufferSourceNode = null;
        }
      };
      return monitorConnections2(nativeWaveShaperNode, whenConnected, whenDisconnected);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js
  var createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError2, createNativeGainNode2, isDCCurve2, monitorConnections2) => {
    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {
      const negativeWaveShaperNode = nativeContext.createWaveShaper();
      const positiveWaveShaperNode = nativeContext.createWaveShaper();
      assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);
      assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);
      const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
      const invertGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: -1 });
      const outputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
      const revertGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: -1 });
      let disconnectNativeAudioBufferSourceNode = null;
      let isConnected = false;
      let unmodifiedCurve = null;
      const nativeWaveShaperNodeFaker = {
        get bufferSize() {
          return void 0;
        },
        get channelCount() {
          return negativeWaveShaperNode.channelCount;
        },
        set channelCount(value) {
          inputGainNode.channelCount = value;
          invertGainNode.channelCount = value;
          negativeWaveShaperNode.channelCount = value;
          outputGainNode.channelCount = value;
          positiveWaveShaperNode.channelCount = value;
          revertGainNode.channelCount = value;
        },
        get channelCountMode() {
          return negativeWaveShaperNode.channelCountMode;
        },
        set channelCountMode(value) {
          inputGainNode.channelCountMode = value;
          invertGainNode.channelCountMode = value;
          negativeWaveShaperNode.channelCountMode = value;
          outputGainNode.channelCountMode = value;
          positiveWaveShaperNode.channelCountMode = value;
          revertGainNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return negativeWaveShaperNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          inputGainNode.channelInterpretation = value;
          invertGainNode.channelInterpretation = value;
          negativeWaveShaperNode.channelInterpretation = value;
          outputGainNode.channelInterpretation = value;
          positiveWaveShaperNode.channelInterpretation = value;
          revertGainNode.channelInterpretation = value;
        },
        get context() {
          return negativeWaveShaperNode.context;
        },
        get curve() {
          return unmodifiedCurve;
        },
        set curve(value) {
          if (value !== null && value.length < 2) {
            throw createInvalidStateError2();
          }
          if (value === null) {
            negativeWaveShaperNode.curve = value;
            positiveWaveShaperNode.curve = value;
          } else {
            const curveLength = value.length;
            const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);
            const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);
            negativeCurve[0] = value[0];
            positiveCurve[0] = -value[curveLength - 1];
            const length = Math.ceil((curveLength + 1) / 2);
            const centerIndex = (curveLength + 1) / 2 - 1;
            for (let i8 = 1; i8 < length; i8 += 1) {
              const theoreticIndex = i8 / length * centerIndex;
              const lowerIndex = Math.floor(theoreticIndex);
              const upperIndex = Math.ceil(theoreticIndex);
              negativeCurve[i8] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];
              positiveCurve[i8] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];
            }
            negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;
            negativeWaveShaperNode.curve = negativeCurve;
            positiveWaveShaperNode.curve = positiveCurve;
          }
          unmodifiedCurve = value;
          if (isConnected) {
            if (isDCCurve2(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {
              disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
            } else if (disconnectNativeAudioBufferSourceNode !== null) {
              disconnectNativeAudioBufferSourceNode();
              disconnectNativeAudioBufferSourceNode = null;
            }
          }
        },
        get inputs() {
          return [inputGainNode];
        },
        get numberOfInputs() {
          return negativeWaveShaperNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return negativeWaveShaperNode.numberOfOutputs;
        },
        get oversample() {
          return negativeWaveShaperNode.oversample;
        },
        set oversample(value) {
          negativeWaveShaperNode.oversample = value;
          positiveWaveShaperNode.oversample = value;
        },
        addEventListener(...args) {
          return inputGainNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return inputGainNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return inputGainNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      if (curve !== null) {
        nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);
      }
      if (oversample !== nativeWaveShaperNodeFaker.oversample) {
        nativeWaveShaperNodeFaker.oversample = oversample;
      }
      const whenConnected = () => {
        inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);
        inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);
        isConnected = true;
        if (isDCCurve2(unmodifiedCurve)) {
          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
        }
      };
      const whenDisconnected = () => {
        inputGainNode.disconnect(negativeWaveShaperNode);
        negativeWaveShaperNode.disconnect(outputGainNode);
        inputGainNode.disconnect(invertGainNode);
        invertGainNode.disconnect(positiveWaveShaperNode);
        positiveWaveShaperNode.disconnect(revertGainNode);
        revertGainNode.disconnect(outputGainNode);
        isConnected = false;
        if (disconnectNativeAudioBufferSourceNode !== null) {
          disconnectNativeAudioBufferSourceNode();
          disconnectNativeAudioBufferSourceNode = null;
        }
      };
      return monitorConnections2(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js
  var createNotSupportedError = () => new DOMException("", "NotSupportedError");

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js
  var DEFAULT_OPTIONS16 = {
    numberOfChannels: 1
  };
  var createOfflineAudioContextConstructor = (baseAudioContextConstructor2, cacheTestResult2, createInvalidStateError2, createNativeOfflineAudioContext2, startRendering2) => {
    return class OfflineAudioContext extends baseAudioContextConstructor2 {
      constructor(a8, b5, c6) {
        let options2;
        if (typeof a8 === "number" && b5 !== void 0 && c6 !== void 0) {
          options2 = { length: b5, numberOfChannels: a8, sampleRate: c6 };
        } else if (typeof a8 === "object") {
          options2 = a8;
        } else {
          throw new Error("The given parameters are not valid.");
        }
        const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS16, ...options2 };
        const nativeOfflineAudioContext = createNativeOfflineAudioContext2(numberOfChannels, length, sampleRate);
        if (!cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
          nativeOfflineAudioContext.addEventListener("statechange", (() => {
            let i8 = 0;
            const delayStateChangeEvent = (event) => {
              if (this._state === "running") {
                if (i8 > 0) {
                  nativeOfflineAudioContext.removeEventListener("statechange", delayStateChangeEvent);
                  event.stopImmediatePropagation();
                  this._waitForThePromiseToSettle(event);
                } else {
                  i8 += 1;
                }
              }
            };
            return delayStateChangeEvent;
          })());
        }
        super(nativeOfflineAudioContext, numberOfChannels);
        this._length = length;
        this._nativeOfflineAudioContext = nativeOfflineAudioContext;
        this._state = null;
      }
      get length() {
        if (this._nativeOfflineAudioContext.length === void 0) {
          return this._length;
        }
        return this._nativeOfflineAudioContext.length;
      }
      get state() {
        return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
      }
      startRendering() {
        if (this._state === "running") {
          return Promise.reject(createInvalidStateError2());
        }
        this._state = "running";
        return startRendering2(this.destination, this._nativeOfflineAudioContext).finally(() => {
          this._state = null;
          deactivateAudioGraph(this);
        });
      }
      _waitForThePromiseToSettle(event) {
        if (this._state === null) {
          this._nativeOfflineAudioContext.dispatchEvent(event);
        } else {
          setTimeout(() => this._waitForThePromiseToSettle(event));
        }
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js
  var DEFAULT_OPTIONS17 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    detune: 0,
    frequency: 440,
    periodicWave: void 0,
    type: "sine"
  };
  var createOscillatorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeOscillatorNode2, createOscillatorNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
    return class OscillatorNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS17, ...options2 };
        const nativeOscillatorNode = createNativeOscillatorNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer2() : null;
        const nyquist = context2.sampleRate / 2;
        super(context2, false, nativeOscillatorNode, oscillatorNodeRenderer);
        this._detune = createAudioParam2(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);
        this._frequency = createAudioParam2(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);
        this._nativeOscillatorNode = nativeOscillatorNode;
        this._onended = null;
        this._oscillatorNodeRenderer = oscillatorNodeRenderer;
        if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== void 0) {
          this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;
        }
      }
      get detune() {
        return this._detune;
      }
      get frequency() {
        return this._frequency;
      }
      get onended() {
        return this._onended;
      }
      set onended(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeOscillatorNode.onended = wrappedListener;
        const nativeOnEnded = this._nativeOscillatorNode.onended;
        this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
      }
      get type() {
        return this._nativeOscillatorNode.type;
      }
      set type(value) {
        this._nativeOscillatorNode.type = value;
        if (this._oscillatorNodeRenderer !== null) {
          this._oscillatorNodeRenderer.periodicWave = null;
        }
      }
      setPeriodicWave(periodicWave) {
        this._nativeOscillatorNode.setPeriodicWave(periodicWave);
        if (this._oscillatorNodeRenderer !== null) {
          this._oscillatorNodeRenderer.periodicWave = periodicWave;
        }
      }
      start(when = 0) {
        this._nativeOscillatorNode.start(when);
        if (this._oscillatorNodeRenderer !== null) {
          this._oscillatorNodeRenderer.start = when;
        }
        if (this.context.state !== "closed") {
          setInternalStateToActive(this);
          const resetInternalStateToPassive = () => {
            this._nativeOscillatorNode.removeEventListener("ended", resetInternalStateToPassive);
            if (isActiveAudioNode(this)) {
              setInternalStateToPassive(this);
            }
          };
          this._nativeOscillatorNode.addEventListener("ended", resetInternalStateToPassive);
        }
      }
      stop(when = 0) {
        this._nativeOscillatorNode.stop(when);
        if (this._oscillatorNodeRenderer !== null) {
          this._oscillatorNodeRenderer.stop = when;
        }
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js
  var createOscillatorNodeRendererFactory = (connectAudioParam2, createNativeOscillatorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeOscillatorNodes = /* @__PURE__ */ new WeakMap();
      let periodicWave = null;
      let start3 = null;
      let stop2 = null;
      const createOscillatorNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeOscillatorNode = getNativeAudioNode2(proxy);
        const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);
        if (!nativeOscillatorNodeIsOwnedByContext) {
          const options2 = {
            channelCount: nativeOscillatorNode.channelCount,
            channelCountMode: nativeOscillatorNode.channelCountMode,
            channelInterpretation: nativeOscillatorNode.channelInterpretation,
            detune: nativeOscillatorNode.detune.value,
            frequency: nativeOscillatorNode.frequency.value,
            periodicWave: periodicWave === null ? void 0 : periodicWave,
            type: nativeOscillatorNode.type
          };
          nativeOscillatorNode = createNativeOscillatorNode2(nativeOfflineAudioContext, options2);
          if (start3 !== null) {
            nativeOscillatorNode.start(start3);
          }
          if (stop2 !== null) {
            nativeOscillatorNode.stop(stop2);
          }
        }
        renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);
        if (!nativeOscillatorNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
          await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeOscillatorNode);
        return nativeOscillatorNode;
      };
      return {
        set periodicWave(value) {
          periodicWave = value;
        },
        set start(value) {
          start3 = value;
        },
        set stop(value) {
          stop2 = value;
        },
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);
          if (renderedNativeOscillatorNode !== void 0) {
            return Promise.resolve(renderedNativeOscillatorNode);
          }
          return createOscillatorNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js
  var DEFAULT_OPTIONS18 = {
    channelCount: 2,
    channelCountMode: "clamped-max",
    channelInterpretation: "speakers",
    coneInnerAngle: 360,
    coneOuterAngle: 360,
    coneOuterGain: 0,
    distanceModel: "inverse",
    maxDistance: 1e4,
    orientationX: 1,
    orientationY: 0,
    orientationZ: 0,
    panningModel: "equalpower",
    positionX: 0,
    positionY: 0,
    positionZ: 0,
    refDistance: 1,
    rolloffFactor: 1
  };
  var createPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativePannerNode2, createPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class PannerNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS18, ...options2 };
        const nativePannerNode = createNativePannerNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const pannerNodeRenderer = isOffline ? createPannerNodeRenderer2() : null;
        super(context2, false, nativePannerNode, pannerNodeRenderer);
        this._nativePannerNode = nativePannerNode;
        this._orientationX = createAudioParam2(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._orientationY = createAudioParam2(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._orientationZ = createAudioParam2(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._positionX = createAudioParam2(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._positionY = createAudioParam2(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._positionZ = createAudioParam2(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        setAudioNodeTailTime2(this, 1);
      }
      get coneInnerAngle() {
        return this._nativePannerNode.coneInnerAngle;
      }
      set coneInnerAngle(value) {
        this._nativePannerNode.coneInnerAngle = value;
      }
      get coneOuterAngle() {
        return this._nativePannerNode.coneOuterAngle;
      }
      set coneOuterAngle(value) {
        this._nativePannerNode.coneOuterAngle = value;
      }
      get coneOuterGain() {
        return this._nativePannerNode.coneOuterGain;
      }
      set coneOuterGain(value) {
        this._nativePannerNode.coneOuterGain = value;
      }
      get distanceModel() {
        return this._nativePannerNode.distanceModel;
      }
      set distanceModel(value) {
        this._nativePannerNode.distanceModel = value;
      }
      get maxDistance() {
        return this._nativePannerNode.maxDistance;
      }
      set maxDistance(value) {
        this._nativePannerNode.maxDistance = value;
      }
      get orientationX() {
        return this._orientationX;
      }
      get orientationY() {
        return this._orientationY;
      }
      get orientationZ() {
        return this._orientationZ;
      }
      get panningModel() {
        return this._nativePannerNode.panningModel;
      }
      set panningModel(value) {
        this._nativePannerNode.panningModel = value;
      }
      get positionX() {
        return this._positionX;
      }
      get positionY() {
        return this._positionY;
      }
      get positionZ() {
        return this._positionZ;
      }
      get refDistance() {
        return this._nativePannerNode.refDistance;
      }
      set refDistance(value) {
        this._nativePannerNode.refDistance = value;
      }
      get rolloffFactor() {
        return this._nativePannerNode.rolloffFactor;
      }
      set rolloffFactor(value) {
        this._nativePannerNode.rolloffFactor = value;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js
  var createPannerNodeRendererFactory = (connectAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativePannerNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
    return () => {
      const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
      let renderedBufferPromise = null;
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeGainNode = null;
        let nativePannerNode = getNativeAudioNode2(proxy);
        const commonAudioNodeOptions = {
          channelCount: nativePannerNode.channelCount,
          channelCountMode: nativePannerNode.channelCountMode,
          channelInterpretation: nativePannerNode.channelInterpretation
        };
        const commonNativePannerNodeOptions = {
          ...commonAudioNodeOptions,
          coneInnerAngle: nativePannerNode.coneInnerAngle,
          coneOuterAngle: nativePannerNode.coneOuterAngle,
          coneOuterGain: nativePannerNode.coneOuterGain,
          distanceModel: nativePannerNode.distanceModel,
          maxDistance: nativePannerNode.maxDistance,
          panningModel: nativePannerNode.panningModel,
          refDistance: nativePannerNode.refDistance,
          rolloffFactor: nativePannerNode.rolloffFactor
        };
        const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);
        if ("bufferSize" in nativePannerNode) {
          nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
        } else if (!nativePannerNodeIsOwnedByContext) {
          const options2 = {
            ...commonNativePannerNodeOptions,
            orientationX: nativePannerNode.orientationX.value,
            orientationY: nativePannerNode.orientationY.value,
            orientationZ: nativePannerNode.orientationZ.value,
            positionX: nativePannerNode.positionX.value,
            positionY: nativePannerNode.positionY.value,
            positionZ: nativePannerNode.positionZ.value
          };
          nativePannerNode = createNativePannerNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);
        if (nativeGainNode !== null) {
          if (renderedBufferPromise === null) {
            if (nativeOfflineAudioContextConstructor2 === null) {
              throw new Error("Missing the native OfflineAudioContext constructor.");
            }
            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(6, proxy.context.length, nativeOfflineAudioContext.sampleRate);
            const nativeChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "speakers",
              numberOfInputs: 6
            });
            nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);
            renderedBufferPromise = (async () => {
              const nativeConstantSourceNodes = await Promise.all([
                proxy.orientationX,
                proxy.orientationY,
                proxy.orientationZ,
                proxy.positionX,
                proxy.positionY,
                proxy.positionZ
              ].map(async (audioParam, index15) => {
                const nativeConstantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                  channelCount: 1,
                  channelCountMode: "explicit",
                  channelInterpretation: "discrete",
                  offset: index15 === 0 ? 1 : 0
                });
                await renderAutomation2(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);
                return nativeConstantSourceNode;
              }));
              for (let i8 = 0; i8 < 6; i8 += 1) {
                nativeConstantSourceNodes[i8].connect(nativeChannelMergerNode, 0, i8);
                nativeConstantSourceNodes[i8].start(0);
              }
              return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
            })();
          }
          const renderedBuffer = await renderedBufferPromise;
          const inputGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, inputGainNode);
          const channelDatas = [];
          for (let i8 = 0; i8 < renderedBuffer.numberOfChannels; i8 += 1) {
            channelDatas.push(renderedBuffer.getChannelData(i8));
          }
          let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];
          let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];
          let gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
          let partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, {
            ...commonNativePannerNodeOptions,
            orientationX: lastOrientation[0],
            orientationY: lastOrientation[1],
            orientationZ: lastOrientation[2],
            positionX: lastPosition[0],
            positionY: lastPosition[1],
            positionZ: lastPosition[2]
          });
          inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
          partialPannerNode.connect(nativeGainNode);
          for (let i8 = 128; i8 < renderedBuffer.length; i8 += 128) {
            const orientation = [channelDatas[0][i8], channelDatas[1][i8], channelDatas[2][i8]];
            const positon = [channelDatas[3][i8], channelDatas[4][i8], channelDatas[5][i8]];
            if (orientation.some((value, index15) => value !== lastOrientation[index15]) || positon.some((value, index15) => value !== lastPosition[index15])) {
              lastOrientation = orientation;
              lastPosition = positon;
              const currentTime = i8 / nativeOfflineAudioContext.sampleRate;
              gateGainNode.gain.setValueAtTime(0, currentTime);
              gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });
              partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, {
                ...commonNativePannerNodeOptions,
                orientationX: lastOrientation[0],
                orientationY: lastOrientation[1],
                orientationZ: lastOrientation[2],
                positionX: lastPosition[0],
                positionY: lastPosition[1],
                positionZ: lastPosition[2]
              });
              gateGainNode.gain.setValueAtTime(1, currentTime);
              inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
              partialPannerNode.connect(nativeGainNode);
            }
          }
          return nativeGainNode;
        }
        if (!nativePannerNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
          await renderAutomation2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
          await renderAutomation2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
          await renderAutomation2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
          await renderAutomation2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
          await renderAutomation2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
        }
        if (isNativeAudioNodeFaker(nativePannerNode)) {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);
        } else {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode);
        }
        return nativePannerNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeGainNodeOrNativePannerNode !== void 0) {
            return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js
  var DEFAULT_OPTIONS19 = {
    disableNormalization: false
  };
  var createPeriodicWaveConstructor = (createNativePeriodicWave2, getNativeContext2, periodicWaveStore, sanitizePeriodicWaveOptions2) => {
    return class PeriodicWave {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = sanitizePeriodicWaveOptions2({ ...DEFAULT_OPTIONS19, ...options2 });
        const periodicWave = createNativePeriodicWave2(nativeContext, mergedOptions);
        periodicWaveStore.add(periodicWave);
        return periodicWave;
      }
      static [Symbol.hasInstance](instance) {
        return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/render-automation.js
  var createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam2) => {
    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
      const audioParamRenderer = getAudioParamRenderer(audioParam);
      audioParamRenderer.replay(nativeAudioParam);
      return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js
  var createRenderInputsOfAudioNode = (getAudioNodeConnections2, getAudioNodeRenderer2, isPartOfACycle2) => {
    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {
      const audioNodeConnections = getAudioNodeConnections2(audioNode);
      await Promise.all(audioNodeConnections.activeInputs.map((connections, input2) => Array.from(connections).map(async ([source, output]) => {
        const audioNodeRenderer = getAudioNodeRenderer2(source);
        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
        const destination = audioNode.context.destination;
        if (!isPartOfACycle2(source) && (audioNode !== destination || !isPartOfACycle2(audioNode))) {
          renderedNativeAudioNode.connect(nativeAudioNode, output, input2);
        }
      })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js
  var createRenderInputsOfAudioParam = (getAudioNodeRenderer2, getAudioParamConnections2, isPartOfACycle2) => {
    return async (audioParam, nativeOfflineAudioContext, nativeAudioParam) => {
      const audioParamConnections = getAudioParamConnections2(audioParam);
      await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {
        const audioNodeRenderer = getAudioNodeRenderer2(source);
        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
        if (!isPartOfACycle2(source)) {
          renderedNativeAudioNode.connect(nativeAudioParam, output);
        }
      }));
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js
  var createRenderNativeOfflineAudioContext = (cacheTestResult2, createNativeGainNode2, createNativeScriptProcessorNode2, testOfflineAudioContextCurrentTimeSupport) => {
    return (nativeOfflineAudioContext) => {
      if (cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
        return Promise.resolve(cacheTestResult2(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {
          if (!isOfflineAudioContextCurrentTimeSupported) {
            const scriptProcessorNode = createNativeScriptProcessorNode2(nativeOfflineAudioContext, 512, 0, 1);
            nativeOfflineAudioContext.oncomplete = () => {
              scriptProcessorNode.onaudioprocess = null;
              scriptProcessorNode.disconnect();
            };
            scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime;
            scriptProcessorNode.connect(nativeOfflineAudioContext.destination);
          }
          return nativeOfflineAudioContext.startRendering();
        });
      }
      return new Promise((resolve2) => {
        const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: 0
        });
        nativeOfflineAudioContext.oncomplete = (event) => {
          gainNode.disconnect();
          resolve2(event.renderedBuffer);
        };
        gainNode.connect(nativeOfflineAudioContext.destination);
        nativeOfflineAudioContext.startRendering();
      });
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/set-active-audio-worklet-node-inputs.js
  var createSetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2) => {
    return (nativeAudioWorkletNode, activeInputs) => {
      activeAudioWorkletNodeInputsStore2.set(nativeAudioWorkletNode, activeInputs);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/set-audio-node-tail-time.js
  var createSetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
    return (audioNode, tailTime) => audioNodeTailTimeStore2.set(audioNode, tailTime);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js
  var createStartRendering = (audioBufferStore2, cacheTestResult2, getAudioNodeRenderer2, getUnrenderedAudioWorkletNodes2, renderNativeOfflineAudioContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer2(destination).render(destination, nativeOfflineAudioContext).then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes2(nativeOfflineAudioContext)).map((audioWorkletNode) => getAudioNodeRenderer2(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)))).then(() => renderNativeOfflineAudioContext2(nativeOfflineAudioContext)).then((audioBuffer) => {
      if (typeof audioBuffer.copyFromChannel !== "function") {
        wrapAudioBufferCopyChannelMethods2(audioBuffer);
        wrapAudioBufferGetChannelDataMethod(audioBuffer);
      } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
        wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
      }
      audioBufferStore2.add(audioBuffer);
      return audioBuffer;
    });
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js
  var DEFAULT_OPTIONS20 = {
    channelCount: 2,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    pan: 0
  };
  var createStereoPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeStereoPannerNode2, createStereoPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class StereoPannerNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS20, ...options2 };
        const nativeStereoPannerNode = createNativeStereoPannerNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer2() : null;
        super(context2, false, nativeStereoPannerNode, stereoPannerNodeRenderer);
        this._pan = createAudioParam2(this, isOffline, nativeStereoPannerNode.pan);
      }
      get pan() {
        return this._pan;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js
  var createStereoPannerNodeRendererFactory = (connectAudioParam2, createNativeStereoPannerNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeStereoPannerNodes = /* @__PURE__ */ new WeakMap();
      const createStereoPannerNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeStereoPannerNode = getNativeAudioNode2(proxy);
        const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);
        if (!nativeStereoPannerNodeIsOwnedByContext) {
          const options2 = {
            channelCount: nativeStereoPannerNode.channelCount,
            channelCountMode: nativeStereoPannerNode.channelCountMode,
            channelInterpretation: nativeStereoPannerNode.channelInterpretation,
            pan: nativeStereoPannerNode.pan.value
          };
          nativeStereoPannerNode = createNativeStereoPannerNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);
        if (!nativeStereoPannerNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
        }
        if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);
        } else {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);
        }
        return nativeStereoPannerNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);
          if (renderedNativeStereoPannerNode !== void 0) {
            return Promise.resolve(renderedNativeStereoPannerNode);
          }
          return createStereoPannerNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js
  var createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor2) => {
    return () => {
      if (nativeAudioBufferConstructor2 === null) {
        return false;
      }
      try {
        new nativeAudioBufferConstructor2({ length: 1, sampleRate: 44100 });
      } catch {
        return false;
      }
      return true;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-post-message-support.js
  var createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2) => {
    return async () => {
      if (nativeAudioWorkletNodeConstructor2 === null) {
        return true;
      }
      if (nativeOfflineAudioContextConstructor2 === null) {
        return false;
      }
      const blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
        type: "application/javascript; charset=utf-8"
      });
      const offlineAudioContext = new nativeOfflineAudioContextConstructor2(1, 128, 44100);
      const url = URL.createObjectURL(blob);
      let isEmittingMessageEvents = false;
      let isEmittingProcessorErrorEvents = false;
      try {
        await offlineAudioContext.audioWorklet.addModule(url);
        const audioWorkletNode = new nativeAudioWorkletNodeConstructor2(offlineAudioContext, "a", { numberOfOutputs: 0 });
        const oscillator = offlineAudioContext.createOscillator();
        audioWorkletNode.port.onmessage = () => isEmittingMessageEvents = true;
        audioWorkletNode.onprocessorerror = () => isEmittingProcessorErrorEvents = true;
        oscillator.connect(audioWorkletNode);
        oscillator.start(0);
        await offlineAudioContext.startRendering();
      } catch {
      } finally {
        URL.revokeObjectURL(url);
      }
      return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js
  var createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode2, nativeOfflineAudioContextConstructor2) => {
    return () => {
      if (nativeOfflineAudioContextConstructor2 === null) {
        return Promise.resolve(false);
      }
      const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
      const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: 0
      });
      return new Promise((resolve2) => {
        nativeOfflineAudioContext.oncomplete = () => {
          gainNode.disconnect();
          resolve2(nativeOfflineAudioContext.currentTime !== 0);
        };
        nativeOfflineAudioContext.startRendering();
      });
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js
  var createUnknownError = () => new DOMException("", "UnknownError");

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js
  var DEFAULT_OPTIONS21 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    curve: null,
    oversample: "none"
  };
  var createWaveShaperNodeConstructor = (audioNodeConstructor2, createInvalidStateError2, createNativeWaveShaperNode2, createWaveShaperNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class WaveShaperNode extends audioNodeConstructor2 {
      constructor(context2, options2) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = { ...DEFAULT_OPTIONS21, ...options2 };
        const nativeWaveShaperNode = createNativeWaveShaperNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer2() : null;
        super(context2, true, nativeWaveShaperNode, waveShaperNodeRenderer);
        this._isCurveNullified = false;
        this._nativeWaveShaperNode = nativeWaveShaperNode;
        setAudioNodeTailTime2(this, 1);
      }
      get curve() {
        if (this._isCurveNullified) {
          return null;
        }
        return this._nativeWaveShaperNode.curve;
      }
      set curve(value) {
        if (value === null) {
          this._isCurveNullified = true;
          this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
        } else {
          if (value.length < 2) {
            throw createInvalidStateError2();
          }
          this._isCurveNullified = false;
          this._nativeWaveShaperNode.curve = value;
        }
      }
      get oversample() {
        return this._nativeWaveShaperNode.oversample;
      }
      set oversample(value) {
        this._nativeWaveShaperNode.oversample = value;
      }
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js
  var createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeWaveShaperNodes = /* @__PURE__ */ new WeakMap();
      const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeWaveShaperNode = getNativeAudioNode2(proxy);
        const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);
        if (!nativeWaveShaperNodeIsOwnedByContext) {
          const options2 = {
            channelCount: nativeWaveShaperNode.channelCount,
            channelCountMode: nativeWaveShaperNode.channelCountMode,
            channelInterpretation: nativeWaveShaperNode.channelInterpretation,
            curve: nativeWaveShaperNode.curve,
            oversample: nativeWaveShaperNode.oversample
          };
          nativeWaveShaperNode = createNativeWaveShaperNode2(nativeOfflineAudioContext, options2);
        }
        renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);
        if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);
        } else {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);
        }
        return nativeWaveShaperNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);
          if (renderedNativeWaveShaperNode !== void 0) {
            return Promise.resolve(renderedNativeWaveShaperNode);
          }
          return createWaveShaperNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/window.js
  var createWindow = () => typeof window === "undefined" ? null : window;

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js
  var createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong2, createIndexSizeError2) => {
    return (audioBuffer) => {
      audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
        if (channelNumber >= audioBuffer.numberOfChannels) {
          throw createIndexSizeError2();
        }
        const audioBufferLength = audioBuffer.length;
        const channelData = audioBuffer.getChannelData(channelNumber);
        const destinationLength = destination.length;
        for (let i8 = bufferOffset < 0 ? -bufferOffset : 0; i8 + bufferOffset < audioBufferLength && i8 < destinationLength; i8 += 1) {
          destination[i8] = channelData[i8 + bufferOffset];
        }
      };
      audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
        if (channelNumber >= audioBuffer.numberOfChannels) {
          throw createIndexSizeError2();
        }
        const audioBufferLength = audioBuffer.length;
        const channelData = audioBuffer.getChannelData(channelNumber);
        const sourceLength = source.length;
        for (let i8 = bufferOffset < 0 ? -bufferOffset : 0; i8 + bufferOffset < audioBufferLength && i8 < sourceLength; i8 += 1) {
          channelData[i8 + bufferOffset] = source[i8];
        }
      };
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js
  var createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong2) => {
    return (audioBuffer) => {
      audioBuffer.copyFromChannel = ((copyFromChannel2) => {
        return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
          const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
          const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
          if (bufferOffset < audioBuffer.length) {
            return copyFromChannel2.call(audioBuffer, destination, channelNumber, bufferOffset);
          }
        };
      })(audioBuffer.copyFromChannel);
      audioBuffer.copyToChannel = ((copyToChannel2) => {
        return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
          const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
          const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
          if (bufferOffset < audioBuffer.length) {
            return copyToChannel2.call(audioBuffer, source, channelNumber, bufferOffset);
          }
        };
      })(audioBuffer.copyToChannel);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js
  var createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors2) => {
    return (nativeAudioBufferSourceNode, nativeContext) => {
      const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);
      if (nativeAudioBufferSourceNode.buffer === null) {
        nativeAudioBufferSourceNode.buffer = nullifiedBuffer;
      }
      overwriteAccessors2(nativeAudioBufferSourceNode, "buffer", (get10) => () => {
        const value = get10.call(nativeAudioBufferSourceNode);
        return value === nullifiedBuffer ? null : value;
      }, (set3) => (value) => {
        return set3.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);
      });
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js
  var createWrapChannelMergerNode = (createInvalidStateError2, monitorConnections2) => {
    return (nativeContext, channelMergerNode) => {
      channelMergerNode.channelCount = 1;
      channelMergerNode.channelCountMode = "explicit";
      Object.defineProperty(channelMergerNode, "channelCount", {
        get: () => 1,
        set: () => {
          throw createInvalidStateError2();
        }
      });
      Object.defineProperty(channelMergerNode, "channelCountMode", {
        get: () => "explicit",
        set: () => {
          throw createInvalidStateError2();
        }
      });
      const audioBufferSourceNode = nativeContext.createBufferSource();
      const whenConnected = () => {
        const length = channelMergerNode.numberOfInputs;
        for (let i8 = 0; i8 < length; i8 += 1) {
          audioBufferSourceNode.connect(channelMergerNode, 0, i8);
        }
      };
      const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);
      monitorConnections2(channelMergerNode, whenConnected, whenDisconnected);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/get-first-sample.js
  var getFirstSample = (audioBuffer, buffer2, channelNumber) => {
    if (audioBuffer.copyFromChannel === void 0) {
      return audioBuffer.getChannelData(channelNumber)[0];
    }
    audioBuffer.copyFromChannel(buffer2, channelNumber);
    return buffer2[0];
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js
  var isDCCurve = (curve) => {
    if (curve === null) {
      return false;
    }
    const length = curve.length;
    if (length % 2 !== 0) {
      return curve[Math.floor(length / 2)] !== 0;
    }
    return curve[length / 2 - 1] + curve[length / 2] !== 0;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js
  var overwriteAccessors = (object, property, createGetter2, createSetter2) => {
    let prototype = object;
    while (!prototype.hasOwnProperty(property)) {
      prototype = Object.getPrototypeOf(prototype);
    }
    const { get: get10, set: set3 } = Object.getOwnPropertyDescriptor(prototype, property);
    Object.defineProperty(object, property, { get: createGetter2(get10), set: createSetter2(set3) });
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/sanitize-audio-worklet-node-options.js
  var sanitizeAudioWorkletNodeOptions = (options2) => {
    return {
      ...options2,
      outputChannelCount: options2.outputChannelCount !== void 0 ? options2.outputChannelCount : options2.numberOfInputs === 1 && options2.numberOfOutputs === 1 ? [options2.channelCount] : Array.from({ length: options2.numberOfOutputs }, () => 1)
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/sanitize-channel-splitter-options.js
  var sanitizeChannelSplitterOptions = (options2) => {
    return { ...options2, channelCount: options2.numberOfOutputs };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/sanitize-periodic-wave-options.js
  var sanitizePeriodicWaveOptions = (options2) => {
    const { imag, real } = options2;
    if (imag === void 0) {
      if (real === void 0) {
        return { ...options2, imag: [0, 0], real: [0, 0] };
      }
      return { ...options2, imag: Array.from(real, () => 0), real };
    }
    if (real === void 0) {
      return { ...options2, imag, real: Array.from(imag, () => 0) };
    }
    return { ...options2, imag, real };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/set-value-at-time-until-possible.js
  var setValueAtTimeUntilPossible = (audioParam, value, startTime) => {
    try {
      audioParam.setValueAtTime(value, startTime);
    } catch (err) {
      if (err.code !== 9) {
        throw err;
      }
      setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.js
  var testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    nativeAudioBufferSourceNode.start();
    try {
      nativeAudioBufferSourceNode.start();
    } catch {
      return true;
    }
    return false;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.js
  var testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
    try {
      nativeAudioBufferSourceNode.start(0, 1);
    } catch {
      return false;
    }
    return true;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js
  var testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    nativeAudioBufferSourceNode.start();
    try {
      nativeAudioBufferSourceNode.stop();
    } catch {
      return false;
    }
    return true;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.js
  var testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createOscillator();
    try {
      nativeAudioBufferSourceNode.start(-1);
    } catch (err) {
      return err instanceof RangeError;
    }
    return false;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js
  var testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext) => {
    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
    nativeAudioBufferSourceNode.start();
    nativeAudioBufferSourceNode.stop();
    try {
      nativeAudioBufferSourceNode.stop();
      return true;
    } catch {
      return false;
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js
  var testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createOscillator();
    try {
      nativeAudioBufferSourceNode.stop(-1);
    } catch (err) {
      return err instanceof RangeError;
    }
    return false;
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/test-audio-worklet-node-options-clonability.js
  var testAudioWorkletNodeOptionsClonability = (audioWorkletNodeOptions) => {
    const { port1, port2 } = new MessageChannel();
    try {
      port1.postMessage(audioWorkletNodeOptions);
    } finally {
      port1.close();
      port2.close();
    }
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js
  var wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {
    nativeAudioBufferSourceNode.start = ((start3) => {
      return (when = 0, offset = 0, duration2) => {
        const buffer2 = nativeAudioBufferSourceNode.buffer;
        const clampedOffset = buffer2 === null ? offset : Math.min(buffer2.duration, offset);
        if (buffer2 !== null && clampedOffset > buffer2.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {
          start3.call(nativeAudioBufferSourceNode, when, 0, 0);
        } else {
          start3.call(nativeAudioBufferSourceNode, when, clampedOffset, duration2);
        }
      };
    })(nativeAudioBufferSourceNode.start);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js
  var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {
    const nativeGainNode = nativeContext.createGain();
    nativeAudioScheduledSourceNode.connect(nativeGainNode);
    const disconnectGainNode = ((disconnect2) => {
      return () => {
        disconnect2.call(nativeAudioScheduledSourceNode, nativeGainNode);
        nativeAudioScheduledSourceNode.removeEventListener("ended", disconnectGainNode);
      };
    })(nativeAudioScheduledSourceNode.disconnect);
    nativeAudioScheduledSourceNode.addEventListener("ended", disconnectGainNode);
    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);
    nativeAudioScheduledSourceNode.stop = ((stop2) => {
      let isStopped = false;
      return (when = 0) => {
        if (isStopped) {
          try {
            stop2.call(nativeAudioScheduledSourceNode, when);
          } catch {
            nativeGainNode.gain.setValueAtTime(0, when);
          }
        } else {
          stop2.call(nativeAudioScheduledSourceNode, when);
          isStopped = true;
        }
      };
    })(nativeAudioScheduledSourceNode.stop);
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js
  var wrapEventListener = (target, eventListener) => {
    return (event) => {
      const descriptor = { value: target };
      Object.defineProperties(event, {
        currentTarget: descriptor,
        target: descriptor
      });
      if (typeof eventListener === "function") {
        return eventListener.call(target, event);
      }
      return eventListener.handleEvent.call(target, event);
    };
  };

  // node_modules/.pnpm/standardized-audio-context@25.3.28/node_modules/standardized-audio-context/build/es2019/module.js
  var addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);
  var addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);
  var deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);
  var audioNodeTailTimeStore = /* @__PURE__ */ new WeakMap();
  var getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);
  var cacheTestResult = createCacheTestResult(/* @__PURE__ */ new Map(), /* @__PURE__ */ new WeakMap());
  var window2 = createWindow();
  var createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);
  var getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);
  var renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);
  var createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);
  var getNativeContext = createGetNativeContext(CONTEXT_STORE);
  var nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window2);
  var isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);
  var audioParamAudioNodeStore = /* @__PURE__ */ new WeakMap();
  var eventTargetConstructor = createEventTargetConstructor(wrapEventListener);
  var nativeAudioContextConstructor = createNativeAudioContextConstructor(window2);
  var isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);
  var isNativeAudioNode2 = createIsNativeAudioNode(window2);
  var isNativeAudioParam = createIsNativeAudioParam(window2);
  var nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window2);
  var audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode2, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);
  var analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);
  var audioBufferStore = /* @__PURE__ */ new WeakSet();
  var nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window2);
  var convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));
  var wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);
  var wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);
  var audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
  var addSilentConnection = createAddSilentConnection(createNativeGainNode);
  var renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);
  var connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);
  var createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
  var renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);
  var createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);
  var audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
  var audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);
  var createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);
  var biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode2);
  var wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);
  var createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);
  var createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);
  var channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);
  var createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);
  var channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);
  var createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);
  var createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);
  var createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
  var createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);
  var createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);
  var convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);
  var createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);
  var createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);
  var renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));
  var createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
  var createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);
  var iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);
  var unrenderedAudioWorkletNodeStore = /* @__PURE__ */ new WeakMap();
  var minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);
  var createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
  var createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
  var createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);
  var createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections);
  var createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);
  var createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections);
  var createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);
  var createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
  var pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);
  var periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, /* @__PURE__ */ new WeakSet(), sanitizePeriodicWaveOptions);
  var nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);
  var createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);
  var createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);
  var createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);
  var waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var isSecureContext = createIsSecureContext(window2);
  var exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window2);
  var backupOfflineAudioContextStore = /* @__PURE__ */ new WeakMap();
  var getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);
  var addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, createEvaluateSource(window2), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, /* @__PURE__ */ new WeakMap(), /* @__PURE__ */ new WeakMap(), createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), window2) : void 0;
  var isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);
  var decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, /* @__PURE__ */ new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
  var baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);
  var mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
  var mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);
  var mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
  var createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext);
  var mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);
  var audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);
  var getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);
  var addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
  var connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);
  var deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
  var disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);
  var activeAudioWorkletNodeInputsStore = /* @__PURE__ */ new WeakMap();
  var getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);
  var createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);
  var createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);
  var createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
  var getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);
  var setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);
  var audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) : void 0;
  var minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);
  var createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);
  var startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
  var minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);
  var offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);
  var isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);
  var isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode2);
  var isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);
  var isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/TypeCheck.js
  function isUndef(arg) {
    return typeof arg === "undefined";
  }
  function isDefined(arg) {
    return !isUndef(arg);
  }
  function isFunction(arg) {
    return typeof arg === "function";
  }
  function isNumber(arg) {
    return typeof arg === "number";
  }
  function isObject(arg) {
    return Object.prototype.toString.call(arg) === "[object Object]" && arg.constructor === Object;
  }
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  function isArray(arg) {
    return Array.isArray(arg);
  }
  function isString(arg) {
    return typeof arg === "string";
  }
  function isNote(arg) {
    return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/Debug.js
  function assert(statement, error) {
    if (!statement) {
      throw new Error(error);
    }
  }
  function assertRange(value, gte, lte = Infinity) {
    if (!(gte <= value && value <= lte)) {
      throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);
    }
  }
  function assertContextRunning(context2) {
    if (!context2.isOffline && context2.state !== "running") {
      warn('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
    }
  }
  var isInsideScheduledCallback = false;
  var printedScheduledWarning = false;
  function enterScheduledCallback(insideCallback) {
    isInsideScheduledCallback = insideCallback;
  }
  function assertUsedScheduleTime(time) {
    if (isUndef(time) && isInsideScheduledCallback && !printedScheduledWarning) {
      printedScheduledWarning = true;
      warn("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing");
    }
  }
  var defaultLogger = console;
  function log(...args) {
    defaultLogger.log(...args);
  }
  function warn(...args) {
    defaultLogger.warn(...args);
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/AudioContext.js
  function createAudioContext(options2) {
    return new audioContextConstructor(options2);
  }
  function createOfflineAudioContext(channels2, length, sampleRate) {
    return new offlineAudioContextConstructor(channels2, length, sampleRate);
  }
  var theWindow = typeof self === "object" ? self : null;
  var hasAudioContext = theWindow && (theWindow.hasOwnProperty("AudioContext") || theWindow.hasOwnProperty("webkitAudioContext"));
  function createAudioWorkletNode(context2, name2, options2) {
    assert(isDefined(audioWorkletNodeConstructor), "This node only works in a secure context (https or localhost)");
    return new audioWorkletNodeConstructor(context2, name2, options2);
  }

  // node_modules/.pnpm/tslib@2.4.0/node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn
  } = import_tslib.default;

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/clock/Ticker.js
  var Ticker = class {
    constructor(callback, type, updateInterval, contextSampleRate) {
      this._callback = callback;
      this._type = type;
      this._minimumUpdateInterval = Math.max(128 / (contextSampleRate || 44100), 1e-3);
      this.updateInterval = updateInterval;
      this._createClock();
    }
    _createWorker() {
      const blob = new Blob([
        `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
      ], { type: "text/javascript" });
      const blobUrl = URL.createObjectURL(blob);
      const worker = new Worker(blobUrl);
      worker.onmessage = this._callback.bind(this);
      this._worker = worker;
    }
    _createTimeout() {
      this._timeout = setTimeout(() => {
        this._createTimeout();
        this._callback();
      }, this._updateInterval * 1e3);
    }
    _createClock() {
      if (this._type === "worker") {
        try {
          this._createWorker();
        } catch (e8) {
          this._type = "timeout";
          this._createClock();
        }
      } else if (this._type === "timeout") {
        this._createTimeout();
      }
    }
    _disposeClock() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._worker) {
        this._worker.terminate();
        this._worker.onmessage = null;
      }
    }
    get updateInterval() {
      return this._updateInterval;
    }
    set updateInterval(interval2) {
      var _a3;
      this._updateInterval = Math.max(interval2, this._minimumUpdateInterval);
      if (this._type === "worker") {
        (_a3 = this._worker) === null || _a3 === void 0 ? void 0 : _a3.postMessage(this._updateInterval * 1e3);
      }
    }
    get type() {
      return this._type;
    }
    set type(type) {
      this._disposeClock();
      this._type = type;
      this._createClock();
    }
    dispose() {
      this._disposeClock();
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js
  function isAudioParam(arg) {
    return isAnyAudioParam(arg);
  }
  function isAudioNode2(arg) {
    return isAnyAudioNode(arg);
  }
  function isOfflineAudioContext(arg) {
    return isAnyOfflineAudioContext(arg);
  }
  function isAudioContext(arg) {
    return isAnyAudioContext(arg);
  }
  function isAudioBuffer(arg) {
    return arg instanceof audioBufferConstructor;
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/Defaults.js
  function noCopy(key, arg) {
    return key === "value" || isAudioParam(arg) || isAudioNode2(arg) || isAudioBuffer(arg);
  }
  function deepMerge(target, ...sources) {
    if (!sources.length) {
      return target;
    }
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
      for (const key in source) {
        if (noCopy(key, source[key])) {
          target[key] = source[key];
        } else if (isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, { [key]: {} });
          }
          deepMerge(target[key], source[key]);
        } else {
          Object.assign(target, { [key]: source[key] });
        }
      }
    }
    return deepMerge(target, ...sources);
  }
  function deepEquals(arrayA, arrayB) {
    return arrayA.length === arrayB.length && arrayA.every((element, index15) => arrayB[index15] === element);
  }
  function optionsFromArguments(defaults, argsArray, keys3 = [], objKey) {
    const opts = {};
    const args = Array.from(argsArray);
    if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {
      const partOfDefaults = Object.keys(args[0]).some((key) => Reflect.has(defaults, key));
      if (!partOfDefaults) {
        deepMerge(opts, { [objKey]: args[0] });
        keys3.splice(keys3.indexOf(objKey), 1);
        args.shift();
      }
    }
    if (args.length === 1 && isObject(args[0])) {
      deepMerge(opts, args[0]);
    } else {
      for (let i8 = 0; i8 < keys3.length; i8++) {
        if (isDefined(args[i8])) {
          opts[keys3[i8]] = args[i8];
        }
      }
    }
    return deepMerge(defaults, opts);
  }
  function getDefaultsFromInstance(instance) {
    return instance.constructor.getDefaults();
  }
  function defaultArg(given, fallback) {
    if (isUndef(given)) {
      return fallback;
    } else {
      return given;
    }
  }
  function omitFromObject(obj, omit) {
    omit.forEach((prop) => {
      if (Reflect.has(obj, prop)) {
        delete obj[prop];
      }
    });
    return obj;
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/Tone.js
  var Tone = class {
    constructor() {
      this.debug = false;
      this._wasDisposed = false;
    }
    static getDefaults() {
      return {};
    }
    log(...args) {
      if (this.debug || theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS) {
        log(this, ...args);
      }
    }
    dispose() {
      this._wasDisposed = true;
      return this;
    }
    get disposed() {
      return this._wasDisposed;
    }
    toString() {
      return this.name;
    }
  };
  Tone.version = version;

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/Math.js
  var EPSILON = 1e-6;
  function GT(a8, b5) {
    return a8 > b5 + EPSILON;
  }
  function GTE(a8, b5) {
    return GT(a8, b5) || EQ(a8, b5);
  }
  function LT(a8, b5) {
    return a8 + EPSILON < b5;
  }
  function EQ(a8, b5) {
    return Math.abs(a8 - b5) < EPSILON;
  }
  function clamp(value, min, max) {
    return Math.max(Math.min(value, max), min);
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/Timeline.js
  var Timeline = class extends Tone {
    constructor() {
      super();
      this.name = "Timeline";
      this._timeline = [];
      const options2 = optionsFromArguments(Timeline.getDefaults(), arguments, ["memory"]);
      this.memory = options2.memory;
      this.increasing = options2.increasing;
    }
    static getDefaults() {
      return {
        memory: Infinity,
        increasing: false
      };
    }
    get length() {
      return this._timeline.length;
    }
    add(event) {
      assert(Reflect.has(event, "time"), "Timeline: events must have a time attribute");
      event.time = event.time.valueOf();
      if (this.increasing && this.length) {
        const lastValue = this._timeline[this.length - 1];
        assert(GTE(event.time, lastValue.time), "The time must be greater than or equal to the last scheduled time");
        this._timeline.push(event);
      } else {
        const index15 = this._search(event.time);
        this._timeline.splice(index15 + 1, 0, event);
      }
      if (this.length > this.memory) {
        const diff = this.length - this.memory;
        this._timeline.splice(0, diff);
      }
      return this;
    }
    remove(event) {
      const index15 = this._timeline.indexOf(event);
      if (index15 !== -1) {
        this._timeline.splice(index15, 1);
      }
      return this;
    }
    get(time, param = "time") {
      const index15 = this._search(time, param);
      if (index15 !== -1) {
        return this._timeline[index15];
      } else {
        return null;
      }
    }
    peek() {
      return this._timeline[0];
    }
    shift() {
      return this._timeline.shift();
    }
    getAfter(time, param = "time") {
      const index15 = this._search(time, param);
      if (index15 + 1 < this._timeline.length) {
        return this._timeline[index15 + 1];
      } else {
        return null;
      }
    }
    getBefore(time) {
      const len = this._timeline.length;
      if (len > 0 && this._timeline[len - 1].time < time) {
        return this._timeline[len - 1];
      }
      const index15 = this._search(time);
      if (index15 - 1 >= 0) {
        return this._timeline[index15 - 1];
      } else {
        return null;
      }
    }
    cancel(after) {
      if (this._timeline.length > 1) {
        let index15 = this._search(after);
        if (index15 >= 0) {
          if (EQ(this._timeline[index15].time, after)) {
            for (let i8 = index15; i8 >= 0; i8--) {
              if (EQ(this._timeline[i8].time, after)) {
                index15 = i8;
              } else {
                break;
              }
            }
            this._timeline = this._timeline.slice(0, index15);
          } else {
            this._timeline = this._timeline.slice(0, index15 + 1);
          }
        } else {
          this._timeline = [];
        }
      } else if (this._timeline.length === 1) {
        if (GTE(this._timeline[0].time, after)) {
          this._timeline = [];
        }
      }
      return this;
    }
    cancelBefore(time) {
      const index15 = this._search(time);
      if (index15 >= 0) {
        this._timeline = this._timeline.slice(index15 + 1);
      }
      return this;
    }
    previousEvent(event) {
      const index15 = this._timeline.indexOf(event);
      if (index15 > 0) {
        return this._timeline[index15 - 1];
      } else {
        return null;
      }
    }
    _search(time, param = "time") {
      if (this._timeline.length === 0) {
        return -1;
      }
      let beginning = 0;
      const len = this._timeline.length;
      let end = len;
      if (len > 0 && this._timeline[len - 1][param] <= time) {
        return len - 1;
      }
      while (beginning < end) {
        let midPoint = Math.floor(beginning + (end - beginning) / 2);
        const event = this._timeline[midPoint];
        const nextEvent = this._timeline[midPoint + 1];
        if (EQ(event[param], time)) {
          for (let i8 = midPoint; i8 < this._timeline.length; i8++) {
            const testEvent = this._timeline[i8];
            if (EQ(testEvent[param], time)) {
              midPoint = i8;
            } else {
              break;
            }
          }
          return midPoint;
        } else if (LT(event[param], time) && GT(nextEvent[param], time)) {
          return midPoint;
        } else if (GT(event[param], time)) {
          end = midPoint;
        } else {
          beginning = midPoint + 1;
        }
      }
      return -1;
    }
    _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {
      this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);
    }
    forEach(callback) {
      this._iterate(callback);
      return this;
    }
    forEachBefore(time, callback) {
      const upperBound = this._search(time);
      if (upperBound !== -1) {
        this._iterate(callback, 0, upperBound);
      }
      return this;
    }
    forEachAfter(time, callback) {
      const lowerBound = this._search(time);
      this._iterate(callback, lowerBound + 1);
      return this;
    }
    forEachBetween(startTime, endTime, callback) {
      let lowerBound = this._search(startTime);
      let upperBound = this._search(endTime);
      if (lowerBound !== -1 && upperBound !== -1) {
        if (this._timeline[lowerBound].time !== startTime) {
          lowerBound += 1;
        }
        if (this._timeline[upperBound].time === endTime) {
          upperBound -= 1;
        }
        this._iterate(callback, lowerBound, upperBound);
      } else if (lowerBound === -1) {
        this._iterate(callback, 0, upperBound);
      }
      return this;
    }
    forEachFrom(time, callback) {
      let lowerBound = this._search(time);
      while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {
        lowerBound--;
      }
      this._iterate(callback, lowerBound + 1);
      return this;
    }
    forEachAtTime(time, callback) {
      const upperBound = this._search(time);
      if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {
        let lowerBound = upperBound;
        for (let i8 = upperBound; i8 >= 0; i8--) {
          if (EQ(this._timeline[i8].time, time)) {
            lowerBound = i8;
          } else {
            break;
          }
        }
        this._iterate((event) => {
          callback(event);
        }, lowerBound, upperBound);
      }
      return this;
    }
    dispose() {
      super.dispose();
      this._timeline = [];
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/ContextInitialization.js
  var notifyNewContext = [];
  function onContextInit(cb) {
    notifyNewContext.push(cb);
  }
  function initializeContext(ctx) {
    notifyNewContext.forEach((cb) => cb(ctx));
  }
  var notifyCloseContext = [];
  function onContextClose(cb) {
    notifyCloseContext.push(cb);
  }
  function closeContext(ctx) {
    notifyCloseContext.forEach((cb) => cb(ctx));
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/Emitter.js
  var Emitter = class extends Tone {
    constructor() {
      super(...arguments);
      this.name = "Emitter";
    }
    on(event, callback) {
      const events = event.split(/\W+/);
      events.forEach((eventName) => {
        if (isUndef(this._events)) {
          this._events = {};
        }
        if (!this._events.hasOwnProperty(eventName)) {
          this._events[eventName] = [];
        }
        this._events[eventName].push(callback);
      });
      return this;
    }
    once(event, callback) {
      const boundCallback = (...args) => {
        callback(...args);
        this.off(event, boundCallback);
      };
      this.on(event, boundCallback);
      return this;
    }
    off(event, callback) {
      const events = event.split(/\W+/);
      events.forEach((eventName) => {
        if (isUndef(this._events)) {
          this._events = {};
        }
        if (this._events.hasOwnProperty(eventName)) {
          if (isUndef(callback)) {
            this._events[eventName] = [];
          } else {
            const eventList = this._events[eventName];
            for (let i8 = eventList.length - 1; i8 >= 0; i8--) {
              if (eventList[i8] === callback) {
                eventList.splice(i8, 1);
              }
            }
          }
        }
      });
      return this;
    }
    emit(event, ...args) {
      if (this._events) {
        if (this._events.hasOwnProperty(event)) {
          const eventList = this._events[event].slice(0);
          for (let i8 = 0, len = eventList.length; i8 < len; i8++) {
            eventList[i8].apply(this, args);
          }
        }
      }
      return this;
    }
    static mixin(constr) {
      ["on", "once", "off", "emit"].forEach((name2) => {
        const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name2);
        Object.defineProperty(constr.prototype, name2, property);
      });
    }
    dispose() {
      super.dispose();
      this._events = void 0;
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/BaseContext.js
  var BaseContext = class extends Emitter {
    constructor() {
      super(...arguments);
      this.isOffline = false;
    }
    toJSON() {
      return {};
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/Context.js
  var Context = class extends BaseContext {
    constructor() {
      var _a3, _b;
      super();
      this.name = "Context";
      this._constants = /* @__PURE__ */ new Map();
      this._timeouts = new Timeline();
      this._timeoutIds = 0;
      this._initialized = false;
      this.isOffline = false;
      this._workletPromise = null;
      const options2 = optionsFromArguments(Context.getDefaults(), arguments, [
        "context"
      ]);
      if (options2.context) {
        this._context = options2.context;
        this._latencyHint = ((_a3 = arguments[0]) === null || _a3 === void 0 ? void 0 : _a3.latencyHint) || "";
      } else {
        this._context = createAudioContext({
          latencyHint: options2.latencyHint
        });
        this._latencyHint = options2.latencyHint;
      }
      this._ticker = new Ticker(this.emit.bind(this, "tick"), options2.clockSource, options2.updateInterval, this._context.sampleRate);
      this.on("tick", this._timeoutLoop.bind(this));
      this._context.onstatechange = () => {
        this.emit("statechange", this.state);
      };
      this[((_b = arguments[0]) === null || _b === void 0 ? void 0 : _b.hasOwnProperty("updateInterval")) ? "_lookAhead" : "lookAhead"] = options2.lookAhead;
    }
    static getDefaults() {
      return {
        clockSource: "worker",
        latencyHint: "interactive",
        lookAhead: 0.1,
        updateInterval: 0.05
      };
    }
    initialize() {
      if (!this._initialized) {
        initializeContext(this);
        this._initialized = true;
      }
      return this;
    }
    createAnalyser() {
      return this._context.createAnalyser();
    }
    createOscillator() {
      return this._context.createOscillator();
    }
    createBufferSource() {
      return this._context.createBufferSource();
    }
    createBiquadFilter() {
      return this._context.createBiquadFilter();
    }
    createBuffer(numberOfChannels, length, sampleRate) {
      return this._context.createBuffer(numberOfChannels, length, sampleRate);
    }
    createChannelMerger(numberOfInputs) {
      return this._context.createChannelMerger(numberOfInputs);
    }
    createChannelSplitter(numberOfOutputs) {
      return this._context.createChannelSplitter(numberOfOutputs);
    }
    createConstantSource() {
      return this._context.createConstantSource();
    }
    createConvolver() {
      return this._context.createConvolver();
    }
    createDelay(maxDelayTime) {
      return this._context.createDelay(maxDelayTime);
    }
    createDynamicsCompressor() {
      return this._context.createDynamicsCompressor();
    }
    createGain() {
      return this._context.createGain();
    }
    createIIRFilter(feedForward, feedback) {
      return this._context.createIIRFilter(feedForward, feedback);
    }
    createPanner() {
      return this._context.createPanner();
    }
    createPeriodicWave(real, imag, constraints) {
      return this._context.createPeriodicWave(real, imag, constraints);
    }
    createStereoPanner() {
      return this._context.createStereoPanner();
    }
    createWaveShaper() {
      return this._context.createWaveShaper();
    }
    createMediaStreamSource(stream) {
      assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
      const context2 = this._context;
      return context2.createMediaStreamSource(stream);
    }
    createMediaElementSource(element) {
      assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
      const context2 = this._context;
      return context2.createMediaElementSource(element);
    }
    createMediaStreamDestination() {
      assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
      const context2 = this._context;
      return context2.createMediaStreamDestination();
    }
    decodeAudioData(audioData) {
      return this._context.decodeAudioData(audioData);
    }
    get currentTime() {
      return this._context.currentTime;
    }
    get state() {
      return this._context.state;
    }
    get sampleRate() {
      return this._context.sampleRate;
    }
    get listener() {
      this.initialize();
      return this._listener;
    }
    set listener(l5) {
      assert(!this._initialized, "The listener cannot be set after initialization.");
      this._listener = l5;
    }
    get transport() {
      this.initialize();
      return this._transport;
    }
    set transport(t8) {
      assert(!this._initialized, "The transport cannot be set after initialization.");
      this._transport = t8;
    }
    get draw() {
      this.initialize();
      return this._draw;
    }
    set draw(d5) {
      assert(!this._initialized, "Draw cannot be set after initialization.");
      this._draw = d5;
    }
    get destination() {
      this.initialize();
      return this._destination;
    }
    set destination(d5) {
      assert(!this._initialized, "The destination cannot be set after initialization.");
      this._destination = d5;
    }
    createAudioWorkletNode(name2, options2) {
      return createAudioWorkletNode(this.rawContext, name2, options2);
    }
    addAudioWorkletModule(url) {
      return __awaiter(this, void 0, void 0, function* () {
        assert(isDefined(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)");
        if (!this._workletPromise) {
          this._workletPromise = this.rawContext.audioWorklet.addModule(url);
        }
        yield this._workletPromise;
      });
    }
    workletsAreReady() {
      return __awaiter(this, void 0, void 0, function* () {
        (yield this._workletPromise) ? this._workletPromise : Promise.resolve();
      });
    }
    get updateInterval() {
      return this._ticker.updateInterval;
    }
    set updateInterval(interval2) {
      this._ticker.updateInterval = interval2;
    }
    get clockSource() {
      return this._ticker.type;
    }
    set clockSource(type) {
      this._ticker.type = type;
    }
    get lookAhead() {
      return this._lookAhead;
    }
    set lookAhead(time) {
      this._lookAhead = time;
      this.updateInterval = time ? time / 2 : 0.01;
    }
    get latencyHint() {
      return this._latencyHint;
    }
    get rawContext() {
      return this._context;
    }
    now() {
      return this._context.currentTime + this._lookAhead;
    }
    immediate() {
      return this._context.currentTime;
    }
    resume() {
      if (isAudioContext(this._context)) {
        return this._context.resume();
      } else {
        return Promise.resolve();
      }
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        if (isAudioContext(this._context)) {
          yield this._context.close();
        }
        if (this._initialized) {
          closeContext(this);
        }
      });
    }
    getConstant(val) {
      if (this._constants.has(val)) {
        return this._constants.get(val);
      } else {
        const buffer2 = this._context.createBuffer(1, 128, this._context.sampleRate);
        const arr = buffer2.getChannelData(0);
        for (let i8 = 0; i8 < arr.length; i8++) {
          arr[i8] = val;
        }
        const constant = this._context.createBufferSource();
        constant.channelCount = 1;
        constant.channelCountMode = "explicit";
        constant.buffer = buffer2;
        constant.loop = true;
        constant.start(0);
        this._constants.set(val, constant);
        return constant;
      }
    }
    dispose() {
      super.dispose();
      this._ticker.dispose();
      this._timeouts.dispose();
      Object.keys(this._constants).map((val) => this._constants[val].disconnect());
      return this;
    }
    _timeoutLoop() {
      const now2 = this.now();
      let firstEvent = this._timeouts.peek();
      while (this._timeouts.length && firstEvent && firstEvent.time <= now2) {
        firstEvent.callback();
        this._timeouts.shift();
        firstEvent = this._timeouts.peek();
      }
    }
    setTimeout(fn, timeout) {
      this._timeoutIds++;
      const now2 = this.now();
      this._timeouts.add({
        callback: fn,
        id: this._timeoutIds,
        time: now2 + timeout
      });
      return this._timeoutIds;
    }
    clearTimeout(id) {
      this._timeouts.forEach((event) => {
        if (event.id === id) {
          this._timeouts.remove(event);
        }
      });
      return this;
    }
    clearInterval(id) {
      return this.clearTimeout(id);
    }
    setInterval(fn, interval2) {
      const id = ++this._timeoutIds;
      const intervalFn = () => {
        const now2 = this.now();
        this._timeouts.add({
          callback: () => {
            fn();
            intervalFn();
          },
          id,
          time: now2 + interval2
        });
      };
      intervalFn();
      return id;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/DummyContext.js
  var DummyContext = class extends BaseContext {
    constructor() {
      super(...arguments);
      this.lookAhead = 0;
      this.latencyHint = 0;
      this.isOffline = false;
    }
    createAnalyser() {
      return {};
    }
    createOscillator() {
      return {};
    }
    createBufferSource() {
      return {};
    }
    createBiquadFilter() {
      return {};
    }
    createBuffer(_numberOfChannels, _length, _sampleRate) {
      return {};
    }
    createChannelMerger(_numberOfInputs) {
      return {};
    }
    createChannelSplitter(_numberOfOutputs) {
      return {};
    }
    createConstantSource() {
      return {};
    }
    createConvolver() {
      return {};
    }
    createDelay(_maxDelayTime) {
      return {};
    }
    createDynamicsCompressor() {
      return {};
    }
    createGain() {
      return {};
    }
    createIIRFilter(_feedForward, _feedback) {
      return {};
    }
    createPanner() {
      return {};
    }
    createPeriodicWave(_real, _imag, _constraints) {
      return {};
    }
    createStereoPanner() {
      return {};
    }
    createWaveShaper() {
      return {};
    }
    createMediaStreamSource(_stream) {
      return {};
    }
    createMediaElementSource(_element) {
      return {};
    }
    createMediaStreamDestination() {
      return {};
    }
    decodeAudioData(_audioData) {
      return Promise.resolve({});
    }
    createAudioWorkletNode(_name, _options) {
      return {};
    }
    get rawContext() {
      return {};
    }
    addAudioWorkletModule(_url) {
      return __awaiter(this, void 0, void 0, function* () {
        return Promise.resolve();
      });
    }
    resume() {
      return Promise.resolve();
    }
    setTimeout(_fn, _timeout) {
      return 0;
    }
    clearTimeout(_id) {
      return this;
    }
    setInterval(_fn, _interval) {
      return 0;
    }
    clearInterval(_id) {
      return this;
    }
    getConstant(_val) {
      return {};
    }
    get currentTime() {
      return 0;
    }
    get state() {
      return {};
    }
    get sampleRate() {
      return 0;
    }
    get listener() {
      return {};
    }
    get transport() {
      return {};
    }
    get draw() {
      return {};
    }
    set draw(_d) {
    }
    get destination() {
      return {};
    }
    set destination(_d) {
    }
    now() {
      return 0;
    }
    immediate() {
      return 0;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/Interface.js
  function readOnly(target, property) {
    if (isArray(property)) {
      property.forEach((str) => readOnly(target, str));
    } else {
      Object.defineProperty(target, property, {
        enumerable: true,
        writable: false
      });
    }
  }
  function writable(target, property) {
    if (isArray(property)) {
      property.forEach((str) => writable(target, str));
    } else {
      Object.defineProperty(target, property, {
        writable: true
      });
    }
  }
  var noOp = () => {
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/ToneAudioBuffer.js
  var ToneAudioBuffer = class extends Tone {
    constructor() {
      super();
      this.name = "ToneAudioBuffer";
      this.onload = noOp;
      const options2 = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, ["url", "onload", "onerror"]);
      this.reverse = options2.reverse;
      this.onload = options2.onload;
      if (isString(options2.url)) {
        this.load(options2.url).catch(options2.onerror);
      } else if (options2.url) {
        this.set(options2.url);
      }
    }
    static getDefaults() {
      return {
        onerror: noOp,
        onload: noOp,
        reverse: false
      };
    }
    get sampleRate() {
      if (this._buffer) {
        return this._buffer.sampleRate;
      } else {
        return getContext().sampleRate;
      }
    }
    set(buffer2) {
      if (buffer2 instanceof ToneAudioBuffer) {
        if (buffer2.loaded) {
          this._buffer = buffer2.get();
        } else {
          buffer2.onload = () => {
            this.set(buffer2);
            this.onload(this);
          };
        }
      } else {
        this._buffer = buffer2;
      }
      if (this._reversed) {
        this._reverse();
      }
      return this;
    }
    get() {
      return this._buffer;
    }
    load(url) {
      return __awaiter(this, void 0, void 0, function* () {
        const doneLoading = ToneAudioBuffer.load(url).then((audioBuffer) => {
          this.set(audioBuffer);
          this.onload(this);
        });
        ToneAudioBuffer.downloads.push(doneLoading);
        try {
          yield doneLoading;
        } finally {
          const index15 = ToneAudioBuffer.downloads.indexOf(doneLoading);
          ToneAudioBuffer.downloads.splice(index15, 1);
        }
        return this;
      });
    }
    dispose() {
      super.dispose();
      this._buffer = void 0;
      return this;
    }
    fromArray(array) {
      const isMultidimensional = isArray(array) && array[0].length > 0;
      const channels2 = isMultidimensional ? array.length : 1;
      const len = isMultidimensional ? array[0].length : array.length;
      const context2 = getContext();
      const buffer2 = context2.createBuffer(channels2, len, context2.sampleRate);
      const multiChannelArray = !isMultidimensional && channels2 === 1 ? [array] : array;
      for (let c6 = 0; c6 < channels2; c6++) {
        buffer2.copyToChannel(multiChannelArray[c6], c6);
      }
      this._buffer = buffer2;
      return this;
    }
    toMono(chanNum) {
      if (isNumber(chanNum)) {
        this.fromArray(this.toArray(chanNum));
      } else {
        let outputArray = new Float32Array(this.length);
        const numChannels = this.numberOfChannels;
        for (let channel = 0; channel < numChannels; channel++) {
          const channelArray = this.toArray(channel);
          for (let i8 = 0; i8 < channelArray.length; i8++) {
            outputArray[i8] += channelArray[i8];
          }
        }
        outputArray = outputArray.map((sample) => sample / numChannels);
        this.fromArray(outputArray);
      }
      return this;
    }
    toArray(channel) {
      if (isNumber(channel)) {
        return this.getChannelData(channel);
      } else if (this.numberOfChannels === 1) {
        return this.toArray(0);
      } else {
        const ret = [];
        for (let c6 = 0; c6 < this.numberOfChannels; c6++) {
          ret[c6] = this.getChannelData(c6);
        }
        return ret;
      }
    }
    getChannelData(channel) {
      if (this._buffer) {
        return this._buffer.getChannelData(channel);
      } else {
        return new Float32Array(0);
      }
    }
    slice(start3, end = this.duration) {
      assert(this.loaded, "Buffer is not loaded");
      const startSamples = Math.floor(start3 * this.sampleRate);
      const endSamples = Math.floor(end * this.sampleRate);
      assert(startSamples < endSamples, "The start time must be less than the end time");
      const length = endSamples - startSamples;
      const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);
      for (let channel = 0; channel < this.numberOfChannels; channel++) {
        retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);
      }
      return new ToneAudioBuffer(retBuffer);
    }
    _reverse() {
      if (this.loaded) {
        for (let i8 = 0; i8 < this.numberOfChannels; i8++) {
          this.getChannelData(i8).reverse();
        }
      }
      return this;
    }
    get loaded() {
      return this.length > 0;
    }
    get duration() {
      if (this._buffer) {
        return this._buffer.duration;
      } else {
        return 0;
      }
    }
    get length() {
      if (this._buffer) {
        return this._buffer.length;
      } else {
        return 0;
      }
    }
    get numberOfChannels() {
      if (this._buffer) {
        return this._buffer.numberOfChannels;
      } else {
        return 0;
      }
    }
    get reverse() {
      return this._reversed;
    }
    set reverse(rev) {
      if (this._reversed !== rev) {
        this._reversed = rev;
        this._reverse();
      }
    }
    static fromArray(array) {
      return new ToneAudioBuffer().fromArray(array);
    }
    static fromUrl(url) {
      return __awaiter(this, void 0, void 0, function* () {
        const buffer2 = new ToneAudioBuffer();
        return yield buffer2.load(url);
      });
    }
    static load(url) {
      return __awaiter(this, void 0, void 0, function* () {
        const matches2 = url.match(/\[([^\]\[]+\|.+)\]$/);
        if (matches2) {
          const extensions = matches2[1].split("|");
          let extension = extensions[0];
          for (const ext of extensions) {
            if (ToneAudioBuffer.supportsType(ext)) {
              extension = ext;
              break;
            }
          }
          url = url.replace(matches2[0], extension);
        }
        const baseUrl = ToneAudioBuffer.baseUrl === "" || ToneAudioBuffer.baseUrl.endsWith("/") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + "/";
        const location2 = document.createElement("a");
        location2.href = baseUrl + url;
        location2.pathname = (location2.pathname + location2.hash).split("/").map(encodeURIComponent).join("/");
        const response = yield fetch(location2.href);
        if (!response.ok) {
          throw new Error(`could not load url: ${url}`);
        }
        const arrayBuffer = yield response.arrayBuffer();
        const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);
        return audioBuffer;
      });
    }
    static supportsType(url) {
      const extensions = url.split(".");
      const extension = extensions[extensions.length - 1];
      const response = document.createElement("audio").canPlayType("audio/" + extension);
      return response !== "";
    }
    static loaded() {
      return __awaiter(this, void 0, void 0, function* () {
        yield Promise.resolve();
        while (ToneAudioBuffer.downloads.length) {
          yield ToneAudioBuffer.downloads[0];
        }
      });
    }
  };
  ToneAudioBuffer.baseUrl = "";
  ToneAudioBuffer.downloads = [];

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/OfflineContext.js
  var OfflineContext = class extends Context {
    constructor() {
      super({
        clockSource: "offline",
        context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),
        lookAhead: 0,
        updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
      });
      this.name = "OfflineContext";
      this._currentTime = 0;
      this.isOffline = true;
      this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
    }
    now() {
      return this._currentTime;
    }
    get currentTime() {
      return this._currentTime;
    }
    _renderClock(asynchronous) {
      return __awaiter(this, void 0, void 0, function* () {
        let index15 = 0;
        while (this._duration - this._currentTime >= 0) {
          this.emit("tick");
          this._currentTime += 128 / this.sampleRate;
          index15++;
          const yieldEvery = Math.floor(this.sampleRate / 128);
          if (asynchronous && index15 % yieldEvery === 0) {
            yield new Promise((done) => setTimeout(done, 1));
          }
        }
      });
    }
    render(asynchronous = true) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.workletsAreReady();
        yield this._renderClock(asynchronous);
        const buffer2 = yield this._context.startRendering();
        return new ToneAudioBuffer(buffer2);
      });
    }
    close() {
      return Promise.resolve();
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/Global.js
  var dummyContext = new DummyContext();
  var globalContext = dummyContext;
  function getContext() {
    if (globalContext === dummyContext && hasAudioContext) {
      setContext(new Context());
    }
    return globalContext;
  }
  function setContext(context2, disposeOld = false) {
    if (disposeOld) {
      globalContext.dispose();
    }
    if (isAudioContext(context2)) {
      globalContext = new Context(context2);
    } else if (isOfflineAudioContext(context2)) {
      globalContext = new OfflineContext(context2);
    } else {
      globalContext = context2;
    }
  }
  function start() {
    return globalContext.resume();
  }
  if (theWindow && !theWindow.TONE_SILENCE_LOGGING) {
    let prefix = "v";
    if (version === "dev") {
      prefix = "";
    }
    const printString = ` * Tone.js ${prefix}${version} * `;
    console.log(`%c${printString}`, "background: #000; color: #fff");
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/type/Conversions.js
  function dbToGain(db) {
    return Math.pow(10, db / 20);
  }
  function gainToDb(gain) {
    return 20 * (Math.log(gain) / Math.LN10);
  }
  function intervalToFrequencyRatio(interval2) {
    return Math.pow(2, interval2 / 12);
  }
  var A4 = 440;
  function getA4() {
    return A4;
  }
  function setA4(freq2) {
    A4 = freq2;
  }
  function ftom(frequency) {
    return Math.round(ftomf(frequency));
  }
  function ftomf(frequency) {
    return 69 + 12 * Math.log2(frequency / A4);
  }
  function mtof(midi4) {
    return A4 * Math.pow(2, (midi4 - 69) / 12);
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/type/TimeBase.js
  var TimeBaseClass = class extends Tone {
    constructor(context2, value, units) {
      super();
      this.defaultUnits = "s";
      this._val = value;
      this._units = units;
      this.context = context2;
      this._expressions = this._getExpressions();
    }
    _getExpressions() {
      return {
        hz: {
          method: (value) => {
            return this._frequencyToUnits(parseFloat(value));
          },
          regexp: /^(\d+(?:\.\d+)?)hz$/i
        },
        i: {
          method: (value) => {
            return this._ticksToUnits(parseInt(value, 10));
          },
          regexp: /^(\d+)i$/i
        },
        m: {
          method: (value) => {
            return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());
          },
          regexp: /^(\d+)m$/i
        },
        n: {
          method: (value, dot) => {
            const numericValue = parseInt(value, 10);
            const scalar = dot === "." ? 1.5 : 1;
            if (numericValue === 1) {
              return this._beatsToUnits(this._getTimeSignature()) * scalar;
            } else {
              return this._beatsToUnits(4 / numericValue) * scalar;
            }
          },
          regexp: /^(\d+)n(\.?)$/i
        },
        number: {
          method: (value) => {
            return this._expressions[this.defaultUnits].method.call(this, value);
          },
          regexp: /^(\d+(?:\.\d+)?)$/
        },
        s: {
          method: (value) => {
            return this._secondsToUnits(parseFloat(value));
          },
          regexp: /^(\d+(?:\.\d+)?)s$/
        },
        samples: {
          method: (value) => {
            return parseInt(value, 10) / this.context.sampleRate;
          },
          regexp: /^(\d+)samples$/
        },
        t: {
          method: (value) => {
            const numericValue = parseInt(value, 10);
            return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));
          },
          regexp: /^(\d+)t$/i
        },
        tr: {
          method: (m3, q, s4) => {
            let total = 0;
            if (m3 && m3 !== "0") {
              total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m3));
            }
            if (q && q !== "0") {
              total += this._beatsToUnits(parseFloat(q));
            }
            if (s4 && s4 !== "0") {
              total += this._beatsToUnits(parseFloat(s4) / 4);
            }
            return total;
          },
          regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
        }
      };
    }
    valueOf() {
      if (this._val instanceof TimeBaseClass) {
        this.fromType(this._val);
      }
      if (isUndef(this._val)) {
        return this._noArg();
      } else if (isString(this._val) && isUndef(this._units)) {
        for (const units in this._expressions) {
          if (this._expressions[units].regexp.test(this._val.trim())) {
            this._units = units;
            break;
          }
        }
      } else if (isObject(this._val)) {
        let total = 0;
        for (const typeName in this._val) {
          if (isDefined(this._val[typeName])) {
            const quantity = this._val[typeName];
            const time = new this.constructor(this.context, typeName).valueOf() * quantity;
            total += time;
          }
        }
        return total;
      }
      if (isDefined(this._units)) {
        const expr = this._expressions[this._units];
        const matching = this._val.toString().trim().match(expr.regexp);
        if (matching) {
          return expr.method.apply(this, matching.slice(1));
        } else {
          return expr.method.call(this, this._val);
        }
      } else if (isString(this._val)) {
        return parseFloat(this._val);
      } else {
        return this._val;
      }
    }
    _frequencyToUnits(freq2) {
      return 1 / freq2;
    }
    _beatsToUnits(beats) {
      return 60 / this._getBpm() * beats;
    }
    _secondsToUnits(seconds) {
      return seconds;
    }
    _ticksToUnits(ticks) {
      return ticks * this._beatsToUnits(1) / this._getPPQ();
    }
    _noArg() {
      return this._now();
    }
    _getBpm() {
      return this.context.transport.bpm.value;
    }
    _getTimeSignature() {
      return this.context.transport.timeSignature;
    }
    _getPPQ() {
      return this.context.transport.PPQ;
    }
    fromType(type) {
      this._units = void 0;
      switch (this.defaultUnits) {
        case "s":
          this._val = type.toSeconds();
          break;
        case "i":
          this._val = type.toTicks();
          break;
        case "hz":
          this._val = type.toFrequency();
          break;
        case "midi":
          this._val = type.toMidi();
          break;
      }
      return this;
    }
    toFrequency() {
      return 1 / this.toSeconds();
    }
    toSamples() {
      return this.toSeconds() * this.context.sampleRate;
    }
    toMilliseconds() {
      return this.toSeconds() * 1e3;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/type/Time.js
  var TimeClass = class extends TimeBaseClass {
    constructor() {
      super(...arguments);
      this.name = "TimeClass";
    }
    _getExpressions() {
      return Object.assign(super._getExpressions(), {
        now: {
          method: (capture) => {
            return this._now() + new this.constructor(this.context, capture).valueOf();
          },
          regexp: /^\+(.+)/
        },
        quantize: {
          method: (capture) => {
            const quantTo = new TimeClass(this.context, capture).valueOf();
            return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));
          },
          regexp: /^@(.+)/
        }
      });
    }
    quantize(subdiv, percent = 1) {
      const subdivision = new this.constructor(this.context, subdiv).valueOf();
      const value = this.valueOf();
      const multiple = Math.round(value / subdivision);
      const ideal = multiple * subdivision;
      const diff = ideal - value;
      return value + diff * percent;
    }
    toNotation() {
      const time = this.toSeconds();
      const testNotations = ["1m"];
      for (let power = 1; power < 9; power++) {
        const subdiv = Math.pow(2, power);
        testNotations.push(subdiv + "n.");
        testNotations.push(subdiv + "n");
        testNotations.push(subdiv + "t");
      }
      testNotations.push("0");
      let closest = testNotations[0];
      let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();
      testNotations.forEach((notation) => {
        const notationSeconds = new TimeClass(this.context, notation).toSeconds();
        if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {
          closest = notation;
          closestSeconds = notationSeconds;
        }
      });
      return closest;
    }
    toBarsBeatsSixteenths() {
      const quarterTime = this._beatsToUnits(1);
      let quarters = this.valueOf() / quarterTime;
      quarters = parseFloat(quarters.toFixed(4));
      const measures = Math.floor(quarters / this._getTimeSignature());
      let sixteenths = quarters % 1 * 4;
      quarters = Math.floor(quarters) % this._getTimeSignature();
      const sixteenthString = sixteenths.toString();
      if (sixteenthString.length > 3) {
        sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));
      }
      const progress = [measures, quarters, sixteenths];
      return progress.join(":");
    }
    toTicks() {
      const quarterTime = this._beatsToUnits(1);
      const quarters = this.valueOf() / quarterTime;
      return quarters * this._getPPQ();
    }
    toSeconds() {
      return this.valueOf();
    }
    toMidi() {
      return ftom(this.toFrequency());
    }
    _now() {
      return this.context.now();
    }
  };
  function Time(value, units) {
    return new TimeClass(getContext(), value, units);
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/type/Frequency.js
  var FrequencyClass = class extends TimeClass {
    constructor() {
      super(...arguments);
      this.name = "Frequency";
      this.defaultUnits = "hz";
    }
    static get A4() {
      return getA4();
    }
    static set A4(freq2) {
      setA4(freq2);
    }
    _getExpressions() {
      return Object.assign({}, super._getExpressions(), {
        midi: {
          regexp: /^(\d+(?:\.\d+)?midi)/,
          method(value) {
            if (this.defaultUnits === "midi") {
              return value;
            } else {
              return FrequencyClass.mtof(value);
            }
          }
        },
        note: {
          regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
          method(pitch, octave2) {
            const index15 = noteToScaleIndex[pitch.toLowerCase()];
            const noteNumber = index15 + (parseInt(octave2, 10) + 1) * 12;
            if (this.defaultUnits === "midi") {
              return noteNumber;
            } else {
              return FrequencyClass.mtof(noteNumber);
            }
          }
        },
        tr: {
          regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
          method(m3, q, s4) {
            let total = 1;
            if (m3 && m3 !== "0") {
              total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m3));
            }
            if (q && q !== "0") {
              total *= this._beatsToUnits(parseFloat(q));
            }
            if (s4 && s4 !== "0") {
              total *= this._beatsToUnits(parseFloat(s4) / 4);
            }
            return total;
          }
        }
      });
    }
    transpose(interval2) {
      return new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval2));
    }
    harmonize(intervals3) {
      return intervals3.map((interval2) => {
        return this.transpose(interval2);
      });
    }
    toMidi() {
      return ftom(this.valueOf());
    }
    toNote() {
      const freq2 = this.toFrequency();
      const log2 = Math.log2(freq2 / FrequencyClass.A4);
      let noteNumber = Math.round(12 * log2) + 57;
      const octave2 = Math.floor(noteNumber / 12);
      if (octave2 < 0) {
        noteNumber += -12 * octave2;
      }
      const noteName = scaleIndexToNote[noteNumber % 12];
      return noteName + octave2.toString();
    }
    toSeconds() {
      return 1 / super.toSeconds();
    }
    toTicks() {
      const quarterTime = this._beatsToUnits(1);
      const quarters = this.valueOf() / quarterTime;
      return Math.floor(quarters * this._getPPQ());
    }
    _noArg() {
      return 0;
    }
    _frequencyToUnits(freq2) {
      return freq2;
    }
    _ticksToUnits(ticks) {
      return 1 / (ticks * 60 / (this._getBpm() * this._getPPQ()));
    }
    _beatsToUnits(beats) {
      return 1 / super._beatsToUnits(beats);
    }
    _secondsToUnits(seconds) {
      return 1 / seconds;
    }
    static mtof(midi4) {
      return mtof(midi4);
    }
    static ftom(frequency) {
      return ftom(frequency);
    }
  };
  var noteToScaleIndex = {
    cbbb: -3,
    cbb: -2,
    cb: -1,
    c: 0,
    "c#": 1,
    cx: 2,
    "c##": 2,
    "c###": 3,
    "cx#": 3,
    "c#x": 3,
    dbbb: -1,
    dbb: 0,
    db: 1,
    d: 2,
    "d#": 3,
    dx: 4,
    "d##": 4,
    "d###": 5,
    "dx#": 5,
    "d#x": 5,
    ebbb: 1,
    ebb: 2,
    eb: 3,
    e: 4,
    "e#": 5,
    ex: 6,
    "e##": 6,
    "e###": 7,
    "ex#": 7,
    "e#x": 7,
    fbbb: 2,
    fbb: 3,
    fb: 4,
    f: 5,
    "f#": 6,
    fx: 7,
    "f##": 7,
    "f###": 8,
    "fx#": 8,
    "f#x": 8,
    gbbb: 4,
    gbb: 5,
    gb: 6,
    g: 7,
    "g#": 8,
    gx: 9,
    "g##": 9,
    "g###": 10,
    "gx#": 10,
    "g#x": 10,
    abbb: 6,
    abb: 7,
    ab: 8,
    a: 9,
    "a#": 10,
    ax: 11,
    "a##": 11,
    "a###": 12,
    "ax#": 12,
    "a#x": 12,
    bbbb: 8,
    bbb: 9,
    bb: 10,
    b: 11,
    "b#": 12,
    bx: 13,
    "b##": 13,
    "b###": 14,
    "bx#": 14,
    "b#x": 14
  };
  var scaleIndexToNote = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  function Frequency(value, units) {
    return new FrequencyClass(getContext(), value, units);
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/type/TransportTime.js
  var TransportTimeClass = class extends TimeClass {
    constructor() {
      super(...arguments);
      this.name = "TransportTime";
    }
    _now() {
      return this.context.transport.seconds;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/ToneWithContext.js
  var ToneWithContext = class extends Tone {
    constructor() {
      super();
      const options2 = optionsFromArguments(ToneWithContext.getDefaults(), arguments, ["context"]);
      if (this.defaultContext) {
        this.context = this.defaultContext;
      } else {
        this.context = options2.context;
      }
    }
    static getDefaults() {
      return {
        context: getContext()
      };
    }
    now() {
      return this.context.currentTime + this.context.lookAhead;
    }
    immediate() {
      return this.context.currentTime;
    }
    get sampleTime() {
      return 1 / this.context.sampleRate;
    }
    get blockTime() {
      return 128 / this.context.sampleRate;
    }
    toSeconds(time) {
      assertUsedScheduleTime(time);
      return new TimeClass(this.context, time).toSeconds();
    }
    toFrequency(freq2) {
      return new FrequencyClass(this.context, freq2).toFrequency();
    }
    toTicks(time) {
      return new TransportTimeClass(this.context, time).toTicks();
    }
    _getPartialProperties(props) {
      const options2 = this.get();
      Object.keys(options2).forEach((name2) => {
        if (isUndef(props[name2])) {
          delete options2[name2];
        }
      });
      return options2;
    }
    get() {
      const defaults = getDefaultsFromInstance(this);
      Object.keys(defaults).forEach((attribute) => {
        if (Reflect.has(this, attribute)) {
          const member = this[attribute];
          if (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {
            defaults[attribute] = member.value;
          } else if (member instanceof ToneWithContext) {
            defaults[attribute] = member._getPartialProperties(defaults[attribute]);
          } else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {
            defaults[attribute] = member;
          } else {
            delete defaults[attribute];
          }
        }
      });
      return defaults;
    }
    set(props) {
      Object.keys(props).forEach((attribute) => {
        if (Reflect.has(this, attribute) && isDefined(this[attribute])) {
          if (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {
            if (this[attribute].value !== props[attribute]) {
              this[attribute].value = props[attribute];
            }
          } else if (this[attribute] instanceof ToneWithContext) {
            this[attribute].set(props[attribute]);
          } else {
            this[attribute] = props[attribute];
          }
        }
      });
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/StateTimeline.js
  var StateTimeline = class extends Timeline {
    constructor(initial = "stopped") {
      super();
      this.name = "StateTimeline";
      this._initial = initial;
      this.setStateAtTime(this._initial, 0);
    }
    getValueAtTime(time) {
      const event = this.get(time);
      if (event !== null) {
        return event.state;
      } else {
        return this._initial;
      }
    }
    setStateAtTime(state, time, options2) {
      assertRange(time, 0);
      this.add(Object.assign({}, options2, {
        state,
        time
      }));
      return this;
    }
    getLastState(state, time) {
      const index15 = this._search(time);
      for (let i8 = index15; i8 >= 0; i8--) {
        const event = this._timeline[i8];
        if (event.state === state) {
          return event;
        }
      }
    }
    getNextState(state, time) {
      const index15 = this._search(time);
      if (index15 !== -1) {
        for (let i8 = index15; i8 < this._timeline.length; i8++) {
          const event = this._timeline[i8];
          if (event.state === state) {
            return event;
          }
        }
      }
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/Param.js
  var Param = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(Param.getDefaults(), arguments, ["param", "units", "convert"]));
      this.name = "Param";
      this.overridden = false;
      this._minOutput = 1e-7;
      const options2 = optionsFromArguments(Param.getDefaults(), arguments, ["param", "units", "convert"]);
      assert(isDefined(options2.param) && (isAudioParam(options2.param) || options2.param instanceof Param), "param must be an AudioParam");
      while (!isAudioParam(options2.param)) {
        options2.param = options2.param._param;
      }
      this._swappable = isDefined(options2.swappable) ? options2.swappable : false;
      if (this._swappable) {
        this.input = this.context.createGain();
        this._param = options2.param;
        this.input.connect(this._param);
      } else {
        this._param = this.input = options2.param;
      }
      this._events = new Timeline(1e3);
      this._initialValue = this._param.defaultValue;
      this.units = options2.units;
      this.convert = options2.convert;
      this._minValue = options2.minValue;
      this._maxValue = options2.maxValue;
      if (isDefined(options2.value) && options2.value !== this._toType(this._initialValue)) {
        this.setValueAtTime(options2.value, 0);
      }
    }
    static getDefaults() {
      return Object.assign(ToneWithContext.getDefaults(), {
        convert: true,
        units: "number"
      });
    }
    get value() {
      const now2 = this.now();
      return this.getValueAtTime(now2);
    }
    set value(value) {
      this.cancelScheduledValues(this.now());
      this.setValueAtTime(value, this.now());
    }
    get minValue() {
      if (isDefined(this._minValue)) {
        return this._minValue;
      } else if (this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples") {
        return 0;
      } else if (this.units === "audioRange") {
        return -1;
      } else if (this.units === "decibels") {
        return -Infinity;
      } else {
        return this._param.minValue;
      }
    }
    get maxValue() {
      if (isDefined(this._maxValue)) {
        return this._maxValue;
      } else if (this.units === "normalRange" || this.units === "audioRange") {
        return 1;
      } else {
        return this._param.maxValue;
      }
    }
    _is(arg, type) {
      return this.units === type;
    }
    _assertRange(value) {
      if (isDefined(this.maxValue) && isDefined(this.minValue)) {
        assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));
      }
      return value;
    }
    _fromType(val) {
      if (this.convert && !this.overridden) {
        if (this._is(val, "time")) {
          return this.toSeconds(val);
        } else if (this._is(val, "decibels")) {
          return dbToGain(val);
        } else if (this._is(val, "frequency")) {
          return this.toFrequency(val);
        } else {
          return val;
        }
      } else if (this.overridden) {
        return 0;
      } else {
        return val;
      }
    }
    _toType(val) {
      if (this.convert && this.units === "decibels") {
        return gainToDb(val);
      } else {
        return val;
      }
    }
    setValueAtTime(value, time) {
      const computedTime = this.toSeconds(time);
      const numericValue = this._fromType(value);
      assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);
      this._assertRange(numericValue);
      this.log(this.units, "setValueAtTime", value, computedTime);
      this._events.add({
        time: computedTime,
        type: "setValueAtTime",
        value: numericValue
      });
      this._param.setValueAtTime(numericValue, computedTime);
      return this;
    }
    getValueAtTime(time) {
      const computedTime = Math.max(this.toSeconds(time), 0);
      const after = this._events.getAfter(computedTime);
      const before = this._events.get(computedTime);
      let value = this._initialValue;
      if (before === null) {
        value = this._initialValue;
      } else if (before.type === "setTargetAtTime" && (after === null || after.type === "setValueAtTime")) {
        const previous = this._events.getBefore(before.time);
        let previousVal;
        if (previous === null) {
          previousVal = this._initialValue;
        } else {
          previousVal = previous.value;
        }
        if (before.type === "setTargetAtTime") {
          value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);
        }
      } else if (after === null) {
        value = before.value;
      } else if (after.type === "linearRampToValueAtTime" || after.type === "exponentialRampToValueAtTime") {
        let beforeValue = before.value;
        if (before.type === "setTargetAtTime") {
          const previous = this._events.getBefore(before.time);
          if (previous === null) {
            beforeValue = this._initialValue;
          } else {
            beforeValue = previous.value;
          }
        }
        if (after.type === "linearRampToValueAtTime") {
          value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
        } else {
          value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
        }
      } else {
        value = before.value;
      }
      return this._toType(value);
    }
    setRampPoint(time) {
      time = this.toSeconds(time);
      let currentVal = this.getValueAtTime(time);
      this.cancelAndHoldAtTime(time);
      if (this._fromType(currentVal) === 0) {
        currentVal = this._toType(this._minOutput);
      }
      this.setValueAtTime(currentVal, time);
      return this;
    }
    linearRampToValueAtTime(value, endTime) {
      const numericValue = this._fromType(value);
      const computedTime = this.toSeconds(endTime);
      assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
      this._assertRange(numericValue);
      this._events.add({
        time: computedTime,
        type: "linearRampToValueAtTime",
        value: numericValue
      });
      this.log(this.units, "linearRampToValueAtTime", value, computedTime);
      this._param.linearRampToValueAtTime(numericValue, computedTime);
      return this;
    }
    exponentialRampToValueAtTime(value, endTime) {
      let numericValue = this._fromType(value);
      numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;
      this._assertRange(numericValue);
      const computedTime = this.toSeconds(endTime);
      assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
      this._events.add({
        time: computedTime,
        type: "exponentialRampToValueAtTime",
        value: numericValue
      });
      this.log(this.units, "exponentialRampToValueAtTime", value, computedTime);
      this._param.exponentialRampToValueAtTime(numericValue, computedTime);
      return this;
    }
    exponentialRampTo(value, rampTime, startTime) {
      startTime = this.toSeconds(startTime);
      this.setRampPoint(startTime);
      this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
      return this;
    }
    linearRampTo(value, rampTime, startTime) {
      startTime = this.toSeconds(startTime);
      this.setRampPoint(startTime);
      this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
      return this;
    }
    targetRampTo(value, rampTime, startTime) {
      startTime = this.toSeconds(startTime);
      this.setRampPoint(startTime);
      this.exponentialApproachValueAtTime(value, startTime, rampTime);
      return this;
    }
    exponentialApproachValueAtTime(value, time, rampTime) {
      time = this.toSeconds(time);
      rampTime = this.toSeconds(rampTime);
      const timeConstant = Math.log(rampTime + 1) / Math.log(200);
      this.setTargetAtTime(value, time, timeConstant);
      this.cancelAndHoldAtTime(time + rampTime * 0.9);
      this.linearRampToValueAtTime(value, time + rampTime);
      return this;
    }
    setTargetAtTime(value, startTime, timeConstant) {
      const numericValue = this._fromType(value);
      assert(isFinite(timeConstant) && timeConstant > 0, "timeConstant must be a number greater than 0");
      const computedTime = this.toSeconds(startTime);
      this._assertRange(numericValue);
      assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);
      this._events.add({
        constant: timeConstant,
        time: computedTime,
        type: "setTargetAtTime",
        value: numericValue
      });
      this.log(this.units, "setTargetAtTime", value, computedTime, timeConstant);
      this._param.setTargetAtTime(numericValue, computedTime, timeConstant);
      return this;
    }
    setValueCurveAtTime(values, startTime, duration2, scaling = 1) {
      duration2 = this.toSeconds(duration2);
      startTime = this.toSeconds(startTime);
      const startingValue = this._fromType(values[0]) * scaling;
      this.setValueAtTime(this._toType(startingValue), startTime);
      const segTime = duration2 / (values.length - 1);
      for (let i8 = 1; i8 < values.length; i8++) {
        const numericValue = this._fromType(values[i8]) * scaling;
        this.linearRampToValueAtTime(this._toType(numericValue), startTime + i8 * segTime);
      }
      return this;
    }
    cancelScheduledValues(time) {
      const computedTime = this.toSeconds(time);
      assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);
      this._events.cancel(computedTime);
      this._param.cancelScheduledValues(computedTime);
      this.log(this.units, "cancelScheduledValues", computedTime);
      return this;
    }
    cancelAndHoldAtTime(time) {
      const computedTime = this.toSeconds(time);
      const valueAtTime = this._fromType(this.getValueAtTime(computedTime));
      assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);
      this.log(this.units, "cancelAndHoldAtTime", computedTime, "value=" + valueAtTime);
      const before = this._events.get(computedTime);
      const after = this._events.getAfter(computedTime);
      if (before && EQ(before.time, computedTime)) {
        if (after) {
          this._param.cancelScheduledValues(after.time);
          this._events.cancel(after.time);
        } else {
          this._param.cancelAndHoldAtTime(computedTime);
          this._events.cancel(computedTime + this.sampleTime);
        }
      } else if (after) {
        this._param.cancelScheduledValues(after.time);
        this._events.cancel(after.time);
        if (after.type === "linearRampToValueAtTime") {
          this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);
        } else if (after.type === "exponentialRampToValueAtTime") {
          this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);
        }
      }
      this._events.add({
        time: computedTime,
        type: "setValueAtTime",
        value: valueAtTime
      });
      this._param.setValueAtTime(valueAtTime, computedTime);
      return this;
    }
    rampTo(value, rampTime = 0.1, startTime) {
      if (this.units === "frequency" || this.units === "bpm" || this.units === "decibels") {
        this.exponentialRampTo(value, rampTime, startTime);
      } else {
        this.linearRampTo(value, rampTime, startTime);
      }
      return this;
    }
    apply(param) {
      const now2 = this.context.currentTime;
      param.setValueAtTime(this.getValueAtTime(now2), now2);
      const previousEvent = this._events.get(now2);
      if (previousEvent && previousEvent.type === "setTargetAtTime") {
        const nextEvent = this._events.getAfter(previousEvent.time);
        const endTime = nextEvent ? nextEvent.time : now2 + 2;
        const subdivisions = (endTime - now2) / 10;
        for (let i8 = now2; i8 < endTime; i8 += subdivisions) {
          param.linearRampToValueAtTime(this.getValueAtTime(i8), i8);
        }
      }
      this._events.forEachAfter(this.context.currentTime, (event) => {
        if (event.type === "cancelScheduledValues") {
          param.cancelScheduledValues(event.time);
        } else if (event.type === "setTargetAtTime") {
          param.setTargetAtTime(event.value, event.time, event.constant);
        } else {
          param[event.type](event.value, event.time);
        }
      });
      return this;
    }
    setParam(param) {
      assert(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
      const input2 = this.input;
      input2.disconnect(this._param);
      this.apply(param);
      this._param = param;
      input2.connect(this._param);
      return this;
    }
    dispose() {
      super.dispose();
      this._events.dispose();
      return this;
    }
    get defaultValue() {
      return this._toType(this._param.defaultValue);
    }
    _exponentialApproach(t0, v0, v1, timeConstant, t8) {
      return v1 + (v0 - v1) * Math.exp(-(t8 - t0) / timeConstant);
    }
    _linearInterpolate(t0, v0, t1, v1, t8) {
      return v0 + (v1 - v0) * ((t8 - t0) / (t1 - t0));
    }
    _exponentialInterpolate(t0, v0, t1, v1, t8) {
      return v0 * Math.pow(v1 / v0, (t8 - t0) / (t1 - t0));
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/ToneAudioNode.js
  var ToneAudioNode = class extends ToneWithContext {
    constructor() {
      super(...arguments);
      this._internalChannels = [];
    }
    get numberOfInputs() {
      if (isDefined(this.input)) {
        if (isAudioParam(this.input) || this.input instanceof Param) {
          return 1;
        } else {
          return this.input.numberOfInputs;
        }
      } else {
        return 0;
      }
    }
    get numberOfOutputs() {
      if (isDefined(this.output)) {
        return this.output.numberOfOutputs;
      } else {
        return 0;
      }
    }
    _isAudioNode(node) {
      return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode2(node));
    }
    _getInternalNodes() {
      const nodeList = this._internalChannels.slice(0);
      if (this._isAudioNode(this.input)) {
        nodeList.push(this.input);
      }
      if (this._isAudioNode(this.output)) {
        if (this.input !== this.output) {
          nodeList.push(this.output);
        }
      }
      return nodeList;
    }
    _setChannelProperties(options2) {
      const nodeList = this._getInternalNodes();
      nodeList.forEach((node) => {
        node.channelCount = options2.channelCount;
        node.channelCountMode = options2.channelCountMode;
        node.channelInterpretation = options2.channelInterpretation;
      });
    }
    _getChannelProperties() {
      const nodeList = this._getInternalNodes();
      assert(nodeList.length > 0, "ToneAudioNode does not have any internal nodes");
      const node = nodeList[0];
      return {
        channelCount: node.channelCount,
        channelCountMode: node.channelCountMode,
        channelInterpretation: node.channelInterpretation
      };
    }
    get channelCount() {
      return this._getChannelProperties().channelCount;
    }
    set channelCount(channelCount) {
      const props = this._getChannelProperties();
      this._setChannelProperties(Object.assign(props, { channelCount }));
    }
    get channelCountMode() {
      return this._getChannelProperties().channelCountMode;
    }
    set channelCountMode(channelCountMode) {
      const props = this._getChannelProperties();
      this._setChannelProperties(Object.assign(props, { channelCountMode }));
    }
    get channelInterpretation() {
      return this._getChannelProperties().channelInterpretation;
    }
    set channelInterpretation(channelInterpretation) {
      const props = this._getChannelProperties();
      this._setChannelProperties(Object.assign(props, { channelInterpretation }));
    }
    connect(destination, outputNum = 0, inputNum = 0) {
      connect(this, destination, outputNum, inputNum);
      return this;
    }
    toDestination() {
      this.connect(this.context.destination);
      return this;
    }
    toMaster() {
      warn("toMaster() has been renamed toDestination()");
      return this.toDestination();
    }
    disconnect(destination, outputNum = 0, inputNum = 0) {
      disconnect(this, destination, outputNum, inputNum);
      return this;
    }
    chain(...nodes) {
      connectSeries(this, ...nodes);
      return this;
    }
    fan(...nodes) {
      nodes.forEach((node) => this.connect(node));
      return this;
    }
    dispose() {
      super.dispose();
      if (isDefined(this.input)) {
        if (this.input instanceof ToneAudioNode) {
          this.input.dispose();
        } else if (isAudioNode2(this.input)) {
          this.input.disconnect();
        }
      }
      if (isDefined(this.output)) {
        if (this.output instanceof ToneAudioNode) {
          this.output.dispose();
        } else if (isAudioNode2(this.output)) {
          this.output.disconnect();
        }
      }
      this._internalChannels = [];
      return this;
    }
  };
  function connectSeries(...nodes) {
    const first = nodes.shift();
    nodes.reduce((prev, current) => {
      if (prev instanceof ToneAudioNode) {
        prev.connect(current);
      } else if (isAudioNode2(prev)) {
        connect(prev, current);
      }
      return current;
    }, first);
  }
  function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
    assert(isDefined(srcNode), "Cannot connect from undefined node");
    assert(isDefined(dstNode), "Cannot connect to undefined node");
    if (dstNode instanceof ToneAudioNode || isAudioNode2(dstNode)) {
      assert(dstNode.numberOfInputs > 0, "Cannot connect to node with no inputs");
    }
    assert(srcNode.numberOfOutputs > 0, "Cannot connect from node with no outputs");
    while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {
      if (isDefined(dstNode.input)) {
        dstNode = dstNode.input;
      }
    }
    while (srcNode instanceof ToneAudioNode) {
      if (isDefined(srcNode.output)) {
        srcNode = srcNode.output;
      }
    }
    if (isAudioParam(dstNode)) {
      srcNode.connect(dstNode, outputNumber);
    } else {
      srcNode.connect(dstNode, outputNumber, inputNumber);
    }
  }
  function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
    if (isDefined(dstNode)) {
      while (dstNode instanceof ToneAudioNode) {
        dstNode = dstNode.input;
      }
    }
    while (!isAudioNode2(srcNode)) {
      if (isDefined(srcNode.output)) {
        srcNode = srcNode.output;
      }
    }
    if (isAudioParam(dstNode)) {
      srcNode.disconnect(dstNode, outputNumber);
    } else if (isAudioNode2(dstNode)) {
      srcNode.disconnect(dstNode, outputNumber, inputNumber);
    } else {
      srcNode.disconnect();
    }
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/Gain.js
  var Gain = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Gain.getDefaults(), arguments, ["gain", "units"]));
      this.name = "Gain";
      this._gainNode = this.context.createGain();
      this.input = this._gainNode;
      this.output = this._gainNode;
      const options2 = optionsFromArguments(Gain.getDefaults(), arguments, ["gain", "units"]);
      this.gain = new Param({
        context: this.context,
        convert: options2.convert,
        param: this._gainNode.gain,
        units: options2.units,
        value: options2.gain,
        minValue: options2.minValue,
        maxValue: options2.maxValue
      });
      readOnly(this, "gain");
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        convert: true,
        gain: 1,
        units: "gain"
      });
    }
    dispose() {
      super.dispose();
      this._gainNode.disconnect();
      this.gain.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/OneShotSource.js
  var OneShotSource = class extends ToneAudioNode {
    constructor(options2) {
      super(options2);
      this.onended = noOp;
      this._startTime = -1;
      this._stopTime = -1;
      this._timeout = -1;
      this.output = new Gain({
        context: this.context,
        gain: 0
      });
      this._gainNode = this.output;
      this.getStateAtTime = function(time) {
        const computedTime = this.toSeconds(time);
        if (this._startTime !== -1 && computedTime >= this._startTime && (this._stopTime === -1 || computedTime <= this._stopTime)) {
          return "started";
        } else {
          return "stopped";
        }
      };
      this._fadeIn = options2.fadeIn;
      this._fadeOut = options2.fadeOut;
      this._curve = options2.curve;
      this.onended = options2.onended;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        curve: "linear",
        fadeIn: 0,
        fadeOut: 0,
        onended: noOp
      });
    }
    _startGain(time, gain = 1) {
      assert(this._startTime === -1, "Source cannot be started more than once");
      const fadeInTime = this.toSeconds(this._fadeIn);
      this._startTime = time + fadeInTime;
      this._startTime = Math.max(this._startTime, this.context.currentTime);
      if (fadeInTime > 0) {
        this._gainNode.gain.setValueAtTime(0, time);
        if (this._curve === "linear") {
          this._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);
        } else {
          this._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);
        }
      } else {
        this._gainNode.gain.setValueAtTime(gain, time);
      }
      return this;
    }
    stop(time) {
      this.log("stop", time);
      this._stopGain(this.toSeconds(time));
      return this;
    }
    _stopGain(time) {
      assert(this._startTime !== -1, "'start' must be called before 'stop'");
      this.cancelStop();
      const fadeOutTime = this.toSeconds(this._fadeOut);
      this._stopTime = this.toSeconds(time) + fadeOutTime;
      this._stopTime = Math.max(this._stopTime, this.now());
      if (fadeOutTime > 0) {
        if (this._curve === "linear") {
          this._gainNode.gain.linearRampTo(0, fadeOutTime, time);
        } else {
          this._gainNode.gain.targetRampTo(0, fadeOutTime, time);
        }
      } else {
        this._gainNode.gain.cancelAndHoldAtTime(time);
        this._gainNode.gain.setValueAtTime(0, time);
      }
      this.context.clearTimeout(this._timeout);
      this._timeout = this.context.setTimeout(() => {
        const additionalTail = this._curve === "exponential" ? fadeOutTime * 2 : 0;
        this._stopSource(this.now() + additionalTail);
        this._onended();
      }, this._stopTime - this.context.currentTime);
      return this;
    }
    _onended() {
      if (this.onended !== noOp) {
        this.onended(this);
        this.onended = noOp;
        if (!this.context.isOffline) {
          const disposeCallback = () => this.dispose();
          if (typeof window.requestIdleCallback !== "undefined") {
            window.requestIdleCallback(disposeCallback);
          } else {
            setTimeout(disposeCallback, 1e3);
          }
        }
      }
    }
    get state() {
      return this.getStateAtTime(this.now());
    }
    cancelStop() {
      this.log("cancelStop");
      assert(this._startTime !== -1, "Source is not started");
      this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);
      this.context.clearTimeout(this._timeout);
      this._stopTime = -1;
      return this;
    }
    dispose() {
      super.dispose();
      this._gainNode.dispose();
      this.onended = noOp;
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/ToneConstantSource.js
  var ToneConstantSource = class extends OneShotSource {
    constructor() {
      super(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, ["offset"]));
      this.name = "ToneConstantSource";
      this._source = this.context.createConstantSource();
      const options2 = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, ["offset"]);
      connect(this._source, this._gainNode);
      this.offset = new Param({
        context: this.context,
        convert: options2.convert,
        param: this._source.offset,
        units: options2.units,
        value: options2.offset,
        minValue: options2.minValue,
        maxValue: options2.maxValue
      });
    }
    static getDefaults() {
      return Object.assign(OneShotSource.getDefaults(), {
        convert: true,
        offset: 1,
        units: "number"
      });
    }
    start(time) {
      const computedTime = this.toSeconds(time);
      this.log("start", computedTime);
      this._startGain(computedTime);
      this._source.start(computedTime);
      return this;
    }
    _stopSource(time) {
      this._source.stop(time);
    }
    dispose() {
      super.dispose();
      if (this.state === "started") {
        this.stop();
      }
      this._source.disconnect();
      this.offset.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/Signal.js
  var Signal = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Signal.getDefaults(), arguments, ["value", "units"]));
      this.name = "Signal";
      this.override = true;
      const options2 = optionsFromArguments(Signal.getDefaults(), arguments, ["value", "units"]);
      this.output = this._constantSource = new ToneConstantSource({
        context: this.context,
        convert: options2.convert,
        offset: options2.value,
        units: options2.units,
        minValue: options2.minValue,
        maxValue: options2.maxValue
      });
      this._constantSource.start(0);
      this.input = this._param = this._constantSource.offset;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        convert: true,
        units: "number",
        value: 0
      });
    }
    connect(destination, outputNum = 0, inputNum = 0) {
      connectSignal(this, destination, outputNum, inputNum);
      return this;
    }
    dispose() {
      super.dispose();
      this._param.dispose();
      this._constantSource.dispose();
      return this;
    }
    setValueAtTime(value, time) {
      this._param.setValueAtTime(value, time);
      return this;
    }
    getValueAtTime(time) {
      return this._param.getValueAtTime(time);
    }
    setRampPoint(time) {
      this._param.setRampPoint(time);
      return this;
    }
    linearRampToValueAtTime(value, time) {
      this._param.linearRampToValueAtTime(value, time);
      return this;
    }
    exponentialRampToValueAtTime(value, time) {
      this._param.exponentialRampToValueAtTime(value, time);
      return this;
    }
    exponentialRampTo(value, rampTime, startTime) {
      this._param.exponentialRampTo(value, rampTime, startTime);
      return this;
    }
    linearRampTo(value, rampTime, startTime) {
      this._param.linearRampTo(value, rampTime, startTime);
      return this;
    }
    targetRampTo(value, rampTime, startTime) {
      this._param.targetRampTo(value, rampTime, startTime);
      return this;
    }
    exponentialApproachValueAtTime(value, time, rampTime) {
      this._param.exponentialApproachValueAtTime(value, time, rampTime);
      return this;
    }
    setTargetAtTime(value, startTime, timeConstant) {
      this._param.setTargetAtTime(value, startTime, timeConstant);
      return this;
    }
    setValueCurveAtTime(values, startTime, duration2, scaling) {
      this._param.setValueCurveAtTime(values, startTime, duration2, scaling);
      return this;
    }
    cancelScheduledValues(time) {
      this._param.cancelScheduledValues(time);
      return this;
    }
    cancelAndHoldAtTime(time) {
      this._param.cancelAndHoldAtTime(time);
      return this;
    }
    rampTo(value, rampTime, startTime) {
      this._param.rampTo(value, rampTime, startTime);
      return this;
    }
    get value() {
      return this._param.value;
    }
    set value(value) {
      this._param.value = value;
    }
    get convert() {
      return this._param.convert;
    }
    set convert(convert) {
      this._param.convert = convert;
    }
    get units() {
      return this._param.units;
    }
    get overridden() {
      return this._param.overridden;
    }
    set overridden(overridden) {
      this._param.overridden = overridden;
    }
    get maxValue() {
      return this._param.maxValue;
    }
    get minValue() {
      return this._param.minValue;
    }
    apply(param) {
      this._param.apply(param);
      return this;
    }
  };
  function connectSignal(signal, destination, outputNum, inputNum) {
    if (destination instanceof Param || isAudioParam(destination) || destination instanceof Signal && destination.override) {
      destination.cancelScheduledValues(0);
      destination.setValueAtTime(0, 0);
      if (destination instanceof Signal) {
        destination.overridden = true;
      }
    }
    connect(signal, destination, outputNum, inputNum);
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/clock/TickParam.js
  var TickParam = class extends Param {
    constructor() {
      super(optionsFromArguments(TickParam.getDefaults(), arguments, ["value"]));
      this.name = "TickParam";
      this._events = new Timeline(Infinity);
      this._multiplier = 1;
      const options2 = optionsFromArguments(TickParam.getDefaults(), arguments, ["value"]);
      this._multiplier = options2.multiplier;
      this._events.cancel(0);
      this._events.add({
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: this._fromType(options2.value)
      });
      this.setValueAtTime(options2.value, 0);
    }
    static getDefaults() {
      return Object.assign(Param.getDefaults(), {
        multiplier: 1,
        units: "hertz",
        value: 1
      });
    }
    setTargetAtTime(value, time, constant) {
      time = this.toSeconds(time);
      this.setRampPoint(time);
      const computedValue = this._fromType(value);
      const prevEvent = this._events.get(time);
      const segments = Math.round(Math.max(1 / constant, 1));
      for (let i8 = 0; i8 <= segments; i8++) {
        const segTime = constant * i8 + time;
        const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);
        this.linearRampToValueAtTime(this._toType(rampVal), segTime);
      }
      return this;
    }
    setValueAtTime(value, time) {
      const computedTime = this.toSeconds(time);
      super.setValueAtTime(value, time);
      const event = this._events.get(computedTime);
      const previousEvent = this._events.previousEvent(event);
      const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
      event.ticks = Math.max(ticksUntilTime, 0);
      return this;
    }
    linearRampToValueAtTime(value, time) {
      const computedTime = this.toSeconds(time);
      super.linearRampToValueAtTime(value, time);
      const event = this._events.get(computedTime);
      const previousEvent = this._events.previousEvent(event);
      const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
      event.ticks = Math.max(ticksUntilTime, 0);
      return this;
    }
    exponentialRampToValueAtTime(value, time) {
      time = this.toSeconds(time);
      const computedVal = this._fromType(value);
      const prevEvent = this._events.get(time);
      const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));
      const segmentDur = (time - prevEvent.time) / segments;
      for (let i8 = 0; i8 <= segments; i8++) {
        const segTime = segmentDur * i8 + prevEvent.time;
        const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);
        this.linearRampToValueAtTime(this._toType(rampVal), segTime);
      }
      return this;
    }
    _getTicksUntilEvent(event, time) {
      if (event === null) {
        event = {
          ticks: 0,
          time: 0,
          type: "setValueAtTime",
          value: 0
        };
      } else if (isUndef(event.ticks)) {
        const previousEvent = this._events.previousEvent(event);
        event.ticks = this._getTicksUntilEvent(previousEvent, event.time);
      }
      const val0 = this._fromType(this.getValueAtTime(event.time));
      let val1 = this._fromType(this.getValueAtTime(time));
      const onTheLineEvent = this._events.get(time);
      if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === "setValueAtTime") {
        val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));
      }
      return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;
    }
    getTicksAtTime(time) {
      const computedTime = this.toSeconds(time);
      const event = this._events.get(computedTime);
      return Math.max(this._getTicksUntilEvent(event, computedTime), 0);
    }
    getDurationOfTicks(ticks, time) {
      const computedTime = this.toSeconds(time);
      const currentTick = this.getTicksAtTime(time);
      return this.getTimeOfTick(currentTick + ticks) - computedTime;
    }
    getTimeOfTick(tick) {
      const before = this._events.get(tick, "ticks");
      const after = this._events.getAfter(tick, "ticks");
      if (before && before.ticks === tick) {
        return before.time;
      } else if (before && after && after.type === "linearRampToValueAtTime" && before.value !== after.value) {
        const val0 = this._fromType(this.getValueAtTime(before.time));
        const val1 = this._fromType(this.getValueAtTime(after.time));
        const delta = (val1 - val0) / (after.time - before.time);
        const k2 = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
        const sol1 = (-val0 + k2) / delta;
        const sol2 = (-val0 - k2) / delta;
        return (sol1 > 0 ? sol1 : sol2) + before.time;
      } else if (before) {
        if (before.value === 0) {
          return Infinity;
        } else {
          return before.time + (tick - before.ticks) / before.value;
        }
      } else {
        return tick / this._initialValue;
      }
    }
    ticksToTime(ticks, when) {
      return this.getDurationOfTicks(ticks, when);
    }
    timeToTicks(duration2, when) {
      const computedTime = this.toSeconds(when);
      const computedDuration = this.toSeconds(duration2);
      const startTicks = this.getTicksAtTime(computedTime);
      const endTicks = this.getTicksAtTime(computedTime + computedDuration);
      return endTicks - startTicks;
    }
    _fromType(val) {
      if (this.units === "bpm" && this.multiplier) {
        return 1 / (60 / val / this.multiplier);
      } else {
        return super._fromType(val);
      }
    }
    _toType(val) {
      if (this.units === "bpm" && this.multiplier) {
        return val / this.multiplier * 60;
      } else {
        return super._toType(val);
      }
    }
    get multiplier() {
      return this._multiplier;
    }
    set multiplier(m3) {
      const currentVal = this.value;
      this._multiplier = m3;
      this.cancelScheduledValues(0);
      this.setValueAtTime(currentVal, 0);
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/clock/TickSignal.js
  var TickSignal = class extends Signal {
    constructor() {
      super(optionsFromArguments(TickSignal.getDefaults(), arguments, ["value"]));
      this.name = "TickSignal";
      const options2 = optionsFromArguments(TickSignal.getDefaults(), arguments, ["value"]);
      this.input = this._param = new TickParam({
        context: this.context,
        convert: options2.convert,
        multiplier: options2.multiplier,
        param: this._constantSource.offset,
        units: options2.units,
        value: options2.value
      });
    }
    static getDefaults() {
      return Object.assign(Signal.getDefaults(), {
        multiplier: 1,
        units: "hertz",
        value: 1
      });
    }
    ticksToTime(ticks, when) {
      return this._param.ticksToTime(ticks, when);
    }
    timeToTicks(duration2, when) {
      return this._param.timeToTicks(duration2, when);
    }
    getTimeOfTick(tick) {
      return this._param.getTimeOfTick(tick);
    }
    getDurationOfTicks(ticks, time) {
      return this._param.getDurationOfTicks(ticks, time);
    }
    getTicksAtTime(time) {
      return this._param.getTicksAtTime(time);
    }
    get multiplier() {
      return this._param.multiplier;
    }
    set multiplier(m3) {
      this._param.multiplier = m3;
    }
    dispose() {
      super.dispose();
      this._param.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/clock/TickSource.js
  var TickSource = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(TickSource.getDefaults(), arguments, ["frequency"]));
      this.name = "TickSource";
      this._state = new StateTimeline();
      this._tickOffset = new Timeline();
      this._ticksAtTime = new Timeline();
      this._secondsAtTime = new Timeline();
      const options2 = optionsFromArguments(TickSource.getDefaults(), arguments, ["frequency"]);
      this.frequency = new TickSignal({
        context: this.context,
        units: options2.units,
        value: options2.frequency
      });
      readOnly(this, "frequency");
      this._state.setStateAtTime("stopped", 0);
      this.setTicksAtTime(0, 0);
    }
    static getDefaults() {
      return Object.assign({
        frequency: 1,
        units: "hertz"
      }, ToneWithContext.getDefaults());
    }
    get state() {
      return this.getStateAtTime(this.now());
    }
    start(time, offset) {
      const computedTime = this.toSeconds(time);
      if (this._state.getValueAtTime(computedTime) !== "started") {
        this._state.setStateAtTime("started", computedTime);
        if (isDefined(offset)) {
          this.setTicksAtTime(offset, computedTime);
        }
        this._ticksAtTime.cancel(computedTime);
        this._secondsAtTime.cancel(computedTime);
      }
      return this;
    }
    stop(time) {
      const computedTime = this.toSeconds(time);
      if (this._state.getValueAtTime(computedTime) === "stopped") {
        const event = this._state.get(computedTime);
        if (event && event.time > 0) {
          this._tickOffset.cancel(event.time);
          this._state.cancel(event.time);
        }
      }
      this._state.cancel(computedTime);
      this._state.setStateAtTime("stopped", computedTime);
      this.setTicksAtTime(0, computedTime);
      this._ticksAtTime.cancel(computedTime);
      this._secondsAtTime.cancel(computedTime);
      return this;
    }
    pause(time) {
      const computedTime = this.toSeconds(time);
      if (this._state.getValueAtTime(computedTime) === "started") {
        this._state.setStateAtTime("paused", computedTime);
        this._ticksAtTime.cancel(computedTime);
        this._secondsAtTime.cancel(computedTime);
      }
      return this;
    }
    cancel(time) {
      time = this.toSeconds(time);
      this._state.cancel(time);
      this._tickOffset.cancel(time);
      this._ticksAtTime.cancel(time);
      this._secondsAtTime.cancel(time);
      return this;
    }
    getTicksAtTime(time) {
      const computedTime = this.toSeconds(time);
      const stopEvent = this._state.getLastState("stopped", computedTime);
      const memoizedEvent = this._ticksAtTime.get(computedTime);
      const tmpEvent = { state: "paused", time: computedTime };
      this._state.add(tmpEvent);
      let lastState = memoizedEvent ? memoizedEvent : stopEvent;
      let elapsedTicks = memoizedEvent ? memoizedEvent.ticks : 0;
      let eventToMemoize = null;
      this._state.forEachBetween(lastState.time, computedTime + this.sampleTime, (e8) => {
        let periodStartTime = lastState.time;
        const offsetEvent = this._tickOffset.get(e8.time);
        if (offsetEvent && offsetEvent.time >= lastState.time) {
          elapsedTicks = offsetEvent.ticks;
          periodStartTime = offsetEvent.time;
        }
        if (lastState.state === "started" && e8.state !== "started") {
          elapsedTicks += this.frequency.getTicksAtTime(e8.time) - this.frequency.getTicksAtTime(periodStartTime);
          if (e8.time != tmpEvent.time) {
            eventToMemoize = { state: e8.state, time: e8.time, ticks: elapsedTicks };
          }
        }
        lastState = e8;
      });
      this._state.remove(tmpEvent);
      if (eventToMemoize) {
        this._ticksAtTime.add(eventToMemoize);
      }
      return elapsedTicks;
    }
    get ticks() {
      return this.getTicksAtTime(this.now());
    }
    set ticks(t8) {
      this.setTicksAtTime(t8, this.now());
    }
    get seconds() {
      return this.getSecondsAtTime(this.now());
    }
    set seconds(s4) {
      const now2 = this.now();
      const ticks = this.frequency.timeToTicks(s4, now2);
      this.setTicksAtTime(ticks, now2);
    }
    getSecondsAtTime(time) {
      time = this.toSeconds(time);
      const stopEvent = this._state.getLastState("stopped", time);
      const tmpEvent = { state: "paused", time };
      this._state.add(tmpEvent);
      const memoizedEvent = this._secondsAtTime.get(time);
      let lastState = memoizedEvent ? memoizedEvent : stopEvent;
      let elapsedSeconds = memoizedEvent ? memoizedEvent.seconds : 0;
      let eventToMemoize = null;
      this._state.forEachBetween(lastState.time, time + this.sampleTime, (e8) => {
        let periodStartTime = lastState.time;
        const offsetEvent = this._tickOffset.get(e8.time);
        if (offsetEvent && offsetEvent.time >= lastState.time) {
          elapsedSeconds = offsetEvent.seconds;
          periodStartTime = offsetEvent.time;
        }
        if (lastState.state === "started" && e8.state !== "started") {
          elapsedSeconds += e8.time - periodStartTime;
          if (e8.time != tmpEvent.time) {
            eventToMemoize = { state: e8.state, time: e8.time, seconds: elapsedSeconds };
          }
        }
        lastState = e8;
      });
      this._state.remove(tmpEvent);
      if (eventToMemoize) {
        this._secondsAtTime.add(eventToMemoize);
      }
      return elapsedSeconds;
    }
    setTicksAtTime(ticks, time) {
      time = this.toSeconds(time);
      this._tickOffset.cancel(time);
      this._tickOffset.add({
        seconds: this.frequency.getDurationOfTicks(ticks, time),
        ticks,
        time
      });
      this._ticksAtTime.cancel(time);
      this._secondsAtTime.cancel(time);
      return this;
    }
    getStateAtTime(time) {
      time = this.toSeconds(time);
      return this._state.getValueAtTime(time);
    }
    getTimeOfTick(tick, before = this.now()) {
      const offset = this._tickOffset.get(before);
      const event = this._state.get(before);
      const startTime = Math.max(offset.time, event.time);
      const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;
      return this.frequency.getTimeOfTick(absoluteTicks);
    }
    forEachTickBetween(startTime, endTime, callback) {
      let lastStateEvent = this._state.get(startTime);
      this._state.forEachBetween(startTime, endTime, (event) => {
        if (lastStateEvent && lastStateEvent.state === "started" && event.state !== "started") {
          this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);
        }
        lastStateEvent = event;
      });
      let error = null;
      if (lastStateEvent && lastStateEvent.state === "started") {
        const maxStartTime = Math.max(lastStateEvent.time, startTime);
        const startTicks = this.frequency.getTicksAtTime(maxStartTime);
        const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);
        const diff = startTicks - ticksAtStart;
        let offset = Math.ceil(diff) - diff;
        offset = EQ(offset, 1) ? 0 : offset;
        let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);
        while (nextTickTime < endTime) {
          try {
            callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));
          } catch (e8) {
            error = e8;
            break;
          }
          nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);
        }
      }
      if (error) {
        throw error;
      }
      return this;
    }
    dispose() {
      super.dispose();
      this._state.dispose();
      this._tickOffset.dispose();
      this._ticksAtTime.dispose();
      this._secondsAtTime.dispose();
      this.frequency.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/clock/Clock.js
  var Clock = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(Clock.getDefaults(), arguments, ["callback", "frequency"]));
      this.name = "Clock";
      this.callback = noOp;
      this._lastUpdate = 0;
      this._state = new StateTimeline("stopped");
      this._boundLoop = this._loop.bind(this);
      const options2 = optionsFromArguments(Clock.getDefaults(), arguments, ["callback", "frequency"]);
      this.callback = options2.callback;
      this._tickSource = new TickSource({
        context: this.context,
        frequency: options2.frequency,
        units: options2.units
      });
      this._lastUpdate = 0;
      this.frequency = this._tickSource.frequency;
      readOnly(this, "frequency");
      this._state.setStateAtTime("stopped", 0);
      this.context.on("tick", this._boundLoop);
    }
    static getDefaults() {
      return Object.assign(ToneWithContext.getDefaults(), {
        callback: noOp,
        frequency: 1,
        units: "hertz"
      });
    }
    get state() {
      return this._state.getValueAtTime(this.now());
    }
    start(time, offset) {
      assertContextRunning(this.context);
      const computedTime = this.toSeconds(time);
      this.log("start", computedTime);
      if (this._state.getValueAtTime(computedTime) !== "started") {
        this._state.setStateAtTime("started", computedTime);
        this._tickSource.start(computedTime, offset);
        if (computedTime < this._lastUpdate) {
          this.emit("start", computedTime, offset);
        }
      }
      return this;
    }
    stop(time) {
      const computedTime = this.toSeconds(time);
      this.log("stop", computedTime);
      this._state.cancel(computedTime);
      this._state.setStateAtTime("stopped", computedTime);
      this._tickSource.stop(computedTime);
      if (computedTime < this._lastUpdate) {
        this.emit("stop", computedTime);
      }
      return this;
    }
    pause(time) {
      const computedTime = this.toSeconds(time);
      if (this._state.getValueAtTime(computedTime) === "started") {
        this._state.setStateAtTime("paused", computedTime);
        this._tickSource.pause(computedTime);
        if (computedTime < this._lastUpdate) {
          this.emit("pause", computedTime);
        }
      }
      return this;
    }
    get ticks() {
      return Math.ceil(this.getTicksAtTime(this.now()));
    }
    set ticks(t8) {
      this._tickSource.ticks = t8;
    }
    get seconds() {
      return this._tickSource.seconds;
    }
    set seconds(s4) {
      this._tickSource.seconds = s4;
    }
    getSecondsAtTime(time) {
      return this._tickSource.getSecondsAtTime(time);
    }
    setTicksAtTime(ticks, time) {
      this._tickSource.setTicksAtTime(ticks, time);
      return this;
    }
    getTimeOfTick(tick, before = this.now()) {
      return this._tickSource.getTimeOfTick(tick, before);
    }
    getTicksAtTime(time) {
      return this._tickSource.getTicksAtTime(time);
    }
    nextTickTime(offset, when) {
      const computedTime = this.toSeconds(when);
      const currentTick = this.getTicksAtTime(computedTime);
      return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);
    }
    _loop() {
      const startTime = this._lastUpdate;
      const endTime = this.now();
      this._lastUpdate = endTime;
      this.log("loop", startTime, endTime);
      if (startTime !== endTime) {
        this._state.forEachBetween(startTime, endTime, (e8) => {
          switch (e8.state) {
            case "started":
              const offset = this._tickSource.getTicksAtTime(e8.time);
              this.emit("start", e8.time, offset);
              break;
            case "stopped":
              if (e8.time !== 0) {
                this.emit("stop", e8.time);
              }
              break;
            case "paused":
              this.emit("pause", e8.time);
              break;
          }
        });
        this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {
          this.callback(time, ticks);
        });
      }
    }
    getStateAtTime(time) {
      const computedTime = this.toSeconds(time);
      return this._state.getValueAtTime(computedTime);
    }
    dispose() {
      super.dispose();
      this.context.off("tick", this._boundLoop);
      this._tickSource.dispose();
      this._state.dispose();
      return this;
    }
  };
  Emitter.mixin(Clock);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/Delay.js
  var Delay = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Delay.getDefaults(), arguments, ["delayTime", "maxDelay"]));
      this.name = "Delay";
      const options2 = optionsFromArguments(Delay.getDefaults(), arguments, ["delayTime", "maxDelay"]);
      const maxDelayInSeconds = this.toSeconds(options2.maxDelay);
      this._maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options2.delayTime));
      this._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);
      this.delayTime = new Param({
        context: this.context,
        param: this._delayNode.delayTime,
        units: "time",
        value: options2.delayTime,
        minValue: 0,
        maxValue: this.maxDelay
      });
      readOnly(this, "delayTime");
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        delayTime: 0,
        maxDelay: 1
      });
    }
    get maxDelay() {
      return this._maxDelay;
    }
    dispose() {
      super.dispose();
      this._delayNode.disconnect();
      this.delayTime.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/ToneAudioBuffers.js
  var ToneAudioBuffers = class extends Tone {
    constructor() {
      super();
      this.name = "ToneAudioBuffers";
      this._buffers = /* @__PURE__ */ new Map();
      this._loadingCount = 0;
      const options2 = optionsFromArguments(ToneAudioBuffers.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
      this.baseUrl = options2.baseUrl;
      Object.keys(options2.urls).forEach((name2) => {
        this._loadingCount++;
        const url = options2.urls[name2];
        this.add(name2, url, this._bufferLoaded.bind(this, options2.onload), options2.onerror);
      });
    }
    static getDefaults() {
      return {
        baseUrl: "",
        onerror: noOp,
        onload: noOp,
        urls: {}
      };
    }
    has(name2) {
      return this._buffers.has(name2.toString());
    }
    get(name2) {
      assert(this.has(name2), `ToneAudioBuffers has no buffer named: ${name2}`);
      return this._buffers.get(name2.toString());
    }
    _bufferLoaded(callback) {
      this._loadingCount--;
      if (this._loadingCount === 0 && callback) {
        callback();
      }
    }
    get loaded() {
      return Array.from(this._buffers).every(([_, buffer2]) => buffer2.loaded);
    }
    add(name2, url, callback = noOp, onerror = noOp) {
      if (isString(url)) {
        if (this.baseUrl && url.trim().substring(0, 11).toLowerCase() === "data:audio/") {
          this.baseUrl = "";
        }
        this._buffers.set(name2.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));
      } else {
        this._buffers.set(name2.toString(), new ToneAudioBuffer(url, callback, onerror));
      }
      return this;
    }
    dispose() {
      super.dispose();
      this._buffers.forEach((buffer2) => buffer2.dispose());
      this._buffers.clear();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/type/Midi.js
  var MidiClass = class extends FrequencyClass {
    constructor() {
      super(...arguments);
      this.name = "MidiClass";
      this.defaultUnits = "midi";
    }
    _frequencyToUnits(freq2) {
      return ftom(super._frequencyToUnits(freq2));
    }
    _ticksToUnits(ticks) {
      return ftom(super._ticksToUnits(ticks));
    }
    _beatsToUnits(beats) {
      return ftom(super._beatsToUnits(beats));
    }
    _secondsToUnits(seconds) {
      return ftom(super._secondsToUnits(seconds));
    }
    toMidi() {
      return this.valueOf();
    }
    toFrequency() {
      return mtof(this.toMidi());
    }
    transpose(interval2) {
      return new MidiClass(this.context, this.toMidi() + interval2);
    }
  };
  function Midi(value, units) {
    return new MidiClass(getContext(), value, units);
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/type/Ticks.js
  var TicksClass = class extends TransportTimeClass {
    constructor() {
      super(...arguments);
      this.name = "Ticks";
      this.defaultUnits = "i";
    }
    _now() {
      return this.context.transport.ticks;
    }
    _beatsToUnits(beats) {
      return this._getPPQ() * beats;
    }
    _secondsToUnits(seconds) {
      return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());
    }
    _ticksToUnits(ticks) {
      return ticks;
    }
    toTicks() {
      return this.valueOf();
    }
    toSeconds() {
      return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/Draw.js
  var Draw = class extends ToneWithContext {
    constructor() {
      super(...arguments);
      this.name = "Draw";
      this.expiration = 0.25;
      this.anticipation = 8e-3;
      this._events = new Timeline();
      this._boundDrawLoop = this._drawLoop.bind(this);
      this._animationFrame = -1;
    }
    schedule(callback, time) {
      this._events.add({
        callback,
        time: this.toSeconds(time)
      });
      if (this._events.length === 1) {
        this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
      }
      return this;
    }
    cancel(after) {
      this._events.cancel(this.toSeconds(after));
      return this;
    }
    _drawLoop() {
      const now2 = this.context.currentTime;
      while (this._events.length && this._events.peek().time - this.anticipation <= now2) {
        const event = this._events.shift();
        if (event && now2 - event.time <= this.expiration) {
          event.callback();
        }
      }
      if (this._events.length > 0) {
        this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
      }
    }
    dispose() {
      super.dispose();
      this._events.dispose();
      cancelAnimationFrame(this._animationFrame);
      return this;
    }
  };
  onContextInit((context2) => {
    context2.draw = new Draw({ context: context2 });
  });
  onContextClose((context2) => {
    context2.draw.dispose();
  });

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/IntervalTimeline.js
  var IntervalTimeline = class extends Tone {
    constructor() {
      super(...arguments);
      this.name = "IntervalTimeline";
      this._root = null;
      this._length = 0;
    }
    add(event) {
      assert(isDefined(event.time), "Events must have a time property");
      assert(isDefined(event.duration), "Events must have a duration parameter");
      event.time = event.time.valueOf();
      let node = new IntervalNode(event.time, event.time + event.duration, event);
      if (this._root === null) {
        this._root = node;
      } else {
        this._root.insert(node);
      }
      this._length++;
      while (node !== null) {
        node.updateHeight();
        node.updateMax();
        this._rebalance(node);
        node = node.parent;
      }
      return this;
    }
    remove(event) {
      if (this._root !== null) {
        const results = [];
        this._root.search(event.time, results);
        for (const node of results) {
          if (node.event === event) {
            this._removeNode(node);
            this._length--;
            break;
          }
        }
      }
      return this;
    }
    get length() {
      return this._length;
    }
    cancel(after) {
      this.forEachFrom(after, (event) => this.remove(event));
      return this;
    }
    _setRoot(node) {
      this._root = node;
      if (this._root !== null) {
        this._root.parent = null;
      }
    }
    _replaceNodeInParent(node, replacement) {
      if (node.parent !== null) {
        if (node.isLeftChild()) {
          node.parent.left = replacement;
        } else {
          node.parent.right = replacement;
        }
        this._rebalance(node.parent);
      } else {
        this._setRoot(replacement);
      }
    }
    _removeNode(node) {
      if (node.left === null && node.right === null) {
        this._replaceNodeInParent(node, null);
      } else if (node.right === null) {
        this._replaceNodeInParent(node, node.left);
      } else if (node.left === null) {
        this._replaceNodeInParent(node, node.right);
      } else {
        const balance = node.getBalance();
        let replacement;
        let temp = null;
        if (balance > 0) {
          if (node.left.right === null) {
            replacement = node.left;
            replacement.right = node.right;
            temp = replacement;
          } else {
            replacement = node.left.right;
            while (replacement.right !== null) {
              replacement = replacement.right;
            }
            if (replacement.parent) {
              replacement.parent.right = replacement.left;
              temp = replacement.parent;
              replacement.left = node.left;
              replacement.right = node.right;
            }
          }
        } else if (node.right.left === null) {
          replacement = node.right;
          replacement.left = node.left;
          temp = replacement;
        } else {
          replacement = node.right.left;
          while (replacement.left !== null) {
            replacement = replacement.left;
          }
          if (replacement.parent) {
            replacement.parent.left = replacement.right;
            temp = replacement.parent;
            replacement.left = node.left;
            replacement.right = node.right;
          }
        }
        if (node.parent !== null) {
          if (node.isLeftChild()) {
            node.parent.left = replacement;
          } else {
            node.parent.right = replacement;
          }
        } else {
          this._setRoot(replacement);
        }
        if (temp) {
          this._rebalance(temp);
        }
      }
      node.dispose();
    }
    _rotateLeft(node) {
      const parent = node.parent;
      const isLeftChild = node.isLeftChild();
      const pivotNode = node.right;
      if (pivotNode) {
        node.right = pivotNode.left;
        pivotNode.left = node;
      }
      if (parent !== null) {
        if (isLeftChild) {
          parent.left = pivotNode;
        } else {
          parent.right = pivotNode;
        }
      } else {
        this._setRoot(pivotNode);
      }
    }
    _rotateRight(node) {
      const parent = node.parent;
      const isLeftChild = node.isLeftChild();
      const pivotNode = node.left;
      if (pivotNode) {
        node.left = pivotNode.right;
        pivotNode.right = node;
      }
      if (parent !== null) {
        if (isLeftChild) {
          parent.left = pivotNode;
        } else {
          parent.right = pivotNode;
        }
      } else {
        this._setRoot(pivotNode);
      }
    }
    _rebalance(node) {
      const balance = node.getBalance();
      if (balance > 1 && node.left) {
        if (node.left.getBalance() < 0) {
          this._rotateLeft(node.left);
        } else {
          this._rotateRight(node);
        }
      } else if (balance < -1 && node.right) {
        if (node.right.getBalance() > 0) {
          this._rotateRight(node.right);
        } else {
          this._rotateLeft(node);
        }
      }
    }
    get(time) {
      if (this._root !== null) {
        const results = [];
        this._root.search(time, results);
        if (results.length > 0) {
          let max = results[0];
          for (let i8 = 1; i8 < results.length; i8++) {
            if (results[i8].low > max.low) {
              max = results[i8];
            }
          }
          return max.event;
        }
      }
      return null;
    }
    forEach(callback) {
      if (this._root !== null) {
        const allNodes = [];
        this._root.traverse((node) => allNodes.push(node));
        allNodes.forEach((node) => {
          if (node.event) {
            callback(node.event);
          }
        });
      }
      return this;
    }
    forEachAtTime(time, callback) {
      if (this._root !== null) {
        const results = [];
        this._root.search(time, results);
        results.forEach((node) => {
          if (node.event) {
            callback(node.event);
          }
        });
      }
      return this;
    }
    forEachFrom(time, callback) {
      if (this._root !== null) {
        const results = [];
        this._root.searchAfter(time, results);
        results.forEach((node) => {
          if (node.event) {
            callback(node.event);
          }
        });
      }
      return this;
    }
    dispose() {
      super.dispose();
      if (this._root !== null) {
        this._root.traverse((node) => node.dispose());
      }
      this._root = null;
      return this;
    }
  };
  var IntervalNode = class {
    constructor(low, high, event) {
      this._left = null;
      this._right = null;
      this.parent = null;
      this.height = 0;
      this.event = event;
      this.low = low;
      this.high = high;
      this.max = this.high;
    }
    insert(node) {
      if (node.low <= this.low) {
        if (this.left === null) {
          this.left = node;
        } else {
          this.left.insert(node);
        }
      } else if (this.right === null) {
        this.right = node;
      } else {
        this.right.insert(node);
      }
    }
    search(point, results) {
      if (point > this.max) {
        return;
      }
      if (this.left !== null) {
        this.left.search(point, results);
      }
      if (this.low <= point && this.high > point) {
        results.push(this);
      }
      if (this.low > point) {
        return;
      }
      if (this.right !== null) {
        this.right.search(point, results);
      }
    }
    searchAfter(point, results) {
      if (this.low >= point) {
        results.push(this);
        if (this.left !== null) {
          this.left.searchAfter(point, results);
        }
      }
      if (this.right !== null) {
        this.right.searchAfter(point, results);
      }
    }
    traverse(callback) {
      callback(this);
      if (this.left !== null) {
        this.left.traverse(callback);
      }
      if (this.right !== null) {
        this.right.traverse(callback);
      }
    }
    updateHeight() {
      if (this.left !== null && this.right !== null) {
        this.height = Math.max(this.left.height, this.right.height) + 1;
      } else if (this.right !== null) {
        this.height = this.right.height + 1;
      } else if (this.left !== null) {
        this.height = this.left.height + 1;
      } else {
        this.height = 0;
      }
    }
    updateMax() {
      this.max = this.high;
      if (this.left !== null) {
        this.max = Math.max(this.max, this.left.max);
      }
      if (this.right !== null) {
        this.max = Math.max(this.max, this.right.max);
      }
    }
    getBalance() {
      let balance = 0;
      if (this.left !== null && this.right !== null) {
        balance = this.left.height - this.right.height;
      } else if (this.left !== null) {
        balance = this.left.height + 1;
      } else if (this.right !== null) {
        balance = -(this.right.height + 1);
      }
      return balance;
    }
    isLeftChild() {
      return this.parent !== null && this.parent.left === this;
    }
    get left() {
      return this._left;
    }
    set left(node) {
      this._left = node;
      if (node !== null) {
        node.parent = this;
      }
      this.updateHeight();
      this.updateMax();
    }
    get right() {
      return this._right;
    }
    set right(node) {
      this._right = node;
      if (node !== null) {
        node.parent = this;
      }
      this.updateHeight();
      this.updateMax();
    }
    dispose() {
      this.parent = null;
      this._left = null;
      this._right = null;
      this.event = null;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/Volume.js
  var Volume = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Volume.getDefaults(), arguments, ["volume"]));
      this.name = "Volume";
      const options2 = optionsFromArguments(Volume.getDefaults(), arguments, ["volume"]);
      this.input = this.output = new Gain({
        context: this.context,
        gain: options2.volume,
        units: "decibels"
      });
      this.volume = this.output.gain;
      readOnly(this, "volume");
      this._unmutedVolume = options2.volume;
      this.mute = options2.mute;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        mute: false,
        volume: 0
      });
    }
    get mute() {
      return this.volume.value === -Infinity;
    }
    set mute(mute) {
      if (!this.mute && mute) {
        this._unmutedVolume = this.volume.value;
        this.volume.value = -Infinity;
      } else if (this.mute && !mute) {
        this.volume.value = this._unmutedVolume;
      }
    }
    dispose() {
      super.dispose();
      this.input.dispose();
      this.volume.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/Destination.js
  var Destination = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Destination.getDefaults(), arguments));
      this.name = "Destination";
      this.input = new Volume({ context: this.context });
      this.output = new Gain({ context: this.context });
      this.volume = this.input.volume;
      const options2 = optionsFromArguments(Destination.getDefaults(), arguments);
      connectSeries(this.input, this.output, this.context.rawContext.destination);
      this.mute = options2.mute;
      this._internalChannels = [this.input, this.context.rawContext.destination, this.output];
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        mute: false,
        volume: 0
      });
    }
    get mute() {
      return this.input.mute;
    }
    set mute(mute) {
      this.input.mute = mute;
    }
    chain(...args) {
      this.input.disconnect();
      args.unshift(this.input);
      args.push(this.output);
      connectSeries(...args);
      return this;
    }
    get maxChannelCount() {
      return this.context.rawContext.destination.maxChannelCount;
    }
    dispose() {
      super.dispose();
      this.volume.dispose();
      return this;
    }
  };
  onContextInit((context2) => {
    context2.destination = new Destination({ context: context2 });
  });
  onContextClose((context2) => {
    context2.destination.dispose();
  });

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/TimelineValue.js
  var TimelineValue = class extends Tone {
    constructor(initialValue) {
      super();
      this.name = "TimelineValue";
      this._timeline = new Timeline({ memory: 10 });
      this._initialValue = initialValue;
    }
    set(value, time) {
      this._timeline.add({
        value,
        time
      });
      return this;
    }
    get(time) {
      const event = this._timeline.get(time);
      if (event) {
        return event.value;
      } else {
        return this._initialValue;
      }
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/clock/TransportEvent.js
  var TransportEvent = class {
    constructor(transport, opts) {
      this.id = TransportEvent._eventId++;
      this._remainderTime = 0;
      const options2 = Object.assign(TransportEvent.getDefaults(), opts);
      this.transport = transport;
      this.callback = options2.callback;
      this._once = options2.once;
      this.time = Math.floor(options2.time);
      this._remainderTime = options2.time - this.time;
    }
    static getDefaults() {
      return {
        callback: noOp,
        once: false,
        time: 0
      };
    }
    get floatTime() {
      return this.time + this._remainderTime;
    }
    invoke(time) {
      if (this.callback) {
        const tickDuration = this.transport.bpm.getDurationOfTicks(1, time);
        this.callback(time + this._remainderTime * tickDuration);
        if (this._once) {
          this.transport.clear(this.id);
        }
      }
    }
    dispose() {
      this.callback = void 0;
      return this;
    }
  };
  TransportEvent._eventId = 0;

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js
  var TransportRepeatEvent = class extends TransportEvent {
    constructor(transport, opts) {
      super(transport, opts);
      this._currentId = -1;
      this._nextId = -1;
      this._nextTick = this.time;
      this._boundRestart = this._restart.bind(this);
      const options2 = Object.assign(TransportRepeatEvent.getDefaults(), opts);
      this.duration = options2.duration;
      this._interval = options2.interval;
      this._nextTick = options2.time;
      this.transport.on("start", this._boundRestart);
      this.transport.on("loopStart", this._boundRestart);
      this.transport.on("ticks", this._boundRestart);
      this.context = this.transport.context;
      this._restart();
    }
    static getDefaults() {
      return Object.assign({}, TransportEvent.getDefaults(), {
        duration: Infinity,
        interval: 1,
        once: false
      });
    }
    invoke(time) {
      this._createEvents(time);
      super.invoke(time);
    }
    _createEvent() {
      if (LT(this._nextTick, this.floatTime + this.duration)) {
        return this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
      }
      return -1;
    }
    _createEvents(time) {
      if (LT(this._nextTick + this._interval, this.floatTime + this.duration)) {
        this._nextTick += this._interval;
        this._currentId = this._nextId;
        this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
      }
    }
    _restart(time) {
      this.transport.clear(this._currentId);
      this.transport.clear(this._nextId);
      this._nextTick = this.floatTime;
      const ticks = this.transport.getTicksAtTime(time);
      if (GT(ticks, this.time)) {
        this._nextTick = this.floatTime + Math.ceil((ticks - this.floatTime) / this._interval) * this._interval;
      }
      this._currentId = this._createEvent();
      this._nextTick += this._interval;
      this._nextId = this._createEvent();
    }
    dispose() {
      super.dispose();
      this.transport.clear(this._currentId);
      this.transport.clear(this._nextId);
      this.transport.off("start", this._boundRestart);
      this.transport.off("loopStart", this._boundRestart);
      this.transport.off("ticks", this._boundRestart);
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/clock/Transport.js
  var Transport = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(Transport.getDefaults(), arguments));
      this.name = "Transport";
      this._loop = new TimelineValue(false);
      this._loopStart = 0;
      this._loopEnd = 0;
      this._scheduledEvents = {};
      this._timeline = new Timeline();
      this._repeatedEvents = new IntervalTimeline();
      this._syncedSignals = [];
      this._swingAmount = 0;
      const options2 = optionsFromArguments(Transport.getDefaults(), arguments);
      this._ppq = options2.ppq;
      this._clock = new Clock({
        callback: this._processTick.bind(this),
        context: this.context,
        frequency: 0,
        units: "bpm"
      });
      this._bindClockEvents();
      this.bpm = this._clock.frequency;
      this._clock.frequency.multiplier = options2.ppq;
      this.bpm.setValueAtTime(options2.bpm, 0);
      readOnly(this, "bpm");
      this._timeSignature = options2.timeSignature;
      this._swingTicks = options2.ppq / 2;
    }
    static getDefaults() {
      return Object.assign(ToneWithContext.getDefaults(), {
        bpm: 120,
        loopEnd: "4m",
        loopStart: 0,
        ppq: 192,
        swing: 0,
        swingSubdivision: "8n",
        timeSignature: 4
      });
    }
    _processTick(tickTime, ticks) {
      if (this._loop.get(tickTime)) {
        if (ticks >= this._loopEnd) {
          this.emit("loopEnd", tickTime);
          this._clock.setTicksAtTime(this._loopStart, tickTime);
          ticks = this._loopStart;
          this.emit("loopStart", tickTime, this._clock.getSecondsAtTime(tickTime));
          this.emit("loop", tickTime);
        }
      }
      if (this._swingAmount > 0 && ticks % this._ppq !== 0 && ticks % (this._swingTicks * 2) !== 0) {
        const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
        const amount = Math.sin(progress * Math.PI) * this._swingAmount;
        tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;
      }
      enterScheduledCallback(true);
      this._timeline.forEachAtTime(ticks, (event) => event.invoke(tickTime));
      enterScheduledCallback(false);
    }
    schedule(callback, time) {
      const event = new TransportEvent(this, {
        callback,
        time: new TransportTimeClass(this.context, time).toTicks()
      });
      return this._addEvent(event, this._timeline);
    }
    scheduleRepeat(callback, interval2, startTime, duration2 = Infinity) {
      const event = new TransportRepeatEvent(this, {
        callback,
        duration: new TimeClass(this.context, duration2).toTicks(),
        interval: new TimeClass(this.context, interval2).toTicks(),
        time: new TransportTimeClass(this.context, startTime).toTicks()
      });
      return this._addEvent(event, this._repeatedEvents);
    }
    scheduleOnce(callback, time) {
      const event = new TransportEvent(this, {
        callback,
        once: true,
        time: new TransportTimeClass(this.context, time).toTicks()
      });
      return this._addEvent(event, this._timeline);
    }
    clear(eventId) {
      if (this._scheduledEvents.hasOwnProperty(eventId)) {
        const item = this._scheduledEvents[eventId.toString()];
        item.timeline.remove(item.event);
        item.event.dispose();
        delete this._scheduledEvents[eventId.toString()];
      }
      return this;
    }
    _addEvent(event, timeline) {
      this._scheduledEvents[event.id.toString()] = {
        event,
        timeline
      };
      timeline.add(event);
      return event.id;
    }
    cancel(after = 0) {
      const computedAfter = this.toTicks(after);
      this._timeline.forEachFrom(computedAfter, (event) => this.clear(event.id));
      this._repeatedEvents.forEachFrom(computedAfter, (event) => this.clear(event.id));
      return this;
    }
    _bindClockEvents() {
      this._clock.on("start", (time, offset) => {
        offset = new TicksClass(this.context, offset).toSeconds();
        this.emit("start", time, offset);
      });
      this._clock.on("stop", (time) => {
        this.emit("stop", time);
      });
      this._clock.on("pause", (time) => {
        this.emit("pause", time);
      });
    }
    get state() {
      return this._clock.getStateAtTime(this.now());
    }
    start(time, offset) {
      this.context.resume();
      let offsetTicks;
      if (isDefined(offset)) {
        offsetTicks = this.toTicks(offset);
      }
      this._clock.start(time, offsetTicks);
      return this;
    }
    stop(time) {
      this._clock.stop(time);
      return this;
    }
    pause(time) {
      this._clock.pause(time);
      return this;
    }
    toggle(time) {
      time = this.toSeconds(time);
      if (this._clock.getStateAtTime(time) !== "started") {
        this.start(time);
      } else {
        this.stop(time);
      }
      return this;
    }
    get timeSignature() {
      return this._timeSignature;
    }
    set timeSignature(timeSig) {
      if (isArray(timeSig)) {
        timeSig = timeSig[0] / timeSig[1] * 4;
      }
      this._timeSignature = timeSig;
    }
    get loopStart() {
      return new TimeClass(this.context, this._loopStart, "i").toSeconds();
    }
    set loopStart(startPosition) {
      this._loopStart = this.toTicks(startPosition);
    }
    get loopEnd() {
      return new TimeClass(this.context, this._loopEnd, "i").toSeconds();
    }
    set loopEnd(endPosition) {
      this._loopEnd = this.toTicks(endPosition);
    }
    get loop() {
      return this._loop.get(this.now());
    }
    set loop(loop) {
      this._loop.set(loop, this.now());
    }
    setLoopPoints(startPosition, endPosition) {
      this.loopStart = startPosition;
      this.loopEnd = endPosition;
      return this;
    }
    get swing() {
      return this._swingAmount;
    }
    set swing(amount) {
      this._swingAmount = amount;
    }
    get swingSubdivision() {
      return new TicksClass(this.context, this._swingTicks).toNotation();
    }
    set swingSubdivision(subdivision) {
      this._swingTicks = this.toTicks(subdivision);
    }
    get position() {
      const now2 = this.now();
      const ticks = this._clock.getTicksAtTime(now2);
      return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();
    }
    set position(progress) {
      const ticks = this.toTicks(progress);
      this.ticks = ticks;
    }
    get seconds() {
      return this._clock.seconds;
    }
    set seconds(s4) {
      const now2 = this.now();
      const ticks = this._clock.frequency.timeToTicks(s4, now2);
      this.ticks = ticks;
    }
    get progress() {
      if (this.loop) {
        const now2 = this.now();
        const ticks = this._clock.getTicksAtTime(now2);
        return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);
      } else {
        return 0;
      }
    }
    get ticks() {
      return this._clock.ticks;
    }
    set ticks(t8) {
      if (this._clock.ticks !== t8) {
        const now2 = this.now();
        if (this.state === "started") {
          const ticks = this._clock.getTicksAtTime(now2);
          const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now2);
          const time = now2 + remainingTick;
          this.emit("stop", time);
          this._clock.setTicksAtTime(t8, time);
          this.emit("start", time, this._clock.getSecondsAtTime(time));
        } else {
          this.emit("ticks", now2);
          this._clock.setTicksAtTime(t8, now2);
        }
      }
    }
    getTicksAtTime(time) {
      return this._clock.getTicksAtTime(time);
    }
    getSecondsAtTime(time) {
      return this._clock.getSecondsAtTime(time);
    }
    get PPQ() {
      return this._clock.frequency.multiplier;
    }
    set PPQ(ppq) {
      this._clock.frequency.multiplier = ppq;
    }
    nextSubdivision(subdivision) {
      subdivision = this.toTicks(subdivision);
      if (this.state !== "started") {
        return 0;
      } else {
        const now2 = this.now();
        const transportPos = this.getTicksAtTime(now2);
        const remainingTicks = subdivision - transportPos % subdivision;
        return this._clock.nextTickTime(remainingTicks, now2);
      }
    }
    syncSignal(signal, ratio) {
      if (!ratio) {
        const now2 = this.now();
        if (signal.getValueAtTime(now2) !== 0) {
          const bpm = this.bpm.getValueAtTime(now2);
          const computedFreq = 1 / (60 / bpm / this.PPQ);
          ratio = signal.getValueAtTime(now2) / computedFreq;
        } else {
          ratio = 0;
        }
      }
      const ratioSignal = new Gain(ratio);
      this.bpm.connect(ratioSignal);
      ratioSignal.connect(signal._param);
      this._syncedSignals.push({
        initial: signal.value,
        ratio: ratioSignal,
        signal
      });
      signal.value = 0;
      return this;
    }
    unsyncSignal(signal) {
      for (let i8 = this._syncedSignals.length - 1; i8 >= 0; i8--) {
        const syncedSignal = this._syncedSignals[i8];
        if (syncedSignal.signal === signal) {
          syncedSignal.ratio.dispose();
          syncedSignal.signal.value = syncedSignal.initial;
          this._syncedSignals.splice(i8, 1);
        }
      }
      return this;
    }
    dispose() {
      super.dispose();
      this._clock.dispose();
      writable(this, "bpm");
      this._timeline.dispose();
      this._repeatedEvents.dispose();
      return this;
    }
  };
  Emitter.mixin(Transport);
  onContextInit((context2) => {
    context2.transport = new Transport({ context: context2 });
  });
  onContextClose((context2) => {
    context2.transport.dispose();
  });

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/Source.js
  var Source = class extends ToneAudioNode {
    constructor(options2) {
      super(options2);
      this.input = void 0;
      this._state = new StateTimeline("stopped");
      this._synced = false;
      this._scheduled = [];
      this._syncedStart = noOp;
      this._syncedStop = noOp;
      this._state.memory = 100;
      this._state.increasing = true;
      this._volume = this.output = new Volume({
        context: this.context,
        mute: options2.mute,
        volume: options2.volume
      });
      this.volume = this._volume.volume;
      readOnly(this, "volume");
      this.onstop = options2.onstop;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        mute: false,
        onstop: noOp,
        volume: 0
      });
    }
    get state() {
      if (this._synced) {
        if (this.context.transport.state === "started") {
          return this._state.getValueAtTime(this.context.transport.seconds);
        } else {
          return "stopped";
        }
      } else {
        return this._state.getValueAtTime(this.now());
      }
    }
    get mute() {
      return this._volume.mute;
    }
    set mute(mute) {
      this._volume.mute = mute;
    }
    _clampToCurrentTime(time) {
      if (this._synced) {
        return time;
      } else {
        return Math.max(time, this.context.currentTime);
      }
    }
    start(time, offset, duration2) {
      let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);
      computedTime = this._clampToCurrentTime(computedTime);
      if (!this._synced && this._state.getValueAtTime(computedTime) === "started") {
        assert(GT(computedTime, this._state.get(computedTime).time), "Start time must be strictly greater than previous start time");
        this._state.cancel(computedTime);
        this._state.setStateAtTime("started", computedTime);
        this.log("restart", computedTime);
        this.restart(computedTime, offset, duration2);
      } else {
        this.log("start", computedTime);
        this._state.setStateAtTime("started", computedTime);
        if (this._synced) {
          const event = this._state.get(computedTime);
          if (event) {
            event.offset = this.toSeconds(defaultArg(offset, 0));
            event.duration = duration2 ? this.toSeconds(duration2) : void 0;
          }
          const sched = this.context.transport.schedule((t8) => {
            this._start(t8, offset, duration2);
          }, computedTime);
          this._scheduled.push(sched);
          if (this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {
            this._syncedStart(this.now(), this.context.transport.seconds);
          }
        } else {
          assertContextRunning(this.context);
          this._start(computedTime, offset, duration2);
        }
      }
      return this;
    }
    stop(time) {
      let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);
      computedTime = this._clampToCurrentTime(computedTime);
      if (this._state.getValueAtTime(computedTime) === "started" || isDefined(this._state.getNextState("started", computedTime))) {
        this.log("stop", computedTime);
        if (!this._synced) {
          this._stop(computedTime);
        } else {
          const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);
          this._scheduled.push(sched);
        }
        this._state.cancel(computedTime);
        this._state.setStateAtTime("stopped", computedTime);
      }
      return this;
    }
    restart(time, offset, duration2) {
      time = this.toSeconds(time);
      if (this._state.getValueAtTime(time) === "started") {
        this._state.cancel(time);
        this._restart(time, offset, duration2);
      }
      return this;
    }
    sync() {
      if (!this._synced) {
        this._synced = true;
        this._syncedStart = (time, offset) => {
          if (GT(offset, 0)) {
            const stateEvent = this._state.get(offset);
            if (stateEvent && stateEvent.state === "started" && stateEvent.time !== offset) {
              const startOffset = offset - this.toSeconds(stateEvent.time);
              let duration2;
              if (stateEvent.duration) {
                duration2 = this.toSeconds(stateEvent.duration) - startOffset;
              }
              this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration2);
            }
          }
        };
        this._syncedStop = (time) => {
          const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));
          if (this._state.getValueAtTime(seconds) === "started") {
            this._stop(time);
          }
        };
        this.context.transport.on("start", this._syncedStart);
        this.context.transport.on("loopStart", this._syncedStart);
        this.context.transport.on("stop", this._syncedStop);
        this.context.transport.on("pause", this._syncedStop);
        this.context.transport.on("loopEnd", this._syncedStop);
      }
      return this;
    }
    unsync() {
      if (this._synced) {
        this.context.transport.off("stop", this._syncedStop);
        this.context.transport.off("pause", this._syncedStop);
        this.context.transport.off("loopEnd", this._syncedStop);
        this.context.transport.off("start", this._syncedStart);
        this.context.transport.off("loopStart", this._syncedStart);
      }
      this._synced = false;
      this._scheduled.forEach((id) => this.context.transport.clear(id));
      this._scheduled = [];
      this._state.cancel(0);
      this._stop(0);
      return this;
    }
    dispose() {
      super.dispose();
      this.onstop = noOp;
      this.unsync();
      this._volume.dispose();
      this._state.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/buffer/ToneBufferSource.js
  var ToneBufferSource = class extends OneShotSource {
    constructor() {
      super(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, ["url", "onload"]));
      this.name = "ToneBufferSource";
      this._source = this.context.createBufferSource();
      this._internalChannels = [this._source];
      this._sourceStarted = false;
      this._sourceStopped = false;
      const options2 = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, ["url", "onload"]);
      connect(this._source, this._gainNode);
      this._source.onended = () => this._stopSource();
      this.playbackRate = new Param({
        context: this.context,
        param: this._source.playbackRate,
        units: "positive",
        value: options2.playbackRate
      });
      this.loop = options2.loop;
      this.loopStart = options2.loopStart;
      this.loopEnd = options2.loopEnd;
      this._buffer = new ToneAudioBuffer(options2.url, options2.onload, options2.onerror);
      this._internalChannels.push(this._source);
    }
    static getDefaults() {
      return Object.assign(OneShotSource.getDefaults(), {
        url: new ToneAudioBuffer(),
        loop: false,
        loopEnd: 0,
        loopStart: 0,
        onload: noOp,
        onerror: noOp,
        playbackRate: 1
      });
    }
    get fadeIn() {
      return this._fadeIn;
    }
    set fadeIn(t8) {
      this._fadeIn = t8;
    }
    get fadeOut() {
      return this._fadeOut;
    }
    set fadeOut(t8) {
      this._fadeOut = t8;
    }
    get curve() {
      return this._curve;
    }
    set curve(t8) {
      this._curve = t8;
    }
    start(time, offset, duration2, gain = 1) {
      assert(this.buffer.loaded, "buffer is either not set or not loaded");
      const computedTime = this.toSeconds(time);
      this._startGain(computedTime, gain);
      if (this.loop) {
        offset = defaultArg(offset, this.loopStart);
      } else {
        offset = defaultArg(offset, 0);
      }
      let computedOffset = Math.max(this.toSeconds(offset), 0);
      if (this.loop) {
        const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
        const loopStart = this.toSeconds(this.loopStart);
        const loopDuration = loopEnd - loopStart;
        if (GTE(computedOffset, loopEnd)) {
          computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;
        }
        if (EQ(computedOffset, this.buffer.duration)) {
          computedOffset = 0;
        }
      }
      this._source.buffer = this.buffer.get();
      this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
      if (LT(computedOffset, this.buffer.duration)) {
        this._sourceStarted = true;
        this._source.start(computedTime, computedOffset);
      }
      if (isDefined(duration2)) {
        let computedDur = this.toSeconds(duration2);
        computedDur = Math.max(computedDur, 0);
        this.stop(computedTime + computedDur);
      }
      return this;
    }
    _stopSource(time) {
      if (!this._sourceStopped && this._sourceStarted) {
        this._sourceStopped = true;
        this._source.stop(this.toSeconds(time));
        this._onended();
      }
    }
    get loopStart() {
      return this._source.loopStart;
    }
    set loopStart(loopStart) {
      this._source.loopStart = this.toSeconds(loopStart);
    }
    get loopEnd() {
      return this._source.loopEnd;
    }
    set loopEnd(loopEnd) {
      this._source.loopEnd = this.toSeconds(loopEnd);
    }
    get buffer() {
      return this._buffer;
    }
    set buffer(buffer2) {
      this._buffer.set(buffer2);
    }
    get loop() {
      return this._source.loop;
    }
    set loop(loop) {
      this._source.loop = loop;
      if (this._sourceStarted) {
        this.cancelStop();
      }
    }
    dispose() {
      super.dispose();
      this._source.onended = null;
      this._source.disconnect();
      this._buffer.dispose();
      this.playbackRate.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/Noise.js
  var Noise = class extends Source {
    constructor() {
      super(optionsFromArguments(Noise.getDefaults(), arguments, ["type"]));
      this.name = "Noise";
      this._source = null;
      const options2 = optionsFromArguments(Noise.getDefaults(), arguments, ["type"]);
      this._playbackRate = options2.playbackRate;
      this.type = options2.type;
      this._fadeIn = options2.fadeIn;
      this._fadeOut = options2.fadeOut;
    }
    static getDefaults() {
      return Object.assign(Source.getDefaults(), {
        fadeIn: 0,
        fadeOut: 0,
        playbackRate: 1,
        type: "white"
      });
    }
    get type() {
      return this._type;
    }
    set type(type) {
      assert(type in _noiseBuffers, "Noise: invalid type: " + type);
      if (this._type !== type) {
        this._type = type;
        if (this.state === "started") {
          const now2 = this.now();
          this._stop(now2);
          this._start(now2);
        }
      }
    }
    get playbackRate() {
      return this._playbackRate;
    }
    set playbackRate(rate) {
      this._playbackRate = rate;
      if (this._source) {
        this._source.playbackRate.value = rate;
      }
    }
    _start(time) {
      const buffer2 = _noiseBuffers[this._type];
      this._source = new ToneBufferSource({
        url: buffer2,
        context: this.context,
        fadeIn: this._fadeIn,
        fadeOut: this._fadeOut,
        loop: true,
        onended: () => this.onstop(this),
        playbackRate: this._playbackRate
      }).connect(this.output);
      this._source.start(this.toSeconds(time), Math.random() * (buffer2.duration - 1e-3));
    }
    _stop(time) {
      if (this._source) {
        this._source.stop(this.toSeconds(time));
        this._source = null;
      }
    }
    get fadeIn() {
      return this._fadeIn;
    }
    set fadeIn(time) {
      this._fadeIn = time;
      if (this._source) {
        this._source.fadeIn = this._fadeIn;
      }
    }
    get fadeOut() {
      return this._fadeOut;
    }
    set fadeOut(time) {
      this._fadeOut = time;
      if (this._source) {
        this._source.fadeOut = this._fadeOut;
      }
    }
    _restart(time) {
      this._stop(time);
      this._start(time);
    }
    dispose() {
      super.dispose();
      if (this._source) {
        this._source.disconnect();
      }
      return this;
    }
  };
  var BUFFER_LENGTH = 44100 * 5;
  var NUM_CHANNELS = 2;
  var _noiseCache = {
    brown: null,
    pink: null,
    white: null
  };
  var _noiseBuffers = {
    get brown() {
      if (!_noiseCache.brown) {
        const buffer2 = [];
        for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
          const channel = new Float32Array(BUFFER_LENGTH);
          buffer2[channelNum] = channel;
          let lastOut = 0;
          for (let i8 = 0; i8 < BUFFER_LENGTH; i8++) {
            const white = Math.random() * 2 - 1;
            channel[i8] = (lastOut + 0.02 * white) / 1.02;
            lastOut = channel[i8];
            channel[i8] *= 3.5;
          }
        }
        _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer2);
      }
      return _noiseCache.brown;
    },
    get pink() {
      if (!_noiseCache.pink) {
        const buffer2 = [];
        for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
          const channel = new Float32Array(BUFFER_LENGTH);
          buffer2[channelNum] = channel;
          let b0, b1, b22, b32, b42, b5, b6;
          b0 = b1 = b22 = b32 = b42 = b5 = b6 = 0;
          for (let i8 = 0; i8 < BUFFER_LENGTH; i8++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b22 = 0.969 * b22 + white * 0.153852;
            b32 = 0.8665 * b32 + white * 0.3104856;
            b42 = 0.55 * b42 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.016898;
            channel[i8] = b0 + b1 + b22 + b32 + b42 + b5 + b6 + white * 0.5362;
            channel[i8] *= 0.11;
            b6 = white * 0.115926;
          }
        }
        _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer2);
      }
      return _noiseCache.pink;
    },
    get white() {
      if (!_noiseCache.white) {
        const buffer2 = [];
        for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
          const channel = new Float32Array(BUFFER_LENGTH);
          buffer2[channelNum] = channel;
          for (let i8 = 0; i8 < BUFFER_LENGTH; i8++) {
            channel[i8] = Math.random() * 2 - 1;
          }
        }
        _noiseCache.white = new ToneAudioBuffer().fromArray(buffer2);
      }
      return _noiseCache.white;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/UserMedia.js
  var UserMedia = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(UserMedia.getDefaults(), arguments, ["volume"]));
      this.name = "UserMedia";
      const options2 = optionsFromArguments(UserMedia.getDefaults(), arguments, ["volume"]);
      this._volume = this.output = new Volume({
        context: this.context,
        volume: options2.volume
      });
      this.volume = this._volume.volume;
      readOnly(this, "volume");
      this.mute = options2.mute;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        mute: false,
        volume: 0
      });
    }
    open(labelOrId) {
      return __awaiter(this, void 0, void 0, function* () {
        assert(UserMedia.supported, "UserMedia is not supported");
        if (this.state === "started") {
          this.close();
        }
        const devices2 = yield UserMedia.enumerateDevices();
        if (isNumber(labelOrId)) {
          this._device = devices2[labelOrId];
        } else {
          this._device = devices2.find((device) => {
            return device.label === labelOrId || device.deviceId === labelOrId;
          });
          if (!this._device && devices2.length > 0) {
            this._device = devices2[0];
          }
          assert(isDefined(this._device), `No matching device ${labelOrId}`);
        }
        const constraints = {
          audio: {
            echoCancellation: false,
            sampleRate: this.context.sampleRate,
            noiseSuppression: false,
            mozNoiseSuppression: false
          }
        };
        if (this._device) {
          constraints.audio.deviceId = this._device.deviceId;
        }
        const stream = yield navigator.mediaDevices.getUserMedia(constraints);
        if (!this._stream) {
          this._stream = stream;
          const mediaStreamNode = this.context.createMediaStreamSource(stream);
          connect(mediaStreamNode, this.output);
          this._mediaStream = mediaStreamNode;
        }
        return this;
      });
    }
    close() {
      if (this._stream && this._mediaStream) {
        this._stream.getAudioTracks().forEach((track2) => {
          track2.stop();
        });
        this._stream = void 0;
        this._mediaStream.disconnect();
        this._mediaStream = void 0;
      }
      this._device = void 0;
      return this;
    }
    static enumerateDevices() {
      return __awaiter(this, void 0, void 0, function* () {
        const allDevices = yield navigator.mediaDevices.enumerateDevices();
        return allDevices.filter((device) => {
          return device.kind === "audioinput";
        });
      });
    }
    get state() {
      return this._stream && this._stream.active ? "started" : "stopped";
    }
    get deviceId() {
      if (this._device) {
        return this._device.deviceId;
      } else {
        return void 0;
      }
    }
    get groupId() {
      if (this._device) {
        return this._device.groupId;
      } else {
        return void 0;
      }
    }
    get label() {
      if (this._device) {
        return this._device.label;
      } else {
        return void 0;
      }
    }
    get mute() {
      return this._volume.mute;
    }
    set mute(mute) {
      this._volume.mute = mute;
    }
    dispose() {
      super.dispose();
      this.close();
      this._volume.dispose();
      this.volume.dispose();
      return this;
    }
    static get supported() {
      return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js
  function generateWaveform(instance, length) {
    return __awaiter(this, void 0, void 0, function* () {
      const duration2 = length / instance.context.sampleRate;
      const context2 = new OfflineContext(1, duration2, instance.context.sampleRate);
      const clone = new instance.constructor(Object.assign(instance.get(), {
        frequency: 2 / duration2,
        detune: 0,
        context: context2
      })).toDestination();
      clone.start(0);
      const buffer2 = yield context2.render();
      return buffer2.getChannelData(0);
    });
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js
  var ToneOscillatorNode = class extends OneShotSource {
    constructor() {
      super(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]));
      this.name = "ToneOscillatorNode";
      this._oscillator = this.context.createOscillator();
      this._internalChannels = [this._oscillator];
      const options2 = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]);
      connect(this._oscillator, this._gainNode);
      this.type = options2.type;
      this.frequency = new Param({
        context: this.context,
        param: this._oscillator.frequency,
        units: "frequency",
        value: options2.frequency
      });
      this.detune = new Param({
        context: this.context,
        param: this._oscillator.detune,
        units: "cents",
        value: options2.detune
      });
      readOnly(this, ["frequency", "detune"]);
    }
    static getDefaults() {
      return Object.assign(OneShotSource.getDefaults(), {
        detune: 0,
        frequency: 440,
        type: "sine"
      });
    }
    start(time) {
      const computedTime = this.toSeconds(time);
      this.log("start", computedTime);
      this._startGain(computedTime);
      this._oscillator.start(computedTime);
      return this;
    }
    _stopSource(time) {
      this._oscillator.stop(time);
    }
    setPeriodicWave(periodicWave) {
      this._oscillator.setPeriodicWave(periodicWave);
      return this;
    }
    get type() {
      return this._oscillator.type;
    }
    set type(type) {
      this._oscillator.type = type;
    }
    dispose() {
      super.dispose();
      if (this.state === "started") {
        this.stop();
      }
      this._oscillator.disconnect();
      this.frequency.dispose();
      this.detune.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/Oscillator.js
  var Oscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(Oscillator.getDefaults(), arguments, ["frequency", "type"]));
      this.name = "Oscillator";
      this._oscillator = null;
      const options2 = optionsFromArguments(Oscillator.getDefaults(), arguments, ["frequency", "type"]);
      this.frequency = new Signal({
        context: this.context,
        units: "frequency",
        value: options2.frequency
      });
      readOnly(this, "frequency");
      this.detune = new Signal({
        context: this.context,
        units: "cents",
        value: options2.detune
      });
      readOnly(this, "detune");
      this._partials = options2.partials;
      this._partialCount = options2.partialCount;
      this._type = options2.type;
      if (options2.partialCount && options2.type !== "custom") {
        this._type = this.baseType + options2.partialCount.toString();
      }
      this.phase = options2.phase;
    }
    static getDefaults() {
      return Object.assign(Source.getDefaults(), {
        detune: 0,
        frequency: 440,
        partialCount: 0,
        partials: [],
        phase: 0,
        type: "sine"
      });
    }
    _start(time) {
      const computedTime = this.toSeconds(time);
      const oscillator = new ToneOscillatorNode({
        context: this.context,
        onended: () => this.onstop(this)
      });
      this._oscillator = oscillator;
      if (this._wave) {
        this._oscillator.setPeriodicWave(this._wave);
      } else {
        this._oscillator.type = this._type;
      }
      this._oscillator.connect(this.output);
      this.frequency.connect(this._oscillator.frequency);
      this.detune.connect(this._oscillator.detune);
      this._oscillator.start(computedTime);
    }
    _stop(time) {
      const computedTime = this.toSeconds(time);
      if (this._oscillator) {
        this._oscillator.stop(computedTime);
      }
    }
    _restart(time) {
      const computedTime = this.toSeconds(time);
      this.log("restart", computedTime);
      if (this._oscillator) {
        this._oscillator.cancelStop();
      }
      this._state.cancel(computedTime);
      return this;
    }
    syncFrequency() {
      this.context.transport.syncSignal(this.frequency);
      return this;
    }
    unsyncFrequency() {
      this.context.transport.unsyncSignal(this.frequency);
      return this;
    }
    _getCachedPeriodicWave() {
      if (this._type === "custom") {
        const oscProps = Oscillator._periodicWaveCache.find((description) => {
          return description.phase === this._phase && deepEquals(description.partials, this._partials);
        });
        return oscProps;
      } else {
        const oscProps = Oscillator._periodicWaveCache.find((description) => {
          return description.type === this._type && description.phase === this._phase;
        });
        this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;
        return oscProps;
      }
    }
    get type() {
      return this._type;
    }
    set type(type) {
      this._type = type;
      const isBasicType = ["sine", "square", "sawtooth", "triangle"].indexOf(type) !== -1;
      if (this._phase === 0 && isBasicType) {
        this._wave = void 0;
        this._partialCount = 0;
        if (this._oscillator !== null) {
          this._oscillator.type = type;
        }
      } else {
        const cache4 = this._getCachedPeriodicWave();
        if (isDefined(cache4)) {
          const { partials, wave } = cache4;
          this._wave = wave;
          this._partials = partials;
          if (this._oscillator !== null) {
            this._oscillator.setPeriodicWave(this._wave);
          }
        } else {
          const [real, imag] = this._getRealImaginary(type, this._phase);
          const periodicWave = this.context.createPeriodicWave(real, imag);
          this._wave = periodicWave;
          if (this._oscillator !== null) {
            this._oscillator.setPeriodicWave(this._wave);
          }
          Oscillator._periodicWaveCache.push({
            imag,
            partialCount: this._partialCount,
            partials: this._partials,
            phase: this._phase,
            real,
            type: this._type,
            wave: this._wave
          });
          if (Oscillator._periodicWaveCache.length > 100) {
            Oscillator._periodicWaveCache.shift();
          }
        }
      }
    }
    get baseType() {
      return this._type.replace(this.partialCount.toString(), "");
    }
    set baseType(baseType) {
      if (this.partialCount && this._type !== "custom" && baseType !== "custom") {
        this.type = baseType + this.partialCount;
      } else {
        this.type = baseType;
      }
    }
    get partialCount() {
      return this._partialCount;
    }
    set partialCount(p6) {
      assertRange(p6, 0);
      let type = this._type;
      const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
      if (partial) {
        type = partial[1];
      }
      if (this._type !== "custom") {
        if (p6 === 0) {
          this.type = type;
        } else {
          this.type = type + p6.toString();
        }
      } else {
        const fullPartials = new Float32Array(p6);
        this._partials.forEach((v3, i8) => fullPartials[i8] = v3);
        this._partials = Array.from(fullPartials);
        this.type = this._type;
      }
    }
    _getRealImaginary(type, phase) {
      const fftSize = 4096;
      let periodicWaveSize = fftSize / 2;
      const real = new Float32Array(periodicWaveSize);
      const imag = new Float32Array(periodicWaveSize);
      let partialCount = 1;
      if (type === "custom") {
        partialCount = this._partials.length + 1;
        this._partialCount = this._partials.length;
        periodicWaveSize = partialCount;
        if (this._partials.length === 0) {
          return [real, imag];
        }
      } else {
        const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
        if (partial) {
          partialCount = parseInt(partial[2], 10) + 1;
          this._partialCount = parseInt(partial[2], 10);
          type = partial[1];
          partialCount = Math.max(partialCount, 2);
          periodicWaveSize = partialCount;
        } else {
          this._partialCount = 0;
        }
        this._partials = [];
      }
      for (let n8 = 1; n8 < periodicWaveSize; ++n8) {
        const piFactor = 2 / (n8 * Math.PI);
        let b5;
        switch (type) {
          case "sine":
            b5 = n8 <= partialCount ? 1 : 0;
            this._partials[n8 - 1] = b5;
            break;
          case "square":
            b5 = n8 & 1 ? 2 * piFactor : 0;
            this._partials[n8 - 1] = b5;
            break;
          case "sawtooth":
            b5 = piFactor * (n8 & 1 ? 1 : -1);
            this._partials[n8 - 1] = b5;
            break;
          case "triangle":
            if (n8 & 1) {
              b5 = 2 * (piFactor * piFactor) * (n8 - 1 >> 1 & 1 ? -1 : 1);
            } else {
              b5 = 0;
            }
            this._partials[n8 - 1] = b5;
            break;
          case "custom":
            b5 = this._partials[n8 - 1];
            break;
          default:
            throw new TypeError("Oscillator: invalid type: " + type);
        }
        if (b5 !== 0) {
          real[n8] = -b5 * Math.sin(phase * n8);
          imag[n8] = b5 * Math.cos(phase * n8);
        } else {
          real[n8] = 0;
          imag[n8] = 0;
        }
      }
      return [real, imag];
    }
    _inverseFFT(real, imag, phase) {
      let sum = 0;
      const len = real.length;
      for (let i8 = 0; i8 < len; i8++) {
        sum += real[i8] * Math.cos(i8 * phase) + imag[i8] * Math.sin(i8 * phase);
      }
      return sum;
    }
    getInitialValue() {
      const [real, imag] = this._getRealImaginary(this._type, 0);
      let maxValue = 0;
      const twoPi = Math.PI * 2;
      const testPositions = 32;
      for (let i8 = 0; i8 < testPositions; i8++) {
        maxValue = Math.max(this._inverseFFT(real, imag, i8 / testPositions * twoPi), maxValue);
      }
      return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);
    }
    get partials() {
      return this._partials.slice(0, this.partialCount);
    }
    set partials(partials) {
      this._partials = partials;
      this._partialCount = this._partials.length;
      if (partials.length) {
        this.type = "custom";
      }
    }
    get phase() {
      return this._phase * (180 / Math.PI);
    }
    set phase(phase) {
      this._phase = phase * Math.PI / 180;
      this.type = this._type;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      if (this._oscillator !== null) {
        this._oscillator.dispose();
      }
      this._wave = void 0;
      this.frequency.dispose();
      this.detune.dispose();
      return this;
    }
  };
  Oscillator._periodicWaveCache = [];

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/SignalOperator.js
  var SignalOperator = class extends ToneAudioNode {
    constructor() {
      super(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, ["context"])));
    }
    connect(destination, outputNum = 0, inputNum = 0) {
      connectSignal(this, destination, outputNum, inputNum);
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/WaveShaper.js
  var WaveShaper = class extends SignalOperator {
    constructor() {
      super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, ["mapping", "length"])));
      this.name = "WaveShaper";
      this._shaper = this.context.createWaveShaper();
      this.input = this._shaper;
      this.output = this._shaper;
      const options2 = optionsFromArguments(WaveShaper.getDefaults(), arguments, ["mapping", "length"]);
      if (isArray(options2.mapping) || options2.mapping instanceof Float32Array) {
        this.curve = Float32Array.from(options2.mapping);
      } else if (isFunction(options2.mapping)) {
        this.setMap(options2.mapping, options2.length);
      }
    }
    static getDefaults() {
      return Object.assign(Signal.getDefaults(), {
        length: 1024
      });
    }
    setMap(mapping, length = 1024) {
      const array = new Float32Array(length);
      for (let i8 = 0, len = length; i8 < len; i8++) {
        const normalized = i8 / (len - 1) * 2 - 1;
        array[i8] = mapping(normalized, i8);
      }
      this.curve = array;
      return this;
    }
    get curve() {
      return this._shaper.curve;
    }
    set curve(mapping) {
      this._shaper.curve = mapping;
    }
    get oversample() {
      return this._shaper.oversample;
    }
    set oversample(oversampling) {
      const isOverSampleType = ["none", "2x", "4x"].some((str) => str.includes(oversampling));
      assert(isOverSampleType, "oversampling must be either 'none', '2x', or '4x'");
      this._shaper.oversample = oversampling;
    }
    dispose() {
      super.dispose();
      this._shaper.disconnect();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/AudioToGain.js
  var AudioToGain = class extends SignalOperator {
    constructor() {
      super(...arguments);
      this.name = "AudioToGain";
      this._norm = new WaveShaper({
        context: this.context,
        mapping: (x4) => (x4 + 1) / 2
      });
      this.input = this._norm;
      this.output = this._norm;
    }
    dispose() {
      super.dispose();
      this._norm.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/Multiply.js
  var Multiply = class extends Signal {
    constructor() {
      super(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, ["value"])));
      this.name = "Multiply";
      this.override = false;
      const options2 = optionsFromArguments(Multiply.getDefaults(), arguments, ["value"]);
      this._mult = this.input = this.output = new Gain({
        context: this.context,
        minValue: options2.minValue,
        maxValue: options2.maxValue
      });
      this.factor = this._param = this._mult.gain;
      this.factor.setValueAtTime(options2.value, 0);
    }
    static getDefaults() {
      return Object.assign(Signal.getDefaults(), {
        value: 0
      });
    }
    dispose() {
      super.dispose();
      this._mult.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/AMOscillator.js
  var AMOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
      this.name = "AMOscillator";
      this._modulationScale = new AudioToGain({ context: this.context });
      this._modulationNode = new Gain({
        context: this.context
      });
      const options2 = optionsFromArguments(AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
      this._carrier = new Oscillator({
        context: this.context,
        detune: options2.detune,
        frequency: options2.frequency,
        onstop: () => this.onstop(this),
        phase: options2.phase,
        type: options2.type
      });
      this.frequency = this._carrier.frequency, this.detune = this._carrier.detune;
      this._modulator = new Oscillator({
        context: this.context,
        phase: options2.phase,
        type: options2.modulationType
      });
      this.harmonicity = new Multiply({
        context: this.context,
        units: "positive",
        value: options2.harmonicity
      });
      this.frequency.chain(this.harmonicity, this._modulator.frequency);
      this._modulator.chain(this._modulationScale, this._modulationNode.gain);
      this._carrier.chain(this._modulationNode, this.output);
      readOnly(this, ["frequency", "detune", "harmonicity"]);
    }
    static getDefaults() {
      return Object.assign(Oscillator.getDefaults(), {
        harmonicity: 1,
        modulationType: "square"
      });
    }
    _start(time) {
      this._modulator.start(time);
      this._carrier.start(time);
    }
    _stop(time) {
      this._modulator.stop(time);
      this._carrier.stop(time);
    }
    _restart(time) {
      this._modulator.restart(time);
      this._carrier.restart(time);
    }
    get type() {
      return this._carrier.type;
    }
    set type(type) {
      this._carrier.type = type;
    }
    get baseType() {
      return this._carrier.baseType;
    }
    set baseType(baseType) {
      this._carrier.baseType = baseType;
    }
    get partialCount() {
      return this._carrier.partialCount;
    }
    set partialCount(partialCount) {
      this._carrier.partialCount = partialCount;
    }
    get modulationType() {
      return this._modulator.type;
    }
    set modulationType(type) {
      this._modulator.type = type;
    }
    get phase() {
      return this._carrier.phase;
    }
    set phase(phase) {
      this._carrier.phase = phase;
      this._modulator.phase = phase;
    }
    get partials() {
      return this._carrier.partials;
    }
    set partials(partials) {
      this._carrier.partials = partials;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this.frequency.dispose();
      this.detune.dispose();
      this.harmonicity.dispose();
      this._carrier.dispose();
      this._modulator.dispose();
      this._modulationNode.dispose();
      this._modulationScale.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/FMOscillator.js
  var FMOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
      this.name = "FMOscillator";
      this._modulationNode = new Gain({
        context: this.context,
        gain: 0
      });
      const options2 = optionsFromArguments(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
      this._carrier = new Oscillator({
        context: this.context,
        detune: options2.detune,
        frequency: 0,
        onstop: () => this.onstop(this),
        phase: options2.phase,
        type: options2.type
      });
      this.detune = this._carrier.detune;
      this.frequency = new Signal({
        context: this.context,
        units: "frequency",
        value: options2.frequency
      });
      this._modulator = new Oscillator({
        context: this.context,
        phase: options2.phase,
        type: options2.modulationType
      });
      this.harmonicity = new Multiply({
        context: this.context,
        units: "positive",
        value: options2.harmonicity
      });
      this.modulationIndex = new Multiply({
        context: this.context,
        units: "positive",
        value: options2.modulationIndex
      });
      this.frequency.connect(this._carrier.frequency);
      this.frequency.chain(this.harmonicity, this._modulator.frequency);
      this.frequency.chain(this.modulationIndex, this._modulationNode);
      this._modulator.connect(this._modulationNode.gain);
      this._modulationNode.connect(this._carrier.frequency);
      this._carrier.connect(this.output);
      this.detune.connect(this._modulator.detune);
      readOnly(this, ["modulationIndex", "frequency", "detune", "harmonicity"]);
    }
    static getDefaults() {
      return Object.assign(Oscillator.getDefaults(), {
        harmonicity: 1,
        modulationIndex: 2,
        modulationType: "square"
      });
    }
    _start(time) {
      this._modulator.start(time);
      this._carrier.start(time);
    }
    _stop(time) {
      this._modulator.stop(time);
      this._carrier.stop(time);
    }
    _restart(time) {
      this._modulator.restart(time);
      this._carrier.restart(time);
      return this;
    }
    get type() {
      return this._carrier.type;
    }
    set type(type) {
      this._carrier.type = type;
    }
    get baseType() {
      return this._carrier.baseType;
    }
    set baseType(baseType) {
      this._carrier.baseType = baseType;
    }
    get partialCount() {
      return this._carrier.partialCount;
    }
    set partialCount(partialCount) {
      this._carrier.partialCount = partialCount;
    }
    get modulationType() {
      return this._modulator.type;
    }
    set modulationType(type) {
      this._modulator.type = type;
    }
    get phase() {
      return this._carrier.phase;
    }
    set phase(phase) {
      this._carrier.phase = phase;
      this._modulator.phase = phase;
    }
    get partials() {
      return this._carrier.partials;
    }
    set partials(partials) {
      this._carrier.partials = partials;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this.frequency.dispose();
      this.harmonicity.dispose();
      this._carrier.dispose();
      this._modulator.dispose();
      this._modulationNode.dispose();
      this.modulationIndex.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/PulseOscillator.js
  var PulseOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(PulseOscillator.getDefaults(), arguments, ["frequency", "width"]));
      this.name = "PulseOscillator";
      this._widthGate = new Gain({
        context: this.context,
        gain: 0
      });
      this._thresh = new WaveShaper({
        context: this.context,
        mapping: (val) => val <= 0 ? -1 : 1
      });
      const options2 = optionsFromArguments(PulseOscillator.getDefaults(), arguments, ["frequency", "width"]);
      this.width = new Signal({
        context: this.context,
        units: "audioRange",
        value: options2.width
      });
      this._triangle = new Oscillator({
        context: this.context,
        detune: options2.detune,
        frequency: options2.frequency,
        onstop: () => this.onstop(this),
        phase: options2.phase,
        type: "triangle"
      });
      this.frequency = this._triangle.frequency;
      this.detune = this._triangle.detune;
      this._triangle.chain(this._thresh, this.output);
      this.width.chain(this._widthGate, this._thresh);
      readOnly(this, ["width", "frequency", "detune"]);
    }
    static getDefaults() {
      return Object.assign(Source.getDefaults(), {
        detune: 0,
        frequency: 440,
        phase: 0,
        type: "pulse",
        width: 0.2
      });
    }
    _start(time) {
      time = this.toSeconds(time);
      this._triangle.start(time);
      this._widthGate.gain.setValueAtTime(1, time);
    }
    _stop(time) {
      time = this.toSeconds(time);
      this._triangle.stop(time);
      this._widthGate.gain.cancelScheduledValues(time);
      this._widthGate.gain.setValueAtTime(0, time);
    }
    _restart(time) {
      this._triangle.restart(time);
      this._widthGate.gain.cancelScheduledValues(time);
      this._widthGate.gain.setValueAtTime(1, time);
    }
    get phase() {
      return this._triangle.phase;
    }
    set phase(phase) {
      this._triangle.phase = phase;
    }
    get type() {
      return "pulse";
    }
    get baseType() {
      return "pulse";
    }
    get partials() {
      return [];
    }
    get partialCount() {
      return 0;
    }
    set carrierType(type) {
      this._triangle.type = type;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this._triangle.dispose();
      this.width.dispose();
      this._widthGate.dispose();
      this._thresh.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/FatOscillator.js
  var FatOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]));
      this.name = "FatOscillator";
      this._oscillators = [];
      const options2 = optionsFromArguments(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]);
      this.frequency = new Signal({
        context: this.context,
        units: "frequency",
        value: options2.frequency
      });
      this.detune = new Signal({
        context: this.context,
        units: "cents",
        value: options2.detune
      });
      this._spread = options2.spread;
      this._type = options2.type;
      this._phase = options2.phase;
      this._partials = options2.partials;
      this._partialCount = options2.partialCount;
      this.count = options2.count;
      readOnly(this, ["frequency", "detune"]);
    }
    static getDefaults() {
      return Object.assign(Oscillator.getDefaults(), {
        count: 3,
        spread: 20,
        type: "sawtooth"
      });
    }
    _start(time) {
      time = this.toSeconds(time);
      this._forEach((osc) => osc.start(time));
    }
    _stop(time) {
      time = this.toSeconds(time);
      this._forEach((osc) => osc.stop(time));
    }
    _restart(time) {
      this._forEach((osc) => osc.restart(time));
    }
    _forEach(iterator) {
      for (let i8 = 0; i8 < this._oscillators.length; i8++) {
        iterator(this._oscillators[i8], i8);
      }
    }
    get type() {
      return this._type;
    }
    set type(type) {
      this._type = type;
      this._forEach((osc) => osc.type = type);
    }
    get spread() {
      return this._spread;
    }
    set spread(spread) {
      this._spread = spread;
      if (this._oscillators.length > 1) {
        const start3 = -spread / 2;
        const step = spread / (this._oscillators.length - 1);
        this._forEach((osc, i8) => osc.detune.value = start3 + step * i8);
      }
    }
    get count() {
      return this._oscillators.length;
    }
    set count(count) {
      assertRange(count, 1);
      if (this._oscillators.length !== count) {
        this._forEach((osc) => osc.dispose());
        this._oscillators = [];
        for (let i8 = 0; i8 < count; i8++) {
          const osc = new Oscillator({
            context: this.context,
            volume: -6 - count * 1.1,
            type: this._type,
            phase: this._phase + i8 / count * 360,
            partialCount: this._partialCount,
            onstop: i8 === 0 ? () => this.onstop(this) : noOp
          });
          if (this.type === "custom") {
            osc.partials = this._partials;
          }
          this.frequency.connect(osc.frequency);
          this.detune.connect(osc.detune);
          osc.detune.overridden = false;
          osc.connect(this.output);
          this._oscillators[i8] = osc;
        }
        this.spread = this._spread;
        if (this.state === "started") {
          this._forEach((osc) => osc.start());
        }
      }
    }
    get phase() {
      return this._phase;
    }
    set phase(phase) {
      this._phase = phase;
      this._forEach((osc, i8) => osc.phase = this._phase + i8 / this.count * 360);
    }
    get baseType() {
      return this._oscillators[0].baseType;
    }
    set baseType(baseType) {
      this._forEach((osc) => osc.baseType = baseType);
      this._type = this._oscillators[0].type;
    }
    get partials() {
      return this._oscillators[0].partials;
    }
    set partials(partials) {
      this._partials = partials;
      this._partialCount = this._partials.length;
      if (partials.length) {
        this._type = "custom";
        this._forEach((osc) => osc.partials = partials);
      }
    }
    get partialCount() {
      return this._oscillators[0].partialCount;
    }
    set partialCount(partialCount) {
      this._partialCount = partialCount;
      this._forEach((osc) => osc.partialCount = partialCount);
      this._type = this._oscillators[0].type;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this.frequency.dispose();
      this.detune.dispose();
      this._forEach((osc) => osc.dispose());
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/PWMOscillator.js
  var PWMOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]));
      this.name = "PWMOscillator";
      this.sourceType = "pwm";
      this._scale = new Multiply({
        context: this.context,
        value: 2
      });
      const options2 = optionsFromArguments(PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
      this._pulse = new PulseOscillator({
        context: this.context,
        frequency: options2.modulationFrequency
      });
      this._pulse.carrierType = "sine";
      this.modulationFrequency = this._pulse.frequency;
      this._modulator = new Oscillator({
        context: this.context,
        detune: options2.detune,
        frequency: options2.frequency,
        onstop: () => this.onstop(this),
        phase: options2.phase
      });
      this.frequency = this._modulator.frequency;
      this.detune = this._modulator.detune;
      this._modulator.chain(this._scale, this._pulse.width);
      this._pulse.connect(this.output);
      readOnly(this, ["modulationFrequency", "frequency", "detune"]);
    }
    static getDefaults() {
      return Object.assign(Source.getDefaults(), {
        detune: 0,
        frequency: 440,
        modulationFrequency: 0.4,
        phase: 0,
        type: "pwm"
      });
    }
    _start(time) {
      time = this.toSeconds(time);
      this._modulator.start(time);
      this._pulse.start(time);
    }
    _stop(time) {
      time = this.toSeconds(time);
      this._modulator.stop(time);
      this._pulse.stop(time);
    }
    _restart(time) {
      this._modulator.restart(time);
      this._pulse.restart(time);
    }
    get type() {
      return "pwm";
    }
    get baseType() {
      return "pwm";
    }
    get partials() {
      return [];
    }
    get partialCount() {
      return 0;
    }
    get phase() {
      return this._modulator.phase;
    }
    set phase(phase) {
      this._modulator.phase = phase;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this._pulse.dispose();
      this._scale.dispose();
      this._modulator.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/OmniOscillator.js
  var OmniOscillatorSourceMap = {
    am: AMOscillator,
    fat: FatOscillator,
    fm: FMOscillator,
    oscillator: Oscillator,
    pulse: PulseOscillator,
    pwm: PWMOscillator
  };
  var OmniOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, ["frequency", "type"]));
      this.name = "OmniOscillator";
      const options2 = optionsFromArguments(OmniOscillator.getDefaults(), arguments, ["frequency", "type"]);
      this.frequency = new Signal({
        context: this.context,
        units: "frequency",
        value: options2.frequency
      });
      this.detune = new Signal({
        context: this.context,
        units: "cents",
        value: options2.detune
      });
      readOnly(this, ["frequency", "detune"]);
      this.set(options2);
    }
    static getDefaults() {
      return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());
    }
    _start(time) {
      this._oscillator.start(time);
    }
    _stop(time) {
      this._oscillator.stop(time);
    }
    _restart(time) {
      this._oscillator.restart(time);
      return this;
    }
    get type() {
      let prefix = "";
      if (["am", "fm", "fat"].some((p6) => this._sourceType === p6)) {
        prefix = this._sourceType;
      }
      return prefix + this._oscillator.type;
    }
    set type(type) {
      if (type.substr(0, 2) === "fm") {
        this._createNewOscillator("fm");
        this._oscillator = this._oscillator;
        this._oscillator.type = type.substr(2);
      } else if (type.substr(0, 2) === "am") {
        this._createNewOscillator("am");
        this._oscillator = this._oscillator;
        this._oscillator.type = type.substr(2);
      } else if (type.substr(0, 3) === "fat") {
        this._createNewOscillator("fat");
        this._oscillator = this._oscillator;
        this._oscillator.type = type.substr(3);
      } else if (type === "pwm") {
        this._createNewOscillator("pwm");
        this._oscillator = this._oscillator;
      } else if (type === "pulse") {
        this._createNewOscillator("pulse");
      } else {
        this._createNewOscillator("oscillator");
        this._oscillator = this._oscillator;
        this._oscillator.type = type;
      }
    }
    get partials() {
      return this._oscillator.partials;
    }
    set partials(partials) {
      if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
        this._oscillator.partials = partials;
      }
    }
    get partialCount() {
      return this._oscillator.partialCount;
    }
    set partialCount(partialCount) {
      if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
        this._oscillator.partialCount = partialCount;
      }
    }
    set(props) {
      if (Reflect.has(props, "type") && props.type) {
        this.type = props.type;
      }
      super.set(props);
      return this;
    }
    _createNewOscillator(oscType) {
      if (oscType !== this._sourceType) {
        this._sourceType = oscType;
        const OscConstructor = OmniOscillatorSourceMap[oscType];
        const now2 = this.now();
        if (this._oscillator) {
          const oldOsc = this._oscillator;
          oldOsc.stop(now2);
          this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);
        }
        this._oscillator = new OscConstructor({
          context: this.context
        });
        this.frequency.connect(this._oscillator.frequency);
        this.detune.connect(this._oscillator.detune);
        this._oscillator.connect(this.output);
        this._oscillator.onstop = () => this.onstop(this);
        if (this.state === "started") {
          this._oscillator.start(now2);
        }
      }
    }
    get phase() {
      return this._oscillator.phase;
    }
    set phase(phase) {
      this._oscillator.phase = phase;
    }
    get sourceType() {
      return this._sourceType;
    }
    set sourceType(sType) {
      let baseType = "sine";
      if (this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse") {
        baseType = this._oscillator.type;
      }
      if (sType === "fm") {
        this.type = "fm" + baseType;
      } else if (sType === "am") {
        this.type = "am" + baseType;
      } else if (sType === "fat") {
        this.type = "fat" + baseType;
      } else if (sType === "oscillator") {
        this.type = baseType;
      } else if (sType === "pulse") {
        this.type = "pulse";
      } else if (sType === "pwm") {
        this.type = "pwm";
      }
    }
    _getOscType(osc, sourceType) {
      return osc instanceof OmniOscillatorSourceMap[sourceType];
    }
    get baseType() {
      return this._oscillator.baseType;
    }
    set baseType(baseType) {
      if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && baseType !== "pulse" && baseType !== "pwm") {
        this._oscillator.baseType = baseType;
      }
    }
    get width() {
      if (this._getOscType(this._oscillator, "pulse")) {
        return this._oscillator.width;
      } else {
        return void 0;
      }
    }
    get count() {
      if (this._getOscType(this._oscillator, "fat")) {
        return this._oscillator.count;
      } else {
        return void 0;
      }
    }
    set count(count) {
      if (this._getOscType(this._oscillator, "fat") && isNumber(count)) {
        this._oscillator.count = count;
      }
    }
    get spread() {
      if (this._getOscType(this._oscillator, "fat")) {
        return this._oscillator.spread;
      } else {
        return void 0;
      }
    }
    set spread(spread) {
      if (this._getOscType(this._oscillator, "fat") && isNumber(spread)) {
        this._oscillator.spread = spread;
      }
    }
    get modulationType() {
      if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
        return this._oscillator.modulationType;
      } else {
        return void 0;
      }
    }
    set modulationType(mType) {
      if ((this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && isString(mType)) {
        this._oscillator.modulationType = mType;
      }
    }
    get modulationIndex() {
      if (this._getOscType(this._oscillator, "fm")) {
        return this._oscillator.modulationIndex;
      } else {
        return void 0;
      }
    }
    get harmonicity() {
      if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
        return this._oscillator.harmonicity;
      } else {
        return void 0;
      }
    }
    get modulationFrequency() {
      if (this._getOscType(this._oscillator, "pwm")) {
        return this._oscillator.modulationFrequency;
      } else {
        return void 0;
      }
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this.detune.dispose();
      this.frequency.dispose();
      this._oscillator.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/Add.js
  var Add = class extends Signal {
    constructor() {
      super(Object.assign(optionsFromArguments(Add.getDefaults(), arguments, ["value"])));
      this.override = false;
      this.name = "Add";
      this._sum = new Gain({ context: this.context });
      this.input = this._sum;
      this.output = this._sum;
      this.addend = this._param;
      connectSeries(this._constantSource, this._sum);
    }
    static getDefaults() {
      return Object.assign(Signal.getDefaults(), {
        value: 0
      });
    }
    dispose() {
      super.dispose();
      this._sum.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/Scale.js
  var Scale = class extends SignalOperator {
    constructor() {
      super(Object.assign(optionsFromArguments(Scale.getDefaults(), arguments, ["min", "max"])));
      this.name = "Scale";
      const options2 = optionsFromArguments(Scale.getDefaults(), arguments, ["min", "max"]);
      this._mult = this.input = new Multiply({
        context: this.context,
        value: options2.max - options2.min
      });
      this._add = this.output = new Add({
        context: this.context,
        value: options2.min
      });
      this._min = options2.min;
      this._max = options2.max;
      this.input.connect(this.output);
    }
    static getDefaults() {
      return Object.assign(SignalOperator.getDefaults(), {
        max: 1,
        min: 0
      });
    }
    get min() {
      return this._min;
    }
    set min(min) {
      this._min = min;
      this._setRange();
    }
    get max() {
      return this._max;
    }
    set max(max) {
      this._max = max;
      this._setRange();
    }
    _setRange() {
      this._add.value = this._min;
      this._mult.value = this._max - this._min;
    }
    dispose() {
      super.dispose();
      this._add.dispose();
      this._mult.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/Zero.js
  var Zero = class extends SignalOperator {
    constructor() {
      super(Object.assign(optionsFromArguments(Zero.getDefaults(), arguments)));
      this.name = "Zero";
      this._gain = new Gain({ context: this.context });
      this.output = this._gain;
      this.input = void 0;
      connect(this.context.getConstant(0), this._gain);
    }
    dispose() {
      super.dispose();
      disconnect(this.context.getConstant(0), this._gain);
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/oscillator/LFO.js
  var LFO = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(LFO.getDefaults(), arguments, ["frequency", "min", "max"]));
      this.name = "LFO";
      this._stoppedValue = 0;
      this._units = "number";
      this.convert = true;
      this._fromType = Param.prototype._fromType;
      this._toType = Param.prototype._toType;
      this._is = Param.prototype._is;
      this._clampValue = Param.prototype._clampValue;
      const options2 = optionsFromArguments(LFO.getDefaults(), arguments, ["frequency", "min", "max"]);
      this._oscillator = new Oscillator(options2);
      this.frequency = this._oscillator.frequency;
      this._amplitudeGain = new Gain({
        context: this.context,
        gain: options2.amplitude,
        units: "normalRange"
      });
      this.amplitude = this._amplitudeGain.gain;
      this._stoppedSignal = new Signal({
        context: this.context,
        units: "audioRange",
        value: 0
      });
      this._zeros = new Zero({ context: this.context });
      this._a2g = new AudioToGain({ context: this.context });
      this._scaler = this.output = new Scale({
        context: this.context,
        max: options2.max,
        min: options2.min
      });
      this.units = options2.units;
      this.min = options2.min;
      this.max = options2.max;
      this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);
      this._zeros.connect(this._a2g);
      this._stoppedSignal.connect(this._a2g);
      readOnly(this, ["amplitude", "frequency"]);
      this.phase = options2.phase;
    }
    static getDefaults() {
      return Object.assign(Oscillator.getDefaults(), {
        amplitude: 1,
        frequency: "4n",
        max: 1,
        min: 0,
        type: "sine",
        units: "number"
      });
    }
    start(time) {
      time = this.toSeconds(time);
      this._stoppedSignal.setValueAtTime(0, time);
      this._oscillator.start(time);
      return this;
    }
    stop(time) {
      time = this.toSeconds(time);
      this._stoppedSignal.setValueAtTime(this._stoppedValue, time);
      this._oscillator.stop(time);
      return this;
    }
    sync() {
      this._oscillator.sync();
      this._oscillator.syncFrequency();
      return this;
    }
    unsync() {
      this._oscillator.unsync();
      this._oscillator.unsyncFrequency();
      return this;
    }
    _setStoppedValue() {
      this._stoppedValue = this._oscillator.getInitialValue();
      this._stoppedSignal.value = this._stoppedValue;
    }
    get min() {
      return this._toType(this._scaler.min);
    }
    set min(min) {
      min = this._fromType(min);
      this._scaler.min = min;
    }
    get max() {
      return this._toType(this._scaler.max);
    }
    set max(max) {
      max = this._fromType(max);
      this._scaler.max = max;
    }
    get type() {
      return this._oscillator.type;
    }
    set type(type) {
      this._oscillator.type = type;
      this._setStoppedValue();
    }
    get partials() {
      return this._oscillator.partials;
    }
    set partials(partials) {
      this._oscillator.partials = partials;
      this._setStoppedValue();
    }
    get phase() {
      return this._oscillator.phase;
    }
    set phase(phase) {
      this._oscillator.phase = phase;
      this._setStoppedValue();
    }
    get units() {
      return this._units;
    }
    set units(val) {
      const currentMin = this.min;
      const currentMax = this.max;
      this._units = val;
      this.min = currentMin;
      this.max = currentMax;
    }
    get state() {
      return this._oscillator.state;
    }
    connect(node, outputNum, inputNum) {
      if (node instanceof Param || node instanceof Signal) {
        this.convert = node.convert;
        this.units = node.units;
      }
      connectSignal(this, node, outputNum, inputNum);
      return this;
    }
    dispose() {
      super.dispose();
      this._oscillator.dispose();
      this._stoppedSignal.dispose();
      this._zeros.dispose();
      this._scaler.dispose();
      this._a2g.dispose();
      this._amplitudeGain.dispose();
      this.amplitude.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/util/Decorator.js
  function range(min, max = Infinity) {
    const valueMap = /* @__PURE__ */ new WeakMap();
    return function(target, propertyKey) {
      Reflect.defineProperty(target, propertyKey, {
        configurable: true,
        enumerable: true,
        get: function() {
          return valueMap.get(this);
        },
        set: function(newValue) {
          assertRange(newValue, min, max);
          valueMap.set(this, newValue);
        }
      });
    };
  }
  function timeRange(min, max = Infinity) {
    const valueMap = /* @__PURE__ */ new WeakMap();
    return function(target, propertyKey) {
      Reflect.defineProperty(target, propertyKey, {
        configurable: true,
        enumerable: true,
        get: function() {
          return valueMap.get(this);
        },
        set: function(newValue) {
          assertRange(this.toSeconds(newValue), min, max);
          valueMap.set(this, newValue);
        }
      });
    };
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/source/buffer/Player.js
  var Player = class extends Source {
    constructor() {
      super(optionsFromArguments(Player.getDefaults(), arguments, [
        "url",
        "onload"
      ]));
      this.name = "Player";
      this._activeSources = /* @__PURE__ */ new Set();
      const options2 = optionsFromArguments(Player.getDefaults(), arguments, [
        "url",
        "onload"
      ]);
      this._buffer = new ToneAudioBuffer({
        onload: this._onload.bind(this, options2.onload),
        onerror: options2.onerror,
        reverse: options2.reverse,
        url: options2.url
      });
      this.autostart = options2.autostart;
      this._loop = options2.loop;
      this._loopStart = options2.loopStart;
      this._loopEnd = options2.loopEnd;
      this._playbackRate = options2.playbackRate;
      this.fadeIn = options2.fadeIn;
      this.fadeOut = options2.fadeOut;
    }
    static getDefaults() {
      return Object.assign(Source.getDefaults(), {
        autostart: false,
        fadeIn: 0,
        fadeOut: 0,
        loop: false,
        loopEnd: 0,
        loopStart: 0,
        onload: noOp,
        onerror: noOp,
        playbackRate: 1,
        reverse: false
      });
    }
    load(url) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this._buffer.load(url);
        this._onload();
        return this;
      });
    }
    _onload(callback = noOp) {
      callback();
      if (this.autostart) {
        this.start();
      }
    }
    _onSourceEnd(source) {
      this.onstop(this);
      this._activeSources.delete(source);
      if (this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started") {
        this._state.cancel(this.now());
        this._state.setStateAtTime("stopped", this.now());
      }
    }
    start(time, offset, duration2) {
      super.start(time, offset, duration2);
      return this;
    }
    _start(startTime, offset, duration2) {
      if (this._loop) {
        offset = defaultArg(offset, this._loopStart);
      } else {
        offset = defaultArg(offset, 0);
      }
      const computedOffset = this.toSeconds(offset);
      const origDuration = duration2;
      duration2 = defaultArg(duration2, Math.max(this._buffer.duration - computedOffset, 0));
      let computedDuration = this.toSeconds(duration2);
      computedDuration = computedDuration / this._playbackRate;
      startTime = this.toSeconds(startTime);
      const source = new ToneBufferSource({
        url: this._buffer,
        context: this.context,
        fadeIn: this.fadeIn,
        fadeOut: this.fadeOut,
        loop: this._loop,
        loopEnd: this._loopEnd,
        loopStart: this._loopStart,
        onended: this._onSourceEnd.bind(this),
        playbackRate: this._playbackRate
      }).connect(this.output);
      if (!this._loop && !this._synced) {
        this._state.cancel(startTime + computedDuration);
        this._state.setStateAtTime("stopped", startTime + computedDuration, {
          implicitEnd: true
        });
      }
      this._activeSources.add(source);
      if (this._loop && isUndef(origDuration)) {
        source.start(startTime, computedOffset);
      } else {
        source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));
      }
    }
    _stop(time) {
      const computedTime = this.toSeconds(time);
      this._activeSources.forEach((source) => source.stop(computedTime));
    }
    restart(time, offset, duration2) {
      super.restart(time, offset, duration2);
      return this;
    }
    _restart(time, offset, duration2) {
      var _a3;
      (_a3 = [...this._activeSources].pop()) === null || _a3 === void 0 ? void 0 : _a3.stop(time);
      this._start(time, offset, duration2);
    }
    seek(offset, when) {
      const computedTime = this.toSeconds(when);
      if (this._state.getValueAtTime(computedTime) === "started") {
        const computedOffset = this.toSeconds(offset);
        this._stop(computedTime);
        this._start(computedTime, computedOffset);
      }
      return this;
    }
    setLoopPoints(loopStart, loopEnd) {
      this.loopStart = loopStart;
      this.loopEnd = loopEnd;
      return this;
    }
    get loopStart() {
      return this._loopStart;
    }
    set loopStart(loopStart) {
      this._loopStart = loopStart;
      if (this.buffer.loaded) {
        assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);
      }
      this._activeSources.forEach((source) => {
        source.loopStart = loopStart;
      });
    }
    get loopEnd() {
      return this._loopEnd;
    }
    set loopEnd(loopEnd) {
      this._loopEnd = loopEnd;
      if (this.buffer.loaded) {
        assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);
      }
      this._activeSources.forEach((source) => {
        source.loopEnd = loopEnd;
      });
    }
    get buffer() {
      return this._buffer;
    }
    set buffer(buffer2) {
      this._buffer.set(buffer2);
    }
    get loop() {
      return this._loop;
    }
    set loop(loop) {
      if (this._loop === loop) {
        return;
      }
      this._loop = loop;
      this._activeSources.forEach((source) => {
        source.loop = loop;
      });
      if (loop) {
        const stopEvent = this._state.getNextState("stopped", this.now());
        if (stopEvent) {
          this._state.cancel(stopEvent.time);
        }
      }
    }
    get playbackRate() {
      return this._playbackRate;
    }
    set playbackRate(rate) {
      this._playbackRate = rate;
      const now2 = this.now();
      const stopEvent = this._state.getNextState("stopped", now2);
      if (stopEvent && stopEvent.implicitEnd) {
        this._state.cancel(stopEvent.time);
        this._activeSources.forEach((source) => source.cancelStop());
      }
      this._activeSources.forEach((source) => {
        source.playbackRate.setValueAtTime(rate, now2);
      });
    }
    get reverse() {
      return this._buffer.reverse;
    }
    set reverse(rev) {
      this._buffer.reverse = rev;
    }
    get loaded() {
      return this._buffer.loaded;
    }
    dispose() {
      super.dispose();
      this._activeSources.forEach((source) => source.dispose());
      this._activeSources.clear();
      this._buffer.dispose();
      return this;
    }
  };
  __decorate([
    timeRange(0)
  ], Player.prototype, "fadeIn", void 0);
  __decorate([
    timeRange(0)
  ], Player.prototype, "fadeOut", void 0);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/Abs.js
  var Abs = class extends SignalOperator {
    constructor() {
      super(...arguments);
      this.name = "Abs";
      this._abs = new WaveShaper({
        context: this.context,
        mapping: (val) => {
          if (Math.abs(val) < 1e-3) {
            return 0;
          } else {
            return Math.abs(val);
          }
        }
      });
      this.input = this._abs;
      this.output = this._abs;
    }
    dispose() {
      super.dispose();
      this._abs.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/GainToAudio.js
  var GainToAudio = class extends SignalOperator {
    constructor() {
      super(...arguments);
      this.name = "GainToAudio";
      this._norm = new WaveShaper({
        context: this.context,
        mapping: (x4) => Math.abs(x4) * 2 - 1
      });
      this.input = this._norm;
      this.output = this._norm;
    }
    dispose() {
      super.dispose();
      this._norm.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/Negate.js
  var Negate = class extends SignalOperator {
    constructor() {
      super(...arguments);
      this.name = "Negate";
      this._multiply = new Multiply({
        context: this.context,
        value: -1
      });
      this.input = this._multiply;
      this.output = this._multiply;
    }
    dispose() {
      super.dispose();
      this._multiply.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/Subtract.js
  var Subtract = class extends Signal {
    constructor() {
      super(Object.assign(optionsFromArguments(Subtract.getDefaults(), arguments, ["value"])));
      this.override = false;
      this.name = "Subtract";
      this._sum = new Gain({ context: this.context });
      this.input = this._sum;
      this.output = this._sum;
      this._neg = new Negate({ context: this.context });
      this.subtrahend = this._param;
      connectSeries(this._constantSource, this._neg, this._sum);
    }
    static getDefaults() {
      return Object.assign(Signal.getDefaults(), {
        value: 0
      });
    }
    dispose() {
      super.dispose();
      this._neg.dispose();
      this._sum.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/GreaterThanZero.js
  var GreaterThanZero = class extends SignalOperator {
    constructor() {
      super(Object.assign(optionsFromArguments(GreaterThanZero.getDefaults(), arguments)));
      this.name = "GreaterThanZero";
      this._thresh = this.output = new WaveShaper({
        context: this.context,
        length: 127,
        mapping: (val) => {
          if (val <= 0) {
            return 0;
          } else {
            return 1;
          }
        }
      });
      this._scale = this.input = new Multiply({
        context: this.context,
        value: 1e4
      });
      this._scale.connect(this._thresh);
    }
    dispose() {
      super.dispose();
      this._scale.dispose();
      this._thresh.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/GreaterThan.js
  var GreaterThan = class extends Signal {
    constructor() {
      super(Object.assign(optionsFromArguments(GreaterThan.getDefaults(), arguments, ["value"])));
      this.name = "GreaterThan";
      this.override = false;
      const options2 = optionsFromArguments(GreaterThan.getDefaults(), arguments, ["value"]);
      this._subtract = this.input = new Subtract({
        context: this.context,
        value: options2.value
      });
      this._gtz = this.output = new GreaterThanZero({ context: this.context });
      this.comparator = this._param = this._subtract.subtrahend;
      readOnly(this, "comparator");
      this._subtract.connect(this._gtz);
    }
    static getDefaults() {
      return Object.assign(Signal.getDefaults(), {
        value: 0
      });
    }
    dispose() {
      super.dispose();
      this._gtz.dispose();
      this._subtract.dispose();
      this.comparator.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/signal/Pow.js
  var Pow = class extends SignalOperator {
    constructor() {
      super(Object.assign(optionsFromArguments(Pow.getDefaults(), arguments, ["value"])));
      this.name = "Pow";
      const options2 = optionsFromArguments(Pow.getDefaults(), arguments, ["value"]);
      this._exponentScaler = this.input = this.output = new WaveShaper({
        context: this.context,
        mapping: this._expFunc(options2.value),
        length: 8192
      });
      this._exponent = options2.value;
    }
    static getDefaults() {
      return Object.assign(SignalOperator.getDefaults(), {
        value: 1
      });
    }
    _expFunc(exponent) {
      return (val) => {
        return Math.pow(Math.abs(val), exponent);
      };
    }
    get value() {
      return this._exponent;
    }
    set value(exponent) {
      this._exponent = exponent;
      this._exponentScaler.setMap(this._expFunc(this._exponent));
    }
    dispose() {
      super.dispose();
      this._exponentScaler.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/envelope/Envelope.js
  var Envelope = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
      this.name = "Envelope";
      this._sig = new Signal({
        context: this.context,
        value: 0
      });
      this.output = this._sig;
      this.input = void 0;
      const options2 = optionsFromArguments(Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
      this.attack = options2.attack;
      this.decay = options2.decay;
      this.sustain = options2.sustain;
      this.release = options2.release;
      this.attackCurve = options2.attackCurve;
      this.releaseCurve = options2.releaseCurve;
      this.decayCurve = options2.decayCurve;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        attack: 0.01,
        attackCurve: "linear",
        decay: 0.1,
        decayCurve: "exponential",
        release: 1,
        releaseCurve: "exponential",
        sustain: 0.5
      });
    }
    get value() {
      return this.getValueAtTime(this.now());
    }
    _getCurve(curve, direction) {
      if (isString(curve)) {
        return curve;
      } else {
        let curveName;
        for (curveName in EnvelopeCurves) {
          if (EnvelopeCurves[curveName][direction] === curve) {
            return curveName;
          }
        }
        return curve;
      }
    }
    _setCurve(name2, direction, curve) {
      if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {
        const curveDef = EnvelopeCurves[curve];
        if (isObject(curveDef)) {
          if (name2 !== "_decayCurve") {
            this[name2] = curveDef[direction];
          }
        } else {
          this[name2] = curveDef;
        }
      } else if (isArray(curve) && name2 !== "_decayCurve") {
        this[name2] = curve;
      } else {
        throw new Error("Envelope: invalid curve: " + curve);
      }
    }
    get attackCurve() {
      return this._getCurve(this._attackCurve, "In");
    }
    set attackCurve(curve) {
      this._setCurve("_attackCurve", "In", curve);
    }
    get releaseCurve() {
      return this._getCurve(this._releaseCurve, "Out");
    }
    set releaseCurve(curve) {
      this._setCurve("_releaseCurve", "Out", curve);
    }
    get decayCurve() {
      return this._decayCurve;
    }
    set decayCurve(curve) {
      assert(["linear", "exponential"].some((c6) => c6 === curve), `Invalid envelope curve: ${curve}`);
      this._decayCurve = curve;
    }
    triggerAttack(time, velocity = 1) {
      this.log("triggerAttack", time, velocity);
      time = this.toSeconds(time);
      const originalAttack = this.toSeconds(this.attack);
      let attack = originalAttack;
      const decay = this.toSeconds(this.decay);
      const currentValue = this.getValueAtTime(time);
      if (currentValue > 0) {
        const attackRate = 1 / attack;
        const remainingDistance = 1 - currentValue;
        attack = remainingDistance / attackRate;
      }
      if (attack < this.sampleTime) {
        this._sig.cancelScheduledValues(time);
        this._sig.setValueAtTime(velocity, time);
      } else if (this._attackCurve === "linear") {
        this._sig.linearRampTo(velocity, attack, time);
      } else if (this._attackCurve === "exponential") {
        this._sig.targetRampTo(velocity, attack, time);
      } else {
        this._sig.cancelAndHoldAtTime(time);
        let curve = this._attackCurve;
        for (let i8 = 1; i8 < curve.length; i8++) {
          if (curve[i8 - 1] <= currentValue && currentValue <= curve[i8]) {
            curve = this._attackCurve.slice(i8);
            curve[0] = currentValue;
            break;
          }
        }
        this._sig.setValueCurveAtTime(curve, time, attack, velocity);
      }
      if (decay && this.sustain < 1) {
        const decayValue = velocity * this.sustain;
        const decayStart = time + attack;
        this.log("decay", decayStart);
        if (this._decayCurve === "linear") {
          this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);
        } else {
          this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);
        }
      }
      return this;
    }
    triggerRelease(time) {
      this.log("triggerRelease", time);
      time = this.toSeconds(time);
      const currentValue = this.getValueAtTime(time);
      if (currentValue > 0) {
        const release = this.toSeconds(this.release);
        if (release < this.sampleTime) {
          this._sig.setValueAtTime(0, time);
        } else if (this._releaseCurve === "linear") {
          this._sig.linearRampTo(0, release, time);
        } else if (this._releaseCurve === "exponential") {
          this._sig.targetRampTo(0, release, time);
        } else {
          assert(isArray(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array");
          this._sig.cancelAndHoldAtTime(time);
          this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);
        }
      }
      return this;
    }
    getValueAtTime(time) {
      return this._sig.getValueAtTime(time);
    }
    triggerAttackRelease(duration2, time, velocity = 1) {
      time = this.toSeconds(time);
      this.triggerAttack(time, velocity);
      this.triggerRelease(time + this.toSeconds(duration2));
      return this;
    }
    cancel(after) {
      this._sig.cancelScheduledValues(this.toSeconds(after));
      return this;
    }
    connect(destination, outputNumber = 0, inputNumber = 0) {
      connectSignal(this, destination, outputNumber, inputNumber);
      return this;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        const duration2 = length / this.context.sampleRate;
        const context2 = new OfflineContext(1, duration2, this.context.sampleRate);
        const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);
        const envelopeDuration = attackPortion + this.toSeconds(this.release);
        const sustainTime = envelopeDuration * 0.1;
        const totalDuration = envelopeDuration + sustainTime;
        const clone = new this.constructor(Object.assign(this.get(), {
          attack: duration2 * this.toSeconds(this.attack) / totalDuration,
          decay: duration2 * this.toSeconds(this.decay) / totalDuration,
          release: duration2 * this.toSeconds(this.release) / totalDuration,
          context: context2
        }));
        clone._sig.toDestination();
        clone.triggerAttackRelease(duration2 * (attackPortion + sustainTime) / totalDuration, 0);
        const buffer2 = yield context2.render();
        return buffer2.getChannelData(0);
      });
    }
    dispose() {
      super.dispose();
      this._sig.dispose();
      return this;
    }
  };
  __decorate([
    timeRange(0)
  ], Envelope.prototype, "attack", void 0);
  __decorate([
    timeRange(0)
  ], Envelope.prototype, "decay", void 0);
  __decorate([
    range(0, 1)
  ], Envelope.prototype, "sustain", void 0);
  __decorate([
    timeRange(0)
  ], Envelope.prototype, "release", void 0);
  var EnvelopeCurves = (() => {
    const curveLen = 128;
    let i8;
    let k2;
    const cosineCurve = [];
    for (i8 = 0; i8 < curveLen; i8++) {
      cosineCurve[i8] = Math.sin(i8 / (curveLen - 1) * (Math.PI / 2));
    }
    const rippleCurve = [];
    const rippleCurveFreq = 6.4;
    for (i8 = 0; i8 < curveLen - 1; i8++) {
      k2 = i8 / (curveLen - 1);
      const sineWave = Math.sin(k2 * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
      rippleCurve[i8] = sineWave / 10 + k2 * 0.83;
    }
    rippleCurve[curveLen - 1] = 1;
    const stairsCurve = [];
    const steps = 5;
    for (i8 = 0; i8 < curveLen; i8++) {
      stairsCurve[i8] = Math.ceil(i8 / (curveLen - 1) * steps) / steps;
    }
    const sineCurve = [];
    for (i8 = 0; i8 < curveLen; i8++) {
      k2 = i8 / (curveLen - 1);
      sineCurve[i8] = 0.5 * (1 - Math.cos(Math.PI * k2));
    }
    const bounceCurve = [];
    for (i8 = 0; i8 < curveLen; i8++) {
      k2 = i8 / (curveLen - 1);
      const freq2 = Math.pow(k2, 3) * 4 + 0.2;
      const val = Math.cos(freq2 * Math.PI * 2 * k2);
      bounceCurve[i8] = Math.abs(val * (1 - k2));
    }
    function invertCurve(curve) {
      const out = new Array(curve.length);
      for (let j2 = 0; j2 < curve.length; j2++) {
        out[j2] = 1 - curve[j2];
      }
      return out;
    }
    function reverseCurve(curve) {
      return curve.slice(0).reverse();
    }
    return {
      bounce: {
        In: invertCurve(bounceCurve),
        Out: bounceCurve
      },
      cosine: {
        In: cosineCurve,
        Out: reverseCurve(cosineCurve)
      },
      exponential: "exponential",
      linear: "linear",
      ripple: {
        In: rippleCurve,
        Out: invertCurve(rippleCurve)
      },
      sine: {
        In: sineCurve,
        Out: invertCurve(sineCurve)
      },
      step: {
        In: stairsCurve,
        Out: invertCurve(stairsCurve)
      }
    };
  })();

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/instrument/Instrument.js
  var Instrument = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Instrument.getDefaults(), arguments));
      this._scheduledEvents = [];
      this._synced = false;
      this._original_triggerAttack = this.triggerAttack;
      this._original_triggerRelease = this.triggerRelease;
      this._syncedRelease = (time) => this._original_triggerRelease(time);
      const options2 = optionsFromArguments(Instrument.getDefaults(), arguments);
      this._volume = this.output = new Volume({
        context: this.context,
        volume: options2.volume
      });
      this.volume = this._volume.volume;
      readOnly(this, "volume");
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        volume: 0
      });
    }
    sync() {
      if (this._syncState()) {
        this._syncMethod("triggerAttack", 1);
        this._syncMethod("triggerRelease", 0);
        this.context.transport.on("stop", this._syncedRelease);
        this.context.transport.on("pause", this._syncedRelease);
        this.context.transport.on("loopEnd", this._syncedRelease);
      }
      return this;
    }
    _syncState() {
      let changed = false;
      if (!this._synced) {
        this._synced = true;
        changed = true;
      }
      return changed;
    }
    _syncMethod(method, timePosition) {
      const originalMethod = this["_original_" + method] = this[method];
      this[method] = (...args) => {
        const time = args[timePosition];
        const id = this.context.transport.schedule((t8) => {
          args[timePosition] = t8;
          originalMethod.apply(this, args);
        }, time);
        this._scheduledEvents.push(id);
      };
    }
    unsync() {
      this._scheduledEvents.forEach((id) => this.context.transport.clear(id));
      this._scheduledEvents = [];
      if (this._synced) {
        this._synced = false;
        this.triggerAttack = this._original_triggerAttack;
        this.triggerRelease = this._original_triggerRelease;
        this.context.transport.off("stop", this._syncedRelease);
        this.context.transport.off("pause", this._syncedRelease);
        this.context.transport.off("loopEnd", this._syncedRelease);
      }
      return this;
    }
    triggerAttackRelease(note3, duration2, time, velocity) {
      const computedTime = this.toSeconds(time);
      const computedDuration = this.toSeconds(duration2);
      this.triggerAttack(note3, computedTime, velocity);
      this.triggerRelease(computedTime + computedDuration);
      return this;
    }
    dispose() {
      super.dispose();
      this._volume.dispose();
      this.unsync();
      this._scheduledEvents = [];
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/instrument/Monophonic.js
  var Monophonic = class extends Instrument {
    constructor() {
      super(optionsFromArguments(Monophonic.getDefaults(), arguments));
      const options2 = optionsFromArguments(Monophonic.getDefaults(), arguments);
      this.portamento = options2.portamento;
      this.onsilence = options2.onsilence;
    }
    static getDefaults() {
      return Object.assign(Instrument.getDefaults(), {
        detune: 0,
        onsilence: noOp,
        portamento: 0
      });
    }
    triggerAttack(note3, time, velocity = 1) {
      this.log("triggerAttack", note3, time, velocity);
      const seconds = this.toSeconds(time);
      this._triggerEnvelopeAttack(seconds, velocity);
      this.setNote(note3, seconds);
      return this;
    }
    triggerRelease(time) {
      this.log("triggerRelease", time);
      const seconds = this.toSeconds(time);
      this._triggerEnvelopeRelease(seconds);
      return this;
    }
    setNote(note3, time) {
      const computedTime = this.toSeconds(time);
      const computedFrequency = note3 instanceof FrequencyClass ? note3.toFrequency() : note3;
      if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {
        const portTime = this.toSeconds(this.portamento);
        this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);
      } else {
        this.frequency.setValueAtTime(computedFrequency, computedTime);
      }
      return this;
    }
  };
  __decorate([
    timeRange(0)
  ], Monophonic.prototype, "portamento", void 0);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js
  var AmplitudeEnvelope = class extends Envelope {
    constructor() {
      super(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
      this.name = "AmplitudeEnvelope";
      this._gainNode = new Gain({
        context: this.context,
        gain: 0
      });
      this.output = this._gainNode;
      this.input = this._gainNode;
      this._sig.connect(this._gainNode.gain);
      this.output = this._gainNode;
      this.input = this._gainNode;
    }
    dispose() {
      super.dispose();
      this._gainNode.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/instrument/Synth.js
  var Synth = class extends Monophonic {
    constructor() {
      super(optionsFromArguments(Synth.getDefaults(), arguments));
      this.name = "Synth";
      const options2 = optionsFromArguments(Synth.getDefaults(), arguments);
      this.oscillator = new OmniOscillator(Object.assign({
        context: this.context,
        detune: options2.detune,
        onstop: () => this.onsilence(this)
      }, options2.oscillator));
      this.frequency = this.oscillator.frequency;
      this.detune = this.oscillator.detune;
      this.envelope = new AmplitudeEnvelope(Object.assign({
        context: this.context
      }, options2.envelope));
      this.oscillator.chain(this.envelope, this.output);
      readOnly(this, ["oscillator", "frequency", "detune", "envelope"]);
    }
    static getDefaults() {
      return Object.assign(Monophonic.getDefaults(), {
        envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
          attack: 5e-3,
          decay: 0.1,
          release: 1,
          sustain: 0.3
        }),
        oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), "frequency", "detune"]), {
          type: "triangle"
        })
      });
    }
    _triggerEnvelopeAttack(time, velocity) {
      this.envelope.triggerAttack(time, velocity);
      this.oscillator.start(time);
      if (this.envelope.sustain === 0) {
        const computedAttack = this.toSeconds(this.envelope.attack);
        const computedDecay = this.toSeconds(this.envelope.decay);
        this.oscillator.stop(time + computedAttack + computedDecay);
      }
    }
    _triggerEnvelopeRelease(time) {
      this.envelope.triggerRelease(time);
      this.oscillator.stop(time + this.toSeconds(this.envelope.release));
    }
    getLevelAtTime(time) {
      time = this.toSeconds(time);
      return this.envelope.getValueAtTime(time);
    }
    dispose() {
      super.dispose();
      this.oscillator.dispose();
      this.envelope.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/filter/BiquadFilter.js
  var BiquadFilter = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(BiquadFilter.getDefaults(), arguments, ["frequency", "type"]));
      this.name = "BiquadFilter";
      const options2 = optionsFromArguments(BiquadFilter.getDefaults(), arguments, ["frequency", "type"]);
      this._filter = this.context.createBiquadFilter();
      this.input = this.output = this._filter;
      this.Q = new Param({
        context: this.context,
        units: "number",
        value: options2.Q,
        param: this._filter.Q
      });
      this.frequency = new Param({
        context: this.context,
        units: "frequency",
        value: options2.frequency,
        param: this._filter.frequency
      });
      this.detune = new Param({
        context: this.context,
        units: "cents",
        value: options2.detune,
        param: this._filter.detune
      });
      this.gain = new Param({
        context: this.context,
        units: "decibels",
        convert: false,
        value: options2.gain,
        param: this._filter.gain
      });
      this.type = options2.type;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        Q: 1,
        type: "lowpass",
        frequency: 350,
        detune: 0,
        gain: 0
      });
    }
    get type() {
      return this._filter.type;
    }
    set type(type) {
      const types2 = [
        "lowpass",
        "highpass",
        "bandpass",
        "lowshelf",
        "highshelf",
        "notch",
        "allpass",
        "peaking"
      ];
      assert(types2.indexOf(type) !== -1, `Invalid filter type: ${type}`);
      this._filter.type = type;
    }
    getFrequencyResponse(len = 128) {
      const freqValues = new Float32Array(len);
      for (let i8 = 0; i8 < len; i8++) {
        const norm = Math.pow(i8 / len, 2);
        const freq2 = norm * (2e4 - 20) + 20;
        freqValues[i8] = freq2;
      }
      const magValues = new Float32Array(len);
      const phaseValues = new Float32Array(len);
      const filterClone = this.context.createBiquadFilter();
      filterClone.type = this.type;
      filterClone.Q.value = this.Q.value;
      filterClone.frequency.value = this.frequency.value;
      filterClone.gain.value = this.gain.value;
      filterClone.getFrequencyResponse(freqValues, magValues, phaseValues);
      return magValues;
    }
    dispose() {
      super.dispose();
      this._filter.disconnect();
      this.Q.dispose();
      this.frequency.dispose();
      this.gain.dispose();
      this.detune.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/filter/Filter.js
  var Filter = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Filter.getDefaults(), arguments, ["frequency", "type", "rolloff"]));
      this.name = "Filter";
      this.input = new Gain({ context: this.context });
      this.output = new Gain({ context: this.context });
      this._filters = [];
      const options2 = optionsFromArguments(Filter.getDefaults(), arguments, ["frequency", "type", "rolloff"]);
      this._filters = [];
      this.Q = new Signal({
        context: this.context,
        units: "positive",
        value: options2.Q
      });
      this.frequency = new Signal({
        context: this.context,
        units: "frequency",
        value: options2.frequency
      });
      this.detune = new Signal({
        context: this.context,
        units: "cents",
        value: options2.detune
      });
      this.gain = new Signal({
        context: this.context,
        units: "decibels",
        convert: false,
        value: options2.gain
      });
      this._type = options2.type;
      this.rolloff = options2.rolloff;
      readOnly(this, ["detune", "frequency", "gain", "Q"]);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        Q: 1,
        detune: 0,
        frequency: 350,
        gain: 0,
        rolloff: -12,
        type: "lowpass"
      });
    }
    get type() {
      return this._type;
    }
    set type(type) {
      const types2 = [
        "lowpass",
        "highpass",
        "bandpass",
        "lowshelf",
        "highshelf",
        "notch",
        "allpass",
        "peaking"
      ];
      assert(types2.indexOf(type) !== -1, `Invalid filter type: ${type}`);
      this._type = type;
      this._filters.forEach((filter2) => filter2.type = type);
    }
    get rolloff() {
      return this._rolloff;
    }
    set rolloff(rolloff) {
      const rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10);
      const possibilities = [-12, -24, -48, -96];
      let cascadingCount = possibilities.indexOf(rolloffNum);
      assert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(", ")}`);
      cascadingCount += 1;
      this._rolloff = rolloffNum;
      this.input.disconnect();
      this._filters.forEach((filter2) => filter2.disconnect());
      this._filters = new Array(cascadingCount);
      for (let count = 0; count < cascadingCount; count++) {
        const filter2 = new BiquadFilter({
          context: this.context
        });
        filter2.type = this._type;
        this.frequency.connect(filter2.frequency);
        this.detune.connect(filter2.detune);
        this.Q.connect(filter2.Q);
        this.gain.connect(filter2.gain);
        this._filters[count] = filter2;
      }
      this._internalChannels = this._filters;
      connectSeries(this.input, ...this._internalChannels, this.output);
    }
    getFrequencyResponse(len = 128) {
      const filterClone = new BiquadFilter({
        frequency: this.frequency.value,
        gain: this.gain.value,
        Q: this.Q.value,
        type: this._type,
        detune: this.detune.value
      });
      const totalResponse = new Float32Array(len).map(() => 1);
      this._filters.forEach(() => {
        const response = filterClone.getFrequencyResponse(len);
        response.forEach((val, i8) => totalResponse[i8] *= val);
      });
      filterClone.dispose();
      return totalResponse;
    }
    dispose() {
      super.dispose();
      this._filters.forEach((filter2) => {
        filter2.dispose();
      });
      writable(this, ["detune", "frequency", "gain", "Q"]);
      this.frequency.dispose();
      this.Q.dispose();
      this.detune.dispose();
      this.gain.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/envelope/FrequencyEnvelope.js
  var FrequencyEnvelope = class extends Envelope {
    constructor() {
      super(optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
      this.name = "FrequencyEnvelope";
      const options2 = optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
      this._octaves = options2.octaves;
      this._baseFrequency = this.toFrequency(options2.baseFrequency);
      this._exponent = this.input = new Pow({
        context: this.context,
        value: options2.exponent
      });
      this._scale = this.output = new Scale({
        context: this.context,
        min: this._baseFrequency,
        max: this._baseFrequency * Math.pow(2, this._octaves)
      });
      this._sig.chain(this._exponent, this._scale);
    }
    static getDefaults() {
      return Object.assign(Envelope.getDefaults(), {
        baseFrequency: 200,
        exponent: 1,
        octaves: 4
      });
    }
    get baseFrequency() {
      return this._baseFrequency;
    }
    set baseFrequency(min) {
      const freq2 = this.toFrequency(min);
      assertRange(freq2, 0);
      this._baseFrequency = freq2;
      this._scale.min = this._baseFrequency;
      this.octaves = this._octaves;
    }
    get octaves() {
      return this._octaves;
    }
    set octaves(octaves) {
      this._octaves = octaves;
      this._scale.max = this._baseFrequency * Math.pow(2, octaves);
    }
    get exponent() {
      return this._exponent.value;
    }
    set exponent(exponent) {
      this._exponent.value = exponent;
    }
    dispose() {
      super.dispose();
      this._exponent.dispose();
      this._scale.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/instrument/MonoSynth.js
  var MonoSynth = class extends Monophonic {
    constructor() {
      super(optionsFromArguments(MonoSynth.getDefaults(), arguments));
      this.name = "MonoSynth";
      const options2 = optionsFromArguments(MonoSynth.getDefaults(), arguments);
      this.oscillator = new OmniOscillator(Object.assign(options2.oscillator, {
        context: this.context,
        detune: options2.detune,
        onstop: () => this.onsilence(this)
      }));
      this.frequency = this.oscillator.frequency;
      this.detune = this.oscillator.detune;
      this.filter = new Filter(Object.assign(options2.filter, { context: this.context }));
      this.filterEnvelope = new FrequencyEnvelope(Object.assign(options2.filterEnvelope, { context: this.context }));
      this.envelope = new AmplitudeEnvelope(Object.assign(options2.envelope, { context: this.context }));
      this.oscillator.chain(this.filter, this.envelope, this.output);
      this.filterEnvelope.connect(this.filter.frequency);
      readOnly(this, ["oscillator", "frequency", "detune", "filter", "filterEnvelope", "envelope"]);
    }
    static getDefaults() {
      return Object.assign(Monophonic.getDefaults(), {
        envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
          attack: 5e-3,
          decay: 0.1,
          release: 1,
          sustain: 0.9
        }),
        filter: Object.assign(omitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
          Q: 1,
          rolloff: -12,
          type: "lowpass"
        }),
        filterEnvelope: Object.assign(omitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
          attack: 0.6,
          baseFrequency: 200,
          decay: 0.2,
          exponent: 2,
          octaves: 3,
          release: 2,
          sustain: 0.5
        }),
        oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())), {
          type: "sawtooth"
        })
      });
    }
    _triggerEnvelopeAttack(time, velocity = 1) {
      this.envelope.triggerAttack(time, velocity);
      this.filterEnvelope.triggerAttack(time);
      this.oscillator.start(time);
      if (this.envelope.sustain === 0) {
        const computedAttack = this.toSeconds(this.envelope.attack);
        const computedDecay = this.toSeconds(this.envelope.decay);
        this.oscillator.stop(time + computedAttack + computedDecay);
      }
    }
    _triggerEnvelopeRelease(time) {
      this.envelope.triggerRelease(time);
      this.filterEnvelope.triggerRelease(time);
      this.oscillator.stop(time + this.toSeconds(this.envelope.release));
    }
    getLevelAtTime(time) {
      time = this.toSeconds(time);
      return this.envelope.getValueAtTime(time);
    }
    dispose() {
      super.dispose();
      this.oscillator.dispose();
      this.envelope.dispose();
      this.filterEnvelope.dispose();
      this.filter.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/instrument/MembraneSynth.js
  var MembraneSynth = class extends Synth {
    constructor() {
      super(optionsFromArguments(MembraneSynth.getDefaults(), arguments));
      this.name = "MembraneSynth";
      this.portamento = 0;
      const options2 = optionsFromArguments(MembraneSynth.getDefaults(), arguments);
      this.pitchDecay = options2.pitchDecay;
      this.octaves = options2.octaves;
      readOnly(this, ["oscillator", "envelope"]);
    }
    static getDefaults() {
      return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {
        envelope: {
          attack: 1e-3,
          attackCurve: "exponential",
          decay: 0.4,
          release: 1.4,
          sustain: 0.01
        },
        octaves: 10,
        oscillator: {
          type: "sine"
        },
        pitchDecay: 0.05
      });
    }
    setNote(note3, time) {
      const seconds = this.toSeconds(time);
      const hertz = this.toFrequency(note3 instanceof FrequencyClass ? note3.toFrequency() : note3);
      const maxNote = hertz * this.octaves;
      this.oscillator.frequency.setValueAtTime(maxNote, seconds);
      this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));
      return this;
    }
    dispose() {
      super.dispose();
      return this;
    }
  };
  __decorate([
    range(0)
  ], MembraneSynth.prototype, "octaves", void 0);
  __decorate([
    timeRange(0)
  ], MembraneSynth.prototype, "pitchDecay", void 0);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/instrument/NoiseSynth.js
  var NoiseSynth = class extends Instrument {
    constructor() {
      super(optionsFromArguments(NoiseSynth.getDefaults(), arguments));
      this.name = "NoiseSynth";
      const options2 = optionsFromArguments(NoiseSynth.getDefaults(), arguments);
      this.noise = new Noise(Object.assign({
        context: this.context
      }, options2.noise));
      this.envelope = new AmplitudeEnvelope(Object.assign({
        context: this.context
      }, options2.envelope));
      this.noise.chain(this.envelope, this.output);
    }
    static getDefaults() {
      return Object.assign(Instrument.getDefaults(), {
        envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
          decay: 0.1,
          sustain: 0
        }),
        noise: Object.assign(omitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())), {
          type: "white"
        })
      });
    }
    triggerAttack(time, velocity = 1) {
      time = this.toSeconds(time);
      this.envelope.triggerAttack(time, velocity);
      this.noise.start(time);
      if (this.envelope.sustain === 0) {
        this.noise.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));
      }
      return this;
    }
    triggerRelease(time) {
      time = this.toSeconds(time);
      this.envelope.triggerRelease(time);
      this.noise.stop(time + this.toSeconds(this.envelope.release));
      return this;
    }
    sync() {
      if (this._syncState()) {
        this._syncMethod("triggerAttack", 0);
        this._syncMethod("triggerRelease", 0);
      }
      return this;
    }
    triggerAttackRelease(duration2, time, velocity = 1) {
      time = this.toSeconds(time);
      duration2 = this.toSeconds(duration2);
      this.triggerAttack(time, velocity);
      this.triggerRelease(time + duration2);
      return this;
    }
    dispose() {
      super.dispose();
      this.noise.dispose();
      this.envelope.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js
  var workletContext = /* @__PURE__ */ new Set();
  function addToWorklet(classOrFunction) {
    workletContext.add(classOrFunction);
  }
  function registerProcessor(name2, classDesc) {
    const processor = `registerProcessor("${name2}", ${classDesc})`;
    workletContext.add(processor);
  }
  function getWorkletGlobalScope() {
    return Array.from(workletContext).join("\n");
  }

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/worklet/ToneAudioWorklet.js
  var ToneAudioWorklet = class extends ToneAudioNode {
    constructor(options2) {
      super(options2);
      this.name = "ToneAudioWorklet";
      this.workletOptions = {};
      this.onprocessorerror = noOp;
      const blobUrl = URL.createObjectURL(new Blob([getWorkletGlobalScope()], { type: "text/javascript" }));
      const name2 = this._audioWorkletName();
      this._dummyGain = this.context.createGain();
      this._dummyParam = this._dummyGain.gain;
      this.context.addAudioWorkletModule(blobUrl).then(() => {
        if (!this.disposed) {
          this._worklet = this.context.createAudioWorkletNode(name2, this.workletOptions);
          this._worklet.onprocessorerror = this.onprocessorerror.bind(this);
          this.onReady(this._worklet);
        }
      });
    }
    dispose() {
      super.dispose();
      this._dummyGain.disconnect();
      if (this._worklet) {
        this._worklet.port.postMessage("dispose");
        this._worklet.disconnect();
      }
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js
  var toneAudioWorkletProcessor = `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;
  addToWorklet(toneAudioWorkletProcessor);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js
  var singleIOProcess = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
  addToWorklet(singleIOProcess);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js
  var delayLine = `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;
  addToWorklet(delayLine);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/filter/FeedbackCombFilter.worklet.js
  var workletName = "feedback-comb-filter";
  var feedbackCombFilter = `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;
  registerProcessor(workletName, feedbackCombFilter);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/filter/OnePoleFilter.js
  var OnePoleFilter = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(OnePoleFilter.getDefaults(), arguments, ["frequency", "type"]));
      this.name = "OnePoleFilter";
      const options2 = optionsFromArguments(OnePoleFilter.getDefaults(), arguments, ["frequency", "type"]);
      this._frequency = options2.frequency;
      this._type = options2.type;
      this.input = new Gain({ context: this.context });
      this.output = new Gain({ context: this.context });
      this._createFilter();
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        frequency: 880,
        type: "lowpass"
      });
    }
    _createFilter() {
      const oldFilter = this._filter;
      const freq2 = this.toFrequency(this._frequency);
      const t8 = 1 / (2 * Math.PI * freq2);
      if (this._type === "lowpass") {
        const a0 = 1 / (t8 * this.context.sampleRate);
        const b1 = a0 - 1;
        this._filter = this.context.createIIRFilter([a0, 0], [1, b1]);
      } else {
        const b1 = 1 / (t8 * this.context.sampleRate) - 1;
        this._filter = this.context.createIIRFilter([1, -1], [1, b1]);
      }
      this.input.chain(this._filter, this.output);
      if (oldFilter) {
        this.context.setTimeout(() => {
          if (!this.disposed) {
            this.input.disconnect(oldFilter);
            oldFilter.disconnect();
          }
        }, this.blockTime);
      }
    }
    get frequency() {
      return this._frequency;
    }
    set frequency(fq) {
      this._frequency = fq;
      this._createFilter();
    }
    get type() {
      return this._type;
    }
    set type(t8) {
      this._type = t8;
      this._createFilter();
    }
    getFrequencyResponse(len = 128) {
      const freqValues = new Float32Array(len);
      for (let i8 = 0; i8 < len; i8++) {
        const norm = Math.pow(i8 / len, 2);
        const freq2 = norm * (2e4 - 20) + 20;
        freqValues[i8] = freq2;
      }
      const magValues = new Float32Array(len);
      const phaseValues = new Float32Array(len);
      this._filter.getFrequencyResponse(freqValues, magValues, phaseValues);
      return magValues;
    }
    dispose() {
      super.dispose();
      this.input.dispose();
      this.output.dispose();
      this._filter.disconnect();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/instrument/PolySynth.js
  var PolySynth = class extends Instrument {
    constructor() {
      super(optionsFromArguments(PolySynth.getDefaults(), arguments, ["voice", "options"]));
      this.name = "PolySynth";
      this._availableVoices = [];
      this._activeVoices = [];
      this._voices = [];
      this._gcTimeout = -1;
      this._averageActiveVoices = 0;
      this._syncedRelease = (time) => this.releaseAll(time);
      const options2 = optionsFromArguments(PolySynth.getDefaults(), arguments, ["voice", "options"]);
      assert(!isNumber(options2.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
      const defaults = options2.voice.getDefaults();
      this.options = Object.assign(defaults, options2.options);
      this.voice = options2.voice;
      this.maxPolyphony = options2.maxPolyphony;
      this._dummyVoice = this._getNextAvailableVoice();
      const index15 = this._voices.indexOf(this._dummyVoice);
      this._voices.splice(index15, 1);
      this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);
    }
    static getDefaults() {
      return Object.assign(Instrument.getDefaults(), {
        maxPolyphony: 32,
        options: {},
        voice: Synth
      });
    }
    get activeVoices() {
      return this._activeVoices.length;
    }
    _makeVoiceAvailable(voice) {
      this._availableVoices.push(voice);
      const activeVoiceIndex = this._activeVoices.findIndex((e8) => e8.voice === voice);
      this._activeVoices.splice(activeVoiceIndex, 1);
    }
    _getNextAvailableVoice() {
      if (this._availableVoices.length) {
        return this._availableVoices.shift();
      } else if (this._voices.length < this.maxPolyphony) {
        const voice = new this.voice(Object.assign(this.options, {
          context: this.context,
          onsilence: this._makeVoiceAvailable.bind(this)
        }));
        assert(voice instanceof Monophonic, "Voice must extend Monophonic class");
        voice.connect(this.output);
        this._voices.push(voice);
        return voice;
      } else {
        warn("Max polyphony exceeded. Note dropped.");
      }
    }
    _collectGarbage() {
      this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);
      if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
        const firstAvail = this._availableVoices.shift();
        const index15 = this._voices.indexOf(firstAvail);
        this._voices.splice(index15, 1);
        if (!this.context.isOffline) {
          firstAvail.dispose();
        }
      }
    }
    _triggerAttack(notes2, time, velocity) {
      notes2.forEach((note3) => {
        const midiNote = new MidiClass(this.context, note3).toMidi();
        const voice = this._getNextAvailableVoice();
        if (voice) {
          voice.triggerAttack(note3, time, velocity);
          this._activeVoices.push({
            midi: midiNote,
            voice,
            released: false
          });
          this.log("triggerAttack", note3, time);
        }
      });
    }
    _triggerRelease(notes2, time) {
      notes2.forEach((note3) => {
        const midiNote = new MidiClass(this.context, note3).toMidi();
        const event = this._activeVoices.find(({ midi: midi4, released }) => midi4 === midiNote && !released);
        if (event) {
          event.voice.triggerRelease(time);
          event.released = true;
          this.log("triggerRelease", note3, time);
        }
      });
    }
    _scheduleEvent(type, notes2, time, velocity) {
      assert(!this.disposed, "Synth was already disposed");
      if (time <= this.now()) {
        if (type === "attack") {
          this._triggerAttack(notes2, time, velocity);
        } else {
          this._triggerRelease(notes2, time);
        }
      } else {
        this.context.setTimeout(() => {
          if (!this.disposed) {
            this._scheduleEvent(type, notes2, time, velocity);
          }
        }, time - this.now());
      }
    }
    triggerAttack(notes2, time, velocity) {
      if (!Array.isArray(notes2)) {
        notes2 = [notes2];
      }
      const computedTime = this.toSeconds(time);
      this._scheduleEvent("attack", notes2, computedTime, velocity);
      return this;
    }
    triggerRelease(notes2, time) {
      if (!Array.isArray(notes2)) {
        notes2 = [notes2];
      }
      const computedTime = this.toSeconds(time);
      this._scheduleEvent("release", notes2, computedTime);
      return this;
    }
    triggerAttackRelease(notes2, duration2, time, velocity) {
      const computedTime = this.toSeconds(time);
      this.triggerAttack(notes2, computedTime, velocity);
      if (isArray(duration2)) {
        assert(isArray(notes2), "If the duration is an array, the notes must also be an array");
        notes2 = notes2;
        for (let i8 = 0; i8 < notes2.length; i8++) {
          const d5 = duration2[Math.min(i8, duration2.length - 1)];
          const durationSeconds = this.toSeconds(d5);
          assert(durationSeconds > 0, "The duration must be greater than 0");
          this.triggerRelease(notes2[i8], computedTime + durationSeconds);
        }
      } else {
        const durationSeconds = this.toSeconds(duration2);
        assert(durationSeconds > 0, "The duration must be greater than 0");
        this.triggerRelease(notes2, computedTime + durationSeconds);
      }
      return this;
    }
    sync() {
      if (this._syncState()) {
        this._syncMethod("triggerAttack", 1);
        this._syncMethod("triggerRelease", 1);
        this.context.transport.on("stop", this._syncedRelease);
        this.context.transport.on("pause", this._syncedRelease);
        this.context.transport.on("loopEnd", this._syncedRelease);
      }
      return this;
    }
    set(options2) {
      const sanitizedOptions = omitFromObject(options2, ["onsilence", "context"]);
      this.options = deepMerge(this.options, sanitizedOptions);
      this._voices.forEach((voice) => voice.set(sanitizedOptions));
      this._dummyVoice.set(sanitizedOptions);
      return this;
    }
    get() {
      return this._dummyVoice.get();
    }
    releaseAll(time) {
      const computedTime = this.toSeconds(time);
      this._activeVoices.forEach(({ voice }) => {
        voice.triggerRelease(computedTime);
      });
      return this;
    }
    dispose() {
      super.dispose();
      this._dummyVoice.dispose();
      this._voices.forEach((v3) => v3.dispose());
      this._activeVoices = [];
      this._availableVoices = [];
      this.context.clearInterval(this._gcTimeout);
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/instrument/Sampler.js
  var Sampler = class extends Instrument {
    constructor() {
      super(optionsFromArguments(Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"));
      this.name = "Sampler";
      this._activeSources = /* @__PURE__ */ new Map();
      const options2 = optionsFromArguments(Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
      const urlMap = {};
      Object.keys(options2.urls).forEach((note3) => {
        const noteNumber = parseInt(note3, 10);
        assert(isNote(note3) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note3}`);
        if (isNote(note3)) {
          const mid = new FrequencyClass(this.context, note3).toMidi();
          urlMap[mid] = options2.urls[note3];
        } else if (isNumber(noteNumber) && isFinite(noteNumber)) {
          urlMap[noteNumber] = options2.urls[noteNumber];
        }
      });
      this._buffers = new ToneAudioBuffers({
        urls: urlMap,
        onload: options2.onload,
        baseUrl: options2.baseUrl,
        onerror: options2.onerror
      });
      this.attack = options2.attack;
      this.release = options2.release;
      this.curve = options2.curve;
      if (this._buffers.loaded) {
        Promise.resolve().then(options2.onload);
      }
    }
    static getDefaults() {
      return Object.assign(Instrument.getDefaults(), {
        attack: 0,
        baseUrl: "",
        curve: "exponential",
        onload: noOp,
        onerror: noOp,
        release: 0.1,
        urls: {}
      });
    }
    _findClosest(midi4) {
      const MAX_INTERVAL = 96;
      let interval2 = 0;
      while (interval2 < MAX_INTERVAL) {
        if (this._buffers.has(midi4 + interval2)) {
          return -interval2;
        } else if (this._buffers.has(midi4 - interval2)) {
          return interval2;
        }
        interval2++;
      }
      throw new Error(`No available buffers for note: ${midi4}`);
    }
    triggerAttack(notes2, time, velocity = 1) {
      this.log("triggerAttack", notes2, time, velocity);
      if (!Array.isArray(notes2)) {
        notes2 = [notes2];
      }
      notes2.forEach((note3) => {
        const midiFloat = ftomf(new FrequencyClass(this.context, note3).toFrequency());
        const midi4 = Math.round(midiFloat);
        const remainder = midiFloat - midi4;
        const difference = this._findClosest(midi4);
        const closestNote = midi4 - difference;
        const buffer2 = this._buffers.get(closestNote);
        const playbackRate = intervalToFrequencyRatio(difference + remainder);
        const source = new ToneBufferSource({
          url: buffer2,
          context: this.context,
          curve: this.curve,
          fadeIn: this.attack,
          fadeOut: this.release,
          playbackRate
        }).connect(this.output);
        source.start(time, 0, buffer2.duration / playbackRate, velocity);
        if (!isArray(this._activeSources.get(midi4))) {
          this._activeSources.set(midi4, []);
        }
        this._activeSources.get(midi4).push(source);
        source.onended = () => {
          if (this._activeSources && this._activeSources.has(midi4)) {
            const sources = this._activeSources.get(midi4);
            const index15 = sources.indexOf(source);
            if (index15 !== -1) {
              sources.splice(index15, 1);
            }
          }
        };
      });
      return this;
    }
    triggerRelease(notes2, time) {
      this.log("triggerRelease", notes2, time);
      if (!Array.isArray(notes2)) {
        notes2 = [notes2];
      }
      notes2.forEach((note3) => {
        const midi4 = new FrequencyClass(this.context, note3).toMidi();
        if (this._activeSources.has(midi4) && this._activeSources.get(midi4).length) {
          const sources = this._activeSources.get(midi4);
          time = this.toSeconds(time);
          sources.forEach((source) => {
            source.stop(time);
          });
          this._activeSources.set(midi4, []);
        }
      });
      return this;
    }
    releaseAll(time) {
      const computedTime = this.toSeconds(time);
      this._activeSources.forEach((sources) => {
        while (sources.length) {
          const source = sources.shift();
          source.stop(computedTime);
        }
      });
      return this;
    }
    sync() {
      if (this._syncState()) {
        this._syncMethod("triggerAttack", 1);
        this._syncMethod("triggerRelease", 1);
      }
      return this;
    }
    triggerAttackRelease(notes2, duration2, time, velocity = 1) {
      const computedTime = this.toSeconds(time);
      this.triggerAttack(notes2, computedTime, velocity);
      if (isArray(duration2)) {
        assert(isArray(notes2), "notes must be an array when duration is array");
        notes2.forEach((note3, index15) => {
          const d5 = duration2[Math.min(index15, duration2.length - 1)];
          this.triggerRelease(note3, computedTime + this.toSeconds(d5));
        });
      } else {
        this.triggerRelease(notes2, computedTime + this.toSeconds(duration2));
      }
      return this;
    }
    add(note3, url, callback) {
      assert(isNote(note3) || isFinite(note3), `note must be a pitch or midi: ${note3}`);
      if (isNote(note3)) {
        const mid = new FrequencyClass(this.context, note3).toMidi();
        this._buffers.add(mid, url, callback);
      } else {
        this._buffers.add(note3, url, callback);
      }
      return this;
    }
    get loaded() {
      return this._buffers.loaded;
    }
    dispose() {
      super.dispose();
      this._buffers.dispose();
      this._activeSources.forEach((sources) => {
        sources.forEach((source) => source.dispose());
      });
      this._activeSources.clear();
      return this;
    }
  };
  __decorate([
    timeRange(0)
  ], Sampler.prototype, "attack", void 0);
  __decorate([
    timeRange(0)
  ], Sampler.prototype, "release", void 0);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/event/ToneEvent.js
  var ToneEvent = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(ToneEvent.getDefaults(), arguments, ["callback", "value"]));
      this.name = "ToneEvent";
      this._state = new StateTimeline("stopped");
      this._startOffset = 0;
      const options2 = optionsFromArguments(ToneEvent.getDefaults(), arguments, ["callback", "value"]);
      this._loop = options2.loop;
      this.callback = options2.callback;
      this.value = options2.value;
      this._loopStart = this.toTicks(options2.loopStart);
      this._loopEnd = this.toTicks(options2.loopEnd);
      this._playbackRate = options2.playbackRate;
      this._probability = options2.probability;
      this._humanize = options2.humanize;
      this.mute = options2.mute;
      this._playbackRate = options2.playbackRate;
      this._state.increasing = true;
      this._rescheduleEvents();
    }
    static getDefaults() {
      return Object.assign(ToneWithContext.getDefaults(), {
        callback: noOp,
        humanize: false,
        loop: false,
        loopEnd: "1m",
        loopStart: 0,
        mute: false,
        playbackRate: 1,
        probability: 1,
        value: null
      });
    }
    _rescheduleEvents(after = -1) {
      this._state.forEachFrom(after, (event) => {
        let duration2;
        if (event.state === "started") {
          if (event.id !== -1) {
            this.context.transport.clear(event.id);
          }
          const startTick = event.time + Math.round(this.startOffset / this._playbackRate);
          if (this._loop === true || isNumber(this._loop) && this._loop > 1) {
            duration2 = Infinity;
            if (isNumber(this._loop)) {
              duration2 = this._loop * this._getLoopDuration();
            }
            const nextEvent = this._state.getAfter(startTick);
            if (nextEvent !== null) {
              duration2 = Math.min(duration2, nextEvent.time - startTick);
            }
            if (duration2 !== Infinity) {
              duration2 = new TicksClass(this.context, duration2);
            }
            const interval2 = new TicksClass(this.context, this._getLoopDuration());
            event.id = this.context.transport.scheduleRepeat(this._tick.bind(this), interval2, new TicksClass(this.context, startTick), duration2);
          } else {
            event.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));
          }
        }
      });
    }
    get state() {
      return this._state.getValueAtTime(this.context.transport.ticks);
    }
    get startOffset() {
      return this._startOffset;
    }
    set startOffset(offset) {
      this._startOffset = offset;
    }
    get probability() {
      return this._probability;
    }
    set probability(prob) {
      this._probability = prob;
    }
    get humanize() {
      return this._humanize;
    }
    set humanize(variation) {
      this._humanize = variation;
    }
    start(time) {
      const ticks = this.toTicks(time);
      if (this._state.getValueAtTime(ticks) === "stopped") {
        this._state.add({
          id: -1,
          state: "started",
          time: ticks
        });
        this._rescheduleEvents(ticks);
      }
      return this;
    }
    stop(time) {
      this.cancel(time);
      const ticks = this.toTicks(time);
      if (this._state.getValueAtTime(ticks) === "started") {
        this._state.setStateAtTime("stopped", ticks, { id: -1 });
        const previousEvent = this._state.getBefore(ticks);
        let rescheduleTime = ticks;
        if (previousEvent !== null) {
          rescheduleTime = previousEvent.time;
        }
        this._rescheduleEvents(rescheduleTime);
      }
      return this;
    }
    cancel(time) {
      time = defaultArg(time, -Infinity);
      const ticks = this.toTicks(time);
      this._state.forEachFrom(ticks, (event) => {
        this.context.transport.clear(event.id);
      });
      this._state.cancel(ticks);
      return this;
    }
    _tick(time) {
      const ticks = this.context.transport.getTicksAtTime(time);
      if (!this.mute && this._state.getValueAtTime(ticks) === "started") {
        if (this.probability < 1 && Math.random() > this.probability) {
          return;
        }
        if (this.humanize) {
          let variation = 0.02;
          if (!isBoolean(this.humanize)) {
            variation = this.toSeconds(this.humanize);
          }
          time += (Math.random() * 2 - 1) * variation;
        }
        this.callback(time, this.value);
      }
    }
    _getLoopDuration() {
      return (this._loopEnd - this._loopStart) / this._playbackRate;
    }
    get loop() {
      return this._loop;
    }
    set loop(loop) {
      this._loop = loop;
      this._rescheduleEvents();
    }
    get playbackRate() {
      return this._playbackRate;
    }
    set playbackRate(rate) {
      this._playbackRate = rate;
      this._rescheduleEvents();
    }
    get loopEnd() {
      return new TicksClass(this.context, this._loopEnd).toSeconds();
    }
    set loopEnd(loopEnd) {
      this._loopEnd = this.toTicks(loopEnd);
      if (this._loop) {
        this._rescheduleEvents();
      }
    }
    get loopStart() {
      return new TicksClass(this.context, this._loopStart).toSeconds();
    }
    set loopStart(loopStart) {
      this._loopStart = this.toTicks(loopStart);
      if (this._loop) {
        this._rescheduleEvents();
      }
    }
    get progress() {
      if (this._loop) {
        const ticks = this.context.transport.ticks;
        const lastEvent = this._state.get(ticks);
        if (lastEvent !== null && lastEvent.state === "started") {
          const loopDuration = this._getLoopDuration();
          const progress = (ticks - lastEvent.time) % loopDuration;
          return progress / loopDuration;
        } else {
          return 0;
        }
      } else {
        return 0;
      }
    }
    dispose() {
      super.dispose();
      this.cancel();
      this._state.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/event/Loop.js
  var Loop = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(Loop.getDefaults(), arguments, ["callback", "interval"]));
      this.name = "Loop";
      const options2 = optionsFromArguments(Loop.getDefaults(), arguments, ["callback", "interval"]);
      this._event = new ToneEvent({
        context: this.context,
        callback: this._tick.bind(this),
        loop: true,
        loopEnd: options2.interval,
        playbackRate: options2.playbackRate,
        probability: options2.probability
      });
      this.callback = options2.callback;
      this.iterations = options2.iterations;
    }
    static getDefaults() {
      return Object.assign(ToneWithContext.getDefaults(), {
        interval: "4n",
        callback: noOp,
        playbackRate: 1,
        iterations: Infinity,
        probability: 1,
        mute: false,
        humanize: false
      });
    }
    start(time) {
      this._event.start(time);
      return this;
    }
    stop(time) {
      this._event.stop(time);
      return this;
    }
    cancel(time) {
      this._event.cancel(time);
      return this;
    }
    _tick(time) {
      this.callback(time);
    }
    get state() {
      return this._event.state;
    }
    get progress() {
      return this._event.progress;
    }
    get interval() {
      return this._event.loopEnd;
    }
    set interval(interval2) {
      this._event.loopEnd = interval2;
    }
    get playbackRate() {
      return this._event.playbackRate;
    }
    set playbackRate(rate) {
      this._event.playbackRate = rate;
    }
    get humanize() {
      return this._event.humanize;
    }
    set humanize(variation) {
      this._event.humanize = variation;
    }
    get probability() {
      return this._event.probability;
    }
    set probability(prob) {
      this._event.probability = prob;
    }
    get mute() {
      return this._event.mute;
    }
    set mute(mute) {
      this._event.mute = mute;
    }
    get iterations() {
      if (this._event.loop === true) {
        return Infinity;
      } else {
        return this._event.loop;
      }
    }
    set iterations(iters) {
      if (iters === Infinity) {
        this._event.loop = true;
      } else {
        this._event.loop = iters;
      }
    }
    dispose() {
      super.dispose();
      this._event.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/event/Part.js
  var Part = class extends ToneEvent {
    constructor() {
      super(optionsFromArguments(Part.getDefaults(), arguments, ["callback", "events"]));
      this.name = "Part";
      this._state = new StateTimeline("stopped");
      this._events = /* @__PURE__ */ new Set();
      const options2 = optionsFromArguments(Part.getDefaults(), arguments, ["callback", "events"]);
      this._state.increasing = true;
      options2.events.forEach((event) => {
        if (isArray(event)) {
          this.add(event[0], event[1]);
        } else {
          this.add(event);
        }
      });
    }
    static getDefaults() {
      return Object.assign(ToneEvent.getDefaults(), {
        events: []
      });
    }
    start(time, offset) {
      const ticks = this.toTicks(time);
      if (this._state.getValueAtTime(ticks) !== "started") {
        offset = defaultArg(offset, this._loop ? this._loopStart : 0);
        if (this._loop) {
          offset = defaultArg(offset, this._loopStart);
        } else {
          offset = defaultArg(offset, 0);
        }
        const computedOffset = this.toTicks(offset);
        this._state.add({
          id: -1,
          offset: computedOffset,
          state: "started",
          time: ticks
        });
        this._forEach((event) => {
          this._startNote(event, ticks, computedOffset);
        });
      }
      return this;
    }
    _startNote(event, ticks, offset) {
      ticks -= offset;
      if (this._loop) {
        if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {
          if (event.startOffset < offset) {
            ticks += this._getLoopDuration();
          }
          event.start(new TicksClass(this.context, ticks));
        } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {
          event.loop = false;
          event.start(new TicksClass(this.context, ticks));
        }
      } else if (event.startOffset >= offset) {
        event.start(new TicksClass(this.context, ticks));
      }
    }
    get startOffset() {
      return this._startOffset;
    }
    set startOffset(offset) {
      this._startOffset = offset;
      this._forEach((event) => {
        event.startOffset += this._startOffset;
      });
    }
    stop(time) {
      const ticks = this.toTicks(time);
      this._state.cancel(ticks);
      this._state.setStateAtTime("stopped", ticks);
      this._forEach((event) => {
        event.stop(time);
      });
      return this;
    }
    at(time, value) {
      const timeInTicks = new TransportTimeClass(this.context, time).toTicks();
      const tickTime = new TicksClass(this.context, 1).toSeconds();
      const iterator = this._events.values();
      let result = iterator.next();
      while (!result.done) {
        const event = result.value;
        if (Math.abs(timeInTicks - event.startOffset) < tickTime) {
          if (isDefined(value)) {
            event.value = value;
          }
          return event;
        }
        result = iterator.next();
      }
      if (isDefined(value)) {
        this.add(time, value);
        return this.at(time);
      } else {
        return null;
      }
    }
    add(time, value) {
      if (time instanceof Object && Reflect.has(time, "time")) {
        value = time;
        time = value.time;
      }
      const ticks = this.toTicks(time);
      let event;
      if (value instanceof ToneEvent) {
        event = value;
        event.callback = this._tick.bind(this);
      } else {
        event = new ToneEvent({
          callback: this._tick.bind(this),
          context: this.context,
          value
        });
      }
      event.startOffset = ticks;
      event.set({
        humanize: this.humanize,
        loop: this.loop,
        loopEnd: this.loopEnd,
        loopStart: this.loopStart,
        playbackRate: this.playbackRate,
        probability: this.probability
      });
      this._events.add(event);
      this._restartEvent(event);
      return this;
    }
    _restartEvent(event) {
      this._state.forEach((stateEvent) => {
        if (stateEvent.state === "started") {
          this._startNote(event, stateEvent.time, stateEvent.offset);
        } else {
          event.stop(new TicksClass(this.context, stateEvent.time));
        }
      });
    }
    remove(time, value) {
      if (isObject(time) && time.hasOwnProperty("time")) {
        value = time;
        time = value.time;
      }
      time = this.toTicks(time);
      this._events.forEach((event) => {
        if (event.startOffset === time) {
          if (isUndef(value) || isDefined(value) && event.value === value) {
            this._events.delete(event);
            event.dispose();
          }
        }
      });
      return this;
    }
    clear() {
      this._forEach((event) => event.dispose());
      this._events.clear();
      return this;
    }
    cancel(after) {
      this._forEach((event) => event.cancel(after));
      this._state.cancel(this.toTicks(after));
      return this;
    }
    _forEach(callback) {
      if (this._events) {
        this._events.forEach((event) => {
          if (event instanceof Part) {
            event._forEach(callback);
          } else {
            callback(event);
          }
        });
      }
      return this;
    }
    _setAll(attr, value) {
      this._forEach((event) => {
        event[attr] = value;
      });
    }
    _tick(time, value) {
      if (!this.mute) {
        this.callback(time, value);
      }
    }
    _testLoopBoundries(event) {
      if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {
        event.cancel(0);
      } else if (event.state === "stopped") {
        this._restartEvent(event);
      }
    }
    get probability() {
      return this._probability;
    }
    set probability(prob) {
      this._probability = prob;
      this._setAll("probability", prob);
    }
    get humanize() {
      return this._humanize;
    }
    set humanize(variation) {
      this._humanize = variation;
      this._setAll("humanize", variation);
    }
    get loop() {
      return this._loop;
    }
    set loop(loop) {
      this._loop = loop;
      this._forEach((event) => {
        event.loopStart = this.loopStart;
        event.loopEnd = this.loopEnd;
        event.loop = loop;
        this._testLoopBoundries(event);
      });
    }
    get loopEnd() {
      return new TicksClass(this.context, this._loopEnd).toSeconds();
    }
    set loopEnd(loopEnd) {
      this._loopEnd = this.toTicks(loopEnd);
      if (this._loop) {
        this._forEach((event) => {
          event.loopEnd = loopEnd;
          this._testLoopBoundries(event);
        });
      }
    }
    get loopStart() {
      return new TicksClass(this.context, this._loopStart).toSeconds();
    }
    set loopStart(loopStart) {
      this._loopStart = this.toTicks(loopStart);
      if (this._loop) {
        this._forEach((event) => {
          event.loopStart = this.loopStart;
          this._testLoopBoundries(event);
        });
      }
    }
    get playbackRate() {
      return this._playbackRate;
    }
    set playbackRate(rate) {
      this._playbackRate = rate;
      this._setAll("playbackRate", rate);
    }
    get length() {
      return this._events.size;
    }
    dispose() {
      super.dispose();
      this.clear();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/event/Sequence.js
  var Sequence = class extends ToneEvent {
    constructor() {
      super(optionsFromArguments(Sequence.getDefaults(), arguments, ["callback", "events", "subdivision"]));
      this.name = "Sequence";
      this._part = new Part({
        callback: this._seqCallback.bind(this),
        context: this.context
      });
      this._events = [];
      this._eventsArray = [];
      const options2 = optionsFromArguments(Sequence.getDefaults(), arguments, ["callback", "events", "subdivision"]);
      this._subdivision = this.toTicks(options2.subdivision);
      this.events = options2.events;
      this.loop = options2.loop;
      this.loopStart = options2.loopStart;
      this.loopEnd = options2.loopEnd;
      this.playbackRate = options2.playbackRate;
      this.probability = options2.probability;
      this.humanize = options2.humanize;
      this.mute = options2.mute;
      this.playbackRate = options2.playbackRate;
    }
    static getDefaults() {
      return Object.assign(omitFromObject(ToneEvent.getDefaults(), ["value"]), {
        events: [],
        loop: true,
        loopEnd: 0,
        loopStart: 0,
        subdivision: "8n"
      });
    }
    _seqCallback(time, value) {
      if (value !== null && !this.mute) {
        this.callback(time, value);
      }
    }
    get events() {
      return this._events;
    }
    set events(s4) {
      this.clear();
      this._eventsArray = s4;
      this._events = this._createSequence(this._eventsArray);
      this._eventsUpdated();
    }
    start(time, offset) {
      this._part.start(time, offset ? this._indexTime(offset) : offset);
      return this;
    }
    stop(time) {
      this._part.stop(time);
      return this;
    }
    get subdivision() {
      return new TicksClass(this.context, this._subdivision).toSeconds();
    }
    _createSequence(array) {
      return new Proxy(array, {
        get: (target, property) => {
          return target[property];
        },
        set: (target, property, value) => {
          if (isString(property) && isFinite(parseInt(property, 10))) {
            if (isArray(value)) {
              target[property] = this._createSequence(value);
            } else {
              target[property] = value;
            }
          } else {
            target[property] = value;
          }
          this._eventsUpdated();
          return true;
        }
      });
    }
    _eventsUpdated() {
      this._part.clear();
      this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);
      this.loopEnd = this.loopEnd;
    }
    _rescheduleSequence(sequence, subdivision, startOffset) {
      sequence.forEach((value, index15) => {
        const eventOffset = index15 * subdivision + startOffset;
        if (isArray(value)) {
          this._rescheduleSequence(value, subdivision / value.length, eventOffset);
        } else {
          const startTime = new TicksClass(this.context, eventOffset, "i").toSeconds();
          this._part.add(startTime, value);
        }
      });
    }
    _indexTime(index15) {
      return new TicksClass(this.context, index15 * this._subdivision + this.startOffset).toSeconds();
    }
    clear() {
      this._part.clear();
      return this;
    }
    dispose() {
      super.dispose();
      this._part.dispose();
      return this;
    }
    get loop() {
      return this._part.loop;
    }
    set loop(l5) {
      this._part.loop = l5;
    }
    get loopStart() {
      return this._loopStart;
    }
    set loopStart(index15) {
      this._loopStart = index15;
      this._part.loopStart = this._indexTime(index15);
    }
    get loopEnd() {
      return this._loopEnd;
    }
    set loopEnd(index15) {
      this._loopEnd = index15;
      if (index15 === 0) {
        this._part.loopEnd = this._indexTime(this._eventsArray.length);
      } else {
        this._part.loopEnd = this._indexTime(index15);
      }
    }
    get startOffset() {
      return this._part.startOffset;
    }
    set startOffset(start3) {
      this._part.startOffset = start3;
    }
    get playbackRate() {
      return this._part.playbackRate;
    }
    set playbackRate(rate) {
      this._part.playbackRate = rate;
    }
    get probability() {
      return this._part.probability;
    }
    set probability(prob) {
      this._part.probability = prob;
    }
    get progress() {
      return this._part.progress;
    }
    get humanize() {
      return this._part.humanize;
    }
    set humanize(variation) {
      this._part.humanize = variation;
    }
    get length() {
      return this._part.length;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/CrossFade.js
  var CrossFade = class extends ToneAudioNode {
    constructor() {
      super(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, ["fade"])));
      this.name = "CrossFade";
      this._panner = this.context.createStereoPanner();
      this._split = this.context.createChannelSplitter(2);
      this._g2a = new GainToAudio({ context: this.context });
      this.a = new Gain({
        context: this.context,
        gain: 0
      });
      this.b = new Gain({
        context: this.context,
        gain: 0
      });
      this.output = new Gain({ context: this.context });
      this._internalChannels = [this.a, this.b];
      const options2 = optionsFromArguments(CrossFade.getDefaults(), arguments, ["fade"]);
      this.fade = new Signal({
        context: this.context,
        units: "normalRange",
        value: options2.fade
      });
      readOnly(this, "fade");
      this.context.getConstant(1).connect(this._panner);
      this._panner.connect(this._split);
      this._panner.channelCount = 1;
      this._panner.channelCountMode = "explicit";
      connect(this._split, this.a.gain, 0);
      connect(this._split, this.b.gain, 1);
      this.fade.chain(this._g2a, this._panner.pan);
      this.a.connect(this.output);
      this.b.connect(this.output);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        fade: 0.5
      });
    }
    dispose() {
      super.dispose();
      this.a.dispose();
      this.b.dispose();
      this.output.dispose();
      this.fade.dispose();
      this._g2a.dispose();
      this._panner.disconnect();
      this._split.disconnect();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/Effect.js
  var Effect = class extends ToneAudioNode {
    constructor(options2) {
      super(options2);
      this.name = "Effect";
      this._dryWet = new CrossFade({ context: this.context });
      this.wet = this._dryWet.fade;
      this.effectSend = new Gain({ context: this.context });
      this.effectReturn = new Gain({ context: this.context });
      this.input = new Gain({ context: this.context });
      this.output = this._dryWet;
      this.input.fan(this._dryWet.a, this.effectSend);
      this.effectReturn.connect(this._dryWet.b);
      this.wet.setValueAtTime(options2.wet, 0);
      this._internalChannels = [this.effectReturn, this.effectSend];
      readOnly(this, "wet");
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        wet: 1
      });
    }
    connectEffect(effect2) {
      this._internalChannels.push(effect2);
      this.effectSend.chain(effect2, this.effectReturn);
      return this;
    }
    dispose() {
      super.dispose();
      this._dryWet.dispose();
      this.effectSend.dispose();
      this.effectReturn.dispose();
      this.wet.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/LFOEffect.js
  var LFOEffect = class extends Effect {
    constructor(options2) {
      super(options2);
      this.name = "LFOEffect";
      this._lfo = new LFO({
        context: this.context,
        frequency: options2.frequency,
        amplitude: options2.depth
      });
      this.depth = this._lfo.amplitude;
      this.frequency = this._lfo.frequency;
      this.type = options2.type;
      readOnly(this, ["frequency", "depth"]);
    }
    static getDefaults() {
      return Object.assign(Effect.getDefaults(), {
        frequency: 1,
        type: "sine",
        depth: 1
      });
    }
    start(time) {
      this._lfo.start(time);
      return this;
    }
    stop(time) {
      this._lfo.stop(time);
      return this;
    }
    sync() {
      this._lfo.sync();
      return this;
    }
    unsync() {
      this._lfo.unsync();
      return this;
    }
    get type() {
      return this._lfo.type;
    }
    set type(type) {
      this._lfo.type = type;
    }
    dispose() {
      super.dispose();
      this._lfo.dispose();
      this.frequency.dispose();
      this.depth.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/AutoFilter.js
  var AutoFilter = class extends LFOEffect {
    constructor() {
      super(optionsFromArguments(AutoFilter.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]));
      this.name = "AutoFilter";
      const options2 = optionsFromArguments(AutoFilter.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]);
      this.filter = new Filter(Object.assign(options2.filter, {
        context: this.context
      }));
      this.connectEffect(this.filter);
      this._lfo.connect(this.filter.frequency);
      this.octaves = options2.octaves;
      this.baseFrequency = options2.baseFrequency;
    }
    static getDefaults() {
      return Object.assign(LFOEffect.getDefaults(), {
        baseFrequency: 200,
        octaves: 2.6,
        filter: {
          type: "lowpass",
          rolloff: -12,
          Q: 1
        }
      });
    }
    get baseFrequency() {
      return this._lfo.min;
    }
    set baseFrequency(freq2) {
      this._lfo.min = this.toFrequency(freq2);
      this.octaves = this._octaves;
    }
    get octaves() {
      return this._octaves;
    }
    set octaves(oct) {
      this._octaves = oct;
      this._lfo.max = this._lfo.min * Math.pow(2, oct);
    }
    dispose() {
      super.dispose();
      this.filter.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/Panner.js
  var Panner = class extends ToneAudioNode {
    constructor() {
      super(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, ["pan"])));
      this.name = "Panner";
      this._panner = this.context.createStereoPanner();
      this.input = this._panner;
      this.output = this._panner;
      const options2 = optionsFromArguments(Panner.getDefaults(), arguments, ["pan"]);
      this.pan = new Param({
        context: this.context,
        param: this._panner.pan,
        value: options2.pan,
        minValue: -1,
        maxValue: 1
      });
      this._panner.channelCount = options2.channelCount;
      this._panner.channelCountMode = "explicit";
      readOnly(this, "pan");
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        pan: 0,
        channelCount: 1
      });
    }
    dispose() {
      super.dispose();
      this._panner.disconnect();
      this.pan.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/AutoPanner.js
  var AutoPanner = class extends LFOEffect {
    constructor() {
      super(optionsFromArguments(AutoPanner.getDefaults(), arguments, ["frequency"]));
      this.name = "AutoPanner";
      const options2 = optionsFromArguments(AutoPanner.getDefaults(), arguments, ["frequency"]);
      this._panner = new Panner({
        context: this.context,
        channelCount: options2.channelCount
      });
      this.connectEffect(this._panner);
      this._lfo.connect(this._panner.pan);
      this._lfo.min = -1;
      this._lfo.max = 1;
    }
    static getDefaults() {
      return Object.assign(LFOEffect.getDefaults(), {
        channelCount: 1
      });
    }
    dispose() {
      super.dispose();
      this._panner.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/analysis/Follower.js
  var Follower = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Follower.getDefaults(), arguments, ["smoothing"]));
      this.name = "Follower";
      const options2 = optionsFromArguments(Follower.getDefaults(), arguments, ["smoothing"]);
      this._abs = this.input = new Abs({ context: this.context });
      this._lowpass = this.output = new OnePoleFilter({
        context: this.context,
        frequency: 1 / this.toSeconds(options2.smoothing),
        type: "lowpass"
      });
      this._abs.connect(this._lowpass);
      this._smoothing = options2.smoothing;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        smoothing: 0.05
      });
    }
    get smoothing() {
      return this._smoothing;
    }
    set smoothing(smoothing) {
      this._smoothing = smoothing;
      this._lowpass.frequency = 1 / this.toSeconds(this.smoothing);
    }
    dispose() {
      super.dispose();
      this._abs.dispose();
      this._lowpass.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/BitCrusher.worklet.js
  var workletName2 = "bit-crusher";
  var bitCrusherWorklet = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
  registerProcessor(workletName2, bitCrusherWorklet);

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/BitCrusher.js
  var BitCrusher = class extends Effect {
    constructor() {
      super(optionsFromArguments(BitCrusher.getDefaults(), arguments, ["bits"]));
      this.name = "BitCrusher";
      const options2 = optionsFromArguments(BitCrusher.getDefaults(), arguments, ["bits"]);
      this._bitCrusherWorklet = new BitCrusherWorklet({
        context: this.context,
        bits: options2.bits
      });
      this.connectEffect(this._bitCrusherWorklet);
      this.bits = this._bitCrusherWorklet.bits;
    }
    static getDefaults() {
      return Object.assign(Effect.getDefaults(), {
        bits: 4
      });
    }
    dispose() {
      super.dispose();
      this._bitCrusherWorklet.dispose();
      return this;
    }
  };
  var BitCrusherWorklet = class extends ToneAudioWorklet {
    constructor() {
      super(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));
      this.name = "BitCrusherWorklet";
      const options2 = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);
      this.input = new Gain({ context: this.context });
      this.output = new Gain({ context: this.context });
      this.bits = new Param({
        context: this.context,
        value: options2.bits,
        units: "positive",
        minValue: 1,
        maxValue: 16,
        param: this._dummyParam,
        swappable: true
      });
    }
    static getDefaults() {
      return Object.assign(ToneAudioWorklet.getDefaults(), {
        bits: 12
      });
    }
    _audioWorkletName() {
      return workletName2;
    }
    onReady(node) {
      connectSeries(this.input, node, this.output);
      const bits = node.parameters.get("bits");
      this.bits.setParam(bits);
    }
    dispose() {
      super.dispose();
      this.input.dispose();
      this.output.dispose();
      this.bits.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/Split.js
  var Split = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Split.getDefaults(), arguments, ["channels"]));
      this.name = "Split";
      const options2 = optionsFromArguments(Split.getDefaults(), arguments, ["channels"]);
      this._splitter = this.input = this.output = this.context.createChannelSplitter(options2.channels);
      this._internalChannels = [this._splitter];
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        channels: 2
      });
    }
    dispose() {
      super.dispose();
      this._splitter.disconnect();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/Merge.js
  var Merge = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Merge.getDefaults(), arguments, ["channels"]));
      this.name = "Merge";
      const options2 = optionsFromArguments(Merge.getDefaults(), arguments, ["channels"]);
      this._merger = this.output = this.input = this.context.createChannelMerger(options2.channels);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        channels: 2
      });
    }
    dispose() {
      super.dispose();
      this._merger.disconnect();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/StereoEffect.js
  var StereoEffect = class extends ToneAudioNode {
    constructor(options2) {
      super(options2);
      this.name = "StereoEffect";
      this.input = new Gain({ context: this.context });
      this.input.channelCount = 2;
      this.input.channelCountMode = "explicit";
      this._dryWet = this.output = new CrossFade({
        context: this.context,
        fade: options2.wet
      });
      this.wet = this._dryWet.fade;
      this._split = new Split({ context: this.context, channels: 2 });
      this._merge = new Merge({ context: this.context, channels: 2 });
      this.input.connect(this._split);
      this.input.connect(this._dryWet.a);
      this._merge.connect(this._dryWet.b);
      readOnly(this, ["wet"]);
    }
    connectEffectLeft(...nodes) {
      this._split.connect(nodes[0], 0, 0);
      connectSeries(...nodes);
      connect(nodes[nodes.length - 1], this._merge, 0, 0);
    }
    connectEffectRight(...nodes) {
      this._split.connect(nodes[0], 1, 0);
      connectSeries(...nodes);
      connect(nodes[nodes.length - 1], this._merge, 0, 1);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        wet: 1
      });
    }
    dispose() {
      super.dispose();
      this._dryWet.dispose();
      this._split.dispose();
      this._merge.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/StereoFeedbackEffect.js
  var StereoFeedbackEffect = class extends StereoEffect {
    constructor(options2) {
      super(options2);
      this.feedback = new Signal({
        context: this.context,
        value: options2.feedback,
        units: "normalRange"
      });
      this._feedbackL = new Gain({ context: this.context });
      this._feedbackR = new Gain({ context: this.context });
      this._feedbackSplit = new Split({ context: this.context, channels: 2 });
      this._feedbackMerge = new Merge({ context: this.context, channels: 2 });
      this._merge.connect(this._feedbackSplit);
      this._feedbackMerge.connect(this._split);
      this._feedbackSplit.connect(this._feedbackL, 0, 0);
      this._feedbackL.connect(this._feedbackMerge, 0, 0);
      this._feedbackSplit.connect(this._feedbackR, 1, 0);
      this._feedbackR.connect(this._feedbackMerge, 0, 1);
      this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
      readOnly(this, ["feedback"]);
    }
    static getDefaults() {
      return Object.assign(StereoEffect.getDefaults(), {
        feedback: 0.5
      });
    }
    dispose() {
      super.dispose();
      this.feedback.dispose();
      this._feedbackL.dispose();
      this._feedbackR.dispose();
      this._feedbackSplit.dispose();
      this._feedbackMerge.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/Freeverb.js
  var combFilterTunings = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100];

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/JCReverb.js
  var combFilterDelayTimes = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3];

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/StereoXFeedbackEffect.js
  var StereoXFeedbackEffect = class extends StereoFeedbackEffect {
    constructor(options2) {
      super(options2);
      this._feedbackL.disconnect();
      this._feedbackL.connect(this._feedbackMerge, 0, 1);
      this._feedbackR.disconnect();
      this._feedbackR.connect(this._feedbackMerge, 0, 0);
      readOnly(this, ["feedback"]);
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/PingPongDelay.js
  var PingPongDelay = class extends StereoXFeedbackEffect {
    constructor() {
      super(optionsFromArguments(PingPongDelay.getDefaults(), arguments, ["delayTime", "feedback"]));
      this.name = "PingPongDelay";
      const options2 = optionsFromArguments(PingPongDelay.getDefaults(), arguments, ["delayTime", "feedback"]);
      this._leftDelay = new Delay({
        context: this.context,
        maxDelay: options2.maxDelay
      });
      this._rightDelay = new Delay({
        context: this.context,
        maxDelay: options2.maxDelay
      });
      this._rightPreDelay = new Delay({
        context: this.context,
        maxDelay: options2.maxDelay
      });
      this.delayTime = new Signal({
        context: this.context,
        units: "time",
        value: options2.delayTime
      });
      this.connectEffectLeft(this._leftDelay);
      this.connectEffectRight(this._rightPreDelay, this._rightDelay);
      this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);
      this._feedbackL.disconnect();
      this._feedbackL.connect(this._rightDelay);
      readOnly(this, ["delayTime"]);
    }
    static getDefaults() {
      return Object.assign(StereoXFeedbackEffect.getDefaults(), {
        delayTime: 0.25,
        maxDelay: 1
      });
    }
    dispose() {
      super.dispose();
      this._leftDelay.dispose();
      this._rightDelay.dispose();
      this._rightPreDelay.dispose();
      this.delayTime.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/Reverb.js
  var Reverb = class extends Effect {
    constructor() {
      super(optionsFromArguments(Reverb.getDefaults(), arguments, ["decay"]));
      this.name = "Reverb";
      this._convolver = this.context.createConvolver();
      this.ready = Promise.resolve();
      const options2 = optionsFromArguments(Reverb.getDefaults(), arguments, ["decay"]);
      this._decay = options2.decay;
      this._preDelay = options2.preDelay;
      this.generate();
      this.connectEffect(this._convolver);
    }
    static getDefaults() {
      return Object.assign(Effect.getDefaults(), {
        decay: 1.5,
        preDelay: 0.01
      });
    }
    get decay() {
      return this._decay;
    }
    set decay(time) {
      time = this.toSeconds(time);
      assertRange(time, 1e-3);
      this._decay = time;
      this.generate();
    }
    get preDelay() {
      return this._preDelay;
    }
    set preDelay(time) {
      time = this.toSeconds(time);
      assertRange(time, 0);
      this._preDelay = time;
      this.generate();
    }
    generate() {
      return __awaiter(this, void 0, void 0, function* () {
        const previousReady = this.ready;
        const context2 = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);
        const noiseL = new Noise({ context: context2 });
        const noiseR = new Noise({ context: context2 });
        const merge = new Merge({ context: context2 });
        noiseL.connect(merge, 0, 0);
        noiseR.connect(merge, 0, 1);
        const gainNode = new Gain({ context: context2 }).toDestination();
        merge.connect(gainNode);
        noiseL.start(0);
        noiseR.start(0);
        gainNode.gain.setValueAtTime(0, 0);
        gainNode.gain.setValueAtTime(1, this._preDelay);
        gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);
        const renderPromise = context2.render();
        this.ready = renderPromise.then(noOp);
        yield previousReady;
        this._convolver.buffer = (yield renderPromise).get();
        return this;
      });
    }
    dispose() {
      super.dispose();
      this._convolver.disconnect();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/MidSideSplit.js
  var MidSideSplit = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(MidSideSplit.getDefaults(), arguments));
      this.name = "MidSideSplit";
      this._split = this.input = new Split({
        channels: 2,
        context: this.context
      });
      this._midAdd = new Add({ context: this.context });
      this.mid = new Multiply({
        context: this.context,
        value: Math.SQRT1_2
      });
      this._sideSubtract = new Subtract({ context: this.context });
      this.side = new Multiply({
        context: this.context,
        value: Math.SQRT1_2
      });
      this._split.connect(this._midAdd, 0);
      this._split.connect(this._midAdd.addend, 1);
      this._split.connect(this._sideSubtract, 0);
      this._split.connect(this._sideSubtract.subtrahend, 1);
      this._midAdd.connect(this.mid);
      this._sideSubtract.connect(this.side);
    }
    dispose() {
      super.dispose();
      this.mid.dispose();
      this.side.dispose();
      this._midAdd.dispose();
      this._sideSubtract.dispose();
      this._split.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/MidSideMerge.js
  var MidSideMerge = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(MidSideMerge.getDefaults(), arguments));
      this.name = "MidSideMerge";
      this.mid = new Gain({ context: this.context });
      this.side = new Gain({ context: this.context });
      this._left = new Add({ context: this.context });
      this._leftMult = new Multiply({
        context: this.context,
        value: Math.SQRT1_2
      });
      this._right = new Subtract({ context: this.context });
      this._rightMult = new Multiply({
        context: this.context,
        value: Math.SQRT1_2
      });
      this._merge = this.output = new Merge({ context: this.context });
      this.mid.fan(this._left);
      this.side.connect(this._left.addend);
      this.mid.connect(this._right);
      this.side.connect(this._right.subtrahend);
      this._left.connect(this._leftMult);
      this._right.connect(this._rightMult);
      this._leftMult.connect(this._merge, 0, 0);
      this._rightMult.connect(this._merge, 0, 1);
    }
    dispose() {
      super.dispose();
      this.mid.dispose();
      this.side.dispose();
      this._leftMult.dispose();
      this._rightMult.dispose();
      this._left.dispose();
      this._right.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/MidSideEffect.js
  var MidSideEffect = class extends Effect {
    constructor(options2) {
      super(options2);
      this.name = "MidSideEffect";
      this._midSideMerge = new MidSideMerge({ context: this.context });
      this._midSideSplit = new MidSideSplit({ context: this.context });
      this._midSend = this._midSideSplit.mid;
      this._sideSend = this._midSideSplit.side;
      this._midReturn = this._midSideMerge.mid;
      this._sideReturn = this._midSideMerge.side;
      this.effectSend.connect(this._midSideSplit);
      this._midSideMerge.connect(this.effectReturn);
    }
    connectEffectMid(...nodes) {
      this._midSend.chain(...nodes, this._midReturn);
    }
    connectEffectSide(...nodes) {
      this._sideSend.chain(...nodes, this._sideReturn);
    }
    dispose() {
      super.dispose();
      this._midSideSplit.dispose();
      this._midSideMerge.dispose();
      this._midSend.dispose();
      this._sideSend.dispose();
      this._midReturn.dispose();
      this._sideReturn.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/effect/StereoWidener.js
  var StereoWidener = class extends MidSideEffect {
    constructor() {
      super(optionsFromArguments(StereoWidener.getDefaults(), arguments, ["width"]));
      this.name = "StereoWidener";
      const options2 = optionsFromArguments(StereoWidener.getDefaults(), arguments, ["width"]);
      this.width = new Signal({
        context: this.context,
        value: options2.width,
        units: "normalRange"
      });
      readOnly(this, ["width"]);
      this._twoTimesWidthMid = new Multiply({
        context: this.context,
        value: 2
      });
      this._twoTimesWidthSide = new Multiply({
        context: this.context,
        value: 2
      });
      this._midMult = new Multiply({ context: this.context });
      this._twoTimesWidthMid.connect(this._midMult.factor);
      this.connectEffectMid(this._midMult);
      this._oneMinusWidth = new Subtract({ context: this.context });
      this._oneMinusWidth.connect(this._twoTimesWidthMid);
      connect(this.context.getConstant(1), this._oneMinusWidth);
      this.width.connect(this._oneMinusWidth.subtrahend);
      this._sideMult = new Multiply({ context: this.context });
      this.width.connect(this._twoTimesWidthSide);
      this._twoTimesWidthSide.connect(this._sideMult.factor);
      this.connectEffectSide(this._sideMult);
    }
    static getDefaults() {
      return Object.assign(MidSideEffect.getDefaults(), {
        width: 0.5
      });
    }
    dispose() {
      super.dispose();
      this.width.dispose();
      this._midMult.dispose();
      this._sideMult.dispose();
      this._twoTimesWidthMid.dispose();
      this._twoTimesWidthSide.dispose();
      this._oneMinusWidth.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/analysis/Analyser.js
  var Analyser = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Analyser.getDefaults(), arguments, ["type", "size"]));
      this.name = "Analyser";
      this._analysers = [];
      this._buffers = [];
      const options2 = optionsFromArguments(Analyser.getDefaults(), arguments, ["type", "size"]);
      this.input = this.output = this._gain = new Gain({ context: this.context });
      this._split = new Split({
        context: this.context,
        channels: options2.channels
      });
      this.input.connect(this._split);
      assertRange(options2.channels, 1);
      for (let channel = 0; channel < options2.channels; channel++) {
        this._analysers[channel] = this.context.createAnalyser();
        this._split.connect(this._analysers[channel], channel, 0);
      }
      this.size = options2.size;
      this.type = options2.type;
      this.smoothing = options2.smoothing;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        size: 1024,
        smoothing: 0.8,
        type: "fft",
        channels: 1
      });
    }
    getValue() {
      this._analysers.forEach((analyser, index15) => {
        const buffer2 = this._buffers[index15];
        if (this._type === "fft") {
          analyser.getFloatFrequencyData(buffer2);
        } else if (this._type === "waveform") {
          analyser.getFloatTimeDomainData(buffer2);
        }
      });
      if (this.channels === 1) {
        return this._buffers[0];
      } else {
        return this._buffers;
      }
    }
    get size() {
      return this._analysers[0].frequencyBinCount;
    }
    set size(size2) {
      this._analysers.forEach((analyser, index15) => {
        analyser.fftSize = size2 * 2;
        this._buffers[index15] = new Float32Array(size2);
      });
    }
    get channels() {
      return this._analysers.length;
    }
    get type() {
      return this._type;
    }
    set type(type) {
      assert(type === "waveform" || type === "fft", `Analyser: invalid type: ${type}`);
      this._type = type;
    }
    get smoothing() {
      return this._analysers[0].smoothingTimeConstant;
    }
    set smoothing(val) {
      this._analysers.forEach((a8) => a8.smoothingTimeConstant = val);
    }
    dispose() {
      super.dispose();
      this._analysers.forEach((a8) => a8.disconnect());
      this._split.dispose();
      this._gain.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/analysis/MeterBase.js
  var MeterBase = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(MeterBase.getDefaults(), arguments));
      this.name = "MeterBase";
      this.input = this.output = this._analyser = new Analyser({
        context: this.context,
        size: 256,
        type: "waveform"
      });
    }
    dispose() {
      super.dispose();
      this._analyser.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/analysis/Meter.js
  var Meter = class extends MeterBase {
    constructor() {
      super(optionsFromArguments(Meter.getDefaults(), arguments, ["smoothing"]));
      this.name = "Meter";
      const options2 = optionsFromArguments(Meter.getDefaults(), arguments, ["smoothing"]);
      this.input = this.output = this._analyser = new Analyser({
        context: this.context,
        size: 256,
        type: "waveform",
        channels: options2.channelCount
      });
      this.smoothing = options2.smoothing, this.normalRange = options2.normalRange;
      this._rms = new Array(options2.channelCount);
      this._rms.fill(0);
    }
    static getDefaults() {
      return Object.assign(MeterBase.getDefaults(), {
        smoothing: 0.8,
        normalRange: false,
        channelCount: 1
      });
    }
    getLevel() {
      warn("'getLevel' has been changed to 'getValue'");
      return this.getValue();
    }
    getValue() {
      const aValues = this._analyser.getValue();
      const channelValues = this.channels === 1 ? [aValues] : aValues;
      const vals = channelValues.map((values, index15) => {
        const totalSquared = values.reduce((total, current) => total + current * current, 0);
        const rms = Math.sqrt(totalSquared / values.length);
        this._rms[index15] = Math.max(rms, this._rms[index15] * this.smoothing);
        return this.normalRange ? this._rms[index15] : gainToDb(this._rms[index15]);
      });
      if (this.channels === 1) {
        return vals[0];
      } else {
        return vals;
      }
    }
    get channels() {
      return this._analyser.channels;
    }
    dispose() {
      super.dispose();
      this._analyser.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/analysis/FFT.js
  var FFT = class extends MeterBase {
    constructor() {
      super(optionsFromArguments(FFT.getDefaults(), arguments, ["size"]));
      this.name = "FFT";
      const options2 = optionsFromArguments(FFT.getDefaults(), arguments, ["size"]);
      this.normalRange = options2.normalRange;
      this._analyser.type = "fft";
      this.size = options2.size;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        normalRange: false,
        size: 1024,
        smoothing: 0.8
      });
    }
    getValue() {
      const values = this._analyser.getValue();
      return values.map((v3) => this.normalRange ? dbToGain(v3) : v3);
    }
    get size() {
      return this._analyser.size;
    }
    set size(size2) {
      this._analyser.size = size2;
    }
    get smoothing() {
      return this._analyser.smoothing;
    }
    set smoothing(val) {
      this._analyser.smoothing = val;
    }
    getFrequencyOfIndex(index15) {
      assert(0 <= index15 && index15 < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);
      return index15 * this.context.sampleRate / (this.size * 2);
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/Solo.js
  var Solo = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Solo.getDefaults(), arguments, ["solo"]));
      this.name = "Solo";
      const options2 = optionsFromArguments(Solo.getDefaults(), arguments, ["solo"]);
      this.input = this.output = new Gain({
        context: this.context
      });
      if (!Solo._allSolos.has(this.context)) {
        Solo._allSolos.set(this.context, /* @__PURE__ */ new Set());
      }
      Solo._allSolos.get(this.context).add(this);
      this.solo = options2.solo;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        solo: false
      });
    }
    get solo() {
      return this._isSoloed();
    }
    set solo(solo) {
      if (solo) {
        this._addSolo();
      } else {
        this._removeSolo();
      }
      Solo._allSolos.get(this.context).forEach((instance) => instance._updateSolo());
    }
    get muted() {
      return this.input.gain.value === 0;
    }
    _addSolo() {
      if (!Solo._soloed.has(this.context)) {
        Solo._soloed.set(this.context, /* @__PURE__ */ new Set());
      }
      Solo._soloed.get(this.context).add(this);
    }
    _removeSolo() {
      if (Solo._soloed.has(this.context)) {
        Solo._soloed.get(this.context).delete(this);
      }
    }
    _isSoloed() {
      return Solo._soloed.has(this.context) && Solo._soloed.get(this.context).has(this);
    }
    _noSolos() {
      return !Solo._soloed.has(this.context) || Solo._soloed.has(this.context) && Solo._soloed.get(this.context).size === 0;
    }
    _updateSolo() {
      if (this._isSoloed()) {
        this.input.gain.value = 1;
      } else if (this._noSolos()) {
        this.input.gain.value = 1;
      } else {
        this.input.gain.value = 0;
      }
    }
    dispose() {
      super.dispose();
      Solo._allSolos.get(this.context).delete(this);
      this._removeSolo();
      return this;
    }
  };
  Solo._allSolos = /* @__PURE__ */ new Map();
  Solo._soloed = /* @__PURE__ */ new Map();

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/PanVol.js
  var PanVol = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(PanVol.getDefaults(), arguments, ["pan", "volume"]));
      this.name = "PanVol";
      const options2 = optionsFromArguments(PanVol.getDefaults(), arguments, ["pan", "volume"]);
      this._panner = this.input = new Panner({
        context: this.context,
        pan: options2.pan,
        channelCount: options2.channelCount
      });
      this.pan = this._panner.pan;
      this._volume = this.output = new Volume({
        context: this.context,
        volume: options2.volume
      });
      this.volume = this._volume.volume;
      this._panner.connect(this._volume);
      this.mute = options2.mute;
      readOnly(this, ["pan", "volume"]);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        mute: false,
        pan: 0,
        volume: 0,
        channelCount: 1
      });
    }
    get mute() {
      return this._volume.mute;
    }
    set mute(mute) {
      this._volume.mute = mute;
    }
    dispose() {
      super.dispose();
      this._panner.dispose();
      this.pan.dispose();
      this._volume.dispose();
      this.volume.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/Channel.js
  var Channel = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Channel.getDefaults(), arguments, ["volume", "pan"]));
      this.name = "Channel";
      const options2 = optionsFromArguments(Channel.getDefaults(), arguments, ["volume", "pan"]);
      this._solo = this.input = new Solo({
        solo: options2.solo,
        context: this.context
      });
      this._panVol = this.output = new PanVol({
        context: this.context,
        pan: options2.pan,
        volume: options2.volume,
        mute: options2.mute,
        channelCount: options2.channelCount
      });
      this.pan = this._panVol.pan;
      this.volume = this._panVol.volume;
      this._solo.connect(this._panVol);
      readOnly(this, ["pan", "volume"]);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        pan: 0,
        volume: 0,
        mute: false,
        solo: false,
        channelCount: 1
      });
    }
    get solo() {
      return this._solo.solo;
    }
    set solo(solo) {
      this._solo.solo = solo;
    }
    get muted() {
      return this._solo.muted || this.mute;
    }
    get mute() {
      return this._panVol.mute;
    }
    set mute(mute) {
      this._panVol.mute = mute;
    }
    _getBus(name2) {
      if (!Channel.buses.has(name2)) {
        Channel.buses.set(name2, new Gain({ context: this.context }));
      }
      return Channel.buses.get(name2);
    }
    send(name2, volume = 0) {
      const bus = this._getBus(name2);
      const sendKnob = new Gain({
        context: this.context,
        units: "decibels",
        gain: volume
      });
      this.connect(sendKnob);
      sendKnob.connect(bus);
      return sendKnob;
    }
    receive(name2) {
      const bus = this._getBus(name2);
      bus.connect(this);
      return this;
    }
    dispose() {
      super.dispose();
      this._panVol.dispose();
      this.pan.dispose();
      this.volume.dispose();
      this._solo.dispose();
      return this;
    }
  };
  Channel.buses = /* @__PURE__ */ new Map();

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/core/context/Listener.js
  var Listener = class extends ToneAudioNode {
    constructor() {
      super(...arguments);
      this.name = "Listener";
      this.positionX = new Param({
        context: this.context,
        param: this.context.rawContext.listener.positionX
      });
      this.positionY = new Param({
        context: this.context,
        param: this.context.rawContext.listener.positionY
      });
      this.positionZ = new Param({
        context: this.context,
        param: this.context.rawContext.listener.positionZ
      });
      this.forwardX = new Param({
        context: this.context,
        param: this.context.rawContext.listener.forwardX
      });
      this.forwardY = new Param({
        context: this.context,
        param: this.context.rawContext.listener.forwardY
      });
      this.forwardZ = new Param({
        context: this.context,
        param: this.context.rawContext.listener.forwardZ
      });
      this.upX = new Param({
        context: this.context,
        param: this.context.rawContext.listener.upX
      });
      this.upY = new Param({
        context: this.context,
        param: this.context.rawContext.listener.upY
      });
      this.upZ = new Param({
        context: this.context,
        param: this.context.rawContext.listener.upZ
      });
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        positionX: 0,
        positionY: 0,
        positionZ: 0,
        forwardX: 0,
        forwardY: 0,
        forwardZ: -1,
        upX: 0,
        upY: 1,
        upZ: 0
      });
    }
    dispose() {
      super.dispose();
      this.positionX.dispose();
      this.positionY.dispose();
      this.positionZ.dispose();
      this.forwardX.dispose();
      this.forwardY.dispose();
      this.forwardZ.dispose();
      this.upX.dispose();
      this.upY.dispose();
      this.upZ.dispose();
      return this;
    }
  };
  onContextInit((context2) => {
    context2.listener = new Listener({ context: context2 });
  });
  onContextClose((context2) => {
    context2.listener.dispose();
  });

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/channel/Recorder.js
  var Recorder = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Recorder.getDefaults(), arguments));
      this.name = "Recorder";
      const options2 = optionsFromArguments(Recorder.getDefaults(), arguments);
      this.input = new Gain({
        context: this.context
      });
      assert(Recorder.supported, "Media Recorder API is not available");
      this._stream = this.context.createMediaStreamDestination();
      this.input.connect(this._stream);
      this._recorder = new MediaRecorder(this._stream.stream, {
        mimeType: options2.mimeType
      });
    }
    static getDefaults() {
      return ToneAudioNode.getDefaults();
    }
    get mimeType() {
      return this._recorder.mimeType;
    }
    static get supported() {
      return theWindow !== null && Reflect.has(theWindow, "MediaRecorder");
    }
    get state() {
      if (this._recorder.state === "inactive") {
        return "stopped";
      } else if (this._recorder.state === "paused") {
        return "paused";
      } else {
        return "started";
      }
    }
    start() {
      return __awaiter(this, void 0, void 0, function* () {
        assert(this.state !== "started", "Recorder is already started");
        const startPromise = new Promise((done) => {
          const handleStart = () => {
            this._recorder.removeEventListener("start", handleStart, false);
            done();
          };
          this._recorder.addEventListener("start", handleStart, false);
        });
        this._recorder.start();
        return yield startPromise;
      });
    }
    stop() {
      return __awaiter(this, void 0, void 0, function* () {
        assert(this.state !== "stopped", "Recorder is not started");
        const dataPromise = new Promise((done) => {
          const handleData = (e8) => {
            this._recorder.removeEventListener("dataavailable", handleData, false);
            done(e8.data);
          };
          this._recorder.addEventListener("dataavailable", handleData, false);
        });
        this._recorder.stop();
        return yield dataPromise;
      });
    }
    pause() {
      assert(this.state === "started", "Recorder must be started");
      this._recorder.pause();
      return this;
    }
    dispose() {
      super.dispose();
      this.input.dispose();
      this._stream.disconnect();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/dynamics/Compressor.js
  var Compressor = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Compressor.getDefaults(), arguments, ["threshold", "ratio"]));
      this.name = "Compressor";
      this._compressor = this.context.createDynamicsCompressor();
      this.input = this._compressor;
      this.output = this._compressor;
      const options2 = optionsFromArguments(Compressor.getDefaults(), arguments, ["threshold", "ratio"]);
      this.threshold = new Param({
        minValue: this._compressor.threshold.minValue,
        maxValue: this._compressor.threshold.maxValue,
        context: this.context,
        convert: false,
        param: this._compressor.threshold,
        units: "decibels",
        value: options2.threshold
      });
      this.attack = new Param({
        minValue: this._compressor.attack.minValue,
        maxValue: this._compressor.attack.maxValue,
        context: this.context,
        param: this._compressor.attack,
        units: "time",
        value: options2.attack
      });
      this.release = new Param({
        minValue: this._compressor.release.minValue,
        maxValue: this._compressor.release.maxValue,
        context: this.context,
        param: this._compressor.release,
        units: "time",
        value: options2.release
      });
      this.knee = new Param({
        minValue: this._compressor.knee.minValue,
        maxValue: this._compressor.knee.maxValue,
        context: this.context,
        convert: false,
        param: this._compressor.knee,
        units: "decibels",
        value: options2.knee
      });
      this.ratio = new Param({
        minValue: this._compressor.ratio.minValue,
        maxValue: this._compressor.ratio.maxValue,
        context: this.context,
        convert: false,
        param: this._compressor.ratio,
        units: "positive",
        value: options2.ratio
      });
      readOnly(this, ["knee", "release", "attack", "ratio", "threshold"]);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        attack: 3e-3,
        knee: 30,
        ratio: 12,
        release: 0.25,
        threshold: -24
      });
    }
    get reduction() {
      return this._compressor.reduction;
    }
    dispose() {
      super.dispose();
      this._compressor.disconnect();
      this.attack.dispose();
      this.release.dispose();
      this.threshold.dispose();
      this.ratio.dispose();
      this.knee.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/dynamics/Gate.js
  var Gate = class extends ToneAudioNode {
    constructor() {
      super(Object.assign(optionsFromArguments(Gate.getDefaults(), arguments, ["threshold", "smoothing"])));
      this.name = "Gate";
      const options2 = optionsFromArguments(Gate.getDefaults(), arguments, ["threshold", "smoothing"]);
      this._follower = new Follower({
        context: this.context,
        smoothing: options2.smoothing
      });
      this._gt = new GreaterThan({
        context: this.context,
        value: dbToGain(options2.threshold)
      });
      this.input = new Gain({ context: this.context });
      this._gate = this.output = new Gain({ context: this.context });
      this.input.connect(this._gate);
      this.input.chain(this._follower, this._gt, this._gate.gain);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        smoothing: 0.1,
        threshold: -40
      });
    }
    get threshold() {
      return gainToDb(this._gt.value);
    }
    set threshold(thresh) {
      this._gt.value = dbToGain(thresh);
    }
    get smoothing() {
      return this._follower.smoothing;
    }
    set smoothing(smoothingTime) {
      this._follower.smoothing = smoothingTime;
    }
    dispose() {
      super.dispose();
      this.input.dispose();
      this._follower.dispose();
      this._gt.dispose();
      this._gate.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/component/dynamics/Limiter.js
  var Limiter = class extends ToneAudioNode {
    constructor() {
      super(Object.assign(optionsFromArguments(Limiter.getDefaults(), arguments, ["threshold"])));
      this.name = "Limiter";
      const options2 = optionsFromArguments(Limiter.getDefaults(), arguments, ["threshold"]);
      this._compressor = this.input = this.output = new Compressor({
        context: this.context,
        ratio: 20,
        attack: 3e-3,
        release: 0.01,
        threshold: options2.threshold
      });
      this.threshold = this._compressor.threshold;
      readOnly(this, "threshold");
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        threshold: -12
      });
    }
    get reduction() {
      return this._compressor.reduction;
    }
    dispose() {
      super.dispose();
      this._compressor.dispose();
      this.threshold.dispose();
      return this;
    }
  };

  // node_modules/.pnpm/tone@14.8.40/node_modules/tone/build/esm/index.js
  function now() {
    return getContext().now();
  }
  var Transport2 = getContext().transport;
  var Destination2 = getContext().destination;
  var Master = getContext().destination;
  function getDestination() {
    return getContext().destination;
  }
  var Listener2 = getContext().listener;
  var Draw2 = getContext().draw;
  var context = getContext();

  // node_modules/.pnpm/vue-demi@0.12.5_vue@3.2.37/node_modules/vue-demi/lib/index.mjs
  var lib_exports = {};
  __export(lib_exports, {
    Vue: () => vue_exports,
    Vue2: () => Vue2,
    del: () => del,
    install: () => install,
    isVue2: () => isVue2,
    isVue3: () => isVue3,
    set: () => set2
  });

  // node_modules/.pnpm/vue@3.2.37/node_modules/vue/index.mjs
  var vue_exports = {};
  __reExport(vue_exports, __toESM(require_vue(), 1));

  // node_modules/.pnpm/vue-demi@0.12.5_vue@3.2.37/node_modules/vue-demi/lib/index.mjs
  __reExport(lib_exports, vue_exports);
  var isVue2 = false;
  var isVue3 = true;
  var Vue2 = void 0;
  function install() {
  }
  function set2(target, key, val) {
    if (Array.isArray(target)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    target[key] = val;
    return val;
  }
  function del(target, key) {
    if (Array.isArray(target)) {
      target.splice(key, 1);
      return;
    }
    delete target[key];
  }

  // node_modules/.pnpm/@vueuse+shared@8.9.2_vue@3.2.37/node_modules/@vueuse/shared/index.mjs
  var _a2;
  var isClient = typeof window !== "undefined";
  var isString3 = (val) => typeof val === "string";
  var timestamp = () => +Date.now();
  var clamp2 = (n8, min, max) => Math.min(max, Math.max(min, n8));
  var noop = () => {
  };
  var isIOS = isClient && ((_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
  function createFilterWrapper(filter2, fn) {
    function wrapper(...args) {
      filter2(() => fn.apply(this, args), { fn, thisArg: this, args });
    }
    return wrapper;
  }
  var bypassFilter = (invoke) => {
    return invoke();
  };
  function pausableFilter(extendFilter = bypassFilter) {
    const isActive = (0, lib_exports.ref)(true);
    function pause() {
      isActive.value = false;
    }
    function resume() {
      isActive.value = true;
    }
    const eventFilter = (...args) => {
      if (isActive.value)
        extendFilter(...args);
    };
    return { isActive, pause, resume, eventFilter };
  }
  function createSingletonPromise(fn) {
    let _promise;
    function wrapper() {
      if (!_promise)
        _promise = fn();
      return _promise;
    }
    wrapper.reset = async () => {
      const _prev = _promise;
      _promise = void 0;
      if (_prev)
        await _prev;
    };
    return wrapper;
  }
  function tryOnScopeDispose(fn) {
    if ((0, lib_exports.getCurrentScope)()) {
      (0, lib_exports.onScopeDispose)(fn);
      return true;
    }
    return false;
  }
  function useIntervalFn(cb, interval2 = 1e3, options2 = {}) {
    const {
      immediate = true,
      immediateCallback = false
    } = options2;
    let timer2 = null;
    const isActive = (0, lib_exports.ref)(false);
    function clean() {
      if (timer2) {
        clearInterval(timer2);
        timer2 = null;
      }
    }
    function pause() {
      isActive.value = false;
      clean();
    }
    function resume() {
      if ((0, lib_exports.unref)(interval2) <= 0)
        return;
      isActive.value = true;
      if (immediateCallback)
        cb();
      clean();
      timer2 = setInterval(cb, (0, lib_exports.unref)(interval2));
    }
    if (immediate && isClient)
      resume();
    if ((0, lib_exports.isRef)(interval2)) {
      const stopWatch = (0, lib_exports.watch)(interval2, () => {
        if (isActive.value && isClient)
          resume();
      });
      tryOnScopeDispose(stopWatch);
    }
    tryOnScopeDispose(pause);
    return {
      isActive,
      pause,
      resume
    };
  }
  function useLastChanged(source, options2 = {}) {
    var _a3;
    const ms = (0, lib_exports.ref)((_a3 = options2.initialValue) != null ? _a3 : null);
    (0, lib_exports.watch)(source, () => ms.value = timestamp(), options2);
    return ms;
  }
  var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
  var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
  var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
  var __objRest$5 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$6)
      for (var prop of __getOwnPropSymbols$6(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function watchWithFilter(source, cb, options2 = {}) {
    const _a3 = options2, {
      eventFilter = bypassFilter
    } = _a3, watchOptions = __objRest$5(_a3, [
      "eventFilter"
    ]);
    return (0, lib_exports.watch)(source, createFilterWrapper(eventFilter, cb), watchOptions);
  }
  var __defProp$2 = Object.defineProperty;
  var __defProps$2 = Object.defineProperties;
  var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
  var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
  var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$2 = (a8, b5) => {
    for (var prop in b5 || (b5 = {}))
      if (__hasOwnProp$2.call(b5, prop))
        __defNormalProp$2(a8, prop, b5[prop]);
    if (__getOwnPropSymbols$2)
      for (var prop of __getOwnPropSymbols$2(b5)) {
        if (__propIsEnum$2.call(b5, prop))
          __defNormalProp$2(a8, prop, b5[prop]);
      }
    return a8;
  };
  var __spreadProps$2 = (a8, b5) => __defProps$2(a8, __getOwnPropDescs$2(b5));
  var __objRest$1 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$2)
      for (var prop of __getOwnPropSymbols$2(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function watchPausable(source, cb, options2 = {}) {
    const _a3 = options2, {
      eventFilter: filter2
    } = _a3, watchOptions = __objRest$1(_a3, [
      "eventFilter"
    ]);
    const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
    const stop2 = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
      eventFilter
    }));
    return { stop: stop2, pause, resume, isActive };
  }

  // node_modules/.pnpm/@vueuse+core@8.9.2_vue@3.2.37/node_modules/@vueuse/core/index.mjs
  function unrefElement(elRef) {
    var _a3;
    const plain = (0, lib_exports.unref)(elRef);
    return (_a3 = plain == null ? void 0 : plain.$el) != null ? _a3 : plain;
  }
  var defaultWindow = isClient ? window : void 0;
  var defaultDocument = isClient ? window.document : void 0;
  var defaultNavigator = isClient ? window.navigator : void 0;
  var defaultLocation = isClient ? window.location : void 0;
  function useEventListener(...args) {
    let target;
    let event;
    let listener;
    let options2;
    if (isString3(args[0])) {
      [event, listener, options2] = args;
      target = defaultWindow;
    } else {
      [target, event, listener, options2] = args;
    }
    if (!target)
      return noop;
    let cleanup = noop;
    const stopWatch = (0, lib_exports.watch)(() => unrefElement(target), (el) => {
      cleanup();
      if (!el)
        return;
      el.addEventListener(event, listener, options2);
      cleanup = () => {
        el.removeEventListener(event, listener, options2);
        cleanup = noop;
      };
    }, { immediate: true, flush: "post" });
    const stop2 = () => {
      stopWatch();
      cleanup();
    };
    tryOnScopeDispose(stop2);
    return stop2;
  }
  var __defProp$j = Object.defineProperty;
  var __defProps$8 = Object.defineProperties;
  var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
  var __hasOwnProp$l = Object.prototype.hasOwnProperty;
  var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$j = (a8, b5) => {
    for (var prop in b5 || (b5 = {}))
      if (__hasOwnProp$l.call(b5, prop))
        __defNormalProp$j(a8, prop, b5[prop]);
    if (__getOwnPropSymbols$l)
      for (var prop of __getOwnPropSymbols$l(b5)) {
        if (__propIsEnum$l.call(b5, prop))
          __defNormalProp$j(a8, prop, b5[prop]);
      }
    return a8;
  };
  var __spreadProps$8 = (a8, b5) => __defProps$8(a8, __getOwnPropDescs$8(b5));
  var createKeyPredicate = (keyFilter) => {
    if (typeof keyFilter === "function")
      return keyFilter;
    else if (typeof keyFilter === "string")
      return (event) => event.key === keyFilter;
    else if (Array.isArray(keyFilter))
      return (event) => keyFilter.includes(event.key);
    else if (keyFilter)
      return () => true;
    else
      return () => false;
  };
  function onKeyStroke(key, handler2, options2 = {}) {
    const { target = defaultWindow, eventName = "keydown", passive = false } = options2;
    const predicate = createKeyPredicate(key);
    const listener = (e8) => {
      if (predicate(e8))
        handler2(e8);
    };
    return useEventListener(target, eventName, listener, passive);
  }
  function onKeyDown(key, handler2, options2 = {}) {
    return onKeyStroke(key, handler2, __spreadProps$8(__spreadValues$j({}, options2), { eventName: "keydown" }));
  }
  function useClamp2(value, min, max) {
    const _value = (0, lib_exports.ref)(value);
    return (0, lib_exports.computed)({
      get() {
        return _value.value = clamp2(_value.value, (0, lib_exports.unref)(min), (0, lib_exports.unref)(max));
      },
      set(value2) {
        _value.value = clamp2(value2, (0, lib_exports.unref)(min), (0, lib_exports.unref)(max));
      }
    });
  }
  var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var globalKey = "__vueuse_ssr_handlers__";
  _global[globalKey] = _global[globalKey] || {};
  var handlers = _global[globalKey];
  function getSSRHandler(key, fallback) {
    return handlers[key] || fallback;
  }
  function guessSerializerType(rawInit) {
    return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
  }
  var StorageSerializers = {
    boolean: {
      read: (v3) => v3 === "true",
      write: (v3) => String(v3)
    },
    object: {
      read: (v3) => JSON.parse(v3),
      write: (v3) => JSON.stringify(v3)
    },
    number: {
      read: (v3) => Number.parseFloat(v3),
      write: (v3) => String(v3)
    },
    any: {
      read: (v3) => v3,
      write: (v3) => String(v3)
    },
    string: {
      read: (v3) => v3,
      write: (v3) => String(v3)
    },
    map: {
      read: (v3) => new Map(JSON.parse(v3)),
      write: (v3) => JSON.stringify(Array.from(v3.entries()))
    },
    set: {
      read: (v3) => new Set(JSON.parse(v3)),
      write: (v3) => JSON.stringify(Array.from(v3))
    },
    date: {
      read: (v3) => new Date(v3),
      write: (v3) => v3.toISOString()
    }
  };
  function useStorage2(key, initialValue, storage, options2 = {}) {
    var _a3;
    const {
      flush = "pre",
      deep = true,
      listenToStorageChanges = true,
      writeDefaults = true,
      shallow,
      window: window3 = defaultWindow,
      eventFilter,
      onError = (e8) => {
        console.error(e8);
      }
    } = options2;
    const data = (shallow ? lib_exports.shallowRef : lib_exports.ref)(initialValue);
    if (!storage) {
      try {
        storage = getSSRHandler("getDefaultStorage", () => {
          var _a22;
          return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
        })();
      } catch (e8) {
        onError(e8);
      }
    }
    if (!storage)
      return data;
    const rawInit = (0, lib_exports.unref)(initialValue);
    const type = guessSerializerType(rawInit);
    const serializer = (_a3 = options2.serializer) != null ? _a3 : StorageSerializers[type];
    const { pause: pauseWatch, resume: resumeWatch } = watchPausable(data, () => write(data.value), { flush, deep, eventFilter });
    if (window3 && listenToStorageChanges)
      useEventListener(window3, "storage", update);
    update();
    return data;
    function write(v3) {
      try {
        if (v3 == null)
          storage.removeItem(key);
        else
          storage.setItem(key, serializer.write(v3));
      } catch (e8) {
        onError(e8);
      }
    }
    function read2(event) {
      if (event && event.key !== key)
        return;
      pauseWatch();
      try {
        const rawValue = event ? event.newValue : storage.getItem(key);
        if (rawValue == null) {
          if (writeDefaults && rawInit !== null)
            storage.setItem(key, serializer.write(rawInit));
          return rawInit;
        } else if (typeof rawValue !== "string") {
          return rawValue;
        } else {
          return serializer.read(rawValue);
        }
      } catch (e8) {
        onError(e8);
      } finally {
        resumeWatch();
      }
    }
    function update(event) {
      if (event && event.key !== key)
        return;
      data.value = read2(event);
    }
  }
  function useCycleList(list, options2) {
    var _a3;
    const state = (0, lib_exports.shallowRef)((_a3 = options2 == null ? void 0 : options2.initialValue) != null ? _a3 : list[0]);
    const index15 = (0, lib_exports.computed)({
      get() {
        var _a22;
        let index22 = (options2 == null ? void 0 : options2.getIndexOf) ? options2.getIndexOf(state.value, list) : list.indexOf(state.value);
        if (index22 < 0)
          index22 = (_a22 = options2 == null ? void 0 : options2.fallbackIndex) != null ? _a22 : 0;
        return index22;
      },
      set(v3) {
        set3(v3);
      }
    });
    function set3(i8) {
      const length = list.length;
      const index22 = (i8 % length + length) % length;
      const value = list[index22];
      state.value = value;
      return value;
    }
    function shift(delta = 1) {
      return set3(index15.value + delta);
    }
    function next(n8 = 1) {
      return shift(n8);
    }
    function prev(n8 = 1) {
      return shift(-n8);
    }
    return {
      state,
      index: index15,
      next,
      prev
    };
  }
  function usePermission(permissionDesc, options2 = {}) {
    const {
      controls = false,
      navigator: navigator2 = defaultNavigator
    } = options2;
    const isSupported3 = Boolean(navigator2 && "permissions" in navigator2);
    let permissionStatus;
    const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
    const state = (0, lib_exports.ref)();
    const onChange = () => {
      if (permissionStatus)
        state.value = permissionStatus.state;
    };
    const query = createSingletonPromise(async () => {
      if (!isSupported3)
        return;
      if (!permissionStatus) {
        try {
          permissionStatus = await navigator2.permissions.query(desc);
          useEventListener(permissionStatus, "change", onChange);
          onChange();
        } catch (e8) {
          state.value = "prompt";
        }
      }
      return permissionStatus;
    });
    query();
    if (controls) {
      return {
        state,
        isSupported: isSupported3,
        query
      };
    } else {
      return state;
    }
  }
  function useDevicesList(options2 = {}) {
    const {
      navigator: navigator2 = defaultNavigator,
      requestPermissions = false,
      constraints = { audio: true, video: true },
      onUpdated: onUpdated3
    } = options2;
    const devices2 = (0, lib_exports.ref)([]);
    const videoInputs = (0, lib_exports.computed)(() => devices2.value.filter((i8) => i8.kind === "videoinput"));
    const audioInputs = (0, lib_exports.computed)(() => devices2.value.filter((i8) => i8.kind === "audioinput"));
    const audioOutputs = (0, lib_exports.computed)(() => devices2.value.filter((i8) => i8.kind === "audiooutput"));
    let isSupported3 = false;
    const permissionGranted = (0, lib_exports.ref)(false);
    async function update() {
      if (!isSupported3)
        return;
      devices2.value = await navigator2.mediaDevices.enumerateDevices();
      onUpdated3 == null ? void 0 : onUpdated3(devices2.value);
    }
    async function ensurePermissions() {
      if (!isSupported3)
        return false;
      if (permissionGranted.value)
        return true;
      const { state, query } = usePermission("camera", { controls: true });
      await query();
      if (state.value !== "granted") {
        const stream = await navigator2.mediaDevices.getUserMedia(constraints);
        stream.getTracks().forEach((t8) => t8.stop());
        update();
        permissionGranted.value = true;
      } else {
        permissionGranted.value = true;
      }
      return permissionGranted.value;
    }
    if (navigator2) {
      isSupported3 = Boolean(navigator2.mediaDevices && navigator2.mediaDevices.enumerateDevices);
      if (isSupported3) {
        if (requestPermissions)
          ensurePermissions();
        useEventListener(navigator2.mediaDevices, "devicechange", update);
        update();
      }
    }
    return {
      devices: devices2,
      ensurePermissions,
      permissionGranted,
      videoInputs,
      audioInputs,
      audioOutputs,
      isSupported: isSupported3
    };
  }
  function useRafFn2(fn, options2 = {}) {
    const {
      immediate = true,
      window: window3 = defaultWindow
    } = options2;
    const isActive = (0, lib_exports.ref)(false);
    let rafId = null;
    function loop() {
      if (!isActive.value || !window3)
        return;
      fn();
      rafId = window3.requestAnimationFrame(loop);
    }
    function resume() {
      if (!isActive.value && window3) {
        isActive.value = true;
        loop();
      }
    }
    function pause() {
      isActive.value = false;
      if (rafId != null && window3) {
        window3.cancelAnimationFrame(rafId);
        rafId = null;
      }
    }
    if (immediate)
      resume();
    tryOnScopeDispose(pause);
    return {
      isActive,
      pause,
      resume
    };
  }
  function useMouse(options2 = {}) {
    const {
      type = "page",
      touch = true,
      resetOnTouchEnds = false,
      initialValue = { x: 0, y: 0 },
      window: window3 = defaultWindow,
      eventFilter
    } = options2;
    const x4 = (0, lib_exports.ref)(initialValue.x);
    const y3 = (0, lib_exports.ref)(initialValue.y);
    const sourceType = (0, lib_exports.ref)(null);
    const mouseHandler = (event) => {
      if (type === "page") {
        x4.value = event.pageX;
        y3.value = event.pageY;
      } else if (type === "client") {
        x4.value = event.clientX;
        y3.value = event.clientY;
      }
      sourceType.value = "mouse";
    };
    const reset2 = () => {
      x4.value = initialValue.x;
      y3.value = initialValue.y;
    };
    const touchHandler = (event) => {
      if (event.touches.length > 0) {
        const touch2 = event.touches[0];
        if (type === "page") {
          x4.value = touch2.pageX;
          y3.value = touch2.pageY;
        } else if (type === "client") {
          x4.value = touch2.clientX;
          y3.value = touch2.clientY;
        }
        sourceType.value = "touch";
      }
    };
    const mouseHandlerWrapper = (event) => {
      return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});
    };
    const touchHandlerWrapper = (event) => {
      return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});
    };
    if (window3) {
      useEventListener(window3, "mousemove", mouseHandlerWrapper, { passive: true });
      useEventListener(window3, "dragover", mouseHandlerWrapper, { passive: true });
      if (touch) {
        useEventListener(window3, "touchstart", touchHandlerWrapper, { passive: true });
        useEventListener(window3, "touchmove", touchHandlerWrapper, { passive: true });
        if (resetOnTouchEnds)
          useEventListener(window3, "touchend", reset2, { passive: true });
      }
    }
    return {
      x: x4,
      y: y3,
      sourceType
    };
  }
  function useMouseInElement(target, options2 = {}) {
    const {
      handleOutside = true,
      window: window3 = defaultWindow
    } = options2;
    const { x: x4, y: y3, sourceType } = useMouse(options2);
    const targetRef = (0, lib_exports.ref)(target != null ? target : window3 == null ? void 0 : window3.document.body);
    const elementX = (0, lib_exports.ref)(0);
    const elementY = (0, lib_exports.ref)(0);
    const elementPositionX = (0, lib_exports.ref)(0);
    const elementPositionY = (0, lib_exports.ref)(0);
    const elementHeight = (0, lib_exports.ref)(0);
    const elementWidth = (0, lib_exports.ref)(0);
    const isOutside = (0, lib_exports.ref)(true);
    let stop2 = () => {
    };
    if (window3) {
      stop2 = (0, lib_exports.watch)([targetRef, x4, y3], () => {
        const el = unrefElement(targetRef);
        if (!el)
          return;
        const {
          left,
          top,
          width,
          height
        } = el.getBoundingClientRect();
        elementPositionX.value = left + window3.pageXOffset;
        elementPositionY.value = top + window3.pageYOffset;
        elementHeight.value = height;
        elementWidth.value = width;
        const elX = x4.value - elementPositionX.value;
        const elY = y3.value - elementPositionY.value;
        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;
        if (handleOutside || !isOutside.value) {
          elementX.value = elX;
          elementY.value = elY;
        }
      }, { immediate: true });
    }
    return {
      x: x4,
      y: y3,
      sourceType,
      elementX,
      elementY,
      elementPositionX,
      elementPositionY,
      elementHeight,
      elementWidth,
      isOutside,
      stop: stop2
    };
  }
  function useMousePressed(options2 = {}) {
    const {
      touch = true,
      drag = true,
      initialValue = false,
      window: window3 = defaultWindow
    } = options2;
    const pressed = (0, lib_exports.ref)(initialValue);
    const sourceType = (0, lib_exports.ref)(null);
    if (!window3) {
      return {
        pressed,
        sourceType
      };
    }
    const onPressed = (srcType) => () => {
      pressed.value = true;
      sourceType.value = srcType;
    };
    const onReleased = () => {
      pressed.value = false;
      sourceType.value = null;
    };
    const target = (0, lib_exports.computed)(() => unrefElement(options2.target) || window3);
    useEventListener(target, "mousedown", onPressed("mouse"), { passive: true });
    useEventListener(window3, "mouseleave", onReleased, { passive: true });
    useEventListener(window3, "mouseup", onReleased, { passive: true });
    if (drag) {
      useEventListener(target, "dragstart", onPressed("mouse"), { passive: true });
      useEventListener(window3, "drop", onReleased, { passive: true });
      useEventListener(window3, "dragend", onReleased, { passive: true });
    }
    if (touch) {
      useEventListener(target, "touchstart", onPressed("touch"), { passive: true });
      useEventListener(window3, "touchend", onReleased, { passive: true });
      useEventListener(window3, "touchcancel", onReleased, { passive: true });
    }
    return {
      pressed,
      sourceType
    };
  }
  var SwipeDirection;
  (function(SwipeDirection2) {
    SwipeDirection2["UP"] = "UP";
    SwipeDirection2["RIGHT"] = "RIGHT";
    SwipeDirection2["DOWN"] = "DOWN";
    SwipeDirection2["LEFT"] = "LEFT";
    SwipeDirection2["NONE"] = "NONE";
  })(SwipeDirection || (SwipeDirection = {}));
  var __defProp2 = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a8, b5) => {
    for (var prop in b5 || (b5 = {}))
      if (__hasOwnProp2.call(b5, prop))
        __defNormalProp(a8, prop, b5[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b5)) {
        if (__propIsEnum.call(b5, prop))
          __defNormalProp(a8, prop, b5[prop]);
      }
    return a8;
  };
  function useTimestamp(options2 = {}) {
    const {
      controls: exposeControls = false,
      offset = 0,
      immediate = true,
      interval: interval2 = "requestAnimationFrame"
    } = options2;
    const ts = (0, lib_exports.ref)(timestamp() + offset);
    const update = () => ts.value = timestamp() + offset;
    const controls = interval2 === "requestAnimationFrame" ? useRafFn2(update, { immediate }) : useIntervalFn(update, interval2, { immediate });
    if (exposeControls) {
      return __spreadValues({
        timestamp: ts
      }, controls);
    } else {
      return ts;
    }
  }

  // .vitepress/use/cast.js
  var currentCamera = useStorage2("cast-camera", "default");
  var currentMic = useStorage2("cast-mic", "default");
  var showRecordingDialog = ref();
  var recordingName = ref("");
  var recordCamera = ref(true);
  var mimeType = useStorage2("slidev-record-mimetype", "video/webm");
  var mimeExtMap = {
    "video/webm": "webm",
    "video/webm;codecs=h264": "mp4",
    "video/x-matroska;codecs=avc1": "mkv"
  };
  function getFilename(media, mimeType2) {
    const d5 = new Date();
    const pad = (v3) => `${v3}`.padStart(2, "0");
    const date = `${pad(d5.getMonth() + 1)}${pad(d5.getDate())}-${pad(d5.getHours())}${pad(d5.getMinutes())}`;
    const ext = mimeType2 ? mimeExtMap[mimeType2] : "webm";
    return `${[date, media, recordingName.value].filter((el) => !!el).join("-")}.${ext}`;
  }
  function getSupportedMimeTypes() {
    if (MediaRecorder && typeof (MediaRecorder == null ? void 0 : MediaRecorder.isTypeSupported) === "function") {
      return Object.keys(mimeExtMap).filter((mime) => MediaRecorder.isTypeSupported(mime));
    }
    return [];
  }
  var fileNames = reactive({
    screen: computed(() => getFilename("screen", mimeType.value)),
    camera: computed(() => getFilename("camera", mimeType.value))
  });
  var {
    devices,
    videoInputs: cameras,
    audioInputs: microphones,
    ensurePermissions: ensureDevicesListPermissions
  } = useDevicesList({
    onUpdated: function() {
      var _a3, _b;
      if (currentCamera.value !== "none") {
        if (!cameras.value.find((i8) => i8.deviceId === currentCamera.value))
          currentCamera.value = ((_a3 = cameras.value[0]) == null ? void 0 : _a3.deviceId) || "default";
      }
      if (currentMic.value !== "none") {
        if (!microphones.value.find((i8) => i8.deviceId === currentMic.value))
          currentMic.value = ((_b = microphones.value[0]) == null ? void 0 : _b.deviceId) || "default";
      }
    }
  });
  function download(name2, url) {
    const a8 = document.createElement("a");
    a8.setAttribute("href", url);
    a8.setAttribute("download", name2);
    document.body.appendChild(a8);
    a8.click();
    document.body.removeChild(a8);
  }
  function useRecording() {
    const recording2 = ref(false);
    const recordingStartedAt = ref();
    const timestamp3 = useTimestamp();
    watch(recording2, (r8) => r8 ? recordingStartedAt.value = Date.now() : recordingStartedAt.value = null);
    const recordingTime = computed(() => {
      if (!recordingStartedAt.value)
        return 0;
      return timestamp3.value - recordingStartedAt.value;
    });
    const showAvatar = ref(false);
    const recorderCamera = shallowRef();
    const recorderSlides = shallowRef();
    const streamCamera = shallowRef();
    const streamCapture = shallowRef();
    const streamSlides = shallowRef();
    const config = {
      type: "video",
      bitsPerSecond: 4 * 256 * 8 * 1024,
      timeSlice: 24 * 60 * 60 * 1e3
    };
    async function toggleAvatar() {
      if (currentCamera.value === "none")
        return;
      if (showAvatar.value) {
        showAvatar.value = false;
        if (!recording2.value)
          closeStream(streamCamera);
      } else {
        await startCameraStream();
        if (streamCamera.value)
          showAvatar.value = !!streamCamera.value;
      }
    }
    async function startCameraStream() {
      await ensureDevicesListPermissions();
      await nextTick();
      if (!streamCamera.value) {
        if (currentCamera.value === "none" && currentMic.value === "none")
          return;
        streamCamera.value = await navigator.mediaDevices.getUserMedia({
          video: currentCamera.value === "none" || recordCamera.value !== true ? false : {
            deviceId: currentCamera.value
          },
          audio: currentMic.value === "none" ? false : {
            deviceId: currentMic.value
          }
        });
      }
    }
    watch(currentCamera, async (v3) => {
      if (v3 === "none") {
        closeStream(streamCamera);
      } else {
        if (recording2.value)
          return;
        if (streamCamera.value) {
          closeStream(streamCamera);
          await startCameraStream();
        }
      }
    });
    async function startRecording(customConfig) {
      var _a3;
      await ensureDevicesListPermissions();
      const { default: Recorder2 } = await Promise.resolve().then(() => __toESM(require_RecordRTC()));
      await startCameraStream();
      streamCapture.value = await navigator.mediaDevices.getDisplayMedia({
        video: {
          frameRate: 30,
          width: 3840,
          height: 2160,
          cursor: "motion",
          resizeMode: "crop-and-scale"
        }
      });
      streamCapture.value.addEventListener("inactive", stopRecording);
      streamSlides.value = new MediaStream();
      streamCapture.value.getVideoTracks().forEach((videoTrack) => streamSlides.value.addTrack(videoTrack));
      Object.assign(config, customConfig);
      if (streamCamera.value) {
        streamSlides.value.addTrack((_a3 = master.stream.stream.getAudioTracks()) == null ? void 0 : _a3[0]);
        recorderCamera.value = new Recorder2(streamCamera.value, config);
        recorderCamera.value.startRecording();
      }
      recorderSlides.value = new Recorder2(streamSlides.value, config);
      recorderSlides.value.startRecording();
      recording2.value = true;
    }
    async function stopRecording() {
      var _a3, _b;
      recording2.value = false;
      (_a3 = recorderCamera.value) == null ? void 0 : _a3.stopRecording(() => {
        if (recordCamera.value) {
          const blob = recorderCamera.value.getBlob();
          const url = URL.createObjectURL(blob);
          download(getFilename("camera", config.mimeType), url);
          window.URL.revokeObjectURL(url);
        }
        recorderCamera.value = void 0;
        if (!showAvatar.value)
          closeStream(streamCamera);
      });
      (_b = recorderSlides.value) == null ? void 0 : _b.stopRecording(() => {
        const blob = recorderSlides.value.getBlob();
        const url = URL.createObjectURL(blob);
        download(getFilename("screen", config.mimeType), url);
        window.URL.revokeObjectURL(url);
        closeStream(streamCapture);
        closeStream(streamSlides);
        recorderSlides.value = void 0;
      });
    }
    function closeStream(stream) {
      const s4 = stream.value;
      if (!s4)
        return;
      s4.getTracks().forEach((i8) => {
        i8.stop();
        s4.removeTrack(i8);
      });
      stream.value = void 0;
    }
    function toggleRecording() {
      if (recording2.value)
        stopRecording();
      else
        startRecording();
    }
    useEventListener("beforeunload", (event) => {
      if (!recording2.value)
        return;
      if (confirm("Recording is not saved yet, do you want to leave?"))
        return;
      event.preventDefault();
      event.returnValue = "";
    });
    return {
      recording: recording2,
      recordingTime,
      showAvatar,
      toggleRecording,
      startRecording,
      stopRecording,
      toggleAvatar,
      recorderCamera,
      recorderSlides,
      streamCamera,
      streamCapture,
      streamSlides
    };
  }
  var cast = useRecording();

  // .vitepress/use/recorder.js
  var recorder;
  var recording = ref(false);
  var toggled = useLastChanged(recording);
  var timestamp2 = useTimestamp();
  var duration = computed(() => timestamp2.value - toggled.value);
  var record = {
    start() {
      if (!recorder)
        useRecorder();
      recorder.start();
      recording.value = true;
    },
    async stop() {
      const date = new Date();
      recording.value = false;
      const rec = await recorder.stop();
      const url = URL.createObjectURL(rec);
      const anchor = document.createElement("a");
      anchor.download = getFilename("rec");
      anchor.href = url;
      anchor.click();
    }
  };
  function useRecorder() {
    if (!recorder) {
      recorder = new Recorder();
    }
    return { recorder, record, recording, toggled, duration };
  }

  // .vitepress/use/audio.js
  var audio = reactive({
    initiated: false,
    mute: useStorage("mute", false),
    volume: useClamp(useStorage("main-vol", 1), 0, 2),
    meter: 0
  });
  var master = shallowReactive({});
  var channels = shallowReactive({});
  function useAudio() {
    if (!audio.initiated) {
      start();
      const { recorder: recorder2 } = useRecorder();
      master.stream = context.createMediaStreamDestination();
      master.meter = new Meter().toDestination();
      master.meter.normalRange = true;
      master.meter.connect(master.stream);
      master.meter.connect(recorder2);
      useRafFn(() => {
        audio.meter = master.meter.getValue();
      });
      master.limiter = new Limiter(-18).connect(master.meter);
      master.reverb = new Reverb({
        decay: 1,
        wet: 0.5
      }).connect(master.meter);
      master.limiter.connect(master.reverb);
      watchEffect(() => {
        getDestination().mute = audio.mute;
      });
      watchEffect(() => {
        getDestination().volume.targetRampTo(gainToDb(audio.volume), 0.1);
      });
      audio.initiated = true;
    }
    return { audio, master, channels };
  }
  function createChannel(title = (Math.random() * 1e3).toFixed(0), options2) {
    const { master: master2 } = useAudio();
    const channel = new Limiter(options2).connect(master2.limiter);
    channels[title] = channel;
    return { channel };
  }
  function initGetUserMedia() {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!window.AudioContext) {
      return alert("AudioContext not supported");
    }
    if (navigator.mediaDevices === void 0) {
      navigator.mediaDevices = {};
    }
    if (navigator.mediaDevices.getUserMedia === void 0) {
      navigator.mediaDevices.getUserMedia = function(constraints) {
        const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        if (!getUserMedia) {
          alert("getUserMedia is not implemented in this browser");
        }
        return new Promise(function(resolve2, reject) {
          getUserMedia.call(navigator, constraints, resolve2, reject);
        });
      };
    }
  }

  // .vitepress/use/calculations.js
  var midiA = 69;
  function pitchNoteOctave(pitch) {
    return {
      note: pitch > 0 ? pitch % 12 : 12 + pitch % 12,
      octave: Math.floor(pitch / 12) + 4
    };
  }
  function pitchFreq(pitch = 0, octave2 = 3, middleA = 440, tuning = "equal") {
    let hz = 0;
    const justCents = [0, 112, 204, 316, 386, 498, 590, 702, 814, 884, 1017, 1088];
    if (tuning == "equal") {
      hz = Number(middleA * Math.pow(2, octave2 - 3 + pitch / 12));
    }
    if (tuning == "just") {
      let diff = Number(Math.pow(Math.pow(2, 1 / 1200), justCents[pitch]));
      hz = Number(middleA * Math.pow(2, octave2 - 4) * diff);
    }
    return hz;
  }
  function pitchColor(pitch = 0, octave2, velocity = 1, alpha = 1) {
    octave2 = octave2 || Math.floor(pitch / 12) + 4;
    return `hsla(${pitch % 12 * 30},${velocity * 100}%,${Math.abs(octave2 + 2) * 8}%,${alpha})`;
  }
  function freqColor(freq2) {
    return pitchColor(freqPitch(freq2));
  }
  function freqPitch(freq2, middleA = 440) {
    return 12 * (Math.log(freq2 / middleA) / Math.log(2));
  }
  function isInChroma(chroma3, tonic, note3) {
    return chroma3.split("")[(24 + note3 - tonic) % 12] == "1";
  }
  function getCircleCoord(n8 = 0, total = 12, radius = 35, width = 100) {
    let angle = (n8 - total / 4) / (total / 2) * Math.PI;
    let x4 = radius * Math.cos(angle) + width / 2;
    let y3 = radius * Math.sin(angle) + width / 2;
    return { x: x4, y: y3 };
  }
  function rotateArray(arr, count = 1) {
    return [...arr.slice(count, arr.length), ...arr.slice(0, count)];
  }
  function clampNum(main, delta, min = 0, max = 100) {
    return Math.max(min, Math.min(Number(main) + Number(delta), max));
  }
  function getCents(frequency, pitch) {
    return Math.floor(1200 * Math.log(frequency / getStandardFrequency(pitch)) / Math.log(2));
  }
  function getStandardFrequency(pitch, middleA = 440) {
    return middleA * Math.pow(2, (pitch - 69) / 12);
  }

  // node_modules/.pnpm/webmidi@3.0.21/node_modules/webmidi/dist/esm/webmidi.esm.min.js
  var e = class {
    constructor(e8 = false) {
      this.eventMap = {}, this.eventsSuspended = e8 == 1;
    }
    addListener(n8, s4, r8 = {}) {
      if (typeof n8 == "string" && n8.length < 1 || n8 instanceof String && n8.length < 1 || typeof n8 != "string" && !(n8 instanceof String) && n8 !== e.ANY_EVENT)
        throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
      if (typeof s4 != "function")
        throw new TypeError("The callback must be a function.");
      const a8 = new t(n8, this, s4, r8);
      return this.eventMap[n8] || (this.eventMap[n8] = []), r8.prepend ? this.eventMap[n8].unshift(a8) : this.eventMap[n8].push(a8), a8;
    }
    addOneTimeListener(e8, t8, n8 = {}) {
      n8.remaining = 1, this.addListener(e8, t8, n8);
    }
    static get ANY_EVENT() {
      return Symbol.for("Any event");
    }
    hasListener(n8, s4) {
      if (n8 === void 0)
        return !!(this.eventMap[e.ANY_EVENT] && this.eventMap[e.ANY_EVENT].length > 0) || Object.entries(this.eventMap).some(([, e8]) => e8.length > 0);
      if (this.eventMap[n8] && this.eventMap[n8].length > 0) {
        if (s4 instanceof t) {
          return this.eventMap[n8].filter((e8) => e8 === s4).length > 0;
        }
        if (typeof s4 == "function") {
          return this.eventMap[n8].filter((e8) => e8.callback === s4).length > 0;
        }
        return s4 == null;
      }
      return false;
    }
    get eventNames() {
      return Object.keys(this.eventMap);
    }
    getListeners(e8) {
      return this.eventMap[e8] || [];
    }
    suspendEvent(e8) {
      this.getListeners(e8).forEach((e9) => {
        e9.suspended = true;
      });
    }
    unsuspendEvent(e8) {
      this.getListeners(e8).forEach((e9) => {
        e9.suspended = false;
      });
    }
    getListenerCount(e8) {
      return this.getListeners(e8).length;
    }
    emit(t8, ...n8) {
      if (typeof t8 != "string" && !(t8 instanceof String))
        throw new TypeError("The 'event' parameter must be a string.");
      if (this.eventsSuspended)
        return;
      let s4 = [], r8 = this.eventMap[e.ANY_EVENT] || [];
      return this.eventMap[t8] && (r8 = r8.concat(this.eventMap[t8])), r8.forEach((e8) => {
        if (e8.suspended)
          return;
        let t9 = [...n8];
        Array.isArray(e8.arguments) && (t9 = t9.concat(e8.arguments)), e8.remaining > 0 && (s4.push(e8.callback.apply(e8.context, t9)), e8.count++), --e8.remaining < 1 && e8.remove();
      }), s4;
    }
    removeListener(e8, t8, n8 = {}) {
      if (e8 === void 0)
        return void (this.eventMap = {});
      if (!this.eventMap[e8])
        return;
      let s4 = this.eventMap[e8].filter((e9) => t8 && e9.callback !== t8 || n8.remaining && n8.remaining !== e9.remaining || n8.context && n8.context !== e9.context);
      s4.length ? this.eventMap[e8] = s4 : delete this.eventMap[e8];
    }
    async waitFor(e8, t8 = {}) {
      return t8.duration = parseInt(t8.duration), (isNaN(t8.duration) || t8.duration <= 0) && (t8.duration = 1 / 0), new Promise((n8, s4) => {
        let r8, a8 = this.addListener(e8, () => {
          clearTimeout(r8), n8();
        }, { remaining: 1 });
        t8.duration !== 1 / 0 && (r8 = setTimeout(() => {
          a8.remove(), s4("The duration expired before the event was emitted.");
        }, t8.duration));
      });
    }
    get eventCount() {
      return Object.keys(this.eventMap).length;
    }
  };
  var t = class {
    constructor(t8, n8, s4, r8 = {}) {
      if (typeof t8 != "string" && !(t8 instanceof String) && t8 !== e.ANY_EVENT)
        throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
      if (!n8)
        throw new ReferenceError("The 'target' parameter is mandatory.");
      if (typeof s4 != "function")
        throw new TypeError("The 'callback' must be a function.");
      r8.arguments === void 0 || Array.isArray(r8.arguments) || (r8.arguments = [r8.arguments]), (r8 = Object.assign({ context: n8, remaining: 1 / 0, arguments: void 0, duration: 1 / 0 }, r8)).duration !== 1 / 0 && setTimeout(() => this.remove(), r8.duration), this.arguments = r8.arguments, this.callback = s4, this.context = r8.context, this.count = 0, this.event = t8, this.remaining = parseInt(r8.remaining) >= 1 ? parseInt(r8.remaining) : 1 / 0, this.suspended = false, this.target = n8;
    }
    remove() {
      this.target.removeListener(this.event, this.callback, { context: this.context, remaining: this.remaining });
    }
  };
  var n = class {
    static get MIDI_CHANNEL_MESSAGES() {
      return { noteoff: 8, noteon: 9, keyaftertouch: 10, controlchange: 11, programchange: 12, channelaftertouch: 13, pitchbend: 14 };
    }
    static get MIDI_CHANNEL_NUMBERS() {
      return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
    }
    static get MIDI_CHANNEL_MODE_MESSAGES() {
      return { allsoundoff: 120, resetallcontrollers: 121, localcontrol: 122, allnotesoff: 123, omnimodeoff: 124, omnimodeon: 125, monomodeon: 126, polymodeon: 127 };
    }
    static get MIDI_CONTROL_CHANGE_MESSAGES() {
      return { bankselectcoarse: 0, modulationwheelcoarse: 1, breathcontrollercoarse: 2, controller3: 3, footcontrollercoarse: 4, portamentotimecoarse: 5, dataentrycoarse: 6, volumecoarse: 7, balancecoarse: 8, controller9: 9, pancoarse: 10, expressioncoarse: 11, effectcontrol1coarse: 12, effectcontrol2coarse: 13, controller14: 14, controller15: 15, generalpurposeslider1: 16, generalpurposeslider2: 17, generalpurposeslider3: 18, generalpurposeslider4: 19, controller20: 20, controller21: 21, controller22: 22, controller23: 23, controller24: 24, controller25: 25, controller26: 26, controller27: 27, controller28: 28, controller29: 29, controller30: 30, controller31: 31, bankselectfine: 32, modulationwheelfine: 33, breathcontrollerfine: 34, controller35: 35, footcontrollerfine: 36, portamentotimefine: 37, dataentryfine: 38, volumefine: 39, balancefine: 40, controller41: 41, panfine: 42, expressionfine: 43, effectcontrol1fine: 44, effectcontrol2fine: 45, controller46: 46, controller47: 47, controller48: 48, controller49: 49, controller50: 50, controller51: 51, controller52: 52, controller53: 53, controller54: 54, controller55: 55, controller56: 56, controller57: 57, controller58: 58, controller59: 59, controller60: 60, controller61: 61, controller62: 62, controller63: 63, holdpedal: 64, portamento: 65, sustenutopedal: 66, softpedal: 67, legatopedal: 68, hold2pedal: 69, soundvariation: 70, resonance: 71, soundreleasetime: 72, soundattacktime: 73, brightness: 74, soundcontrol6: 75, soundcontrol7: 76, soundcontrol8: 77, soundcontrol9: 78, soundcontrol10: 79, generalpurposebutton1: 80, generalpurposebutton2: 81, generalpurposebutton3: 82, generalpurposebutton4: 83, controller84: 84, controller85: 85, controller86: 86, controller87: 87, controller88: 88, controller89: 89, controller90: 90, reverblevel: 91, tremololevel: 92, choruslevel: 93, celestelevel: 94, phaserlevel: 95, databuttonincrement: 96, databuttondecrement: 97, nonregisteredparametercoarse: 98, nonregisteredparameterfine: 99, registeredparametercoarse: 100, registeredparameterfine: 101, controller102: 102, controller103: 103, controller104: 104, controller105: 105, controller106: 106, controller107: 107, controller108: 108, controller109: 109, controller110: 110, controller111: 111, controller112: 112, controller113: 113, controller114: 114, controller115: 115, controller116: 116, controller117: 117, controller118: 118, controller119: 119, allsoundoff: 120, resetallcontrollers: 121, localcontrol: 122, allnotesoff: 123, omnimodeoff: 124, omnimodeon: 125, monomodeon: 126, polymodeon: 127 };
    }
    static get MIDI_REGISTERED_PARAMETERS() {
      return { pitchbendrange: [0, 0], channelfinetuning: [0, 1], channelcoarsetuning: [0, 2], tuningprogram: [0, 3], tuningbank: [0, 4], modulationrange: [0, 5], azimuthangle: [61, 0], elevationangle: [61, 1], gain: [61, 2], distanceratio: [61, 3], maximumdistance: [61, 4], maximumdistancegain: [61, 5], referencedistanceratio: [61, 6], panspreadangle: [61, 7], rollangle: [61, 8] };
    }
    static get MIDI_SYSTEM_MESSAGES() {
      return { sysex: 240, timecode: 241, songposition: 242, songselect: 243, tunerequest: 246, tuningrequest: 246, sysexend: 247, clock: 248, start: 250, continue: 251, stop: 252, activesensing: 254, reset: 255, midimessage: 0, unknownsystemmessage: -1 };
    }
    static get CHANNEL_EVENTS() {
      return ["noteoff", "controlchange", "noteon", "keyaftertouch", "programchange", "channelaftertouch", "pitchbend", "allnotesoff", "allsoundoff", "localcontrol", "monomode", "omnimode", "resetallcontrollers", "nrpn", "nrpn-dataentrycoarse", "nrpn-dataentryfine", "nrpn-databuttonincrement", "nrpn-databuttondecrement", "rpn", "rpn-dataentrycoarse", "rpn-dataentryfine", "rpn-databuttonincrement", "rpn-databuttondecrement"];
    }
  };
  var s = class {
    constructor(e8, t8 = {}) {
      this.duration = d.defaults.note.duration, this.attack = d.defaults.note.attack, this.release = d.defaults.note.release, t8.duration != null && (this.duration = t8.duration), t8.attack != null && (this.attack = t8.attack), t8.rawAttack != null && (this.attack = r.from7bitToFloat(t8.rawAttack)), t8.release != null && (this.release = t8.release), t8.rawRelease != null && (this.release = r.from7bitToFloat(t8.rawRelease)), Number.isInteger(e8) ? this.identifier = r.toNoteIdentifier(e8) : this.identifier = e8;
    }
    get identifier() {
      return this._name + (this._accidental || "") + this._octave;
    }
    set identifier(e8) {
      const t8 = r.getNoteDetails(e8);
      if (d.validation && !e8)
        throw new Error("Invalid note identifier");
      this._name = t8.name, this._accidental = t8.accidental, this._octave = t8.octave;
    }
    get name() {
      return this._name;
    }
    set name(e8) {
      if (d.validation && (e8 = e8.toUpperCase(), !["C", "D", "E", "F", "G", "A", "B"].includes(e8)))
        throw new Error("Invalid name value");
      this._name = e8;
    }
    get accidental() {
      return this._accidental;
    }
    set accidental(e8) {
      if (d.validation && (e8 = e8.toLowerCase(), !["#", "##", "b", "bb"].includes(e8)))
        throw new Error("Invalid accidental value");
      this._accidental = e8;
    }
    get octave() {
      return this._octave;
    }
    set octave(e8) {
      if (d.validation && (e8 = parseInt(e8), isNaN(e8)))
        throw new Error("Invalid octave value");
      this._octave = e8;
    }
    get duration() {
      return this._duration;
    }
    set duration(e8) {
      if (d.validation && (e8 = parseFloat(e8), isNaN(e8) || e8 === null || e8 < 0))
        throw new RangeError("Invalid duration value.");
      this._duration = e8;
    }
    get attack() {
      return this._attack;
    }
    set attack(e8) {
      if (d.validation && (e8 = parseFloat(e8), isNaN(e8) || !(e8 >= 0 && e8 <= 1)))
        throw new RangeError("Invalid attack value.");
      this._attack = e8;
    }
    get release() {
      return this._release;
    }
    set release(e8) {
      if (d.validation && (e8 = parseFloat(e8), isNaN(e8) || !(e8 >= 0 && e8 <= 1)))
        throw new RangeError("Invalid release value.");
      this._release = e8;
    }
    get rawAttack() {
      return r.fromFloatTo7Bit(this._attack);
    }
    set rawAttack(e8) {
      this._attack = r.from7bitToFloat(e8);
    }
    get rawRelease() {
      return r.fromFloatTo7Bit(this._release);
    }
    set rawRelease(e8) {
      this._release = r.from7bitToFloat(e8);
    }
    get number() {
      return r.toNoteNumber(this.identifier);
    }
    getOffsetNumber(e8 = 0, t8 = 0) {
      return d.validation && (e8 = parseInt(e8) || 0, t8 = parseInt(t8) || 0), Math.min(Math.max(this.number + 12 * e8 + t8, 0), 127);
    }
  };
  var r = class {
    static toNoteNumber(e8, t8 = 0) {
      if (t8 = t8 == null ? 0 : parseInt(t8), isNaN(t8))
        throw new RangeError("Invalid 'octaveOffset' value");
      typeof e8 != "string" && (e8 = "");
      const n8 = this.getNoteDetails(e8);
      if (!n8)
        throw new TypeError("Invalid note identifier");
      let s4 = 12 * (n8.octave + 1 + t8);
      if (s4 += { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 }[n8.name], n8.accidental && (n8.accidental.startsWith("b") ? s4 -= n8.accidental.length : s4 += n8.accidental.length), s4 < 0 || s4 > 127)
        throw new RangeError("Invalid octaveOffset value");
      return s4;
    }
    static getNoteDetails(e8) {
      Number.isInteger(e8) && (e8 = this.toNoteIdentifier(e8));
      const t8 = e8.match(/^([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)$/i);
      if (!t8)
        throw new TypeError("Invalid note identifier");
      const n8 = t8[1].toUpperCase(), s4 = parseInt(t8[3]);
      let r8 = t8[2].toLowerCase();
      return r8 = r8 === "" ? void 0 : r8, { accidental: r8, identifier: n8 + (r8 || "") + s4, name: n8, octave: s4 };
    }
    static sanitizeChannels(e8) {
      let t8;
      if (this.validation) {
        if (e8 === "all")
          t8 = ["all"];
        else if (e8 === "none")
          return [];
      }
      return t8 = Array.isArray(e8) ? e8 : [e8], t8.indexOf("all") > -1 && (t8 = n.MIDI_CHANNEL_NUMBERS), t8.map(function(e9) {
        return parseInt(e9);
      }).filter(function(e9) {
        return e9 >= 1 && e9 <= 16;
      });
    }
    static toTimestamp(e8) {
      let t8 = false;
      const n8 = parseFloat(e8);
      return !isNaN(n8) && (typeof e8 == "string" && e8.substring(0, 1) === "+" ? n8 >= 0 && (t8 = d.time + n8) : n8 >= 0 && (t8 = n8), t8);
    }
    static guessNoteNumber(e8, t8) {
      t8 = parseInt(t8) || 0;
      let n8 = false;
      if (Number.isInteger(e8) && e8 >= 0 && e8 <= 127)
        n8 = parseInt(e8);
      else if (parseInt(e8) >= 0 && parseInt(e8) <= 127)
        n8 = parseInt(e8);
      else if (typeof e8 == "string" || e8 instanceof String)
        try {
          n8 = this.toNoteNumber(e8.trim(), t8);
        } catch (e9) {
          return false;
        }
      return n8;
    }
    static toNoteIdentifier(e8, t8) {
      if (e8 = parseInt(e8), isNaN(e8) || e8 < 0 || e8 > 127)
        throw new RangeError("Invalid note number");
      if (t8 = t8 == null ? 0 : parseInt(t8), isNaN(t8))
        throw new RangeError("Invalid octaveOffset value");
      const n8 = Math.floor(e8 / 12 - 1) + t8;
      return ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"][e8 % 12] + n8.toString();
    }
    static buildNote(e8, t8 = {}) {
      if (t8.octaveOffset = parseInt(t8.octaveOffset) || 0, e8 instanceof s)
        return e8;
      let n8 = this.guessNoteNumber(e8, t8.octaveOffset);
      if (n8 === false)
        throw new TypeError(`The input could not be parsed as a note (${e8})`);
      return t8.octaveOffset = void 0, new s(n8, t8);
    }
    static buildNoteArray(e8, t8 = {}) {
      let n8 = [];
      return Array.isArray(e8) || (e8 = [e8]), e8.forEach((e9) => {
        n8.push(this.buildNote(e9, t8));
      }), n8;
    }
    static from7bitToFloat(e8) {
      return e8 === 1 / 0 && (e8 = 127), e8 = parseInt(e8) || 0, Math.min(Math.max(e8 / 127, 0), 1);
    }
    static fromFloatTo7Bit(e8) {
      return e8 === 1 / 0 && (e8 = 1), e8 = parseFloat(e8) || 0, Math.min(Math.max(Math.round(127 * e8), 0), 127);
    }
    static fromMsbLsbToFloat(e8, t8 = 0) {
      d.validation && (e8 = Math.min(Math.max(parseInt(e8) || 0, 0), 127), t8 = Math.min(Math.max(parseInt(t8) || 0, 0), 127));
      const n8 = ((e8 << 7) + t8) / 16383;
      return Math.min(Math.max(n8, 0), 1);
    }
    static fromFloatToMsbLsb(e8) {
      d.validation && (e8 = Math.min(Math.max(parseFloat(e8) || 0, 0), 1));
      const t8 = Math.round(16383 * e8);
      return { msb: t8 >> 7, lsb: 127 & t8 };
    }
    static offsetNumber(e8, t8 = 0, n8 = 0) {
      if (d.validation) {
        if (e8 = parseInt(e8), isNaN(e8))
          throw new Error("Invalid note number");
        t8 = parseInt(t8) || 0, n8 = parseInt(n8) || 0;
      }
      return Math.min(Math.max(e8 + 12 * t8 + n8, 0), 127);
    }
    static getPropertyByValue(e8, t8) {
      return Object.keys(e8).find((n8) => e8[n8] === t8);
    }
    static getCcNameByNumber(e8) {
      return r.getPropertyByValue(n.MIDI_CONTROL_CHANGE_MESSAGES, e8);
    }
    static getChannelModeByNumber(e8) {
      if (!(e8 >= 120 && e8 <= 127))
        return false;
      for (let t8 in n.MIDI_CHANNEL_MODE_MESSAGES)
        if (n.MIDI_CHANNEL_MODE_MESSAGES.hasOwnProperty(t8) && e8 === n.MIDI_CHANNEL_MODE_MESSAGES[t8])
          return t8;
      return false;
    }
    static get isNode() {
      return typeof process != "undefined" && process.versions != null && process.versions.node != null;
    }
    static get isBrowser() {
      return typeof window != "undefined" && window.document !== void 0;
    }
  };
  var a = class extends e {
    constructor(e8, t8) {
      super(), this._output = e8, this._number = t8, this._octaveOffset = 0;
    }
    destroy() {
      this._output = null, this._number = null, this._octaveOffset = 0, this.removeListener();
    }
    send(e8, t8 = { time: 0 }) {
      return this.output.send(e8, t8), this;
    }
    sendKeyAftertouch(e8, t8, s4 = {}) {
      if (d.validation) {
        if (s4.useRawValue && (s4.rawValue = s4.useRawValue), isNaN(parseFloat(t8)))
          throw new RangeError("Invalid key aftertouch value.");
        if (s4.rawValue) {
          if (!(t8 >= 0 && t8 <= 127 && Number.isInteger(t8)))
            throw new RangeError("Key aftertouch raw value must be an integer between 0 and 127.");
        } else if (!(t8 >= 0 && t8 <= 1))
          throw new RangeError("Key aftertouch value must be a float between 0 and 1.");
      }
      s4.rawValue || (t8 = r.fromFloatTo7Bit(t8));
      const a8 = d.octaveOffset + this.output.octaveOffset + this.octaveOffset;
      return Array.isArray(e8) || (e8 = [e8]), r.buildNoteArray(e8).forEach((e9) => {
        this.send([(n.MIDI_CHANNEL_MESSAGES.keyaftertouch << 4) + (this.number - 1), e9.getOffsetNumber(a8), t8], { time: r.toTimestamp(s4.time) });
      }), this;
    }
    sendControlChange(e8, t8, s4 = {}) {
      if (typeof e8 == "string" && (e8 = n.MIDI_CONTROL_CHANGE_MESSAGES[e8]), Array.isArray(t8) || (t8 = [t8]), d.validation) {
        if (e8 === void 0)
          throw new TypeError("Control change must be identified with a valid name or an integer between 0 and 127.");
        if (!Number.isInteger(e8) || !(e8 >= 0 && e8 <= 127))
          throw new TypeError("Control change number must be an integer between 0 and 127.");
        if ((t8 = t8.map((e9) => {
          const t9 = Math.min(Math.max(parseInt(e9), 0), 127);
          if (isNaN(t9))
            throw new TypeError("Values must be integers between 0 and 127");
          return t9;
        })).length === 2 && e8 >= 32)
          throw new TypeError("To use a value array, the controller must be between 0 and 31");
      }
      return t8.forEach((a8, i8) => {
        this.send([(n.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), e8 + 32 * i8, t8[i8]], { time: r.toTimestamp(s4.time) });
      }), this;
    }
    _selectNonRegisteredParameter(e8, t8 = {}) {
      return this.sendControlChange(99, e8[0], t8), this.sendControlChange(98, e8[1], t8), this;
    }
    _deselectRegisteredParameter(e8 = {}) {
      return this.sendControlChange(101, 127, e8), this.sendControlChange(100, 127, e8), this;
    }
    _deselectNonRegisteredParameter(e8 = {}) {
      return this.sendControlChange(101, 127, e8), this.sendControlChange(100, 127, e8), this;
    }
    _selectRegisteredParameter(e8, t8 = {}) {
      return this.sendControlChange(101, e8[0], t8), this.sendControlChange(100, e8[1], t8), this;
    }
    _setCurrentParameter(e8, t8 = {}) {
      return e8 = [].concat(e8), this.sendControlChange(6, e8[0], t8), e8.length < 2 || this.sendControlChange(38, e8[1], t8), this;
    }
    sendRpnDecrement(e8, t8 = {}) {
      if (Array.isArray(e8) || (e8 = n.MIDI_REGISTERED_PARAMETERS[e8]), d.validation) {
        if (e8 === void 0)
          throw new TypeError("The specified registered parameter is invalid.");
        let t9 = false;
        if (Object.getOwnPropertyNames(n.MIDI_REGISTERED_PARAMETERS).forEach((s4) => {
          n.MIDI_REGISTERED_PARAMETERS[s4][0] === e8[0] && n.MIDI_REGISTERED_PARAMETERS[s4][1] === e8[1] && (t9 = true);
        }), !t9)
          throw new TypeError("The specified registered parameter is invalid.");
      }
      return this._selectRegisteredParameter(e8, t8), this.sendControlChange(97, 0, t8), this._deselectRegisteredParameter(t8), this;
    }
    sendRpnIncrement(e8, t8 = {}) {
      if (Array.isArray(e8) || (e8 = n.MIDI_REGISTERED_PARAMETERS[e8]), d.validation) {
        if (e8 === void 0)
          throw new TypeError("The specified registered parameter is invalid.");
        let t9 = false;
        if (Object.getOwnPropertyNames(n.MIDI_REGISTERED_PARAMETERS).forEach((s4) => {
          n.MIDI_REGISTERED_PARAMETERS[s4][0] === e8[0] && n.MIDI_REGISTERED_PARAMETERS[s4][1] === e8[1] && (t9 = true);
        }), !t9)
          throw new TypeError("The specified registered parameter is invalid.");
      }
      return this._selectRegisteredParameter(e8, t8), this.sendControlChange(96, 0, t8), this._deselectRegisteredParameter(t8), this;
    }
    playNote(e8, t8 = {}) {
      if (this.sendNoteOn(e8, t8), t8.duration > 0 && isFinite(String(t8.duration).trim() || NaN)) {
        let n8 = { time: (r.toTimestamp(t8.time) || d.time) + t8.duration, release: t8.release, rawRelease: t8.rawRelease };
        this.sendNoteOff(e8, n8);
      }
      return this;
    }
    sendNoteOff(e8, t8 = {}) {
      if (d.validation) {
        if (t8.rawRelease != null && !(t8.rawRelease >= 0 && t8.rawRelease <= 127))
          throw new RangeError("The 'rawRelease' option must be an integer between 0 and 127");
        if (t8.release != null && !(t8.release >= 0 && t8.release <= 1))
          throw new RangeError("The 'release' option must be an number between 0 and 1");
        t8.rawVelocity && (t8.rawRelease = t8.velocity, console.warn("The 'rawVelocity' option is deprecated. Use 'rawRelease' instead.")), t8.velocity && (t8.release = t8.velocity, console.warn("The 'velocity' option is deprecated. Use 'attack' instead."));
      }
      let s4 = 64;
      t8.rawRelease != null ? s4 = t8.rawRelease : isNaN(t8.release) || (s4 = Math.round(127 * t8.release));
      const a8 = d.octaveOffset + this.output.octaveOffset + this.octaveOffset;
      return r.buildNoteArray(e8, { rawRelease: parseInt(s4) }).forEach((e9) => {
        this.send([(n.MIDI_CHANNEL_MESSAGES.noteoff << 4) + (this.number - 1), e9.getOffsetNumber(a8), e9.rawRelease], { time: r.toTimestamp(t8.time) });
      }), this;
    }
    stopNote(e8, t8 = {}) {
      return this.sendNoteOff(e8, t8);
    }
    sendNoteOn(e8, t8 = {}) {
      if (d.validation) {
        if (t8.rawAttack != null && !(t8.rawAttack >= 0 && t8.rawAttack <= 127))
          throw new RangeError("The 'rawAttack' option must be an integer between 0 and 127");
        if (t8.attack != null && !(t8.attack >= 0 && t8.attack <= 1))
          throw new RangeError("The 'attack' option must be an number between 0 and 1");
        t8.rawVelocity && (t8.rawAttack = t8.velocity, t8.rawRelease = t8.release, console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' or 'rawRelease'.")), t8.velocity && (t8.attack = t8.velocity, console.warn("The 'velocity' option is deprecated. Use 'attack' instead."));
      }
      let s4 = 64;
      t8.rawAttack != null ? s4 = t8.rawAttack : isNaN(t8.attack) || (s4 = Math.round(127 * t8.attack));
      const a8 = d.octaveOffset + this.output.octaveOffset + this.octaveOffset;
      return r.buildNoteArray(e8, { rawAttack: s4 }).forEach((e9) => {
        this.send([(n.MIDI_CHANNEL_MESSAGES.noteon << 4) + (this.number - 1), e9.getOffsetNumber(a8), e9.rawAttack], { time: r.toTimestamp(t8.time) });
      }), this;
    }
    sendChannelMode(e8, t8 = 0, s4 = {}) {
      if (typeof e8 == "string" && (e8 = n.MIDI_CHANNEL_MODE_MESSAGES[e8]), d.validation) {
        if (e8 === void 0)
          throw new TypeError("Invalid channel mode message name or number.");
        if (isNaN(e8) || !(e8 >= 120 && e8 <= 127))
          throw new TypeError("Invalid channel mode message number.");
        if (isNaN(parseInt(t8)) || t8 < 0 || t8 > 127)
          throw new RangeError("Value must be an integer between 0 and 127.");
      }
      return this.send([(n.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), e8, t8], { time: r.toTimestamp(s4.time) }), this;
    }
    sendOmniMode(e8, t8 = {}) {
      return e8 === void 0 || e8 ? this.sendChannelMode("omnimodeon", 0, t8) : this.sendChannelMode("omnimodeoff", 0, t8), this;
    }
    sendChannelAftertouch(e8, t8 = {}) {
      if (d.validation) {
        if (isNaN(parseFloat(e8)))
          throw new RangeError("Invalid channel aftertouch value.");
        if (t8.rawValue) {
          if (!(e8 >= 0 && e8 <= 127 && Number.isInteger(e8)))
            throw new RangeError("Channel aftertouch raw value must be an integer between 0 and 127.");
        } else if (!(e8 >= 0 && e8 <= 1))
          throw new RangeError("Channel aftertouch value must be a float between 0 and 1.");
      }
      return this.send([(n.MIDI_CHANNEL_MESSAGES.channelaftertouch << 4) + (this.number - 1), Math.round(127 * e8)], { time: r.toTimestamp(t8.time) }), this;
    }
    sendMasterTuning(e8, t8 = {}) {
      if (e8 = parseFloat(e8) || 0, d.validation && !(e8 > -65 && e8 < 64))
        throw new RangeError("The value must be a decimal number larger than -65 and smaller than 64.");
      let n8 = Math.floor(e8) + 64, s4 = e8 - Math.floor(e8);
      s4 = Math.round((s4 + 1) / 2 * 16383);
      let r8 = s4 >> 7 & 127, a8 = 127 & s4;
      return this.sendRpnValue("channelcoarsetuning", n8, t8), this.sendRpnValue("channelfinetuning", [r8, a8], t8), this;
    }
    sendModulationRange(e8, t8, n8 = {}) {
      if (d.validation) {
        if (!Number.isInteger(e8) || !(e8 >= 0 && e8 <= 127))
          throw new RangeError("The semitones value must be an integer between 0 and 127.");
        if (!(t8 == null || Number.isInteger(t8) && t8 >= 0 && t8 <= 127))
          throw new RangeError("If specified, the cents value must be an integer between 0 and 127.");
      }
      return t8 >= 0 && t8 <= 127 || (t8 = 0), this.sendRpnValue("modulationrange", [e8, t8], n8), this;
    }
    sendNrpnValue(e8, t8, n8 = {}) {
      if (t8 = [].concat(t8), d.validation) {
        if (!Array.isArray(e8) || !Number.isInteger(e8[0]) || !Number.isInteger(e8[1]))
          throw new TypeError("The specified NRPN is invalid.");
        if (!(e8[0] >= 0 && e8[0] <= 127))
          throw new RangeError("The first byte of the NRPN must be between 0 and 127.");
        if (!(e8[1] >= 0 && e8[1] <= 127))
          throw new RangeError("The second byte of the NRPN must be between 0 and 127.");
        t8.forEach((e9) => {
          if (!(e9 >= 0 && e9 <= 127))
            throw new RangeError("The data bytes of the NRPN must be between 0 and 127.");
        });
      }
      return this._selectNonRegisteredParameter(e8, n8), this._setCurrentParameter(t8, n8), this._deselectNonRegisteredParameter(n8), this;
    }
    sendPitchBend(e8, t8 = {}) {
      if (d.validation)
        if (t8.rawValue && Array.isArray(e8)) {
          if (!(e8[0] >= 0 && e8[0] <= 127))
            throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
          if (!(e8[1] >= 0 && e8[1] <= 127))
            throw new RangeError("The pitch bend LSB must be an integer between 0 and 127.");
        } else if (t8.rawValue && !Array.isArray(e8)) {
          if (!(e8 >= 0 && e8 <= 127))
            throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
        } else {
          if (isNaN(e8) || e8 === null)
            throw new RangeError("Invalid pitch bend value.");
          if (!(e8 >= -1 && e8 <= 1))
            throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
        }
      let s4 = 0, a8 = 0;
      if (t8.rawValue && Array.isArray(e8))
        s4 = e8[0], a8 = e8[1];
      else if (t8.rawValue && !Array.isArray(e8))
        s4 = e8;
      else {
        const t9 = r.fromFloatToMsbLsb((e8 + 1) / 2);
        s4 = t9.msb, a8 = t9.lsb;
      }
      return this.send([(n.MIDI_CHANNEL_MESSAGES.pitchbend << 4) + (this.number - 1), a8, s4], { time: r.toTimestamp(t8.time) }), this;
    }
    sendPitchBendRange(e8, t8, n8 = {}) {
      if (d.validation) {
        if (!Number.isInteger(e8) || !(e8 >= 0 && e8 <= 127))
          throw new RangeError("The semitones value must be an integer between 0 and 127.");
        if (!Number.isInteger(t8) || !(t8 >= 0 && t8 <= 127))
          throw new RangeError("The cents value must be an integer between 0 and 127.");
      }
      return this.sendRpnValue("pitchbendrange", [e8, t8], n8), this;
    }
    sendProgramChange(e8, t8 = {}) {
      if (e8 = parseInt(e8) || 0, d.validation && !(e8 >= 0 && e8 <= 127))
        throw new RangeError("The program number must be between 0 and 127.");
      return this.send([(n.MIDI_CHANNEL_MESSAGES.programchange << 4) + (this.number - 1), e8], { time: r.toTimestamp(t8.time) }), this;
    }
    sendRpnValue(e8, t8, s4 = {}) {
      if (Array.isArray(e8) || (e8 = n.MIDI_REGISTERED_PARAMETERS[e8]), d.validation) {
        if (!Number.isInteger(e8[0]) || !Number.isInteger(e8[1]))
          throw new TypeError("The specified NRPN is invalid.");
        if (!(e8[0] >= 0 && e8[0] <= 127))
          throw new RangeError("The first byte of the RPN must be between 0 and 127.");
        if (!(e8[1] >= 0 && e8[1] <= 127))
          throw new RangeError("The second byte of the RPN must be between 0 and 127.");
        [].concat(t8).forEach((e9) => {
          if (!(e9 >= 0 && e9 <= 127))
            throw new RangeError("The data bytes of the RPN must be between 0 and 127.");
        });
      }
      return this._selectRegisteredParameter(e8, s4), this._setCurrentParameter(t8, s4), this._deselectRegisteredParameter(s4), this;
    }
    sendTuningBank(e8, t8 = {}) {
      if (d.validation && (!Number.isInteger(e8) || !(e8 >= 0 && e8 <= 127)))
        throw new RangeError("The tuning bank number must be between 0 and 127.");
      return this.sendRpnValue("tuningbank", e8, t8), this;
    }
    sendTuningProgram(e8, t8 = {}) {
      if (d.validation && (!Number.isInteger(e8) || !(e8 >= 0 && e8 <= 127)))
        throw new RangeError("The tuning program number must be between 0 and 127.");
      return this.sendRpnValue("tuningprogram", e8, t8), this;
    }
    sendLocalControl(e8, t8 = {}) {
      return e8 ? this.sendChannelMode("localcontrol", 127, t8) : this.sendChannelMode("localcontrol", 0, t8);
    }
    sendAllNotesOff(e8 = {}) {
      return this.sendChannelMode("allnotesoff", 0, e8);
    }
    sendAllSoundOff(e8 = {}) {
      return this.sendChannelMode("allsoundoff", 0, e8);
    }
    sendResetAllControllers(e8 = {}) {
      return this.sendChannelMode("resetallcontrollers", 0, e8);
    }
    sendPolyphonicMode(e8, t8 = {}) {
      return e8 === "mono" ? this.sendChannelMode("monomodeon", 0, t8) : this.sendChannelMode("polymodeon", 0, t8);
    }
    get octaveOffset() {
      return this._octaveOffset;
    }
    set octaveOffset(e8) {
      if (this.validation && (e8 = parseInt(e8), isNaN(e8)))
        throw new TypeError("The 'octaveOffset' property must be an integer.");
      this._octaveOffset = e8;
    }
    get output() {
      return this._output;
    }
    get number() {
      return this._number;
    }
  };
  var i = class extends e {
    constructor(e8) {
      super(), this._midiOutput = e8, this._octaveOffset = 0, this.channels = [];
      for (let e9 = 1; e9 <= 16; e9++)
        this.channels[e9] = new a(this, e9);
      this._midiOutput.onstatechange = this._onStateChange.bind(this);
    }
    async destroy() {
      this.removeListener(), this.channels.forEach((e8) => e8.destroy()), this.channels = [], this._midiOutput.onstatechange = null, await this.close(), this._midiOutput = null;
    }
    _onStateChange(e8) {
      let t8 = { timestamp: d.time };
      e8.port.connection === "open" ? (t8.type = "opened", t8.target = this, t8.port = t8.target, this.emit("opened", t8)) : e8.port.connection === "closed" && e8.port.state === "connected" ? (t8.type = "closed", t8.target = this, t8.port = t8.target, this.emit("closed", t8)) : e8.port.connection === "closed" && e8.port.state === "disconnected" ? (t8.type = "disconnected", t8.port = { connection: e8.port.connection, id: e8.port.id, manufacturer: e8.port.manufacturer, name: e8.port.name, state: e8.port.state, type: e8.port.type }, this.emit("disconnected", t8)) : e8.port.connection === "pending" && e8.port.state === "disconnected" || console.warn("This statechange event was not caught:", e8.port.connection, e8.port.state);
    }
    async open() {
      try {
        return await this._midiOutput.open(), Promise.resolve(this);
      } catch (e8) {
        return Promise.reject(e8);
      }
    }
    async close() {
      this._midiOutput ? await this._midiOutput.close() : await Promise.resolve();
    }
    send(e8, t8 = { time: 0 }, n8 = 0) {
      if (e8 instanceof h2 && (e8 = r.isNode ? e8.data : e8.rawData), e8 instanceof Uint8Array && r.isNode && (e8 = Array.from(e8)), d.validation) {
        if (Array.isArray(e8) || e8 instanceof Uint8Array || (e8 = [e8], Array.isArray(t8) && (e8 = e8.concat(t8)), t8 = isNaN(n8) ? { time: 0 } : { time: n8 }), !(parseInt(e8[0]) >= 128 && parseInt(e8[0]) <= 255))
          throw new RangeError("The first byte (status) must be an integer between 128 and 255.");
        e8.slice(1).forEach((e9) => {
          if (!((e9 = parseInt(e9)) >= 0 && e9 <= 255))
            throw new RangeError("Data bytes must be integers between 0 and 255.");
        }), t8 || (t8 = { time: 0 });
      }
      return this._midiOutput.send(e8, r.toTimestamp(t8.time)), this;
    }
    sendSysex(e8, t8 = [], s4 = {}) {
      if (e8 = [].concat(e8), t8 instanceof Uint8Array) {
        const r8 = new Uint8Array(1 + e8.length + t8.length + 1);
        r8[0] = n.MIDI_SYSTEM_MESSAGES.sysex, r8.set(Uint8Array.from(e8), 1), r8.set(t8, 1 + e8.length), r8[r8.length - 1] = n.MIDI_SYSTEM_MESSAGES.sysexend, this.send(r8, { time: s4.time });
      } else {
        const r8 = e8.concat(t8, n.MIDI_SYSTEM_MESSAGES.sysexend);
        this.send([n.MIDI_SYSTEM_MESSAGES.sysex].concat(r8), { time: s4.time });
      }
      return this;
    }
    clear() {
      return this._midiOutput.clear ? this._midiOutput.clear() : d.validation && console.warn("The 'clear()' method has not yet been implemented in your environment."), this;
    }
    sendTimecodeQuarterFrame(e8, t8 = {}) {
      if (d.validation && (e8 = parseInt(e8), isNaN(e8) || !(e8 >= 0 && e8 <= 127)))
        throw new RangeError("The value must be an integer between 0 and 127.");
      return this.send([n.MIDI_SYSTEM_MESSAGES.timecode, e8], { time: t8.time }), this;
    }
    sendSongPosition(e8 = 0, t8 = {}) {
      var s4 = (e8 = Math.floor(e8) || 0) >> 7 & 127, r8 = 127 & e8;
      return this.send([n.MIDI_SYSTEM_MESSAGES.songposition, s4, r8], { time: t8.time }), this;
    }
    sendSongSelect(e8 = 0, t8 = {}) {
      if (d.validation && (e8 = parseInt(e8), isNaN(e8) || !(e8 >= 0 && e8 <= 127)))
        throw new RangeError("The program value must be between 0 and 127");
      return this.send([n.MIDI_SYSTEM_MESSAGES.songselect, e8], { time: t8.time }), this;
    }
    sendTuneRequest(e8 = {}) {
      return this.send([n.MIDI_SYSTEM_MESSAGES.tunerequest], { time: e8.time }), this;
    }
    sendClock(e8 = {}) {
      return this.send([n.MIDI_SYSTEM_MESSAGES.clock], { time: e8.time }), this;
    }
    sendStart(e8 = {}) {
      return this.send([n.MIDI_SYSTEM_MESSAGES.start], { time: e8.time }), this;
    }
    sendContinue(e8 = {}) {
      return this.send([n.MIDI_SYSTEM_MESSAGES.continue], { time: e8.time }), this;
    }
    sendStop(e8 = {}) {
      return this.send([n.MIDI_SYSTEM_MESSAGES.stop], { time: e8.time }), this;
    }
    sendActiveSensing(e8 = {}) {
      return this.send([n.MIDI_SYSTEM_MESSAGES.activesensing], { time: e8.time }), this;
    }
    sendReset(e8 = {}) {
      return this.send([n.MIDI_SYSTEM_MESSAGES.reset], { time: e8.time }), this;
    }
    sendTuningRequest(e8 = {}) {
      return d.validation && console.warn("The sendTuningRequest() method has been deprecated. Use sendTuningRequest() instead."), this.sendTuneRequest(e8);
    }
    sendKeyAftertouch(e8, t8, s4 = {}) {
      return s4.channels == null && (s4.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(s4.channels).forEach((n8) => {
        this.channels[n8].sendKeyAftertouch(e8, t8, s4);
      }), this;
    }
    sendControlChange(e8, t8, s4 = {}, a8 = {}) {
      if (d.validation && (Array.isArray(s4) || Number.isInteger(s4) || s4 === "all")) {
        const e9 = s4;
        (s4 = a8).channels = e9, s4.channels === "all" && (s4.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return s4.channels == null && (s4.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(s4.channels).forEach((n8) => {
        this.channels[n8].sendControlChange(e8, t8, s4);
      }), this;
    }
    sendPitchBendRange(e8 = 0, t8 = 0, s4 = {}) {
      return s4.channels == null && (s4.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(s4.channels).forEach((n8) => {
        this.channels[n8].sendPitchBendRange(e8, t8, s4);
      }), this;
    }
    setPitchBendRange(e8 = 0, t8 = 0, s4 = "all", r8 = {}) {
      return d.validation && (console.warn("The setPitchBendRange() method is deprecated. Use sendPitchBendRange() instead."), r8.channels = s4, r8.channels === "all" && (r8.channels = n.MIDI_CHANNEL_NUMBERS)), this.sendPitchBendRange(e8, t8, r8);
    }
    sendRpnValue(e8, t8, s4 = {}) {
      return s4.channels == null && (s4.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(s4.channels).forEach((n8) => {
        this.channels[n8].sendRpnValue(e8, t8, s4);
      }), this;
    }
    setRegisteredParameter(e8, t8 = [], s4 = "all", r8 = {}) {
      return d.validation && (console.warn("The setRegisteredParameter() method is deprecated. Use sendRpnValue() instead."), r8.channels = s4, r8.channels === "all" && (r8.channels = n.MIDI_CHANNEL_NUMBERS)), this.sendRpnValue(e8, t8, r8);
    }
    sendChannelAftertouch(e8, t8 = {}, s4 = {}) {
      if (d.validation && (Array.isArray(t8) || Number.isInteger(t8) || t8 === "all")) {
        const e9 = t8;
        (t8 = s4).channels = e9, t8.channels === "all" && (t8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendChannelAftertouch(e8, t8);
      }), this;
    }
    sendPitchBend(e8, t8 = {}, s4 = {}) {
      if (d.validation && (Array.isArray(t8) || Number.isInteger(t8) || t8 === "all")) {
        const e9 = t8;
        (t8 = s4).channels = e9, t8.channels === "all" && (t8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendPitchBend(e8, t8);
      }), this;
    }
    sendProgramChange(e8 = 0, t8 = {}, s4 = {}) {
      if (d.validation && (Array.isArray(t8) || Number.isInteger(t8) || t8 === "all")) {
        const e9 = t8;
        (t8 = s4).channels = e9, t8.channels === "all" && (t8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendProgramChange(e8, t8);
      }), this;
    }
    sendModulationRange(e8, t8, s4 = {}) {
      return s4.channels == null && (s4.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(s4.channels).forEach((n8) => {
        this.channels[n8].sendModulationRange(e8, t8, s4);
      }), this;
    }
    setModulationRange(e8 = 0, t8 = 0, s4 = "all", r8 = {}) {
      return d.validation && (console.warn("The setModulationRange() method is deprecated. Use sendModulationRange() instead."), r8.channels = s4, r8.channels === "all" && (r8.channels = n.MIDI_CHANNEL_NUMBERS)), this.sendModulationRange(e8, t8, r8);
    }
    sendMasterTuning(e8, t8 = {}) {
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendMasterTuning(e8, t8);
      }), this;
    }
    setMasterTuning(e8, t8 = {}, s4 = {}) {
      return d.validation && (console.warn("The setMasterTuning() method is deprecated. Use sendMasterTuning() instead."), s4.channels = t8, s4.channels === "all" && (s4.channels = n.MIDI_CHANNEL_NUMBERS)), this.sendMasterTuning(e8, s4);
    }
    sendTuningProgram(e8, t8 = {}) {
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendTuningProgram(e8, t8);
      }), this;
    }
    setTuningProgram(e8, t8 = "all", s4 = {}) {
      return d.validation && (console.warn("The setTuningProgram() method is deprecated. Use sendTuningProgram() instead."), s4.channels = t8, s4.channels === "all" && (s4.channels = n.MIDI_CHANNEL_NUMBERS)), this.sendTuningProgram(e8, s4);
    }
    sendTuningBank(e8 = 0, t8 = {}) {
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendTuningBank(e8, t8);
      }), this;
    }
    setTuningBank(e8, t8 = "all", s4 = {}) {
      return d.validation && (console.warn("The setTuningBank() method is deprecated. Use sendTuningBank() instead."), s4.channels = t8, s4.channels === "all" && (s4.channels = n.MIDI_CHANNEL_NUMBERS)), this.sendTuningBank(e8, s4);
    }
    sendChannelMode(e8, t8 = 0, s4 = {}, a8 = {}) {
      if (d.validation && (Array.isArray(s4) || Number.isInteger(s4) || s4 === "all")) {
        const e9 = s4;
        (s4 = a8).channels = e9, s4.channels === "all" && (s4.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return s4.channels == null && (s4.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(s4.channels).forEach((n8) => {
        this.channels[n8].sendChannelMode(e8, t8, s4);
      }), this;
    }
    sendAllSoundOff(e8 = {}) {
      return e8.channels == null && (e8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(e8.channels).forEach((t8) => {
        this.channels[t8].sendAllSoundOff(e8);
      }), this;
    }
    sendAllNotesOff(e8 = {}) {
      return e8.channels == null && (e8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(e8.channels).forEach((t8) => {
        this.channels[t8].sendAllNotesOff(e8);
      }), this;
    }
    sendResetAllControllers(e8 = {}, t8 = {}) {
      if (d.validation && (Array.isArray(e8) || Number.isInteger(e8) || e8 === "all")) {
        const s4 = e8;
        (e8 = t8).channels = s4, e8.channels === "all" && (e8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return e8.channels == null && (e8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(e8.channels).forEach((t9) => {
        this.channels[t9].sendResetAllControllers(e8);
      }), this;
    }
    sendPolyphonicMode(e8, t8 = {}, s4 = {}) {
      if (d.validation && (Array.isArray(t8) || Number.isInteger(t8) || t8 === "all")) {
        const e9 = t8;
        (t8 = s4).channels = e9, t8.channels === "all" && (t8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendPolyphonicMode(e8, t8);
      }), this;
    }
    sendLocalControl(e8, t8 = {}, s4 = {}) {
      if (d.validation && (Array.isArray(t8) || Number.isInteger(t8) || t8 === "all")) {
        const e9 = t8;
        (t8 = s4).channels = e9, t8.channels === "all" && (t8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendLocalControl(e8, t8);
      }), this;
    }
    sendOmniMode(e8, t8 = {}, s4 = {}) {
      if (d.validation && (Array.isArray(t8) || Number.isInteger(t8) || t8 === "all")) {
        const e9 = t8;
        (t8 = s4).channels = e9, t8.channels === "all" && (t8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendOmniMode(e8, t8);
      }), this;
    }
    sendNrpnValue(e8, t8, s4 = {}) {
      return s4.channels == null && (s4.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(s4.channels).forEach((n8) => {
        this.channels[n8].sendNrpnValue(e8, t8, s4);
      }), this;
    }
    setNonRegisteredParameter(e8, t8 = [], s4 = "all", r8 = {}) {
      return d.validation && (console.warn("The setNonRegisteredParameter() method is deprecated. Use sendNrpnValue() instead."), r8.channels = s4, r8.channels === "all" && (r8.channels = n.MIDI_CHANNEL_NUMBERS)), this.sendNrpnValue(e8, t8, r8);
    }
    sendRpnIncrement(e8, t8 = {}) {
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendRpnIncrement(e8, t8);
      }), this;
    }
    incrementRegisteredParameter(e8, t8 = "all", s4 = {}) {
      return d.validation && (console.warn("The incrementRegisteredParameter() method is deprecated. Use sendRpnIncrement() instead."), s4.channels = t8, s4.channels === "all" && (s4.channels = n.MIDI_CHANNEL_NUMBERS)), this.sendRpnIncrement(e8, s4);
    }
    sendRpnDecrement(e8, t8 = {}) {
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendRpnDecrement(e8, t8);
      }), this;
    }
    decrementRegisteredParameter(e8, t8 = "all", s4 = {}) {
      return d.validation && (console.warn("The decrementRegisteredParameter() method is deprecated. Use sendRpnDecrement() instead."), s4.channels = t8, s4.channels === "all" && (s4.channels = n.MIDI_CHANNEL_NUMBERS)), this.sendRpnDecrement(e8, s4);
    }
    sendNoteOff(e8, t8 = {}, s4 = {}) {
      if (d.validation && (Array.isArray(t8) || Number.isInteger(t8) || t8 === "all")) {
        const e9 = t8;
        (t8 = s4).channels = e9, t8.channels === "all" && (t8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendNoteOff(e8, t8);
      }), this;
    }
    stopNote(e8, t8) {
      return this.sendNoteOff(e8, t8);
    }
    playNote(e8, t8 = {}, s4 = {}) {
      if (d.validation && (t8.rawVelocity && console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' instead."), t8.velocity && console.warn("The 'velocity' option is deprecated. Use 'velocity' instead."), Array.isArray(t8) || Number.isInteger(t8) || t8 === "all")) {
        const e9 = t8;
        (t8 = s4).channels = e9, t8.channels === "all" && (t8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].playNote(e8, t8);
      }), this;
    }
    sendNoteOn(e8, t8 = {}, s4 = {}) {
      if (d.validation && (Array.isArray(t8) || Number.isInteger(t8) || t8 === "all")) {
        const e9 = t8;
        (t8 = s4).channels = e9, t8.channels === "all" && (t8.channels = n.MIDI_CHANNEL_NUMBERS);
      }
      return t8.channels == null && (t8.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(t8.channels).forEach((n8) => {
        this.channels[n8].sendNoteOn(e8, t8);
      }), this;
    }
    get name() {
      return this._midiOutput.name;
    }
    get id() {
      return this._midiOutput.id;
    }
    get connection() {
      return this._midiOutput.connection;
    }
    get manufacturer() {
      return this._midiOutput.manufacturer;
    }
    get state() {
      return this._midiOutput.state;
    }
    get type() {
      return this._midiOutput.type;
    }
    get octaveOffset() {
      return this._octaveOffset;
    }
    set octaveOffset(e8) {
      if (this.validation && (e8 = parseInt(e8), isNaN(e8)))
        throw new TypeError("The 'octaveOffset' property must be an integer.");
      this._octaveOffset = e8;
    }
  };
  var o = class {
    constructor(e8 = [], t8 = {}) {
      this.destinations = [], this.types = [...Object.keys(n.MIDI_SYSTEM_MESSAGES), ...Object.keys(n.MIDI_CHANNEL_MESSAGES)], this.channels = n.MIDI_CHANNEL_NUMBERS, this.suspended = false, Array.isArray(e8) || (e8 = [e8]), t8.types && !Array.isArray(t8.types) && (t8.types = [t8.types]), t8.channels && !Array.isArray(t8.channels) && (t8.channels = [t8.channels]), d.validation && (e8.forEach((e9) => {
        if (!(e9 instanceof i))
          throw new TypeError("Destinations must be of type 'Output'.");
      }), t8.types !== void 0 && t8.types.forEach((e9) => {
        if (!n.MIDI_SYSTEM_MESSAGES.hasOwnProperty(e9) && !n.MIDI_CHANNEL_MESSAGES.hasOwnProperty(e9))
          throw new TypeError("Type must be a valid message type.");
      }), t8.channels !== void 0 && t8.channels.forEach((e9) => {
        if (!n.MIDI_CHANNEL_NUMBERS.includes(e9))
          throw new TypeError("MIDI channel must be between 1 and 16.");
      })), this.destinations = e8, t8.types && (this.types = t8.types), t8.channels && (this.channels = t8.channels);
    }
    forward(e8) {
      this.suspended || this.types.includes(e8.type) && (e8.channel && !this.channels.includes(e8.channel) || this.destinations.forEach((t8) => {
        (!d.validation || t8 instanceof i) && t8.send(e8);
      }));
    }
  };
  var l = class extends e {
    constructor(e8, t8) {
      super(), this._input = e8, this._number = t8, this._octaveOffset = 0, this._nrpnBuffer = [], this._rpnBuffer = [], this.parameterNumberEventsEnabled = true, this.notesState = new Array(128).fill(false);
    }
    destroy() {
      this._input = null, this._number = null, this._octaveOffset = 0, this._nrpnBuffer = [], this.notesState = new Array(128).fill(false), this.parameterNumberEventsEnabled = false, this.removeListener();
    }
    _processMidiMessageEvent(e8) {
      const t8 = Object.assign({}, e8);
      t8.port = this.input, t8.target = this, t8.type = "midimessage", this.emit(t8.type, t8), this._parseEventForStandardMessages(t8);
    }
    _parseEventForStandardMessages(e8) {
      const t8 = Object.assign({}, e8);
      t8.type = t8.message.type || "unknownmessage";
      const n8 = e8.message.dataBytes[0], a8 = e8.message.dataBytes[1];
      if (t8.type === "noteoff" || t8.type === "noteon" && a8 === 0)
        this.notesState[n8] = false, t8.type = "noteoff", t8.note = new s(r.offsetNumber(n8, this.octaveOffset + this.input.octaveOffset + d.octaveOffset), { rawAttack: 0, rawRelease: a8 }), t8.value = r.from7bitToFloat(a8), t8.rawValue = a8, t8.velocity = t8.note.release, t8.rawVelocity = t8.note.rawRelease;
      else if (t8.type === "noteon")
        this.notesState[n8] = true, t8.note = new s(r.offsetNumber(n8, this.octaveOffset + this.input.octaveOffset + d.octaveOffset), { rawAttack: a8 }), t8.value = r.from7bitToFloat(a8), t8.rawValue = a8, t8.velocity = t8.note.attack, t8.rawVelocity = t8.note.rawAttack;
      else if (t8.type === "keyaftertouch")
        t8.note = new s(r.offsetNumber(n8, this.octaveOffset + this.input.octaveOffset + d.octaveOffset)), t8.value = r.from7bitToFloat(a8), t8.rawValue = a8, t8.identifier = t8.note.identifier, t8.key = t8.note.number, t8.rawKey = n8;
      else if (t8.type === "controlchange") {
        t8.controller = { number: n8, name: r.getCcNameByNumber(n8) }, t8.subtype = t8.controller.name || "controller" + n8, t8.value = r.from7bitToFloat(a8), t8.rawValue = a8;
        const e9 = Object.assign({}, t8);
        e9.type = `${t8.type}-controller${n8}`, delete e9.subtype, this.emit(e9.type, e9), t8.message.dataBytes[0] >= 120 && this._parseChannelModeMessage(t8), this.parameterNumberEventsEnabled && this._isRpnOrNrpnController(t8.message.dataBytes[0]) && this._parseEventForParameterNumber(t8);
      } else
        t8.type === "programchange" ? (t8.value = n8, t8.rawValue = t8.value) : t8.type === "channelaftertouch" ? (t8.value = r.from7bitToFloat(n8), t8.rawValue = n8) : t8.type === "pitchbend" ? (t8.value = ((a8 << 7) + n8 - 8192) / 8192, t8.rawValue = (a8 << 7) + n8) : t8.type = "unknownmessage";
      this.emit(t8.type, t8);
    }
    _parseChannelModeMessage(e8) {
      const t8 = Object.assign({}, e8);
      t8.type = t8.controller.name, t8.type === "localcontrol" && (t8.value = t8.message.data[2] === 127, t8.rawValue = t8.message.data[2]), t8.type === "omnimodeon" ? (t8.type = "omnimode", t8.value = true, t8.rawValue = t8.message.data[2]) : t8.type === "omnimodeoff" && (t8.type = "omnimode", t8.value = false, t8.rawValue = t8.message.data[2]), t8.type === "monomodeon" ? (t8.type = "monomode", t8.value = true, t8.rawValue = t8.message.data[2]) : t8.type === "polymodeon" && (t8.type = "monomode", t8.value = false, t8.rawValue = t8.message.data[2]), this.emit(t8.type, t8);
    }
    _parseEventForParameterNumber(e8) {
      const t8 = e8.message.dataBytes[0], s4 = e8.message.dataBytes[1], r8 = n.MIDI_CONTROL_CHANGE_MESSAGES;
      t8 === r8.nonregisteredparameterfine || t8 === r8.registeredparameterfine ? (this._nrpnBuffer = [], this._rpnBuffer = [], t8 === r8.nonregisteredparameterfine ? this._nrpnBuffer = [e8.message] : s4 !== 127 && (this._rpnBuffer = [e8.message])) : t8 === r8.nonregisteredparametercoarse || t8 === r8.registeredparametercoarse ? t8 === r8.nonregisteredparametercoarse ? (this._rpnBuffer = [], this._nrpnBuffer.length === 1 ? this._nrpnBuffer.push(e8.message) : this._nrpnBuffer = []) : (this._nrpnBuffer = [], this._rpnBuffer.length === 1 && s4 !== 127 ? this._rpnBuffer.push(e8.message) : this._rpnBuffer = []) : t8 !== r8.dataentrycoarse && t8 !== r8.dataentryfine && t8 !== r8.databuttonincrement && t8 !== r8.databuttondecrement || (this._rpnBuffer.length === 2 ? this._dispatchParameterNumberEvent("rpn", this._rpnBuffer[0].dataBytes[1], this._rpnBuffer[1].dataBytes[1], e8) : this._nrpnBuffer.length === 2 ? this._dispatchParameterNumberEvent("nrpn", this._nrpnBuffer[0].dataBytes[1], this._nrpnBuffer[1].dataBytes[1], e8) : (this._nrpnBuffer = [], this._rpnBuffer = []));
    }
    _isRpnOrNrpnController(e8) {
      return e8 === n.MIDI_CONTROL_CHANGE_MESSAGES.dataentrycoarse || e8 === n.MIDI_CONTROL_CHANGE_MESSAGES.dataentryfine || e8 === n.MIDI_CONTROL_CHANGE_MESSAGES.databuttonincrement || e8 === n.MIDI_CONTROL_CHANGE_MESSAGES.databuttondecrement || e8 === n.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparametercoarse || e8 === n.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparameterfine || e8 === n.MIDI_CONTROL_CHANGE_MESSAGES.registeredparametercoarse || e8 === n.MIDI_CONTROL_CHANGE_MESSAGES.registeredparameterfine;
    }
    _dispatchParameterNumberEvent(e8, t8, s4, a8) {
      e8 = e8 === "nrpn" ? "nrpn" : "rpn";
      const i8 = { target: a8.target, timestamp: a8.timestamp, message: a8.message, parameterMsb: t8, parameterLsb: s4, value: r.from7bitToFloat(a8.message.dataBytes[1]), rawValue: a8.message.dataBytes[1] };
      i8.parameter = e8 === "rpn" ? Object.keys(n.MIDI_REGISTERED_PARAMETERS).find((e9) => n.MIDI_REGISTERED_PARAMETERS[e9][0] === t8 && n.MIDI_REGISTERED_PARAMETERS[e9][1] === s4) : (t8 << 7) + s4;
      const o8 = r.getPropertyByValue(n.MIDI_CONTROL_CHANGE_MESSAGES, a8.message.dataBytes[0]);
      i8.type = `${e8}-${o8}`, this.emit(i8.type, i8), i8.type = e8, i8.subtype = o8, this.emit(i8.type, i8);
    }
    getChannelModeByNumber(e8) {
      return d.validation && (console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class."), e8 = Math.floor(e8)), r.getChannelModeByNumber(e8);
    }
    getCcNameByNumber(e8) {
      if (d.validation && (console.warn("The 'getCcNameByNumber()' method has been moved to the 'Utilities' class."), !((e8 = parseInt(e8)) >= 0 && e8 <= 127)))
        throw new RangeError("Invalid control change number.");
      return r.getCcNameByNumber(e8);
    }
    getNoteState(e8) {
      e8 instanceof s && (e8 = e8.identifier);
      const t8 = r.guessNoteNumber(e8, d.octaveOffset + this.input.octaveOffset + this.octaveOffset);
      return this.notesState[t8];
    }
    get octaveOffset() {
      return this._octaveOffset;
    }
    set octaveOffset(e8) {
      if (this.validation && (e8 = parseInt(e8), isNaN(e8)))
        throw new TypeError("The 'octaveOffset' property must be an integer.");
      this._octaveOffset = e8;
    }
    get input() {
      return this._input;
    }
    get number() {
      return this._number;
    }
    get nrpnEventsEnabled() {
      return this.parameterNumberEventsEnabled;
    }
    set nrpnEventsEnabled(e8) {
      this.validation && (e8 = !!e8), this.parameterNumberEventsEnabled = e8;
    }
  };
  var h2 = class {
    constructor(e8) {
      this.rawData = e8, this.data = Array.from(this.rawData), this.statusByte = this.rawData[0], this.rawDataBytes = this.rawData.slice(1), this.dataBytes = this.data.slice(1), this.isChannelMessage = false, this.isSystemMessage = false, this.command = void 0, this.channel = void 0, this.manufacturerId = void 0, this.type = void 0, this.statusByte < 240 ? (this.isChannelMessage = true, this.command = this.statusByte >> 4, this.channel = 1 + (15 & this.statusByte)) : (this.isSystemMessage = true, this.command = this.statusByte), this.isChannelMessage ? this.type = r.getPropertyByValue(n.MIDI_CHANNEL_MESSAGES, this.command) : this.isSystemMessage && (this.type = r.getPropertyByValue(n.MIDI_SYSTEM_MESSAGES, this.command)), this.statusByte === n.MIDI_SYSTEM_MESSAGES.sysex && (this.dataBytes[0] === 0 ? (this.manufacturerId = this.dataBytes.slice(0, 3), this.dataBytes = this.dataBytes.slice(3, this.rawDataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(3, this.rawDataBytes.length - 1)) : (this.manufacturerId = [this.dataBytes[0]], this.dataBytes = this.dataBytes.slice(1, this.dataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(1, this.rawDataBytes.length - 1)));
    }
  };
  var c = class extends e {
    constructor(e8) {
      super(), this._midiInput = e8, this._octaveOffset = 0, this.channels = [];
      for (let e9 = 1; e9 <= 16; e9++)
        this.channels[e9] = new l(this, e9);
      this._forwarders = [], this._midiInput.onstatechange = this._onStateChange.bind(this), this._midiInput.onmidimessage = this._onMidiMessage.bind(this);
    }
    async destroy() {
      this.removeListener(), this.channels.forEach((e8) => e8.destroy()), this.channels = [], this._forwarders = [], this._midiInput && (this._midiInput.onstatechange = null, this._midiInput.onmidimessage = null), await this.close(), this._midiInput = null;
    }
    _onStateChange(e8) {
      let t8 = { timestamp: d.time, target: this, port: this };
      e8.port.connection === "open" ? (t8.type = "opened", this.emit("opened", t8)) : e8.port.connection === "closed" && e8.port.state === "connected" ? (t8.type = "closed", this.emit("closed", t8)) : e8.port.connection === "closed" && e8.port.state === "disconnected" ? (t8.type = "disconnected", t8.port = { connection: e8.port.connection, id: e8.port.id, manufacturer: e8.port.manufacturer, name: e8.port.name, state: e8.port.state, type: e8.port.type }, this.emit("disconnected", t8)) : e8.port.connection === "pending" && e8.port.state === "disconnected" || console.warn("This statechange event was not caught: ", e8.port.connection, e8.port.state);
    }
    _onMidiMessage(e8) {
      const t8 = new h2(e8.data), n8 = { port: this, target: this, message: t8, timestamp: e8.timeStamp, type: "midimessage", data: t8.data, rawData: t8.data, statusByte: t8.data[0], dataBytes: t8.dataBytes };
      this.emit("midimessage", n8), t8.isSystemMessage ? this._parseEvent(n8) : t8.isChannelMessage && this.channels[t8.channel]._processMidiMessageEvent(n8), this._forwarders.forEach((e9) => e9.forward(t8));
    }
    _parseEvent(e8) {
      const t8 = Object.assign({}, e8);
      t8.type = t8.message.type || "unknownmidimessage", t8.type === "songselect" && (t8.song = e8.data[1] + 1, t8.value = e8.data[1], t8.rawValue = t8.value), this.emit(t8.type, t8);
    }
    async open() {
      try {
        await this._midiInput.open();
      } catch (e8) {
        return Promise.reject(e8);
      }
      return Promise.resolve(this);
    }
    async close() {
      if (!this._midiInput)
        return Promise.resolve(this);
      try {
        await this._midiInput.close();
      } catch (e8) {
        return Promise.reject(e8);
      }
      return Promise.resolve(this);
    }
    getChannelModeByNumber() {
      d.validation && console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class.");
    }
    addListener(e8, t8, s4 = {}) {
      if (d.validation && typeof s4 == "function") {
        let e9 = t8 != null ? [].concat(t8) : void 0;
        t8 = s4, s4 = { channels: e9 };
      }
      if (n.CHANNEL_EVENTS.includes(e8)) {
        s4.channels === void 0 && (s4.channels = n.MIDI_CHANNEL_NUMBERS);
        let a8 = [];
        return r.sanitizeChannels(s4.channels).forEach((n8) => {
          a8.push(this.channels[n8].addListener(e8, t8, s4));
        }), a8;
      }
      return super.addListener(e8, t8, s4);
    }
    addOneTimeListener(e8, t8, n8 = {}) {
      return n8.remaining = 1, this.addListener(e8, t8, n8);
    }
    on(e8, t8, n8, s4) {
      return this.addListener(e8, t8, n8, s4);
    }
    hasListener(e8, t8, s4 = {}) {
      if (d.validation && typeof s4 == "function") {
        let e9 = [].concat(t8);
        t8 = s4, s4 = { channels: e9 };
      }
      return n.CHANNEL_EVENTS.includes(e8) ? (s4.channels === void 0 && (s4.channels = n.MIDI_CHANNEL_NUMBERS), r.sanitizeChannels(s4.channels).every((n8) => this.channels[n8].hasListener(e8, t8))) : super.hasListener(e8, t8);
    }
    removeListener(e8, t8, s4 = {}) {
      if (d.validation && typeof s4 == "function") {
        let e9 = [].concat(t8);
        t8 = s4, s4 = { channels: e9 };
      }
      if (s4.channels === void 0 && (s4.channels = n.MIDI_CHANNEL_NUMBERS), e8 == null)
        return r.sanitizeChannels(s4.channels).forEach((e9) => {
          this.channels[e9] && this.channels[e9].removeListener();
        }), super.removeListener();
      n.CHANNEL_EVENTS.includes(e8) ? r.sanitizeChannels(s4.channels).forEach((n8) => {
        this.channels[n8].removeListener(e8, t8, s4);
      }) : super.removeListener(e8, t8, s4);
    }
    addForwarder(e8, t8 = {}) {
      let n8;
      return n8 = e8 instanceof o ? e8 : new o(e8, t8), this._forwarders.push(n8), n8;
    }
    removeForwarder(e8) {
      this._forwarders = this._forwarders.filter((t8) => t8 !== e8);
    }
    hasForwarder(e8) {
      return this._forwarders.includes(e8);
    }
    get name() {
      return this._midiInput.name;
    }
    get id() {
      return this._midiInput.id;
    }
    get connection() {
      return this._midiInput.connection;
    }
    get manufacturer() {
      return this._midiInput.manufacturer;
    }
    get octaveOffset() {
      return this._octaveOffset;
    }
    set octaveOffset(e8) {
      if (this.validation && (e8 = parseInt(e8), isNaN(e8)))
        throw new TypeError("The 'octaveOffset' property must be an integer.");
      this._octaveOffset = e8;
    }
    get state() {
      return this._midiInput.state;
    }
    get type() {
      return this._midiInput.type;
    }
    get nrpnEventsEnabled() {
      return d.validation && console.warn("The 'nrpnEventsEnabled' property has been moved to the 'InputChannel' class."), false;
    }
  };
  var d = new class extends e {
    constructor() {
      super(), this.defaults = { note: { attack: r.from7bitToFloat(64), release: r.from7bitToFloat(64), duration: 1 / 0 } }, this.interface = null, this.validation = true, this._inputs = [], this._disconnectedInputs = [], this._outputs = [], this._disconnectedOutputs = [], this._stateChangeQueue = [], this._octaveOffset = 0;
    }
    async enable(e8 = {}, t8 = false) {
      if (r.isNode) {
        try {
          window.navigator;
        } catch (e9) {
          global.navigator = await Object.getPrototypeOf(async function() {
          }).constructor('\n        let jzz = await import("jzz");\n        return jzz.default;\n        ')();
        }
        try {
          performance;
        } catch (e9) {
          global.performance = await Object.getPrototypeOf(async function() {
          }).constructor('\n        let perf_hooks = await import("perf_hooks");\n        return perf_hooks.performance;\n        ')();
        }
      }
      if (this.validation = e8.validation !== false, this.validation && (typeof e8 == "function" && (e8 = { callback: e8, sysex: t8 }), t8 && (e8.sysex = true)), this.enabled)
        return typeof e8.callback == "function" && e8.callback(), Promise.resolve();
      const n8 = { timestamp: this.time, target: this, type: "error", error: void 0 }, s4 = { timestamp: this.time, target: this, type: "midiaccessgranted" }, a8 = { timestamp: this.time, target: this, type: "enabled" };
      try {
        typeof e8.requestMIDIAccessFunction == "function" ? this.interface = await e8.requestMIDIAccessFunction({ sysex: e8.sysex, software: e8.software }) : this.interface = await navigator.requestMIDIAccess({ sysex: e8.sysex, software: e8.software });
      } catch (t9) {
        return n8.error = t9, this.emit("error", n8), typeof e8.callback == "function" && e8.callback(t9), Promise.reject(t9);
      }
      this.emit("midiaccessgranted", s4), this.interface.onstatechange = this._onInterfaceStateChange.bind(this);
      try {
        await this._updateInputsAndOutputs();
      } catch (t9) {
        return n8.error = t9, this.emit("error", n8), typeof e8.callback == "function" && e8.callback(t9), Promise.reject(t9);
      }
      return this.emit("enabled", a8), typeof e8.callback == "function" && e8.callback(), Promise.resolve(this);
    }
    async disable() {
      return this._destroyInputsAndOutputs().then(() => {
        navigator && typeof navigator.close == "function" && navigator.close(), this.interface && (this.interface.onstatechange = void 0), this.interface = null;
        let e8 = { timestamp: this.time, target: this, type: "disabled" };
        this.emit("disabled", e8), this.removeListener();
      });
    }
    getInputById(e8, t8 = { disconnected: false }) {
      if (this.validation) {
        if (!this.enabled)
          throw new Error("WebMidi is not enabled.");
        if (!e8)
          return;
      }
      if (t8.disconnected) {
        for (let t9 = 0; t9 < this._disconnectedInputs.length; t9++)
          if (this._disconnectedInputs[t9].id === e8.toString())
            return this._disconnectedInputs[t9];
      } else
        for (let t9 = 0; t9 < this.inputs.length; t9++)
          if (this.inputs[t9].id === e8.toString())
            return this.inputs[t9];
    }
    getInputByName(e8, t8 = { disconnected: false }) {
      if (this.validation) {
        if (!this.enabled)
          throw new Error("WebMidi is not enabled.");
        if (!e8)
          return;
        e8 = e8.toString();
      }
      if (t8.disconnected) {
        for (let t9 = 0; t9 < this._disconnectedInputs.length; t9++)
          if (~this._disconnectedInputs[t9].name.indexOf(e8))
            return this._disconnectedInputs[t9];
      } else
        for (let t9 = 0; t9 < this.inputs.length; t9++)
          if (~this.inputs[t9].name.indexOf(e8))
            return this.inputs[t9];
    }
    getOutputByName(e8, t8 = { disconnected: false }) {
      if (this.validation) {
        if (!this.enabled)
          throw new Error("WebMidi is not enabled.");
        if (!e8)
          return;
        e8 = e8.toString();
      }
      if (t8.disconnected) {
        for (let t9 = 0; t9 < this._disconnectedOutputs.length; t9++)
          if (~this._disconnectedOutputs[t9].name.indexOf(e8))
            return this._disconnectedOutputs[t9];
      } else
        for (let t9 = 0; t9 < this.outputs.length; t9++)
          if (~this.outputs[t9].name.indexOf(e8))
            return this.outputs[t9];
    }
    getOutputById(e8, t8 = { disconnected: false }) {
      if (this.validation) {
        if (!this.enabled)
          throw new Error("WebMidi is not enabled.");
        if (!e8)
          return;
      }
      if (t8.disconnected) {
        for (let t9 = 0; t9 < this._disconnectedOutputs.length; t9++)
          if (this._disconnectedOutputs[t9].id === e8.toString())
            return this._disconnectedOutputs[t9];
      } else
        for (let t9 = 0; t9 < this.outputs.length; t9++)
          if (this.outputs[t9].id === e8.toString())
            return this.outputs[t9];
    }
    noteNameToNumber(e8) {
      return this.validation && console.warn("The noteNameToNumber() method is deprecated. Use Utilities.toNoteNumber() instead."), r.toNoteNumber(e8, this.octaveOffset);
    }
    getOctave(e8) {
      return this.validation && (console.warn("The getOctave()is deprecated. Use Utilities.getNoteDetails() instead"), e8 = parseInt(e8)), !isNaN(e8) && e8 >= 0 && e8 <= 127 && r.getNoteDetails(r.offsetNumber(e8, this.octaveOffset)).octave;
    }
    sanitizeChannels(e8) {
      return this.validation && console.warn("The sanitizeChannels() method has been moved to the utilities class."), r.sanitizeChannels(e8);
    }
    toMIDIChannels(e8) {
      return this.validation && console.warn("The toMIDIChannels() method has been deprecated. Use Utilities.sanitizeChannels() instead."), r.sanitizeChannels(e8);
    }
    guessNoteNumber(e8) {
      return this.validation && console.warn("The guessNoteNumber() method has been deprecated. Use Utilities.guessNoteNumber() instead."), r.guessNoteNumber(e8, this.octaveOffset);
    }
    getValidNoteArray(e8, t8 = {}) {
      return this.validation && console.warn("The getValidNoteArray() method has been moved to the Utilities.buildNoteArray()"), r.buildNoteArray(e8, t8);
    }
    convertToTimestamp(e8) {
      return this.validation && console.warn("The convertToTimestamp() method has been moved to Utilities.toTimestamp()."), r.toTimestamp(e8);
    }
    async _destroyInputsAndOutputs() {
      let e8 = [];
      return this.inputs.forEach((t8) => e8.push(t8.destroy())), this.outputs.forEach((t8) => e8.push(t8.destroy())), Promise.all(e8).then(() => {
        this._inputs = [], this._outputs = [];
      });
    }
    _onInterfaceStateChange(e8) {
      this._updateInputsAndOutputs();
      let t8 = { timestamp: e8.timeStamp, type: e8.port.state, target: this };
      if (e8.port.state === "connected" && e8.port.connection === "open") {
        e8.port.type === "output" ? t8.port = this.getOutputById(e8.port.id) : e8.port.type === "input" && (t8.port = this.getInputById(e8.port.id)), this.emit(e8.port.state, t8);
        const n8 = Object.assign({}, t8);
        n8.type = "portschanged", this.emit(n8.type, n8);
      } else if (e8.port.state === "disconnected" && e8.port.connection === "pending") {
        e8.port.type === "input" ? t8.port = this.getInputById(e8.port.id, { disconnected: true }) : e8.port.type === "output" && (t8.port = this.getOutputById(e8.port.id, { disconnected: true })), this.emit(e8.port.state, t8);
        const n8 = Object.assign({}, t8);
        n8.type = "portschanged", this.emit(n8.type, n8);
      }
    }
    async _updateInputsAndOutputs() {
      return Promise.all([this._updateInputs(), this._updateOutputs()]);
    }
    async _updateInputs() {
      if (!this.interface)
        return;
      for (let e9 = this._inputs.length - 1; e9 >= 0; e9--) {
        const t8 = this._inputs[e9];
        Array.from(this.interface.inputs.values()).find((e10) => e10 === t8._midiInput) || (this._disconnectedInputs.push(t8), this._inputs.splice(e9, 1));
      }
      let e8 = [];
      return this.interface.inputs.forEach((t8) => {
        if (!this._inputs.find((e9) => e9._midiInput === t8)) {
          let n8 = this._disconnectedInputs.find((e9) => e9._midiInput === t8);
          n8 || (n8 = new c(t8)), this._inputs.push(n8), e8.push(n8.open());
        }
      }), Promise.all(e8);
    }
    async _updateOutputs() {
      if (!this.interface)
        return;
      for (let e9 = this._outputs.length - 1; e9 >= 0; e9--) {
        const t8 = this._outputs[e9];
        Array.from(this.interface.outputs.values()).find((e10) => e10 === t8._midiOutput) || (this._disconnectedOutputs.push(t8), this._outputs.splice(e9, 1));
      }
      let e8 = [];
      return this.interface.outputs.forEach((t8) => {
        if (!this._outputs.find((e9) => e9._midiOutput === t8)) {
          let n8 = this._disconnectedOutputs.find((e9) => e9._midiOutput === t8);
          n8 || (n8 = new i(t8)), this._outputs.push(n8), e8.push(n8.open());
        }
      }), Promise.all(e8);
    }
    get enabled() {
      return this.interface !== null;
    }
    get inputs() {
      return this._inputs;
    }
    get isNode() {
      return this.validation && console.warn("WebMidi.isNode has been deprecated. Use Utilities.isNode instead."), r.isNode;
    }
    get isBrowser() {
      return this.validation && console.warn("WebMidi.isBrowser has been deprecated. Use Utilities.isBrowser instead."), r.isBrowser;
    }
    get octaveOffset() {
      return this._octaveOffset;
    }
    set octaveOffset(e8) {
      if (this.validation && (e8 = parseInt(e8), isNaN(e8)))
        throw new TypeError("The 'octaveOffset' property must be an integer.");
      this._octaveOffset = e8;
    }
    get outputs() {
      return this._outputs;
    }
    get supported() {
      return typeof navigator != "undefined" && navigator.requestMIDIAccess;
    }
    get sysexEnabled() {
      return !(!this.interface || !this.interface.sysexEnabled);
    }
    get time() {
      return performance.now();
    }
    get version() {
      return "3.0.21";
    }
    get CHANNEL_EVENTS() {
      return this.validation && console.warn("The CHANNEL_EVENTS enum has been moved to Enumerations.CHANNEL_EVENTS."), n.CHANNEL_EVENTS;
    }
    get MIDI_SYSTEM_MESSAGES() {
      return this.validation && console.warn("The MIDI_SYSTEM_MESSAGES enum has been moved to Enumerations.MIDI_SYSTEM_MESSAGES."), n.MIDI_SYSTEM_MESSAGES;
    }
    get MIDI_CHANNEL_MODE_MESSAGES() {
      return this.validation && console.warn("The MIDI_CHANNEL_MODE_MESSAGES enum has been moved to Enumerations.MIDI_CHANNEL_MODE_MESSAGES."), n.MIDI_CHANNEL_MODE_MESSAGES;
    }
    get MIDI_CONTROL_CHANGE_MESSAGES() {
      return this.validation && console.warn("The MIDI_CONTROL_CHANGE_MESSAGES enum has been moved to Enumerations.MIDI_CONTROL_CHANGE_MESSAGES."), n.MIDI_CONTROL_CHANGE_MESSAGES;
    }
    get MIDI_REGISTERED_PARAMETER() {
      return this.validation && console.warn("The MIDI_REGISTERED_PARAMETER enum has been moved to Enumerations.MIDI_REGISTERED_PARAMETERS."), this.MIDI_REGISTERED_PARAMETERS;
    }
    get NOTES() {
      return this.validation && console.warn("The NOTES enum has been deprecated."), ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    }
  }();
  d.constructor = null;

  // .vitepress/use/keyboard.js
  var noteKeys = {
    "KeyQ": { note: "F", offset: 1 },
    "Digit2": { note: "F#", offset: 1 },
    "KeyW": { note: "G", offset: 1 },
    "Digit3": { note: "G#", offset: 1 },
    "KeyE": { note: "A", offset: 1 },
    "Digit4": { note: "A#", offset: 1 },
    "KeyR": { note: "B", offset: 1 },
    "KeyT": { note: "C", offset: 2 },
    "Digit6": { note: "C#", offset: 2 },
    "KeyY": { note: "D", offset: 2 },
    "Digit7": { note: "D#", offset: 2 },
    "KeyU": { note: "E", offset: 2 },
    "KeyI": { note: "F", offset: 2 },
    "Digit9": { note: "F#", offset: 2 },
    "KeyO": { note: "G", offset: 2 },
    "Digit0": { note: "G#", offset: 2 },
    "KeyP": { note: "A", offset: 2 },
    "Minus": { note: "A#", offset: 2 },
    "BracketLeft": { note: "B", offset: 2 },
    "BracketRIght": { note: "C", offset: 3 },
    "KeyZ": { note: "C", offset: 0 },
    "KeyS": { note: "C#", offset: 0 },
    "KeyX": { note: "D", offset: 0 },
    "KeyD": { note: "D#", offset: 0 },
    "KeyC": { note: "E", offset: 0 },
    "KeyV": { note: "F", offset: 0 },
    "KeyG": { note: "F#", offset: 0 },
    "KeyB": { note: "G", offset: 0 },
    "KeyH": { note: "G#", offset: 0 },
    "KeyN": { note: "A", offset: 0 },
    "KeyJ": { note: "A#", offset: 0 },
    "KeyM": { note: "B", offset: 0 },
    "Comma": { note: "C", offset: 1 },
    "KeyL": { note: "C#", offset: 1 },
    "Period": { note: "D", offset: 1 },
    "Semicolon": { note: "D#", offset: 1 },
    "Slash": { note: "E", offset: 1 }
  };
  function setupKeyboard() {
    document.addEventListener("keydown", (e8) => {
      if (e8.code == "Digit1")
        midi.offset--;
      if (e8.code == "Equal")
        midi.offset++;
      if (e8.repeat || !midi.keyboard || !noteKeys[e8.code])
        return;
      if (e8.ctrlKey || e8.altKey || e8.metaKey)
        return;
      if (e8.code == "Slash")
        e8.preventDefault();
      playKey(noteKeys[e8.code].note, noteKeys[e8.code].offset);
    });
    document.addEventListener("keyup", (e8) => {
      if (!noteKeys[e8.code])
        return;
      playKey(noteKeys[e8.code].note, noteKeys[e8.code].offset, true);
    });
  }

  // .vitepress/use/midi.js
  var midi = reactive({
    enabled: false,
    initiated: false,
    out: true,
    inputs: {},
    outputs: {},
    forwards: {},
    playing: false,
    channels: {},
    channel: useStorage2("global-midi-channel", 1),
    note: {
      pitch: 0,
      channel: 1
    },
    offset: useClamp2(0, -2, 2),
    keyboard: true,
    cc: {},
    ccLearn: {},
    message: null,
    log: [],
    clock: 0,
    filter: useStorage2("global-midi-filter", {}),
    available: computed(() => Object.entries(midi.outputs).length > 0),
    activeNotes: computed(() => {
      let notes2 = {};
      for (let ch in midi.channels) {
        for (let num2 in midi.channels[ch].activeNotes) {
          notes2[num2] = midi.channels[ch].activeNotes[num2];
        }
      }
      return notes2;
    }),
    activeChroma: computed(() => {
      let chroma3 = new Array(12);
      for (let num2 in midi.activeNotes) {
        chroma3[(num2 - 9) % 12] = num2;
      }
      return chroma3;
    })
  });
  function learnCC({ param, number, channel } = {}) {
    const val = ref(0);
    watch(() => midi.cc, (cc) => {
      if (channel && cc.channel != channel)
        return;
      if (number == cc.number)
        val.value = cc.value;
    });
    return val;
  }
  function playKey(name2, offset = 0, off, velocity = 1) {
    let noteName = name2 + (4 + offset + midi.offset);
    const note3 = new s(noteName, {
      attack: off ? 0 : velocity,
      release: off ? 0 : velocity
    });
    const ev = {
      type: off ? "noteoff" : "noteon",
      note: note3,
      port: { id: "PC Keyboard" },
      timestamp: midi.time,
      target: { number: 0 }
    };
    noteInOn(ev);
  }
  function useMidi() {
    if (!midi.initiated) {
      setupKeyboard();
      onMounted(() => {
        if (d.supported) {
          setupMidi();
        }
      });
      watchEffect(() => {
        if (!midi.out)
          return;
        let outs = Object.values(d.outputs);
        if (midi.playing) {
          outs.forEach((output) => {
            output.sendContinue();
          });
        } else {
          outs.forEach((output) => {
            output.sendStop();
          });
        }
      });
      midi.initiated = true;
    }
    return {
      midi,
      midiAttack,
      midiRelease,
      midiOnce: midiOnce2,
      setCC,
      WebMidi: d
    };
  }
  function setupMidi() {
    d.enable();
    d.addListener("enabled", (e8) => {
      midi.enabled = true;
      initMidi();
    });
    d.addListener("connected", (e8) => {
      initMidi();
    });
    d.addListener("disconnected", (e8) => {
      delete midi[e8.port.type + "s"][e8.port.id];
    });
    midi.initiated = true;
  }
  function initMidi() {
    midi.inputs = reactive({});
    d.inputs.forEach((input2) => {
      midi.enabled = true;
      midi.inputs[input2.id] = {
        name: input2.name,
        manufacturer: input2.manufacturer,
        forwarder: input2.addForwarder(),
        event: null,
        note: null,
        cc: null
      };
      input2.removeListener();
      input2.addListener("start", () => {
        midi.playing = true;
      });
      input2.addListener("stop", () => {
        midi.playing = false;
        midi.channels = {};
      });
      input2.addListener("midimessage", (ev) => {
        var _a3;
        if (((_a3 = ev == null ? void 0 : ev.message) == null ? void 0 : _a3.type) == "clock")
          return;
        midi.inputs[input2.id].event = ev;
        midi.message = ev.message;
        midi.log.unshift(ev);
        if (midi.log.length > 100)
          midi.log.pop();
      });
      input2.addListener("noteon", (ev) => {
        midi.inputs[input2.id].note = noteInOn(ev);
      }, {
        channels: "all"
      });
      input2.addListener("noteoff", (ev) => {
        midi.inputs[input2.id].note = noteInOn(ev);
      }, { channels: "all" });
      input2.addListener("controlchange", (ev) => {
        const cc = ccIn(ev);
        if (!cc)
          return;
        midi.inputs[input2.id].cc = cc;
        midi.cc = cc;
      }, {
        channels: "all"
      });
      input2.addListener("clock", (ev) => {
        midi.clock = ev.timestamp;
      });
    });
    midi.outputs = reactive({});
    d.outputs.forEach((output) => {
      midi.outputs[output.id] = {
        name: output.name,
        manufacturer: output.manufacturer
      };
    });
  }
  function noteInOn(ev) {
    let note3 = ev.note;
    note3.port = ev.port.id;
    note3.type = ev.type;
    note3.timestamp = ev.timestamp;
    note3.channel = ev.target.number;
    if (midi.filter[note3.channel])
      return;
    createChannel2(note3.channel);
    midi.channels[note3.channel].notes[note3.number] = note3;
    if (ev.type == "noteoff") {
      note3.velocity = 0;
      delete midi.channels[note3.channel].activeNotes[note3.number];
    } else {
      note3.velocity = 120 * (ev.note.attack || 1);
      midi.channels[note3.channel].activeNotes[note3.number] = true;
    }
    note3.pitch = (note3.number + 3) % 12;
    note3.octA = Math.floor((note3.number + 3) / 12) - 1;
    midi.note = note3;
    return note3;
  }
  function ccIn(ev) {
    if (midi.filter[ev.target.number])
      return;
    let cc = {
      channel: ev.target.number,
      timestamp: ev.timestamp,
      number: ev.controller.number,
      value: ev.value,
      raw: ev.rawValue,
      port: ev.port.id
    };
    createChannel2(cc.channel);
    midi.channels[cc.channel].cc[cc.number] = cc;
    return cc;
  }
  function createChannel2(ch) {
    if (!midi.channels[ch]) {
      midi.channels[ch] = reactive({ num: ch, activeNotes: {}, notes: {}, cc: {} });
    }
  }
  function setVelocity(channel, note3, velocity) {
    var _a3, _b, _c;
    if ((_c = (_b = (_a3 = midi.channels) == null ? void 0 : _a3[channel]) == null ? void 0 : _b.notes) == null ? void 0 : _c[note3]) {
      midi.channels[channel].notes[note3].velocity = velocity;
    }
  }
  function midiAttack(note3, options2) {
    if (!midi.out)
      return;
    let channel = (note3 == null ? void 0 : note3.channel) || midi.channel;
    setVelocity(channel, note3 == null ? void 0 : note3.number, 100);
    d.outputs.forEach((output) => {
      output.playNote(note3.number, {
        channels: channel,
        ...options2
      });
    });
  }
  function midiPlay(note3, options2) {
    if (!midi.out)
      return;
    d.outputs.forEach((output) => {
      output.playNote(note3, {
        channels: midi.channel,
        ...options2
      });
    });
  }
  function midiStop(note3, options2) {
    if (!midi.out)
      return;
    if (note3) {
      d.outputs.forEach((output) => {
        output.stopNote(note3, { channels: midi.channel, ...options2 });
      });
    } else {
      d.outputs.forEach((output) => {
        output.sendAllNotesOff();
        output.sendAllSoundOff({ time: "+1" });
      });
    }
  }
  function midiRelease(note3) {
    if (!midi.out)
      return;
    if (note3) {
      let channel = (note3 == null ? void 0 : note3.channel) || midi.channel;
      setVelocity(channel, note3 == null ? void 0 : note3.number, 0);
      d.outputs.forEach((output) => {
        output.stopNote(note3.number, { channels: channel });
      });
    } else {
      d.outputs.forEach((output) => {
        output.sendAllNotesOff();
        output.sendAllSoundOff({ time: "+1" });
      });
    }
  }
  function midiOnce2(note3, options2) {
    if (!midi.out || midi.filter[midi.channel])
      return;
    midiPlay(note3, options2);
    setTimeout(() => {
      midiStop(note3, options2);
    }, 300);
  }
  function setCC(cc, value) {
    if (!midi.out)
      return;
    d.outputs.forEach((output) => {
      output.sendControlChange(Number(cc.number), value, cc.channel);
    });
  }
  function stopAll() {
    if (!midi.out)
      return;
    midi.channels = {};
    midi.playing = false;
    d.outputs.forEach((output) => {
      output.sendAllNotesOff();
      output.sendAllSoundOff({ time: "+1" });
      output.sendReset();
    });
  }
  function forwardMidi(iid, oid) {
    var _a3, _b;
    const output = d.outputs.find((out) => out.id == oid);
    const destinations = midi.inputs[iid].forwarder.destinations;
    const index15 = destinations.indexOf(output);
    if (index15 == -1) {
      destinations.push(output);
      midi.forwards[iid] = midi.forwards[iid] || {};
      midi.forwards[iid][oid] = true;
    } else {
      destinations.splice(index15, 1);
      (_b = (_a3 = midi.forwards) == null ? void 0 : _a3[iid]) == null ? true : delete _b[oid];
    }
  }

  // .vitepress/use/synth.js
  var quantizeModes = ["+0", "@8n", "@16n", "@32n"];
  var synth = {
    state: reactive({
      midi: useStorage2("synth-midi", true),
      initiated: false,
      mute: false,
      quantize: useCycleList(quantizeModes, { initialValue: "+0" }),
      volume: useClamp2(1, 0, 2)
    }),
    params: reactive({
      maxPolyphony: 50,
      oscillator: {
        type: useStorage2("synth-osc", "sawtooth8")
      },
      volume: -30,
      envelope: {
        attack: 0.01,
        decay: 0.1,
        sustain: 0.6,
        release: 1
      },
      filterEnvelope: {
        attack: 1e-3,
        decay: 0.7,
        sustain: 0.5,
        release: 1,
        baseFrequency: 60,
        octaves: 5
      }
    })
  };
  function useSynth() {
    if (!synth.state.initiated) {
      onKeyDown("Escape", () => {
        synthReleaseAll();
      });
      watch(() => synth.state.volume, (vol) => synth.poly && synth.poly.volume.rampTo(gainToDb(vol)));
      watch(synth.params, (params) => {
        if (synth.poly) {
          synth.poly.set(params);
        }
      }, { deep: true, immediate: true });
      watch(() => midi.note, (note3) => {
        if (!synth.state.midi)
          return;
        if (note3.velocity > 0) {
          synthAttack(Midi(note3.number).toFrequency(), note3.velocity / 127);
        } else {
          synthRelease(Midi(note3.number).toFrequency());
        }
      });
      watch(() => midi.playing, (play) => {
        if (!play)
          synthReleaseAll();
      });
    }
    return { init, synth, synthOnce, synthAttack, synthRelease, synthReleaseAll };
  }
  function init() {
    start();
    if (synth == null ? void 0 : synth.poly)
      return;
    const { channel } = createChannel("synth");
    synth.widener = new StereoWidener(0.7).connect(channel);
    synth.reverb = new Reverb(3).connect(synth.widener);
    synth.delay = new PingPongDelay({ delayTime: "16n", feedback: 0.3, wet: 0.3, maxDelay: "4n" }).connect(synth.widener);
    synth.pan = new AutoPanner({ frequency: "4n", depth: 0.4 }).connect(synth.reverb).connect(synth.delay).connect(synth.widener);
    synth.compressor = new Compressor().connect(synth.pan);
    synth.poly = new PolySynth(MonoSynth, synth.params).connect(synth.compressor);
    synth.pan.start();
  }
  function synthOnce(note3 = "A4", duration2 = "8n", time) {
    if (!synth.poly || synth.state.mute)
      return init();
    synth.poly.triggerAttackRelease(note3, duration2, time);
  }
  function synthAttack(note3, velocity) {
    if (!synth.poly || synth.state.mute)
      return init();
    synth.poly.triggerAttack(note3, synth.state.quantize.state, velocity);
  }
  function synthRelease(note3) {
    if (!synth.poly || synth.state.mute)
      return init();
    synth.poly.triggerRelease(note3, synth.state.quantize.state);
  }
  function synthReleaseAll() {
    if (!synth.poly || synth.state.mute)
      return init();
    synth.poly.releaseAll();
  }

  // node_modules/.pnpm/@tonaljs+core@4.6.5/node_modules/@tonaljs/core/dist/index.es.js
  var fillStr = (s4, n8) => Array(Math.abs(n8) + 1).join(s4);
  function deprecate(original, alternative, fn) {
    return function(...args) {
      console.warn(`${original} is deprecated. Use ${alternative}.`);
      return fn.apply(this, args);
    };
  }
  function isNamed(src) {
    return src !== null && typeof src === "object" && typeof src.name === "string" ? true : false;
  }
  function isPitch(pitch) {
    return pitch !== null && typeof pitch === "object" && typeof pitch.step === "number" && typeof pitch.alt === "number" ? true : false;
  }
  var FIFTHS = [0, 2, 4, -1, 1, 3, 5];
  var STEPS_TO_OCTS = FIFTHS.map((fifths) => Math.floor(fifths * 7 / 12));
  function encode(pitch) {
    const { step, alt, oct, dir = 1 } = pitch;
    const f4 = FIFTHS[step] + 7 * alt;
    if (oct === void 0) {
      return [dir * f4];
    }
    const o8 = oct - STEPS_TO_OCTS[step] - 4 * alt;
    return [dir * f4, dir * o8];
  }
  var FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];
  function decode(coord) {
    const [f4, o8, dir] = coord;
    const step = FIFTHS_TO_STEPS[unaltered(f4)];
    const alt = Math.floor((f4 + 1) / 7);
    if (o8 === void 0) {
      return { step, alt, dir };
    }
    const oct = o8 + 4 * alt + STEPS_TO_OCTS[step];
    return { step, alt, oct, dir };
  }
  function unaltered(f4) {
    const i8 = (f4 + 1) % 7;
    return i8 < 0 ? 7 + i8 : i8;
  }
  var NoNote = { empty: true, name: "", pc: "", acc: "" };
  var cache$1 = /* @__PURE__ */ new Map();
  var stepToLetter = (step) => "CDEFGAB".charAt(step);
  var altToAcc = (alt) => alt < 0 ? fillStr("b", -alt) : fillStr("#", alt);
  var accToAlt = (acc) => acc[0] === "b" ? -acc.length : acc.length;
  function note(src) {
    const cached = cache$1.get(src);
    if (cached) {
      return cached;
    }
    const value = typeof src === "string" ? parse$1(src) : isPitch(src) ? note(pitchName$1(src)) : isNamed(src) ? note(src.name) : NoNote;
    cache$1.set(src, value);
    return value;
  }
  var REGEX$1 = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
  function tokenizeNote(str) {
    const m3 = REGEX$1.exec(str);
    return [m3[1].toUpperCase(), m3[2].replace(/x/g, "##"), m3[3], m3[4]];
  }
  function coordToNote(noteCoord) {
    return note(decode(noteCoord));
  }
  var mod = (n8, m3) => (n8 % m3 + m3) % m3;
  var SEMI = [0, 2, 4, 5, 7, 9, 11];
  function parse$1(noteName) {
    const tokens = tokenizeNote(noteName);
    if (tokens[0] === "" || tokens[3] !== "") {
      return NoNote;
    }
    const letter = tokens[0];
    const acc = tokens[1];
    const octStr = tokens[2];
    const step = (letter.charCodeAt(0) + 3) % 7;
    const alt = accToAlt(acc);
    const oct = octStr.length ? +octStr : void 0;
    const coord = encode({ step, alt, oct });
    const name2 = letter + acc + octStr;
    const pc = letter + acc;
    const chroma3 = (SEMI[step] + alt + 120) % 12;
    const height = oct === void 0 ? mod(SEMI[step] + alt, 12) - 12 * 99 : SEMI[step] + alt + 12 * (oct + 1);
    const midi4 = height >= 0 && height <= 127 ? height : null;
    const freq2 = oct === void 0 ? null : Math.pow(2, (height - 69) / 12) * 440;
    return {
      empty: false,
      acc,
      alt,
      chroma: chroma3,
      coord,
      freq: freq2,
      height,
      letter,
      midi: midi4,
      name: name2,
      oct,
      pc,
      step
    };
  }
  function pitchName$1(props) {
    const { step, alt, oct } = props;
    const letter = stepToLetter(step);
    if (!letter) {
      return "";
    }
    const pc = letter + altToAcc(alt);
    return oct || oct === 0 ? pc + oct : pc;
  }
  var NoInterval = { empty: true, name: "", acc: "" };
  var INTERVAL_TONAL_REGEX = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
  var INTERVAL_SHORTHAND_REGEX = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
  var REGEX = new RegExp("^" + INTERVAL_TONAL_REGEX + "|" + INTERVAL_SHORTHAND_REGEX + "$");
  function tokenizeInterval(str) {
    const m3 = REGEX.exec(`${str}`);
    if (m3 === null) {
      return ["", ""];
    }
    return m3[1] ? [m3[1], m3[2]] : [m3[4], m3[3]];
  }
  var cache = {};
  function interval(src) {
    return typeof src === "string" ? cache[src] || (cache[src] = parse2(src)) : isPitch(src) ? interval(pitchName(src)) : isNamed(src) ? interval(src.name) : NoInterval;
  }
  var SIZES = [0, 2, 4, 5, 7, 9, 11];
  var TYPES = "PMMPPMM";
  function parse2(str) {
    const tokens = tokenizeInterval(str);
    if (tokens[0] === "") {
      return NoInterval;
    }
    const num2 = +tokens[0];
    const q = tokens[1];
    const step = (Math.abs(num2) - 1) % 7;
    const t8 = TYPES[step];
    if (t8 === "M" && q === "P") {
      return NoInterval;
    }
    const type = t8 === "M" ? "majorable" : "perfectable";
    const name2 = "" + num2 + q;
    const dir = num2 < 0 ? -1 : 1;
    const simple = num2 === 8 || num2 === -8 ? num2 : dir * (step + 1);
    const alt = qToAlt(type, q);
    const oct = Math.floor((Math.abs(num2) - 1) / 7);
    const semitones = dir * (SIZES[step] + alt + 12 * oct);
    const chroma3 = (dir * (SIZES[step] + alt) % 12 + 12) % 12;
    const coord = encode({ step, alt, oct, dir });
    return {
      empty: false,
      name: name2,
      num: num2,
      q,
      step,
      alt,
      dir,
      type,
      simple,
      semitones,
      chroma: chroma3,
      coord,
      oct
    };
  }
  function coordToInterval(coord, forceDescending) {
    const [f4, o8 = 0] = coord;
    const isDescending = f4 * 7 + o8 * 12 < 0;
    const ivl = forceDescending || isDescending ? [-f4, -o8, -1] : [f4, o8, 1];
    return interval(decode(ivl));
  }
  function qToAlt(type, q) {
    return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
  }
  function pitchName(props) {
    const { step, alt, oct = 0, dir } = props;
    if (!dir) {
      return "";
    }
    const calcNum = step + 1 + 7 * oct;
    const num2 = calcNum === 0 ? step + 1 : calcNum;
    const d5 = dir < 0 ? "-" : "";
    const type = TYPES[step] === "M" ? "majorable" : "perfectable";
    const name2 = d5 + num2 + altToQ(type, alt);
    return name2;
  }
  function altToQ(type, alt) {
    if (alt === 0) {
      return type === "majorable" ? "M" : "P";
    } else if (alt === -1 && type === "majorable") {
      return "m";
    } else if (alt > 0) {
      return fillStr("A", alt);
    } else {
      return fillStr("d", type === "perfectable" ? alt : alt + 1);
    }
  }
  function transpose(noteName, intervalName) {
    const note$1 = note(noteName);
    const interval$1 = interval(intervalName);
    if (note$1.empty || interval$1.empty) {
      return "";
    }
    const noteCoord = note$1.coord;
    const intervalCoord = interval$1.coord;
    const tr2 = noteCoord.length === 1 ? [noteCoord[0] + intervalCoord[0]] : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];
    return coordToNote(tr2).name;
  }
  function distance(fromNote, toNote) {
    const from = note(fromNote);
    const to = note(toNote);
    if (from.empty || to.empty) {
      return "";
    }
    const fcoord = from.coord;
    const tcoord = to.coord;
    const fifths = tcoord[0] - fcoord[0];
    const octs = fcoord.length === 2 && tcoord.length === 2 ? tcoord[1] - fcoord[1] : -Math.floor(fifths * 7 / 12);
    const forceDescending = to.height === from.height && to.midi !== null && from.midi !== null && from.step > to.step;
    return coordToInterval([fifths, octs], forceDescending).name;
  }

  // node_modules/.pnpm/@tonaljs+collection@4.6.2/node_modules/@tonaljs/collection/dist/index.es.js
  function ascR(b5, n8) {
    const a8 = [];
    for (; n8--; a8[n8] = n8 + b5)
      ;
    return a8;
  }
  function descR(b5, n8) {
    const a8 = [];
    for (; n8--; a8[n8] = b5 - n8)
      ;
    return a8;
  }
  function range3(from, to) {
    return from < to ? ascR(from, to - from + 1) : descR(from, from - to + 1);
  }
  function rotate(times, arr) {
    const len = arr.length;
    const n8 = (times % len + len) % len;
    return arr.slice(n8, len).concat(arr.slice(0, n8));
  }
  function compact(arr) {
    return arr.filter((n8) => n8 === 0 || n8);
  }

  // node_modules/.pnpm/@tonaljs+pcset@4.6.5/node_modules/@tonaljs/pcset/dist/index.es.js
  var EmptyPcset = {
    empty: true,
    name: "",
    setNum: 0,
    chroma: "000000000000",
    normalized: "000000000000",
    intervals: []
  };
  var setNumToChroma = (num2) => Number(num2).toString(2);
  var chromaToNumber = (chroma3) => parseInt(chroma3, 2);
  var REGEX2 = /^[01]{12}$/;
  function isChroma(set3) {
    return REGEX2.test(set3);
  }
  var isPcsetNum = (set3) => typeof set3 === "number" && set3 >= 0 && set3 <= 4095;
  var isPcset = (set3) => set3 && isChroma(set3.chroma);
  var cache2 = { [EmptyPcset.chroma]: EmptyPcset };
  function get2(src) {
    const chroma3 = isChroma(src) ? src : isPcsetNum(src) ? setNumToChroma(src) : Array.isArray(src) ? listToChroma(src) : isPcset(src) ? src.chroma : EmptyPcset.chroma;
    return cache2[chroma3] = cache2[chroma3] || chromaToPcset(chroma3);
  }
  var pcset = deprecate("Pcset.pcset", "Pcset.get", get2);
  var chroma = (set3) => get2(set3).chroma;
  var intervals = (set3) => get2(set3).intervals;
  var num = (set3) => get2(set3).setNum;
  var IVLS = [
    "1P",
    "2m",
    "2M",
    "3m",
    "3M",
    "4P",
    "5d",
    "5P",
    "6m",
    "6M",
    "7m",
    "7M"
  ];
  function chromaToIntervals(chroma3) {
    const intervals3 = [];
    for (let i8 = 0; i8 < 12; i8++) {
      if (chroma3.charAt(i8) === "1")
        intervals3.push(IVLS[i8]);
    }
    return intervals3;
  }
  function chromas() {
    return range3(2048, 4095).map(setNumToChroma);
  }
  function modes(set3, normalize = true) {
    const pcs = get2(set3);
    const binary = pcs.chroma.split("");
    return compact(binary.map((_, i8) => {
      const r8 = rotate(i8, binary);
      return normalize && r8[0] === "0" ? null : r8.join("");
    }));
  }
  function isEqual(s1, s22) {
    return get2(s1).setNum === get2(s22).setNum;
  }
  function isSubsetOf(set3) {
    const s4 = get2(set3).setNum;
    return (notes2) => {
      const o8 = get2(notes2).setNum;
      return s4 && s4 !== o8 && (o8 & s4) === o8;
    };
  }
  function isSupersetOf(set3) {
    const s4 = get2(set3).setNum;
    return (notes2) => {
      const o8 = get2(notes2).setNum;
      return s4 && s4 !== o8 && (o8 | s4) === o8;
    };
  }
  function isNoteIncludedIn(set3) {
    const s4 = get2(set3);
    return (noteName) => {
      const n8 = note(noteName);
      return s4 && !n8.empty && s4.chroma.charAt(n8.chroma) === "1";
    };
  }
  function filter(set3) {
    const isIncluded = isNoteIncludedIn(set3);
    return (notes2) => {
      return notes2.filter(isIncluded);
    };
  }
  var index = {
    get: get2,
    chroma,
    num,
    intervals,
    chromas,
    isSupersetOf,
    isSubsetOf,
    isNoteIncludedIn,
    isEqual,
    filter,
    modes,
    pcset
  };
  function chromaRotations(chroma3) {
    const binary = chroma3.split("");
    return binary.map((_, i8) => rotate(i8, binary).join(""));
  }
  function chromaToPcset(chroma3) {
    const setNum = chromaToNumber(chroma3);
    const normalizedNum = chromaRotations(chroma3).map(chromaToNumber).filter((n8) => n8 >= 2048).sort()[0];
    const normalized = setNumToChroma(normalizedNum);
    const intervals3 = chromaToIntervals(chroma3);
    return {
      empty: false,
      name: "",
      setNum,
      chroma: chroma3,
      normalized,
      intervals: intervals3
    };
  }
  function listToChroma(set3) {
    if (set3.length === 0) {
      return EmptyPcset.chroma;
    }
    let pitch;
    const binary = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (let i8 = 0; i8 < set3.length; i8++) {
      pitch = note(set3[i8]);
      if (pitch.empty)
        pitch = interval(set3[i8]);
      if (!pitch.empty)
        binary[pitch.chroma] = 1;
    }
    return binary.join("");
  }

  // node_modules/.pnpm/@tonaljs+chord-type@4.6.5/node_modules/@tonaljs/chord-type/dist/index.es.js
  var CHORDS = [
    ["1P 3M 5P", "major", "M ^ "],
    ["1P 3M 5P 7M", "major seventh", "maj7 \u0394 ma7 M7 Maj7 ^7"],
    ["1P 3M 5P 7M 9M", "major ninth", "maj9 \u03949 ^9"],
    ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
    ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
    ["1P 3M 5P 6M 9M", "sixth/ninth", "6/9 69 M69"],
    ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
    [
      "1P 3M 5P 7M 11A",
      "major seventh sharp eleventh",
      "maj#4 \u0394#4 \u0394#11 M7#11 ^7#11 maj7#11"
    ],
    ["1P 3m 5P", "minor", "m min -"],
    ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
    [
      "1P 3m 5P 7M",
      "minor/major seventh",
      "m/ma7 m/maj7 mM7 mMaj7 m/M7 -\u03947 m\u0394 -^7"
    ],
    ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
    ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
    ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
    ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
    ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
    ["1P 3m 5d", "diminished", "dim \xB0 o"],
    ["1P 3m 5d 7d", "diminished seventh", "dim7 \xB07 o7"],
    ["1P 3m 5d 7m", "half-diminished", "m7b5 \xF8 -7b5 h7 h"],
    ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
    ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
    ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
    ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
    ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
    ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
    ["1P 3M 7m 9m", "altered", "alt7"],
    ["1P 4P 5P", "suspended fourth", "sus4 sus"],
    ["1P 2M 5P", "suspended second", "sus2"],
    ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
    ["1P 5P 7m 9M 11P", "eleventh", "11"],
    [
      "1P 4P 5P 7m 9m",
      "suspended fourth flat ninth",
      "b9sus phryg 7b9sus 7b9sus4"
    ],
    ["1P 5P", "fifth", "5"],
    ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
    ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
    ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
    [
      "1P 3M 5P 7M 9M 11A",
      "major sharp eleventh (lydian)",
      "maj9#11 \u03949#11 ^9#11"
    ],
    ["1P 2M 4P 5P", "", "sus24 sus4add9"],
    ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
    ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
    ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
    ["1P 3M 5A 7m 9M", "", "9#5 9+"],
    ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
    ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
    ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
    ["1P 3M 5A 9A", "", "+add#9"],
    ["1P 3M 5A 9M", "", "M#5add9 +add9"],
    ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
    ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
    ["1P 3M 5P 6M 9M 11A", "", "69#11"],
    ["1P 3m 5P 6M 9M", "", "m69 -69"],
    ["1P 3M 5P 6m 7m", "", "7b6"],
    ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
    ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
    ["1P 3M 5P 7M 9m", "", "M7b9"],
    ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
    ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
    ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
    ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
    ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
    ["1P 3M 5P 7m 9A 13M", "", "13#9"],
    ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
    ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
    ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
    ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
    ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
    ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
    ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
    ["1P 3M 5P 7m 9m 13M", "", "13b9"],
    ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
    ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
    ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
    ["1P 3M 5P 9m", "", "Maddb9"],
    ["1P 3M 5d", "", "Mb5"],
    ["1P 3M 5d 6M 7m 9M", "", "13b5"],
    ["1P 3M 5d 7M", "", "M7b5"],
    ["1P 3M 5d 7M 9M", "", "M9b5"],
    ["1P 3M 5d 7m", "", "7b5"],
    ["1P 3M 5d 7m 9M", "", "9b5"],
    ["1P 3M 7m", "", "7no5"],
    ["1P 3M 7m 13m", "", "7b13"],
    ["1P 3M 7m 9M", "", "9no5"],
    ["1P 3M 7m 9M 13M", "", "13no5"],
    ["1P 3M 7m 9M 13m", "", "9b13"],
    ["1P 3m 4P 5P", "", "madd4"],
    ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
    ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
    ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
    ["1P 3m 5P 9M", "", "madd9"],
    ["1P 3m 5d 6M 7M", "", "o7M7"],
    ["1P 3m 5d 7M", "", "oM7"],
    ["1P 3m 6m 7M", "", "mb6M7"],
    ["1P 3m 6m 7m", "", "m7#5"],
    ["1P 3m 6m 7m 9M", "", "m9#5"],
    ["1P 3m 5A 7m 9M 11P", "", "m11A"],
    ["1P 3m 6m 9m", "", "mb6b9"],
    ["1P 2M 3m 5d 7m", "", "m9b5"],
    ["1P 4P 5A 7M", "", "M7#5sus4"],
    ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
    ["1P 4P 5A 7m", "", "7#5sus4"],
    ["1P 4P 5P 7M", "", "M7sus4"],
    ["1P 4P 5P 7M 9M", "", "M9sus4"],
    ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
    ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
    ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
    ["1P 4P 7m 10m", "", "4 quartal"],
    ["1P 5P 7m 9m 11P", "", "11b9"]
  ];
  var NoChordType = {
    ...EmptyPcset,
    name: "",
    quality: "Unknown",
    intervals: [],
    aliases: []
  };
  var dictionary = [];
  var index2 = {};
  function get3(type) {
    return index2[type] || NoChordType;
  }
  var chordType = deprecate("ChordType.chordType", "ChordType.get", get3);
  function names() {
    return dictionary.map((chord2) => chord2.name).filter((x4) => x4);
  }
  function symbols() {
    return dictionary.map((chord2) => chord2.aliases[0]).filter((x4) => x4);
  }
  function keys() {
    return Object.keys(index2);
  }
  function all() {
    return dictionary.slice();
  }
  var entries = deprecate("ChordType.entries", "ChordType.all", all);
  function removeAll() {
    dictionary = [];
    index2 = {};
  }
  function add2(intervals3, aliases, fullName) {
    const quality = getQuality(intervals3);
    const chord2 = {
      ...get2(intervals3),
      name: fullName || "",
      quality,
      intervals: intervals3,
      aliases
    };
    dictionary.push(chord2);
    if (chord2.name) {
      index2[chord2.name] = chord2;
    }
    index2[chord2.setNum] = chord2;
    index2[chord2.chroma] = chord2;
    chord2.aliases.forEach((alias) => addAlias(chord2, alias));
  }
  function addAlias(chord2, alias) {
    index2[alias] = chord2;
  }
  function getQuality(intervals3) {
    const has2 = (interval2) => intervals3.indexOf(interval2) !== -1;
    return has2("5A") ? "Augmented" : has2("3M") ? "Major" : has2("5d") ? "Diminished" : has2("3m") ? "Minor" : "Unknown";
  }
  CHORDS.forEach(([ivls, fullName, names5]) => add2(ivls.split(" "), names5.split(" "), fullName));
  dictionary.sort((a8, b5) => a8.setNum - b5.setNum);
  var index$1 = {
    names,
    symbols,
    get: get3,
    all,
    add: add2,
    removeAll,
    keys,
    entries,
    chordType
  };

  // node_modules/.pnpm/@tonaljs+scale-type@4.6.5/node_modules/@tonaljs/scale-type/dist/index.es.js
  var SCALES = [
    ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
    ["1P 3M 4P 5P 7M", "ionian pentatonic"],
    ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
    ["1P 2M 4P 5P 6M", "ritusen"],
    ["1P 2M 4P 5P 7m", "egyptian"],
    ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
    ["1P 3m 4P 5P 6m", "vietnamese 1"],
    ["1P 2m 3m 5P 6m", "pelog"],
    ["1P 2m 4P 5P 6m", "kumoijoshi"],
    ["1P 2M 3m 5P 6m", "hirajoshi"],
    ["1P 2m 4P 5d 7m", "iwato"],
    ["1P 2m 4P 5P 7m", "in-sen"],
    ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
    ["1P 3m 4P 6m 7m", "malkos raga"],
    ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
    ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
    ["1P 3m 4P 5P 6M", "minor six pentatonic"],
    ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
    ["1P 2M 3M 5P 6m", "flat six pentatonic"],
    ["1P 2m 3M 5P 6M", "scriabin"],
    ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
    ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
    ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
    ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
    ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
    ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
    ["1P 2A 3M 5P 5A 7M", "augmented"],
    ["1P 2M 3m 3M 5P 6M", "major blues"],
    ["1P 2M 4P 5P 6M 7m", "piongio"],
    ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
    ["1P 2M 3M 4A 6M 7m", "prometheus"],
    ["1P 2m 3M 5d 6m 7m", "mystery #1"],
    ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
    ["1P 2M 3M 4A 5A 7m", "whole tone", "messiaen's mode #1"],
    ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
    ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
    ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
    ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
    ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
    [
      "1P 2m 2A 3M 4A 6m 7m",
      "altered",
      "super locrian",
      "diminished whole tone",
      "pomeroy"
    ],
    ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
    [
      "1P 2M 3M 4P 5P 6m 7m",
      "mixolydian b6",
      "melodic minor fifth mode",
      "hindu"
    ],
    ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
    ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
    ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
    [
      "1P 2m 3m 4P 5P 6M 7m",
      "dorian b2",
      "phrygian #6",
      "melodic minor second mode"
    ],
    ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
    ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
    [
      "1P 2m 3m 4d 5d 6m 7d",
      "ultralocrian",
      "superlocrian bb7",
      "superlocrian diminished"
    ],
    ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
    ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
    [
      "1P 2M 3m 4A 5P 6M 7m",
      "dorian #4",
      "ukrainian dorian",
      "romanian minor",
      "altered dorian"
    ],
    ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
    ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
    ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
    ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
    ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
    ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
    ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
    ["1P 2M 3m 4P 5P 6m 7m", "aeolian", "minor"],
    ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
    ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
    ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
    ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
    ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
    ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
    ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
    ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
    ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
    ["1P 2m 3M 4P 5d 6m 7M", "persian"],
    ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
    ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
    [
      "1P 2M 3M 4P 5A 6M 7M",
      "major augmented",
      "major #5",
      "ionian augmented",
      "ionian #5"
    ],
    ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
    ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
    ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
    ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
    ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
    ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
    ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
    ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
    ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
    ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
    ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
    ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
    [
      "1P 2m 3m 3M 4A 5P 6M 7m",
      "half-whole diminished",
      "dominant diminished",
      "messiaen's mode #2"
    ],
    ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
    ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
    ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
    ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
    ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
    ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
  ];
  var NoScaleType = {
    ...EmptyPcset,
    intervals: [],
    aliases: []
  };
  var dictionary2 = [];
  var index3 = {};
  function names2() {
    return dictionary2.map((scale2) => scale2.name);
  }
  function get4(type) {
    return index3[type] || NoScaleType;
  }
  var scaleType = deprecate("ScaleDictionary.scaleType", "ScaleType.get", get4);
  function all2() {
    return dictionary2.slice();
  }
  var entries2 = deprecate("ScaleDictionary.entries", "ScaleType.all", all2);
  function keys2() {
    return Object.keys(index3);
  }
  function removeAll2() {
    dictionary2 = [];
    index3 = {};
  }
  function add3(intervals3, name2, aliases = []) {
    const scale2 = { ...get2(intervals3), name: name2, intervals: intervals3, aliases };
    dictionary2.push(scale2);
    index3[scale2.name] = scale2;
    index3[scale2.setNum] = scale2;
    index3[scale2.chroma] = scale2;
    scale2.aliases.forEach((alias) => addAlias2(scale2, alias));
    return scale2;
  }
  function addAlias2(scale2, alias) {
    index3[alias] = scale2;
  }
  SCALES.forEach(([ivls, name2, ...aliases]) => add3(ivls.split(" "), name2, aliases));
  var index$12 = {
    names: names2,
    get: get4,
    all: all2,
    add: add3,
    removeAll: removeAll2,
    keys: keys2,
    entries: entries2,
    scaleType
  };

  // node_modules/.pnpm/@tonaljs+chord@4.6.5/node_modules/@tonaljs/chord/dist/index.es.js
  var NoChord = {
    empty: true,
    name: "",
    symbol: "",
    root: "",
    rootDegree: 0,
    type: "",
    tonic: null,
    setNum: NaN,
    quality: "Unknown",
    chroma: "",
    normalized: "",
    aliases: [],
    notes: [],
    intervals: []
  };
  var NUM_TYPES = /^(6|64|7|9|11|13)$/;
  function tokenize(name2) {
    const [letter, acc, oct, type] = tokenizeNote(name2);
    if (letter === "") {
      return ["", name2];
    }
    if (letter === "A" && type === "ug") {
      return ["", "aug"];
    }
    if (!type && (oct === "4" || oct === "5")) {
      return [letter + acc, oct];
    }
    if (NUM_TYPES.test(oct)) {
      return [letter + acc, oct + type];
    } else {
      return [letter + acc + oct, type];
    }
  }
  function get5(src) {
    if (src === "") {
      return NoChord;
    }
    if (Array.isArray(src) && src.length === 2) {
      return getChord(src[1], src[0]);
    } else {
      const [tonic, type] = tokenize(src);
      const chord2 = getChord(type, tonic);
      return chord2.empty ? getChord(src) : chord2;
    }
  }
  function getChord(typeName, optionalTonic, optionalRoot) {
    const type = get3(typeName);
    const tonic = note(optionalTonic || "");
    const root = note(optionalRoot || "");
    if (type.empty || optionalTonic && tonic.empty || optionalRoot && root.empty) {
      return NoChord;
    }
    const rootInterval = distance(tonic.pc, root.pc);
    const rootDegree = type.intervals.indexOf(rootInterval) + 1;
    if (!root.empty && !rootDegree) {
      return NoChord;
    }
    const intervals3 = Array.from(type.intervals);
    for (let i8 = 1; i8 < rootDegree; i8++) {
      const num2 = intervals3[0][0];
      const quality = intervals3[0][1];
      const newNum = parseInt(num2, 10) + 7;
      intervals3.push(`${newNum}${quality}`);
      intervals3.shift();
    }
    const notes2 = tonic.empty ? [] : intervals3.map((i8) => transpose(tonic, i8));
    typeName = type.aliases.indexOf(typeName) !== -1 ? typeName : type.aliases[0];
    const symbol = `${tonic.empty ? "" : tonic.pc}${typeName}${root.empty || rootDegree <= 1 ? "" : "/" + root.pc}`;
    const name2 = `${optionalTonic ? tonic.pc + " " : ""}${type.name}${rootDegree > 1 && optionalRoot ? " over " + root.pc : ""}`;
    return {
      ...type,
      name: name2,
      symbol,
      type: type.name,
      root: root.name,
      intervals: intervals3,
      rootDegree,
      tonic: tonic.name,
      notes: notes2
    };
  }
  var chord = deprecate("Chord.chord", "Chord.get", get5);

  // node_modules/.pnpm/@tonaljs+duration-value@4.6.2/node_modules/@tonaljs/duration-value/dist/index.es.js
  var DATA = [
    [
      0.125,
      "dl",
      ["large", "duplex longa", "maxima", "octuple", "octuple whole"]
    ],
    [0.25, "l", ["long", "longa"]],
    [0.5, "d", ["double whole", "double", "breve"]],
    [1, "w", ["whole", "semibreve"]],
    [2, "h", ["half", "minim"]],
    [4, "q", ["quarter", "crotchet"]],
    [8, "e", ["eighth", "quaver"]],
    [16, "s", ["sixteenth", "semiquaver"]],
    [32, "t", ["thirty-second", "demisemiquaver"]],
    [64, "sf", ["sixty-fourth", "hemidemisemiquaver"]],
    [128, "h", ["hundred twenty-eighth"]],
    [256, "th", ["two hundred fifty-sixth"]]
  ];
  var VALUES = [];
  DATA.forEach(([denominator, shorthand, names5]) => add4(denominator, shorthand, names5));
  function add4(denominator, shorthand, names5) {
    VALUES.push({
      empty: false,
      dots: "",
      name: "",
      value: 1 / denominator,
      fraction: denominator < 1 ? [1 / denominator, 1] : [1, denominator],
      shorthand,
      names: names5
    });
  }

  // node_modules/.pnpm/@tonaljs+interval@4.6.5/node_modules/@tonaljs/interval/dist/index.es.js
  var IQ = "P m M m M P d P m M m M".split(" ");
  var add5 = combinator((a8, b5) => [a8[0] + b5[0], a8[1] + b5[1]]);
  var substract = combinator((a8, b5) => [a8[0] - b5[0], a8[1] - b5[1]]);
  function combinator(fn) {
    return (a8, b5) => {
      const coordA = interval(a8).coord;
      const coordB = interval(b5).coord;
      if (coordA && coordB) {
        const coord = fn(coordA, coordB);
        return coordToInterval(coord).name;
      }
    };
  }

  // node_modules/.pnpm/@tonaljs+midi@4.6.5/node_modules/@tonaljs/midi/dist/index.es.js
  var L2 = Math.log(2);
  var L440 = Math.log(440);
  function freqToMidi(freq2) {
    const v3 = 12 * (Math.log(freq2) - L440) / L2 + 69;
    return Math.round(v3 * 100) / 100;
  }
  var SHARPS = "C C# D D# E F F# G G# A A# B".split(" ");
  var FLATS = "C Db D Eb E F Gb G Ab A Bb B".split(" ");
  function midiToNoteName(midi4, options2 = {}) {
    if (isNaN(midi4) || midi4 === -Infinity || midi4 === Infinity)
      return "";
    midi4 = Math.round(midi4);
    const pcs = options2.sharps === true ? SHARPS : FLATS;
    const pc = pcs[midi4 % 12];
    if (options2.pitchClass) {
      return pc;
    }
    const o8 = Math.floor(midi4 / 12) - 1;
    return pc + o8;
  }

  // node_modules/.pnpm/@tonaljs+note@4.6.5/node_modules/@tonaljs/note/dist/index.es.js
  var NAMES = ["C", "D", "E", "F", "G", "A", "B"];
  var toName = (n8) => n8.name;
  var onlyNotes = (array) => array.map(note).filter((n8) => !n8.empty);
  function names3(array) {
    if (array === void 0) {
      return NAMES.slice();
    } else if (!Array.isArray(array)) {
      return [];
    } else {
      return onlyNotes(array).map(toName);
    }
  }
  var get6 = note;
  var name = (note3) => get6(note3).name;
  var pitchClass = (note3) => get6(note3).pc;
  var accidentals = (note3) => get6(note3).acc;
  var octave = (note3) => get6(note3).oct;
  var midi2 = (note3) => get6(note3).midi;
  var freq = (note3) => get6(note3).freq;
  var chroma2 = (note3) => get6(note3).chroma;
  function fromMidi(midi4) {
    return midiToNoteName(midi4);
  }
  function fromFreq(freq2) {
    return midiToNoteName(freqToMidi(freq2));
  }
  function fromFreqSharps(freq2) {
    return midiToNoteName(freqToMidi(freq2), { sharps: true });
  }
  function fromMidiSharps(midi4) {
    return midiToNoteName(midi4, { sharps: true });
  }
  var transpose2 = transpose;
  var tr = transpose;
  var transposeBy = (interval2) => (note3) => transpose2(note3, interval2);
  var trBy = transposeBy;
  var transposeFrom = (note3) => (interval2) => transpose2(note3, interval2);
  var trFrom = transposeFrom;
  function transposeFifths(noteName, fifths) {
    const note3 = get6(noteName);
    if (note3.empty) {
      return "";
    }
    const [nFifths, nOcts] = note3.coord;
    const transposed = nOcts === void 0 ? coordToNote([nFifths + fifths]) : coordToNote([nFifths + fifths, nOcts]);
    return transposed.name;
  }
  var trFifths = transposeFifths;
  var ascending = (a8, b5) => a8.height - b5.height;
  var descending = (a8, b5) => b5.height - a8.height;
  function sortedNames(notes2, comparator) {
    comparator = comparator || ascending;
    return onlyNotes(notes2).sort(comparator).map(toName);
  }
  function sortedUniqNames(notes2) {
    return sortedNames(notes2, ascending).filter((n8, i8, a8) => i8 === 0 || n8 !== a8[i8 - 1]);
  }
  var simplify = (noteName) => {
    const note3 = get6(noteName);
    if (note3.empty) {
      return "";
    }
    return midiToNoteName(note3.midi || note3.chroma, {
      sharps: note3.alt > 0,
      pitchClass: note3.midi === null
    });
  };
  function enharmonic(noteName, destName) {
    const src = get6(noteName);
    if (src.empty) {
      return "";
    }
    const dest = get6(destName || midiToNoteName(src.midi || src.chroma, {
      sharps: src.alt < 0,
      pitchClass: true
    }));
    if (dest.empty || dest.chroma !== src.chroma) {
      return "";
    }
    if (src.oct === void 0) {
      return dest.pc;
    }
    const srcChroma = src.chroma - src.alt;
    const destChroma = dest.chroma - dest.alt;
    const destOctOffset = srcChroma > 11 || destChroma < 0 ? -1 : srcChroma < 0 || destChroma > 11 ? 1 : 0;
    const destOct = src.oct + destOctOffset;
    return dest.pc + destOct;
  }
  var index4 = {
    names: names3,
    get: get6,
    name,
    pitchClass,
    accidentals,
    octave,
    midi: midi2,
    ascending,
    descending,
    sortedNames,
    sortedUniqNames,
    fromMidi,
    fromMidiSharps,
    freq,
    fromFreq,
    fromFreqSharps,
    chroma: chroma2,
    transpose: transpose2,
    tr,
    transposeBy,
    trBy,
    transposeFrom,
    trFrom,
    transposeFifths,
    trFifths,
    simplify,
    enharmonic
  };

  // node_modules/.pnpm/@tonaljs+roman-numeral@4.6.5/node_modules/@tonaljs/roman-numeral/dist/index.es.js
  var NoRomanNumeral = { empty: true, name: "", chordType: "" };
  var cache3 = {};
  function get7(src) {
    return typeof src === "string" ? cache3[src] || (cache3[src] = parse3(src)) : typeof src === "number" ? get7(NAMES2[src] || "") : isPitch(src) ? fromPitch(src) : isNamed(src) ? get7(src.name) : NoRomanNumeral;
  }
  var romanNumeral = deprecate("RomanNumeral.romanNumeral", "RomanNumeral.get", get7);
  function fromPitch(pitch) {
    return get7(altToAcc(pitch.alt) + NAMES2[pitch.step]);
  }
  var REGEX3 = /^(#{1,}|b{1,}|x{1,}|)(IV|I{1,3}|VI{0,2}|iv|i{1,3}|vi{0,2})([^IViv]*)$/;
  function tokenize2(str) {
    return REGEX3.exec(str) || ["", "", "", ""];
  }
  var ROMANS = "I II III IV V VI VII";
  var NAMES2 = ROMANS.split(" ");
  var NAMES_MINOR = ROMANS.toLowerCase().split(" ");
  function parse3(src) {
    const [name2, acc, roman, chordType3] = tokenize2(src);
    if (!roman) {
      return NoRomanNumeral;
    }
    const upperRoman = roman.toUpperCase();
    const step = NAMES2.indexOf(upperRoman);
    const alt = accToAlt(acc);
    const dir = 1;
    return {
      empty: false,
      name: name2,
      roman,
      interval: interval({ step, alt, dir }).name,
      acc,
      chordType: chordType3,
      alt,
      step,
      major: roman === upperRoman,
      oct: 0,
      dir
    };
  }

  // node_modules/.pnpm/@tonaljs+key@4.6.5/node_modules/@tonaljs/key/dist/index.es.js
  var Empty = Object.freeze([]);
  var NoKey = {
    type: "major",
    tonic: "",
    alteration: 0,
    keySignature: ""
  };
  var NoKeyScale = {
    tonic: "",
    grades: Empty,
    intervals: Empty,
    scale: Empty,
    chords: Empty,
    chordsHarmonicFunction: Empty,
    chordScales: Empty
  };
  var NoMajorKey = {
    ...NoKey,
    ...NoKeyScale,
    type: "major",
    minorRelative: "",
    scale: Empty,
    secondaryDominants: Empty,
    secondaryDominantsMinorRelative: Empty,
    substituteDominants: Empty,
    substituteDominantsMinorRelative: Empty
  };
  var NoMinorKey = {
    ...NoKey,
    type: "minor",
    relativeMajor: "",
    natural: NoKeyScale,
    harmonic: NoKeyScale,
    melodic: NoKeyScale
  };
  var mapScaleToType = (scale2, list, sep = "") => list.map((type, i8) => `${scale2[i8]}${sep}${type}`);
  function keyScale(grades, chords3, harmonicFunctions, chordScales) {
    return (tonic) => {
      const intervals3 = grades.map((gr) => get7(gr).interval || "");
      const scale2 = intervals3.map((interval2) => transpose(tonic, interval2));
      return {
        tonic,
        grades,
        intervals: intervals3,
        scale: scale2,
        chords: mapScaleToType(scale2, chords3),
        chordsHarmonicFunction: harmonicFunctions.slice(),
        chordScales: mapScaleToType(scale2, chordScales, " ")
      };
    };
  }
  var MajorScale = keyScale("I II III IV V VI VII".split(" "), "maj7 m7 m7 maj7 7 m7 m7b5".split(" "), "T SD T SD D T D".split(" "), "major,dorian,phrygian,lydian,mixolydian,minor,locrian".split(","));
  var NaturalScale = keyScale("I II bIII IV V bVI bVII".split(" "), "m7 m7b5 maj7 m7 m7 maj7 7".split(" "), "T SD T SD D SD SD".split(" "), "minor,locrian,major,dorian,phrygian,lydian,mixolydian".split(","));
  var HarmonicScale = keyScale("I II bIII IV V bVI VII".split(" "), "mMaj7 m7b5 +maj7 m7 7 maj7 o7".split(" "), "T SD T SD D SD D".split(" "), "harmonic minor,locrian 6,major augmented,lydian diminished,phrygian dominant,lydian #9,ultralocrian".split(","));
  var MelodicScale = keyScale("I II bIII IV V VI VII".split(" "), "m6 m7 +maj7 7 7 m7b5 m7b5".split(" "), "T SD T SD D  ".split(" "), "melodic minor,dorian b2,lydian augmented,lydian dominant,mixolydian b6,locrian #2,altered".split(","));

  // node_modules/.pnpm/@tonaljs+mode@4.6.5/node_modules/@tonaljs/mode/dist/index.es.js
  var MODES = [
    [0, 2773, 0, "ionian", "", "Maj7", "major"],
    [1, 2902, 2, "dorian", "m", "m7"],
    [2, 3418, 4, "phrygian", "m", "m7"],
    [3, 2741, -1, "lydian", "", "Maj7"],
    [4, 2774, 1, "mixolydian", "", "7"],
    [5, 2906, 3, "aeolian", "m", "m7", "minor"],
    [6, 3434, 5, "locrian", "dim", "m7b5"]
  ];
  var NoMode = {
    ...EmptyPcset,
    name: "",
    alt: 0,
    modeNum: NaN,
    triad: "",
    seventh: "",
    aliases: []
  };
  var modes2 = MODES.map(toMode);
  var index5 = {};
  modes2.forEach((mode2) => {
    index5[mode2.name] = mode2;
    mode2.aliases.forEach((alias) => {
      index5[alias] = mode2;
    });
  });
  function get8(name2) {
    return typeof name2 === "string" ? index5[name2.toLowerCase()] || NoMode : name2 && name2.name ? get8(name2.name) : NoMode;
  }
  var mode = deprecate("Mode.mode", "Mode.get", get8);
  function all3() {
    return modes2.slice();
  }
  var entries3 = deprecate("Mode.mode", "Mode.all", all3);
  function toMode(mode2) {
    const [modeNum, setNum, alt, name2, triad, seventh, alias] = mode2;
    const aliases = alias ? [alias] : [];
    const chroma3 = Number(setNum).toString(2);
    const intervals3 = get4(name2).intervals;
    return {
      empty: false,
      intervals: intervals3,
      modeNum,
      chroma: chroma3,
      normalized: chroma3,
      name: name2,
      setNum,
      alt,
      triad,
      seventh,
      aliases
    };
  }
  function chords(chords3) {
    return (modeName, tonic) => {
      const mode2 = get8(modeName);
      if (mode2.empty)
        return [];
      const triads2 = rotate(mode2.modeNum, chords3);
      const tonics = mode2.intervals.map((i8) => transpose(tonic, i8));
      return triads2.map((triad, i8) => tonics[i8] + triad);
    };
  }
  var triads = chords(MODES.map((x4) => x4[4]));
  var seventhChords = chords(MODES.map((x4) => x4[5]));

  // node_modules/.pnpm/@tonaljs+scale@4.6.5/node_modules/@tonaljs/scale/dist/index.es.js
  var NoScale = {
    empty: true,
    name: "",
    type: "",
    tonic: null,
    setNum: NaN,
    chroma: "",
    normalized: "",
    aliases: [],
    notes: [],
    intervals: []
  };
  function tokenize3(name2) {
    if (typeof name2 !== "string") {
      return ["", ""];
    }
    const i8 = name2.indexOf(" ");
    const tonic = note(name2.substring(0, i8));
    if (tonic.empty) {
      const n8 = note(name2);
      return n8.empty ? ["", name2] : [n8.name, ""];
    }
    const type = name2.substring(tonic.name.length + 1);
    return [tonic.name, type.length ? type : ""];
  }
  var names4 = names2;
  function get9(src) {
    const tokens = Array.isArray(src) ? src : tokenize3(src);
    const tonic = note(tokens[0]).name;
    const st = get4(tokens[1]);
    if (st.empty) {
      return NoScale;
    }
    const type = st.name;
    const notes2 = tonic ? st.intervals.map((i8) => transpose(tonic, i8)) : [];
    const name2 = tonic ? tonic + " " + type : type;
    return { ...st, name: name2, type, tonic, notes: notes2 };
  }
  var scale = deprecate("Scale.scale", "Scale.get", get9);
  function scaleChords(name2) {
    const s4 = get9(name2);
    const inScale = isSubsetOf(s4.chroma);
    return all().filter((chord2) => inScale(chord2.chroma)).map((chord2) => chord2.aliases[0]);
  }
  function extended(name2) {
    const s4 = get9(name2);
    const isSuperset = isSupersetOf(s4.chroma);
    return all2().filter((scale2) => isSuperset(scale2.chroma)).map((scale2) => scale2.name);
  }
  function reduced(name2) {
    const isSubset = isSubsetOf(get9(name2).chroma);
    return all2().filter((scale2) => isSubset(scale2.chroma)).map((scale2) => scale2.name);
  }
  function scaleNotes(notes2) {
    const pcset2 = notes2.map((n8) => note(n8).pc).filter((x4) => x4);
    const tonic = pcset2[0];
    const scale2 = sortedUniqNames(pcset2);
    return rotate(scale2.indexOf(tonic), scale2);
  }
  function modeNames(name2) {
    const s4 = get9(name2);
    if (s4.empty) {
      return [];
    }
    const tonics = s4.tonic ? s4.notes : s4.intervals;
    return modes(s4.chroma).map((chroma3, i8) => {
      const modeName = get9(chroma3).name;
      return modeName ? [tonics[i8], modeName] : ["", ""];
    }).filter((x4) => x4[0]);
  }
  function getNoteNameOf(scale2) {
    const names5 = Array.isArray(scale2) ? scaleNotes(scale2) : get9(scale2).notes;
    const chromas2 = names5.map((name2) => note(name2).chroma);
    return (noteOrMidi) => {
      const currNote = typeof noteOrMidi === "number" ? note(fromMidi(noteOrMidi)) : note(noteOrMidi);
      const height = currNote.height;
      if (height === void 0)
        return void 0;
      const chroma3 = height % 12;
      const position = chromas2.indexOf(chroma3);
      if (position === -1)
        return void 0;
      return enharmonic(currNote.name, names5[position]);
    };
  }
  function rangeOf(scale2) {
    const getName = getNoteNameOf(scale2);
    return (fromNote, toNote) => {
      const from = note(fromNote).height;
      const to = note(toNote).height;
      if (from === void 0 || to === void 0)
        return [];
      return range3(from, to).map(getName).filter((x4) => x4);
    };
  }
  var index6 = {
    get: get9,
    names: names4,
    extended,
    modeNames,
    reduced,
    scaleChords,
    scaleNotes,
    tokenize: tokenize3,
    rangeOf,
    scale
  };

  // .vitepress/use/theory.js
  index$1.add(["1P", "2m"], ["2m"], "minor second");
  index$1.add(["1P", "2M"], ["2M"], "major second");
  index$1.add(["1P", "3m"], ["3m"], "minor third");
  index$1.add(["1P", "3M"], ["3M"], "major third");
  index$1.add(["1P", "4P"], ["4P"], "perfect fourth");
  index$1.add(["1P", "5d"], ["TT"], "tritone");
  index$1.add(["1P", "5P"], ["5P"], "perfect fifth");
  index$1.add(["1P", "6m"], ["6m"], "minor sixth");
  index$1.add(["1P", "6M"], ["6M"], "major sixth");
  index$1.add(["1P", "7m"], ["7m"], "minor seventh");
  index$1.add(["1P", "7M"], ["7M"], "major seventh");
  var chordType2 = index$1;
  var scaleType2 = index$12;
  var chordList = index$1.all();
  var scaleList = index$12.all();
  var intervals2 = ["1P", "2m", "2M", "3m", "3M", "4P", "TT", "5P", "6m", "6M", "7m", "7M"];
  var noteNames = [];
  var naturals = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
  var sharps = ["G##", "A#", "A##", "B#", "C#", "C##", "D#", "D##", "E#", "F#", "F##", "G#"];
  var flats = ["Bbb", "Bb", "Cb", "Dbb", "Db", "Ebb", "Eb", "Fb", "Gbb", "Gb", "Abb", "Ab"];
  naturals.forEach((note3, n8) => {
    noteNames[note3] = n8;
  });
  sharps.forEach((note3, n8) => {
    noteNames[note3] = n8;
  });
  flats.forEach((note3, n8) => {
    noteNames[note3] = n8;
  });
  var notes = naturals;
  var chords2 = {
    min: { handle: "min", name: "Minor", semitones: [0, 3, 7] },
    maj: { handle: "maj", name: "Major", semitones: [0, 4, 7] },
    aug: { handle: "aug", name: "Augmented", semitones: [0, 4, 8] },
    dim: { handle: "dim", name: "Diminished", semitones: [0, 3, 6] },
    M7: { handle: "M7", name: "Major 7th", semitones: [0, 4, 7, 11] },
    m7: { handle: "m7", name: "Minor 7th", semitones: [0, 3, 7, 10] },
    "7": { handle: "7", name: "Dominant 7th", semitones: [0, 4, 7, 10] },
    "+7": { handle: "+7", name: "Augmented 7th", semitones: [0, 4, 8, 10] },
    o7: { handle: "o7", name: "Diminished 7th", semitones: [0, 3, 6, 9] },
    "07": { handle: "07", name: "Half-diminished 7th", semitones: [0, 3, 6, 10] },
    "+M7": { handle: "+M7", name: "Augmented major 7th", semitones: [0, 3, 7, 11] },
    "6": { handle: "6", name: "Major 6th", semitones: [0, 4, 7, 9] },
    m6: { handle: "m6", name: "Minor 6th", semitones: [0, 3, 7, 9] },
    sus2: { handle: "sus2", name: "Suspended 2nd", semitones: [0, 2, 7] },
    sus4: { handle: "sus4", name: "Suspended 4th", semitones: [0, 5, 7] },
    "9": { handle: "9", name: "9th", semitones: [0, 3, 7, 13] }
  };
  var scales = {
    major: {
      handle: "major",
      name: "Major (Ionian)",
      chords: ["maj", "", "min", "", "min", "maj", "", "7", "", "min", "", "dim"],
      steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]
    },
    minor: {
      handle: "minor",
      name: "Minor (Aeolian)",
      chords: ["min", "", "dim", "maj", "", "min", "", "min", "maj", "", "7", ""],
      steps: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]
    },
    dorian: {
      handle: "dorian",
      name: "Dorian",
      chords: ["min", "", "min", "maj", "", "7", "", "min", "", "dim", "maj", ""],
      steps: [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0]
    },
    phrygian: {
      handle: "phrygian",
      name: "Phrygian",
      chords: ["min", "maj", "", "7", "", "min", "", "dim", "maj", "", "min", ""],
      steps: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0]
    },
    lydian: {
      handle: "lydian",
      name: "Lydian",
      chords: ["maj", "", "7", "", "min", "", "dim", "maj", "", "min", "", "min"],
      steps: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1]
    },
    mixolydian: {
      handle: "mixolydian",
      name: "Mixolydian",
      chords: ["7", "", "min", "", "dim", "maj", "", "min", "", "min", "maj", ""],
      steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0]
    },
    locrian: {
      handle: "locrian",
      name: "Locrian",
      chords: ["dim", "maj", "", "min", "", "min", "maj", "", "7", "", "min", ""],
      steps: [1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0]
    },
    majorPenta: {
      handle: "majorPenta",
      name: "Major pentatonic",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0]
    },
    minorPenta: {
      handle: "minorPenta",
      name: "Minor pentatonic",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0]
    },
    acoustic: {
      handle: "acoustic",
      name: "Acoustic",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0]
    },
    adonai: {
      handle: "adonai",
      name: "Adonai malakh",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0]
    },
    algerian: {
      handle: "algerian",
      name: "Algerian",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]
    },
    augmented: {
      handle: "augmented",
      name: "Augmented",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1]
    },
    bebopDom: {
      handle: "bebopDom",
      name: "Bebop dominant",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1]
    },
    bebopMaj: {
      handle: "bebopMaj",
      name: "Bebop major",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1]
    },
    bluesHexa: {
      handle: "bluesHexa",
      name: "Blues hexatonic",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0]
    },
    doubleHarmonic: {
      handle: "doubleHarmonic",
      name: "Double harmonic",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1]
    },
    enigmatic: {
      handle: "enigmatic",
      name: "Enigmatic",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1]
    },
    gypsy: {
      handle: "gypsy",
      name: "Gypsy",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0]
    },
    halfDim: {
      handle: "halfDim",
      name: "Half diminished",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0]
    },
    harmonicMaj: {
      handle: "harmonicMaj",
      name: "Harmonic major",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1]
    },
    harmonicMin: {
      handle: "harmonicMin",
      name: "Harmonic minor",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1]
    },
    hungarianMin: {
      handle: "hungarianMin",
      name: "Hungarian minor",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]
    },
    istrian: {
      handle: "istrian",
      name: "Istrian",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0]
    },
    lydianAug: {
      handle: "lydianAug",
      name: "Lydian augmented",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1]
    },
    majLocrian: {
      handle: "majLocrian",
      name: "Major locrian",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0]
    },
    jazzMin: {
      handle: "jazzMin",
      name: "Jazz minor",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1]
    },
    neapolitanMaj: {
      handle: "neapolitanMaj",
      name: "Neapolitan major",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
    },
    neapolitanMin: {
      handle: "neapolitanMin",
      name: "Neapolitan minor",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1]
    },
    octatonic: {
      handle: "octatonic",
      name: "Octatonic (diminished)",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1]
    },
    persian: {
      handle: "persian",
      name: "Persian",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1]
    },
    phrygianDom: {
      handle: "phrygianDom",
      name: "Phrygian dominant",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0]
    },
    prometheus: {
      handle: "prometheus",
      name: "Prometheus",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0]
    },
    tritone: {
      handle: "tritone",
      name: "Tritone",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0]
    },
    ukranianDorian: {
      handle: "ukranianDorian",
      name: "Ukranian dorian",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0]
    },
    wholeTone: {
      handle: "wholeTone",
      name: "Whole tone",
      chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
      steps: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
    },
    chromatic: {
      handle: "chromatic",
      name: "Chromatic",
      chords: [
        "1/1",
        "25/24",
        "9/8",
        "6/5",
        "5/4",
        "4/3",
        "45/32",
        "3/2",
        "8/5",
        "5/3",
        "9/5",
        "15/8"
      ],
      steps: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    }
  };

  // .vitepress/use/chroma.js
  var allNotes = [...notes].map((n8, i8) => ({ name: n8, pitch: i8 }));
  var globalScale = reactive({
    tonic: useClamp2(useStorage("global-tonic", 0), 0, 11),
    note: computed(() => allNotes[globalScale.tonic]),
    chroma: useStorage("global-chroma", "101011010101"),
    set: computed(() => index$12.get(globalScale.chroma)),
    full: computed(() => {
      let sc = globalScale.note.name + "4 " + globalScale.set.name;
      return index6.get(sc);
    }),
    pcs: computed(() => index6.scaleNotes(globalScale.full.notes)),
    isIn: computed(() => index.isNoteIncludedIn(globalScale.pcs))
  });
  function getChromaNotes(chroma3 = "100010010000", tonic = globalScale.tonic) {
    let shiftChroma = rotateArray(chroma3.split(""), -tonic);
    let chOct = rotateArray(allNotes, -tonic).map((n8, i8) => {
      let noteName = Frequency(n8.pitch + tonic + 57, "midi").toNote();
      return noteName;
    });
    let filtered = chOct.filter((val, i8) => {
      if (shiftChroma[i8] == "1") {
        return true;
      }
    });
    return index4.sortedNames(filtered);
  }
  function playChromaOnce(chroma3, tonic) {
    let notes2 = getChromaNotes(chroma3, tonic);
    notes2.forEach((name2, i8) => {
      midiOnce(name2);
    });
    synthOnce(notes2, "4n");
  }
  function playChroma(chroma3, tonic) {
    let notes2 = getChromaNotes(chroma3, tonic);
    notes2.forEach((name2) => {
      midiPlay(name2);
    });
    synthAttack(notes2);
  }
  function stopChroma(chroma3, tonic) {
    let notes2 = getChromaNotes(chroma3, tonic);
    notes2.forEach((name2) => {
      midiStop(name2);
    });
    synthRelease(notes2);
  }
  function playNote(name2) {
    midiPlay(name2);
    synthAttack(name2);
  }
  function stopNote(name2) {
    midiStop(name2);
    synthRelease(name2);
  }

  // node_modules/.pnpm/colord@2.9.2/node_modules/colord/index.mjs
  var r2 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
  var t2 = function(r8) {
    return typeof r8 == "string" ? r8.length > 0 : typeof r8 == "number";
  };
  var n2 = function(r8, t8, n8) {
    return t8 === void 0 && (t8 = 0), n8 === void 0 && (n8 = Math.pow(10, t8)), Math.round(n8 * r8) / n8 + 0;
  };
  var e2 = function(r8, t8, n8) {
    return t8 === void 0 && (t8 = 0), n8 === void 0 && (n8 = 1), r8 > n8 ? n8 : r8 > t8 ? r8 : t8;
  };
  var u = function(r8) {
    return (r8 = isFinite(r8) ? r8 % 360 : 0) > 0 ? r8 : r8 + 360;
  };
  var a2 = function(r8) {
    return { r: e2(r8.r, 0, 255), g: e2(r8.g, 0, 255), b: e2(r8.b, 0, 255), a: e2(r8.a) };
  };
  var o2 = function(r8) {
    return { r: n2(r8.r), g: n2(r8.g), b: n2(r8.b), a: n2(r8.a, 3) };
  };
  var i2 = /^#([0-9a-f]{3,8})$/i;
  var s2 = function(r8) {
    var t8 = r8.toString(16);
    return t8.length < 2 ? "0" + t8 : t8;
  };
  var h3 = function(r8) {
    var t8 = r8.r, n8 = r8.g, e8 = r8.b, u7 = r8.a, a8 = Math.max(t8, n8, e8), o8 = a8 - Math.min(t8, n8, e8), i8 = o8 ? a8 === t8 ? (n8 - e8) / o8 : a8 === n8 ? 2 + (e8 - t8) / o8 : 4 + (t8 - n8) / o8 : 0;
    return { h: 60 * (i8 < 0 ? i8 + 6 : i8), s: a8 ? o8 / a8 * 100 : 0, v: a8 / 255 * 100, a: u7 };
  };
  var b = function(r8) {
    var t8 = r8.h, n8 = r8.s, e8 = r8.v, u7 = r8.a;
    t8 = t8 / 360 * 6, n8 /= 100, e8 /= 100;
    var a8 = Math.floor(t8), o8 = e8 * (1 - n8), i8 = e8 * (1 - (t8 - a8) * n8), s4 = e8 * (1 - (1 - t8 + a8) * n8), h8 = a8 % 6;
    return { r: 255 * [e8, i8, o8, o8, s4, e8][h8], g: 255 * [s4, e8, e8, i8, o8, o8][h8], b: 255 * [o8, o8, s4, e8, e8, i8][h8], a: u7 };
  };
  var g = function(r8) {
    return { h: u(r8.h), s: e2(r8.s, 0, 100), l: e2(r8.l, 0, 100), a: e2(r8.a) };
  };
  var d2 = function(r8) {
    return { h: n2(r8.h), s: n2(r8.s), l: n2(r8.l), a: n2(r8.a, 3) };
  };
  var f = function(r8) {
    return b((n8 = (t8 = r8).s, { h: t8.h, s: (n8 *= ((e8 = t8.l) < 50 ? e8 : 100 - e8) / 100) > 0 ? 2 * n8 / (e8 + n8) * 100 : 0, v: e8 + n8, a: t8.a }));
    var t8, n8, e8;
  };
  var c2 = function(r8) {
    return { h: (t8 = h3(r8)).h, s: (u7 = (200 - (n8 = t8.s)) * (e8 = t8.v) / 100) > 0 && u7 < 200 ? n8 * e8 / 100 / (u7 <= 100 ? u7 : 200 - u7) * 100 : 0, l: u7 / 2, a: t8.a };
    var t8, n8, e8, u7;
  };
  var l2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var p2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var y = { string: [[function(r8) {
    var t8 = i2.exec(r8);
    return t8 ? (r8 = t8[1]).length <= 4 ? { r: parseInt(r8[0] + r8[0], 16), g: parseInt(r8[1] + r8[1], 16), b: parseInt(r8[2] + r8[2], 16), a: r8.length === 4 ? n2(parseInt(r8[3] + r8[3], 16) / 255, 2) : 1 } : r8.length === 6 || r8.length === 8 ? { r: parseInt(r8.substr(0, 2), 16), g: parseInt(r8.substr(2, 2), 16), b: parseInt(r8.substr(4, 2), 16), a: r8.length === 8 ? n2(parseInt(r8.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
  }, "hex"], [function(r8) {
    var t8 = v.exec(r8) || m.exec(r8);
    return t8 ? t8[2] !== t8[4] || t8[4] !== t8[6] ? null : a2({ r: Number(t8[1]) / (t8[2] ? 100 / 255 : 1), g: Number(t8[3]) / (t8[4] ? 100 / 255 : 1), b: Number(t8[5]) / (t8[6] ? 100 / 255 : 1), a: t8[7] === void 0 ? 1 : Number(t8[7]) / (t8[8] ? 100 : 1) }) : null;
  }, "rgb"], [function(t8) {
    var n8 = l2.exec(t8) || p2.exec(t8);
    if (!n8)
      return null;
    var e8, u7, a8 = g({ h: (e8 = n8[1], u7 = n8[2], u7 === void 0 && (u7 = "deg"), Number(e8) * (r2[u7] || 1)), s: Number(n8[3]), l: Number(n8[4]), a: n8[5] === void 0 ? 1 : Number(n8[5]) / (n8[6] ? 100 : 1) });
    return f(a8);
  }, "hsl"]], object: [[function(r8) {
    var n8 = r8.r, e8 = r8.g, u7 = r8.b, o8 = r8.a, i8 = o8 === void 0 ? 1 : o8;
    return t2(n8) && t2(e8) && t2(u7) ? a2({ r: Number(n8), g: Number(e8), b: Number(u7), a: Number(i8) }) : null;
  }, "rgb"], [function(r8) {
    var n8 = r8.h, e8 = r8.s, u7 = r8.l, a8 = r8.a, o8 = a8 === void 0 ? 1 : a8;
    if (!t2(n8) || !t2(e8) || !t2(u7))
      return null;
    var i8 = g({ h: Number(n8), s: Number(e8), l: Number(u7), a: Number(o8) });
    return f(i8);
  }, "hsl"], [function(r8) {
    var n8 = r8.h, a8 = r8.s, o8 = r8.v, i8 = r8.a, s4 = i8 === void 0 ? 1 : i8;
    if (!t2(n8) || !t2(a8) || !t2(o8))
      return null;
    var h8 = function(r9) {
      return { h: u(r9.h), s: e2(r9.s, 0, 100), v: e2(r9.v, 0, 100), a: e2(r9.a) };
    }({ h: Number(n8), s: Number(a8), v: Number(o8), a: Number(s4) });
    return b(h8);
  }, "hsv"]] };
  var N = function(r8, t8) {
    for (var n8 = 0; n8 < t8.length; n8++) {
      var e8 = t8[n8][0](r8);
      if (e8)
        return [e8, t8[n8][1]];
    }
    return [null, void 0];
  };
  var x2 = function(r8) {
    return typeof r8 == "string" ? N(r8.trim(), y.string) : typeof r8 == "object" && r8 !== null ? N(r8, y.object) : [null, void 0];
  };
  var M = function(r8, t8) {
    var n8 = c2(r8);
    return { h: n8.h, s: e2(n8.s + 100 * t8, 0, 100), l: n8.l, a: n8.a };
  };
  var H = function(r8) {
    return (299 * r8.r + 587 * r8.g + 114 * r8.b) / 1e3 / 255;
  };
  var $ = function(r8, t8) {
    var n8 = c2(r8);
    return { h: n8.h, s: n8.s, l: e2(n8.l + 100 * t8, 0, 100), a: n8.a };
  };
  var j = function() {
    function r8(r9) {
      this.parsed = x2(r9)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
    }
    return r8.prototype.isValid = function() {
      return this.parsed !== null;
    }, r8.prototype.brightness = function() {
      return n2(H(this.rgba), 2);
    }, r8.prototype.isDark = function() {
      return H(this.rgba) < 0.5;
    }, r8.prototype.isLight = function() {
      return H(this.rgba) >= 0.5;
    }, r8.prototype.toHex = function() {
      return r9 = o2(this.rgba), t8 = r9.r, e8 = r9.g, u7 = r9.b, i8 = (a8 = r9.a) < 1 ? s2(n2(255 * a8)) : "", "#" + s2(t8) + s2(e8) + s2(u7) + i8;
      var r9, t8, e8, u7, a8, i8;
    }, r8.prototype.toRgb = function() {
      return o2(this.rgba);
    }, r8.prototype.toRgbString = function() {
      return r9 = o2(this.rgba), t8 = r9.r, n8 = r9.g, e8 = r9.b, (u7 = r9.a) < 1 ? "rgba(" + t8 + ", " + n8 + ", " + e8 + ", " + u7 + ")" : "rgb(" + t8 + ", " + n8 + ", " + e8 + ")";
      var r9, t8, n8, e8, u7;
    }, r8.prototype.toHsl = function() {
      return d2(c2(this.rgba));
    }, r8.prototype.toHslString = function() {
      return r9 = d2(c2(this.rgba)), t8 = r9.h, n8 = r9.s, e8 = r9.l, (u7 = r9.a) < 1 ? "hsla(" + t8 + ", " + n8 + "%, " + e8 + "%, " + u7 + ")" : "hsl(" + t8 + ", " + n8 + "%, " + e8 + "%)";
      var r9, t8, n8, e8, u7;
    }, r8.prototype.toHsv = function() {
      return r9 = h3(this.rgba), { h: n2(r9.h), s: n2(r9.s), v: n2(r9.v), a: n2(r9.a, 3) };
      var r9;
    }, r8.prototype.invert = function() {
      return w({ r: 255 - (r9 = this.rgba).r, g: 255 - r9.g, b: 255 - r9.b, a: r9.a });
      var r9;
    }, r8.prototype.saturate = function(r9) {
      return r9 === void 0 && (r9 = 0.1), w(M(this.rgba, r9));
    }, r8.prototype.desaturate = function(r9) {
      return r9 === void 0 && (r9 = 0.1), w(M(this.rgba, -r9));
    }, r8.prototype.grayscale = function() {
      return w(M(this.rgba, -1));
    }, r8.prototype.lighten = function(r9) {
      return r9 === void 0 && (r9 = 0.1), w($(this.rgba, r9));
    }, r8.prototype.darken = function(r9) {
      return r9 === void 0 && (r9 = 0.1), w($(this.rgba, -r9));
    }, r8.prototype.rotate = function(r9) {
      return r9 === void 0 && (r9 = 15), this.hue(this.hue() + r9);
    }, r8.prototype.alpha = function(r9) {
      return typeof r9 == "number" ? w({ r: (t8 = this.rgba).r, g: t8.g, b: t8.b, a: r9 }) : n2(this.rgba.a, 3);
      var t8;
    }, r8.prototype.hue = function(r9) {
      var t8 = c2(this.rgba);
      return typeof r9 == "number" ? w({ h: r9, s: t8.s, l: t8.l, a: t8.a }) : n2(t8.h);
    }, r8.prototype.isEqual = function(r9) {
      return this.toHex() === w(r9).toHex();
    }, r8;
  }();
  var w = function(r8) {
    return r8 instanceof j ? r8 : new j(r8);
  };
  var S = [];
  var k = function(r8) {
    r8.forEach(function(r9) {
      S.indexOf(r9) < 0 && (r9(j, y), S.push(r9));
    });
  };

  // node_modules/.pnpm/colord@2.9.2/node_modules/colord/plugins/lch.mjs
  var r3 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
  var t3 = function(r8) {
    return typeof r8 == "string" ? r8.length > 0 : typeof r8 == "number";
  };
  var a3 = function(r8, t8, a8) {
    return t8 === void 0 && (t8 = 0), a8 === void 0 && (a8 = Math.pow(10, t8)), Math.round(a8 * r8) / a8 + 0;
  };
  var n3 = function(r8, t8, a8) {
    return t8 === void 0 && (t8 = 0), a8 === void 0 && (a8 = 1), r8 > a8 ? a8 : r8 > t8 ? r8 : t8;
  };
  var u2 = function(r8) {
    var t8 = r8 / 255;
    return t8 < 0.04045 ? t8 / 12.92 : Math.pow((t8 + 0.055) / 1.055, 2.4);
  };
  var h4 = function(r8) {
    return 255 * (r8 > 31308e-7 ? 1.055 * Math.pow(r8, 1 / 2.4) - 0.055 : 12.92 * r8);
  };
  var o3 = 96.422;
  var e3 = 100;
  var c3 = 82.521;
  var i3 = function(r8) {
    var t8, a8, u7 = { x: 0.9555766 * (t8 = r8).x + -0.0230393 * t8.y + 0.0631636 * t8.z, y: -0.0282895 * t8.x + 1.0099416 * t8.y + 0.0210077 * t8.z, z: 0.0122982 * t8.x + -0.020483 * t8.y + 1.3299098 * t8.z };
    return a8 = { r: h4(0.032404542 * u7.x - 0.015371385 * u7.y - 4985314e-9 * u7.z), g: h4(-969266e-8 * u7.x + 0.018760108 * u7.y + 41556e-8 * u7.z), b: h4(556434e-9 * u7.x - 2040259e-9 * u7.y + 0.010572252 * u7.z), a: r8.a }, { r: n3(a8.r, 0, 255), g: n3(a8.g, 0, 255), b: n3(a8.b, 0, 255), a: n3(a8.a) };
  };
  var l3 = function(r8) {
    var t8 = u2(r8.r), a8 = u2(r8.g), h8 = u2(r8.b);
    return function(r9) {
      return { x: n3(r9.x, 0, o3), y: n3(r9.y, 0, e3), z: n3(r9.z, 0, c3), a: n3(r9.a) };
    }(function(r9) {
      return { x: 1.0478112 * r9.x + 0.0228866 * r9.y + -0.050127 * r9.z, y: 0.0295424 * r9.x + 0.9904844 * r9.y + -0.0170491 * r9.z, z: -92345e-7 * r9.x + 0.0150436 * r9.y + 0.7521316 * r9.z, a: r9.a };
    }({ x: 100 * (0.4124564 * t8 + 0.3575761 * a8 + 0.1804375 * h8), y: 100 * (0.2126729 * t8 + 0.7151522 * a8 + 0.072175 * h8), z: 100 * (0.0193339 * t8 + 0.119192 * a8 + 0.9503041 * h8), a: r8.a }));
  };
  var f2 = 216 / 24389;
  var b2 = 24389 / 27;
  var d3 = function(r8) {
    return { l: n3(r8.l, 0, 100), c: r8.c, h: (t8 = r8.h, (t8 = isFinite(t8) ? t8 % 360 : 0) > 0 ? t8 : t8 + 360), a: r8.a };
    var t8;
  };
  var p3 = function(r8) {
    return { l: a3(r8.l, 2), c: a3(r8.c, 2), h: a3(r8.h, 2), a: a3(r8.a, 3) };
  };
  var v2 = function(r8) {
    var a8 = r8.l, n8 = r8.c, u7 = r8.h, h8 = r8.a, o8 = h8 === void 0 ? 1 : h8;
    if (!t3(a8) || !t3(n8) || !t3(u7))
      return null;
    var e8 = d3({ l: Number(a8), c: Number(n8), h: Number(u7), a: Number(o8) });
    return M2(e8);
  };
  var y2 = function(r8) {
    var t8 = function(r9) {
      var t9 = l3(r9), a8 = t9.x / o3, n9 = t9.y / e3, u8 = t9.z / c3;
      return a8 = a8 > f2 ? Math.cbrt(a8) : (b2 * a8 + 16) / 116, { l: 116 * (n9 = n9 > f2 ? Math.cbrt(n9) : (b2 * n9 + 16) / 116) - 16, a: 500 * (a8 - n9), b: 200 * (n9 - (u8 = u8 > f2 ? Math.cbrt(u8) : (b2 * u8 + 16) / 116)), alpha: t9.a };
    }(r8), n8 = a3(t8.a, 3), u7 = a3(t8.b, 3), h8 = Math.atan2(u7, n8) / Math.PI * 180;
    return { l: t8.l, c: Math.sqrt(n8 * n8 + u7 * u7), h: h8 < 0 ? h8 + 360 : h8, a: t8.alpha };
  };
  var M2 = function(r8) {
    return t8 = { l: r8.l, a: r8.c * Math.cos(r8.h * Math.PI / 180), b: r8.c * Math.sin(r8.h * Math.PI / 180), alpha: r8.a }, n8 = t8.a / 500 + (a8 = (t8.l + 16) / 116), u7 = a8 - t8.b / 200, i3({ x: (Math.pow(n8, 3) > f2 ? Math.pow(n8, 3) : (116 * n8 - 16) / b2) * o3, y: (t8.l > 8 ? Math.pow((t8.l + 16) / 116, 3) : t8.l / b2) * e3, z: (Math.pow(u7, 3) > f2 ? Math.pow(u7, 3) : (116 * u7 - 16) / b2) * c3, a: t8.alpha });
    var t8, a8, n8, u7;
  };
  var x3 = /^lch\(\s*([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var s3 = function(t8) {
    var a8 = x3.exec(t8);
    if (!a8)
      return null;
    var n8, u7, h8 = d3({ l: Number(a8[1]), c: Number(a8[2]), h: (n8 = a8[3], u7 = a8[4], u7 === void 0 && (u7 = "deg"), Number(n8) * (r3[u7] || 1)), a: a8[5] === void 0 ? 1 : Number(a8[5]) / (a8[6] ? 100 : 1) });
    return M2(h8);
  };
  function lch_default(r8, t8) {
    r8.prototype.toLch = function() {
      return p3(y2(this.rgba));
    }, r8.prototype.toLchString = function() {
      return r9 = p3(y2(this.rgba)), t9 = r9.l, a8 = r9.c, n8 = r9.h, (u7 = r9.a) < 1 ? "lch(" + t9 + "% " + a8 + " " + n8 + " / " + u7 + ")" : "lch(" + t9 + "% " + a8 + " " + n8 + ")";
      var r9, t9, a8, n8, u7;
    }, t8.string.push([s3, "lch"]), t8.object.push([v2, "lch"]);
  }

  // node_modules/.pnpm/colord@2.9.2/node_modules/colord/plugins/mix.mjs
  var t4 = function(t8, a8, n8) {
    return a8 === void 0 && (a8 = 0), n8 === void 0 && (n8 = 1), t8 > n8 ? n8 : t8 > a8 ? t8 : a8;
  };
  var a4 = function(t8) {
    var a8 = t8 / 255;
    return a8 < 0.04045 ? a8 / 12.92 : Math.pow((a8 + 0.055) / 1.055, 2.4);
  };
  var n4 = function(t8) {
    return 255 * (t8 > 31308e-7 ? 1.055 * Math.pow(t8, 1 / 2.4) - 0.055 : 12.92 * t8);
  };
  var r4 = 96.422;
  var o4 = 100;
  var u3 = 82.521;
  var e4 = function(a8) {
    var r8, o8, u7 = { x: 0.9555766 * (r8 = a8).x + -0.0230393 * r8.y + 0.0631636 * r8.z, y: -0.0282895 * r8.x + 1.0099416 * r8.y + 0.0210077 * r8.z, z: 0.0122982 * r8.x + -0.020483 * r8.y + 1.3299098 * r8.z };
    return o8 = { r: n4(0.032404542 * u7.x - 0.015371385 * u7.y - 4985314e-9 * u7.z), g: n4(-969266e-8 * u7.x + 0.018760108 * u7.y + 41556e-8 * u7.z), b: n4(556434e-9 * u7.x - 2040259e-9 * u7.y + 0.010572252 * u7.z), a: a8.a }, { r: t4(o8.r, 0, 255), g: t4(o8.g, 0, 255), b: t4(o8.b, 0, 255), a: t4(o8.a) };
  };
  var i4 = function(n8) {
    var e8 = a4(n8.r), i8 = a4(n8.g), p6 = a4(n8.b);
    return function(a8) {
      return { x: t4(a8.x, 0, r4), y: t4(a8.y, 0, o4), z: t4(a8.z, 0, u3), a: t4(a8.a) };
    }(function(t8) {
      return { x: 1.0478112 * t8.x + 0.0228866 * t8.y + -0.050127 * t8.z, y: 0.0295424 * t8.x + 0.9904844 * t8.y + -0.0170491 * t8.z, z: -92345e-7 * t8.x + 0.0150436 * t8.y + 0.7521316 * t8.z, a: t8.a };
    }({ x: 100 * (0.4124564 * e8 + 0.3575761 * i8 + 0.1804375 * p6), y: 100 * (0.2126729 * e8 + 0.7151522 * i8 + 0.072175 * p6), z: 100 * (0.0193339 * e8 + 0.119192 * i8 + 0.9503041 * p6), a: n8.a }));
  };
  var p4 = 216 / 24389;
  var h5 = 24389 / 27;
  var f3 = function(t8) {
    var a8 = i4(t8), n8 = a8.x / r4, e8 = a8.y / o4, f4 = a8.z / u3;
    return n8 = n8 > p4 ? Math.cbrt(n8) : (h5 * n8 + 16) / 116, { l: 116 * (e8 = e8 > p4 ? Math.cbrt(e8) : (h5 * e8 + 16) / 116) - 16, a: 500 * (n8 - e8), b: 200 * (e8 - (f4 = f4 > p4 ? Math.cbrt(f4) : (h5 * f4 + 16) / 116)), alpha: a8.a };
  };
  var c4 = function(a8, n8, i8) {
    var c6, y3 = f3(a8), x4 = f3(n8);
    return function(t8) {
      var a9 = (t8.l + 16) / 116, n9 = t8.a / 500 + a9, i9 = a9 - t8.b / 200;
      return e4({ x: (Math.pow(n9, 3) > p4 ? Math.pow(n9, 3) : (116 * n9 - 16) / h5) * r4, y: (t8.l > 8 ? Math.pow((t8.l + 16) / 116, 3) : t8.l / h5) * o4, z: (Math.pow(i9, 3) > p4 ? Math.pow(i9, 3) : (116 * i9 - 16) / h5) * u3, a: t8.alpha });
    }({ l: t4((c6 = { l: y3.l * (1 - i8) + x4.l * i8, a: y3.a * (1 - i8) + x4.a * i8, b: y3.b * (1 - i8) + x4.b * i8, alpha: y3.alpha * (1 - i8) + x4.alpha * i8 }).l, 0, 400), a: c6.a, b: c6.b, alpha: t4(c6.alpha) });
  };
  function mix_default(t8) {
    function a8(t9, a9, n8) {
      n8 === void 0 && (n8 = 5);
      for (var r8 = [], o8 = 1 / (n8 - 1), u7 = 0; u7 <= n8 - 1; u7++)
        r8.push(t9.mix(a9, o8 * u7));
      return r8;
    }
    t8.prototype.mix = function(a9, n8) {
      n8 === void 0 && (n8 = 0.5);
      var r8 = a9 instanceof t8 ? a9 : new t8(a9), o8 = c4(this.toRgb(), r8.toRgb(), n8);
      return new t8(o8);
    }, t8.prototype.tints = function(t9) {
      return a8(this, "#fff", t9);
    }, t8.prototype.shades = function(t9) {
      return a8(this, "#000", t9);
    }, t8.prototype.tones = function(t9) {
      return a8(this, "#808080", t9);
    };
  }

  // node_modules/.pnpm/colord@2.9.2/node_modules/colord/plugins/names.mjs
  function names_default(e8, f4) {
    var a8 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r8 = {};
    for (var d5 in a8)
      r8[a8[d5]] = d5;
    var l5 = {};
    e8.prototype.toName = function(f5) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
        return "transparent";
      var d6, i8, n8 = r8[this.toHex()];
      if (n8)
        return n8;
      if (f5 == null ? void 0 : f5.closest) {
        var o8 = this.toRgb(), t8 = 1 / 0, b5 = "black";
        if (!l5.length)
          for (var c6 in a8)
            l5[c6] = new e8(a8[c6]).toRgb();
        for (var g2 in a8) {
          var u7 = (d6 = o8, i8 = l5[g2], Math.pow(d6.r - i8.r, 2) + Math.pow(d6.g - i8.g, 2) + Math.pow(d6.b - i8.b, 2));
          u7 < t8 && (t8 = u7, b5 = g2);
        }
        return b5;
      }
    };
    f4.string.push([function(f5) {
      var r9 = f5.toLowerCase(), d6 = r9 === "transparent" ? "#0000" : a8[r9];
      return d6 ? new e8(d6).toRgb() : null;
    }, "name"]);
  }

  // node_modules/.pnpm/colord@2.9.2/node_modules/colord/plugins/lab.mjs
  var a5 = function(a8) {
    return typeof a8 == "string" ? a8.length > 0 : typeof a8 == "number";
  };
  var t5 = function(a8, t8, o8) {
    return t8 === void 0 && (t8 = 0), o8 === void 0 && (o8 = Math.pow(10, t8)), Math.round(o8 * a8) / o8 + 0;
  };
  var o5 = function(a8, t8, o8) {
    return t8 === void 0 && (t8 = 0), o8 === void 0 && (o8 = 1), a8 > o8 ? o8 : a8 > t8 ? a8 : t8;
  };
  var r5 = function(a8) {
    var t8 = a8 / 255;
    return t8 < 0.04045 ? t8 / 12.92 : Math.pow((t8 + 0.055) / 1.055, 2.4);
  };
  var h6 = function(a8) {
    return 255 * (a8 > 31308e-7 ? 1.055 * Math.pow(a8, 1 / 2.4) - 0.055 : 12.92 * a8);
  };
  var n5 = 96.422;
  var p5 = 100;
  var M3 = 82.521;
  var u4 = function(a8) {
    var t8, r8, n8 = { x: 0.9555766 * (t8 = a8).x + -0.0230393 * t8.y + 0.0631636 * t8.z, y: -0.0282895 * t8.x + 1.0099416 * t8.y + 0.0210077 * t8.z, z: 0.0122982 * t8.x + -0.020483 * t8.y + 1.3299098 * t8.z };
    return r8 = { r: h6(0.032404542 * n8.x - 0.015371385 * n8.y - 4985314e-9 * n8.z), g: h6(-969266e-8 * n8.x + 0.018760108 * n8.y + 41556e-8 * n8.z), b: h6(556434e-9 * n8.x - 2040259e-9 * n8.y + 0.010572252 * n8.z), a: a8.a }, { r: o5(r8.r, 0, 255), g: o5(r8.g, 0, 255), b: o5(r8.b, 0, 255), a: o5(r8.a) };
  };
  var e5 = function(a8) {
    var t8 = r5(a8.r), h8 = r5(a8.g), u7 = r5(a8.b);
    return function(a9) {
      return { x: o5(a9.x, 0, n5), y: o5(a9.y, 0, p5), z: o5(a9.z, 0, M3), a: o5(a9.a) };
    }(function(a9) {
      return { x: 1.0478112 * a9.x + 0.0228866 * a9.y + -0.050127 * a9.z, y: 0.0295424 * a9.x + 0.9904844 * a9.y + -0.0170491 * a9.z, z: -92345e-7 * a9.x + 0.0150436 * a9.y + 0.7521316 * a9.z, a: a9.a };
    }({ x: 100 * (0.4124564 * t8 + 0.3575761 * h8 + 0.1804375 * u7), y: 100 * (0.2126729 * t8 + 0.7151522 * h8 + 0.072175 * u7), z: 100 * (0.0193339 * t8 + 0.119192 * h8 + 0.9503041 * u7), a: a8.a }));
  };
  var w2 = 216 / 24389;
  var b3 = 24389 / 27;
  var i5 = function(t8) {
    var r8 = t8.l, h8 = t8.a, n8 = t8.b, p6 = t8.alpha, M4 = p6 === void 0 ? 1 : p6;
    if (!a5(r8) || !a5(h8) || !a5(n8))
      return null;
    var u7 = function(a8) {
      return { l: o5(a8.l, 0, 400), a: a8.a, b: a8.b, alpha: o5(a8.alpha) };
    }({ l: Number(r8), a: Number(h8), b: Number(n8), alpha: Number(M4) });
    return l4(u7);
  };
  var l4 = function(a8) {
    var t8 = (a8.l + 16) / 116, o8 = a8.a / 500 + t8, r8 = t8 - a8.b / 200;
    return u4({ x: (Math.pow(o8, 3) > w2 ? Math.pow(o8, 3) : (116 * o8 - 16) / b3) * n5, y: (a8.l > 8 ? Math.pow((a8.l + 16) / 116, 3) : a8.l / b3) * p5, z: (Math.pow(r8, 3) > w2 ? Math.pow(r8, 3) : (116 * r8 - 16) / b3) * M3, a: a8.alpha });
  };
  function lab_default(a8, r8) {
    a8.prototype.toLab = function() {
      return o8 = e5(this.rgba), h8 = o8.y / p5, u7 = o8.z / M3, r9 = (r9 = o8.x / n5) > w2 ? Math.cbrt(r9) : (b3 * r9 + 16) / 116, a9 = { l: 116 * (h8 = h8 > w2 ? Math.cbrt(h8) : (b3 * h8 + 16) / 116) - 16, a: 500 * (r9 - h8), b: 200 * (h8 - (u7 = u7 > w2 ? Math.cbrt(u7) : (b3 * u7 + 16) / 116)), alpha: o8.a }, { l: t5(a9.l, 2), a: t5(a9.a, 2), b: t5(a9.b, 2), alpha: t5(a9.alpha, 3) };
      var a9, o8, r9, h8, u7;
    }, a8.prototype.delta = function(r9) {
      r9 === void 0 && (r9 = "#FFF");
      var h8 = r9 instanceof a8 ? r9 : new a8(r9), n8 = function(a9, t8) {
        var o8 = a9.l, r10 = a9.a, h9 = a9.b, n9 = t8.l, p6 = t8.a, M4 = t8.b, u7 = 180 / Math.PI, e8 = Math.PI / 180, w3 = Math.pow(Math.pow(r10, 2) + Math.pow(h9, 2), 0.5), b5 = Math.pow(Math.pow(p6, 2) + Math.pow(M4, 2), 0.5), i8 = (o8 + n9) / 2, l5 = Math.pow((w3 + b5) / 2, 7), c6 = 0.5 * (1 - Math.pow(l5 / (l5 + Math.pow(25, 7)), 0.5)), f4 = r10 * (1 + c6), y3 = p6 * (1 + c6), v3 = Math.pow(Math.pow(f4, 2) + Math.pow(h9, 2), 0.5), x4 = Math.pow(Math.pow(y3, 2) + Math.pow(M4, 2), 0.5), z = (v3 + x4) / 2, s4 = f4 === 0 && h9 === 0 ? 0 : Math.atan2(h9, f4) * u7, d5 = y3 === 0 && M4 === 0 ? 0 : Math.atan2(M4, y3) * u7;
        s4 < 0 && (s4 += 360), d5 < 0 && (d5 += 360);
        var g2 = d5 - s4, m3 = Math.abs(d5 - s4);
        m3 > 180 && d5 <= s4 ? g2 += 360 : m3 > 180 && d5 > s4 && (g2 -= 360);
        var N2 = s4 + d5;
        m3 <= 180 ? N2 /= 2 : N2 = (s4 + d5 < 360 ? N2 + 360 : N2 - 360) / 2;
        var F = 1 - 0.17 * Math.cos(e8 * (N2 - 30)) + 0.24 * Math.cos(2 * e8 * N2) + 0.32 * Math.cos(e8 * (3 * N2 + 6)) - 0.2 * Math.cos(e8 * (4 * N2 - 63)), L = n9 - o8, I = x4 - v3, P = 2 * Math.sin(e8 * g2 / 2) * Math.pow(v3 * x4, 0.5), j2 = 1 + 0.015 * Math.pow(i8 - 50, 2) / Math.pow(20 + Math.pow(i8 - 50, 2), 0.5), k2 = 1 + 0.045 * z, q = 1 + 0.015 * z * F, A = 30 * Math.exp(-1 * Math.pow((N2 - 275) / 25, 2)), B = -2 * Math.pow(l5 / (l5 + Math.pow(25, 7)), 0.5) * Math.sin(2 * e8 * A);
        return Math.pow(Math.pow(L / 1 / j2, 2) + Math.pow(I / 1 / k2, 2) + Math.pow(P / 1 / q, 2) + B * I * P / (1 * k2 * 1 * q), 0.5);
      }(this.toLab(), h8.toLab()) / 100;
      return o5(t5(n8, 3));
    }, r8.object.push([i5, "lab"]);
  }

  // node_modules/.pnpm/colord@2.9.2/node_modules/colord/plugins/cmyk.mjs
  var r6 = function(r8) {
    return typeof r8 == "string" ? r8.length > 0 : typeof r8 == "number";
  };
  var n6 = function(r8, n8, t8) {
    return n8 === void 0 && (n8 = 0), t8 === void 0 && (t8 = Math.pow(10, n8)), Math.round(t8 * r8) / t8 + 0;
  };
  var t6 = function(r8, n8, t8) {
    return n8 === void 0 && (n8 = 0), t8 === void 0 && (t8 = 1), r8 > t8 ? t8 : r8 > n8 ? r8 : n8;
  };
  var u5 = function(r8) {
    return { c: t6(r8.c, 0, 100), m: t6(r8.m, 0, 100), y: t6(r8.y, 0, 100), k: t6(r8.k, 0, 100), a: t6(r8.a) };
  };
  var e6 = function(r8) {
    return { c: n6(r8.c, 2), m: n6(r8.m, 2), y: n6(r8.y, 2), k: n6(r8.k, 2), a: n6(r8.a, 3) };
  };
  function c5(r8) {
    return { r: n6(255 * (1 - r8.c / 100) * (1 - r8.k / 100)), g: n6(255 * (1 - r8.m / 100) * (1 - r8.k / 100)), b: n6(255 * (1 - r8.y / 100) * (1 - r8.k / 100)), a: r8.a };
  }
  function i6(r8) {
    var t8 = 1 - Math.max(r8.r / 255, r8.g / 255, r8.b / 255), u7 = (1 - r8.r / 255 - t8) / (1 - t8), e8 = (1 - r8.g / 255 - t8) / (1 - t8), c6 = (1 - r8.b / 255 - t8) / (1 - t8);
    return { c: isNaN(u7) ? 0 : n6(100 * u7), m: isNaN(e8) ? 0 : n6(100 * e8), y: isNaN(c6) ? 0 : n6(100 * c6), k: n6(100 * t8), a: r8.a };
  }
  function o6(n8) {
    var t8 = n8.c, e8 = n8.m, i8 = n8.y, o8 = n8.k, m3 = n8.a, a8 = m3 === void 0 ? 1 : m3;
    return r6(t8) && r6(e8) && r6(i8) && r6(o8) ? c5(u5({ c: Number(t8), m: Number(e8), y: Number(i8), k: Number(o8), a: Number(a8) })) : null;
  }
  var m2 = /^device-cmyk\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var a6 = function(r8) {
    var n8 = m2.exec(r8);
    return n8 ? c5(u5({ c: Number(n8[1]) * (n8[2] ? 1 : 100), m: Number(n8[3]) * (n8[4] ? 1 : 100), y: Number(n8[5]) * (n8[6] ? 1 : 100), k: Number(n8[7]) * (n8[8] ? 1 : 100), a: n8[9] === void 0 ? 1 : Number(n8[9]) / (n8[10] ? 100 : 1) })) : null;
  };
  function cmyk_default(r8, n8) {
    r8.prototype.toCmyk = function() {
      return e6(i6(this.rgba));
    }, r8.prototype.toCmykString = function() {
      return r9 = e6(i6(this.rgba)), n9 = r9.c, t8 = r9.m, u7 = r9.y, c6 = r9.k, (o8 = r9.a) < 1 ? "device-cmyk(" + n9 + "% " + t8 + "% " + u7 + "% " + c6 + "% / " + o8 + ")" : "device-cmyk(" + n9 + "% " + t8 + "% " + u7 + "% " + c6 + "%)";
      var r9, n9, t8, u7, c6, o8;
    }, n8.object.push([o6, "cmyk"]), n8.string.push([a6, "cmyk"]);
  }

  // node_modules/.pnpm/colord@2.9.2/node_modules/colord/plugins/hwb.mjs
  var r7 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
  var t7 = function(r8) {
    return typeof r8 == "string" ? r8.length > 0 : typeof r8 == "number";
  };
  var n7 = function(r8, t8, n8) {
    return t8 === void 0 && (t8 = 0), n8 === void 0 && (n8 = Math.pow(10, t8)), Math.round(n8 * r8) / n8 + 0;
  };
  var u6 = function(r8, t8, n8) {
    return t8 === void 0 && (t8 = 0), n8 === void 0 && (n8 = 1), r8 > n8 ? n8 : r8 > t8 ? r8 : t8;
  };
  var a7 = function(r8) {
    return { h: (t8 = r8.h, (t8 = isFinite(t8) ? t8 % 360 : 0) > 0 ? t8 : t8 + 360), w: u6(r8.w, 0, 100), b: u6(r8.b, 0, 100), a: u6(r8.a) };
    var t8;
  };
  var e7 = function(r8) {
    return { h: n7(r8.h), w: n7(r8.w), b: n7(r8.b), a: n7(r8.a, 3) };
  };
  var b4 = function(r8) {
    return { h: function(r9) {
      var t8 = r9.r, n8 = r9.g, u7 = r9.b, a8 = r9.a, e8 = Math.max(t8, n8, u7), b5 = e8 - Math.min(t8, n8, u7), o8 = b5 ? e8 === t8 ? (n8 - u7) / b5 : e8 === n8 ? 2 + (u7 - t8) / b5 : 4 + (t8 - n8) / b5 : 0;
      return { h: 60 * (o8 < 0 ? o8 + 6 : o8), s: e8 ? b5 / e8 * 100 : 0, v: e8 / 255 * 100, a: a8 };
    }(r8).h, w: Math.min(r8.r, r8.g, r8.b) / 255 * 100, b: 100 - Math.max(r8.r, r8.g, r8.b) / 255 * 100, a: r8.a };
  };
  var o7 = function(r8) {
    return function(r9) {
      var t8 = r9.h, n8 = r9.s, u7 = r9.v, a8 = r9.a;
      t8 = t8 / 360 * 6, n8 /= 100, u7 /= 100;
      var e8 = Math.floor(t8), b5 = u7 * (1 - n8), o8 = u7 * (1 - (t8 - e8) * n8), i8 = u7 * (1 - (1 - t8 + e8) * n8), h8 = e8 % 6;
      return { r: 255 * [u7, o8, b5, b5, i8, u7][h8], g: 255 * [i8, u7, u7, o8, b5, b5][h8], b: 255 * [b5, b5, i8, u7, u7, o8][h8], a: a8 };
    }({ h: r8.h, s: r8.b === 100 ? 0 : 100 - r8.w / (100 - r8.b) * 100, v: 100 - r8.b, a: r8.a });
  };
  var i7 = function(r8) {
    var n8 = r8.h, u7 = r8.w, e8 = r8.b, b5 = r8.a, i8 = b5 === void 0 ? 1 : b5;
    if (!t7(n8) || !t7(u7) || !t7(e8))
      return null;
    var h8 = a7({ h: Number(n8), w: Number(u7), b: Number(e8), a: Number(i8) });
    return o7(h8);
  };
  var h7 = /^hwb\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var d4 = function(t8) {
    var n8 = h7.exec(t8);
    if (!n8)
      return null;
    var u7, e8, b5 = a7({ h: (u7 = n8[1], e8 = n8[2], e8 === void 0 && (e8 = "deg"), Number(u7) * (r7[e8] || 1)), w: Number(n8[3]), b: Number(n8[4]), a: n8[5] === void 0 ? 1 : Number(n8[5]) / (n8[6] ? 100 : 1) });
    return o7(b5);
  };
  function hwb_default(r8, t8) {
    r8.prototype.toHwb = function() {
      return e7(b4(this.rgba));
    }, r8.prototype.toHwbString = function() {
      return r9 = e7(b4(this.rgba)), t9 = r9.h, n8 = r9.w, u7 = r9.b, (a8 = r9.a) < 1 ? "hwb(" + t9 + " " + n8 + "% " + u7 + "% / " + a8 + ")" : "hwb(" + t9 + " " + n8 + "% " + u7 + "%)";
      var r9, t9, n8, u7, a8;
    }, t8.string.push([d4, "hwb"]), t8.object.push([i7, "hwb"]);
  }

  // .vitepress/use/colors.js
  k([mix_default, lch_default, names_default, lab_default, cmyk_default, hwb_default]);
  function lchToHsl(n8 = 0, total = 12, a8 = 1, s4 = 20, lightness = 60) {
    let lch = `lch(${lightness}% ${s4} ${n8 * (360 / total)} / ${a8})`;
    let hsl = w(lch).toHslString();
    return hsl;
  }
  function getColorInfo(color) {
    const cld = w(color);
    let info = {
      dark: cld.isDark(),
      hex: cld.toHex(),
      rgb: cld.toRgbString(),
      name: cld.toName({ closest: true }),
      cmyk: cld.toCmykString(),
      hsl: cld.toHslString(),
      lab: cld.toLab()
    };
    return info;
  }
  function levelColor(i8 = 0, n8 = 3, a8 = "0.5", s4 = "0.8", l5 = "0.5", reverse = false) {
    if (reverse) {
      i8 = n8 - i8 - 1;
    }
    return `hsla(${i8 * (360 / n8)}, ${s4 * 100}%, ${l5 * 100}%, ${a8})`;
  }
  function chromaColorMix(chroma3, tonic, part = 0.3) {
    let hsl = w(pitchColor(tonic));
    let lch = w(lchToHsl(tonic, 12, 1));
    chroma3.split("").forEach((bit, i8) => {
      if (isInChroma(chroma3, tonic, i8)) {
        hsl = hsl.mix(pitchColor(i8), part);
        lch = lch.mix(lchToHsl(i8, 12, 1), part);
      }
    });
    return {
      hsl: hsl.toHslString(),
      lch: lch.toHslString()
    };
  }

  // .vitepress/use/tempo.js
  var tempo = (0, vue_exports.reactive)({
    initialized: false,
    bpm: useClamp(useStorage2("tempo-bpm", 100), 10, 500),
    blink: false,
    started: false,
    playing: false,
    stopped: false,
    mute: useStorage2("tempo-mute", true),
    volume: useClamp(useStorage2("tempo-volume", 0.5), 0, 1),
    progress: 0,
    position: 0,
    ticks: 0,
    metre: {
      over: 4,
      under: 4,
      num: (0, vue_exports.computed)(() => (tempo.metre.over / (tempo.metre.under / 4)).toFixed(2))
    },
    hz: (0, vue_exports.computed)(() => (tempo.bpm / 60).toFixed(2)),
    note: (0, vue_exports.computed)(() => index4.pitchClass(Frequency(tempo.hz).toNote())),
    tune: (0, vue_exports.computed)(() => {
      return index4.pitchClass(tempo.note) + 4;
    }),
    pitch: (0, vue_exports.computed)(() => freqPitch(tempo.hz)),
    digit: (0, vue_exports.computed)(() => (Frequency(tempo.hz).toMidi() + 12 * 10 + 3) % 12),
    color: (0, vue_exports.computed)(() => pitchColor(tempo.digit)),
    tap: {
      last: 0,
      diff: 0,
      timeout: 2e3,
      times: [],
      bpm: null
    },
    set(diff) {
      tempo.bpm = Math.round(diff + tempo.bpm);
    }
  });
  function useTempo() {
    if (tempo.initialized)
      return tempo;
    const metro = shallowReactive({
      counter: 0
    });
    (0, vue_exports.onMounted)(() => {
      const { channel } = createChannel("tempo-tick");
      metro.channel = channel;
      metro.pluck = new Sampler({
        urls: {
          E1: "/logic/high.wav",
          E2: "/logic/low.wav"
        },
        volume: -20,
        envelope: {
          attack: 1e-3,
          release: 2
        },
        baseUrl: "/audio/metronome/"
      }).connect(channel);
      metro.loop = new Loop((time) => {
        let even = metro.counter % 2 == 0;
        if (even)
          tempo.blink = true;
        if (!tempo.mute) {
          metro.pluck.triggerAttackRelease(even ? "E1" : "E2", "16n", time, even ? 1 : 0.2);
        }
        metro.counter++;
        setTimeout(() => {
          tempo.blink = false;
        }, 60);
      }, "8n").start(0);
      useRafFn2(() => {
        tempo.position = Transport2.position;
        tempo.ticks = Transport2.ticks;
        tempo.progress = metro.loop.progress;
      });
    });
    (0, vue_exports.watch)(() => tempo.volume, (vol) => metro.pluck.volume.rampTo(gainToDb(tempo.volume)));
    (0, vue_exports.watch)(() => tempo.bpm, (bpm) => Transport2.bpm.rampTo(bpm, "4n"), { immediate: true });
    (0, vue_exports.watch)(() => tempo.stopped, (stop2) => {
      if (stop2) {
        Transport2.stop();
        tempo.playing = false;
      }
    });
    (0, vue_exports.watch)(() => tempo.playing, (playing) => {
      if (playing) {
        if (!tempo.started) {
          start();
          tempo.started = true;
        }
        tempo.stopped = false;
        Transport2.start();
      } else {
        Transport2.pause();
      }
    }, {
      immediate: true
    });
    tempo.initialized = true;
    return tempo;
  }
  function tap() {
    var time = performance.now();
    if (tempo.tap.last) {
      tempo.tap.diff = time - tempo.tap.last;
      tempo.tap.times.push(tempo.tap.diff);
      refresh();
    }
    tempo.tap.last = time;
    beginTimeout();
  }
  function refresh() {
    if (tempo.tap.times.length > 2) {
      var average = tempo.tap.times.reduce((result, t8) => result += t8) / tempo.tap.times.length;
      var bpm = 1 / (average / 1e3) * 60;
      tempo.tap.bpm = bpm;
    }
  }
  var timer = null;
  function beginTimeout() {
    clearTimeout(timer);
    timer = setTimeout(function() {
      tempo.tap.times = [tempo.tap.diff];
      tempo.tap.last = null;
    }, tempo.tap.timeout);
  }

  // .vitepress/use/midiRender.js
  var import_midi_writer_js = __toESM(require_build());
  var import_midi7 = __toESM(require_Midi());
  function createAndDownloadBlobFile(body, filename, extension = "mid") {
    const blob = new Blob([body]);
    const fileName = `${filename}.${extension}`;
    if (navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, fileName);
    } else {
      const link = document.createElement("a");
      if (link.download !== void 0) {
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", fileName);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }
  }

  // .vitepress/use/loop.js
  var import_midi_writer_js2 = __toESM(require_build());
  var loops = reactive([]);
  function useLoop(order = 0) {
    const loop = reactive({
      pitch: computed(() => globalScale.tonic),
      chroma: computed(() => globalScale.set.chroma),
      metre: {
        over: useStorage(`grid-${order}-over`, 4),
        under: useStorage(`grid-${order}-under`, 4)
      },
      octave: useStorage(`grid-${order}-octave`, 3),
      volume: useStorage(`grid-${order}-vol`, 1),
      pan: useStorage(`grid-${order}-pan`, order % 2 == 1 ? -0.5 : 0.5),
      probability: useStorage(`grid-${order}-probability`, 1),
      tonic: computed(() => {
        return loop.pitch + 12 * loop.octave - 3;
      }),
      steps: useStorage(`grid-${order}-steps`, []),
      current: [],
      progress: computed(() => {
        if (tempo.ticks) {
          return sequence == null ? void 0 : sequence.progress;
        } else {
          return 0;
        }
      }),
      clear() {
        loop.steps.forEach((step, s4) => {
          loop.steps[s4] = [{}];
        });
      },
      rotate(way = 1) {
        loop.steps = rotateArray(loop.steps, way);
      }
    });
    loops[order] = loop;
    const { channel } = createChannel(`grid-loop-${order}`);
    const panner = new PanVol(loop.pan, 0).connect(channel);
    const synth2 = new PolySynth({
      envelope: {
        attack: 0.5,
        release: 0.2
      },
      filterEnvelope: {
        attack: 0.1,
        release: 0.2
      }
    }).connect(panner);
    synth2.maxPolyphony = 100;
    let sequence = new Sequence((time, step) => {
      beatClick(step, time);
    }, loop.steps, loop.metre.under + "n").start(0);
    watch(() => loop.metre.under, () => {
      sequence.stop().dispose();
      sequence = new Sequence((time, step) => {
        beatClick(step, time);
      }, loop.steps, loop.metre.under + "n").start(0);
      sequence.probability = loop.probability;
    });
    watch(() => loop.metre.over, () => {
      if (loop.steps.length > loop.metre.over) {
        loop.steps.length = loop.metre.over;
      } else {
        for (let i8 = loop.steps.length; i8 < loop.metre.over; i8++) {
          loop.steps.push([{}]);
        }
      }
      sequence.events = loop.steps;
    }, { immediate: true });
    watchEffect(() => {
      sequence.events = loop.steps;
    });
    watchEffect(() => {
      if (tempo.stopped) {
        loop.current = null;
      }
    });
    watchEffect(() => {
      sequence.probability = loop.probability;
      panner.volume.targetRampTo(gainToDb(loop.volume), 1);
      panner.pan.targetRampTo(loop.pan, 1);
    });
    function beatClick(step, time) {
      if (context.state == "suspended") {
        start();
      }
      let notes2 = Object.entries(step).map((entry) => {
        if (entry[0] == "sub")
          return;
        return entry[1] ? Midi(Number(entry[0]) + loop.tonic) : null;
      }).filter(Number);
      synth2.triggerAttackRelease(notes2, { [loop.metre.under + "n"]: 1 / (step.sub || 1) }, time);
      Draw2.schedule(() => {
        let dur = Time({
          [loop.metre.under + "n"]: 1 / (step.sub || 1)
        }).toMilliseconds();
        let midiNotes = notes2.map((n8) => n8.toMidi());
        midiPlay(midiNotes, { duration: dur, attack: loop.volume });
      }, time);
    }
    onBeforeUnmount(() => {
      loops.splice(order, 1);
      sequence.stop().dispose();
      panner.dispose();
      synth2.dispose();
    });
    return loop;
  }

  // .vitepress/use/mic.js
  var mic = reactive({
    initiated: false,
    open: false,
    opened: false,
    monitor: false,
    meter: 0,
    volume: useClamp2(useStorage("mic-vol", 1), 0, 2),
    gate: useClamp2(useStorage("mic-gate", -60), -100, -40)
  });
  var meter;
  var input;
  var gate;
  var compressor;
  function useMic() {
    if (!mic.initiated) {
      meter = new Meter();
      meter.normalRange = true;
      input = new UserMedia();
      compressor = new Compressor({ threshold: -20, ratio: 2 }).connect(meter);
      gate = new Gate({ threshold: -60, smoothing: 1 });
      input.connect(gate);
      gate.connect(compressor);
      const { channel } = createChannel("mic");
      watch(() => mic.open, (o8) => {
        if (o8) {
          input.open().then(() => {
            mic.opened = true;
            useRafFn2(() => {
              mic.meter = meter.getValue();
            });
          });
        } else {
          input.close();
          mic.opened = false;
        }
      });
      watch(() => mic.monitor, (mon) => mon ? meter.connect(channel) : meter.disconnect(channel));
      watch(() => mic.volume, (vol) => input.volume.rampTo(gainToDb(vol)), { immediate: true });
      watch(() => mic.gate, (g2) => gate.threshold = g2, { immediate: true });
    }
    return { mic, input };
  }

  // .vitepress/use/mouse.js
  function useSvgMouse() {
    const svg = ref(null);
    const area = ref(null);
    const { pressed } = useMousePressed();
    const mouse = reactive({
      x: 0,
      y: 0,
      normX: 0,
      normY: 0,
      pressed,
      inside: false
    });
    onMounted(() => {
      svg.value.addEventListener("mousemove", getCursorPosition);
      const { isOutside } = useMouseInElement(area);
      watch(isOutside, (out) => {
        mouse.inside = !out;
      });
    });
    function getCursorPosition(event, svgElement = svg.value, rect = area.value) {
      if (!svgElement)
        return;
      var svgPoint = svgElement.createSVGPoint();
      svgPoint.x = event.clientX;
      svgPoint.y = event.clientY;
      let correct = svgPoint.matrixTransform(svgElement.getScreenCTM().inverse());
      if (rect) {
        let bounds = rect.getBBox();
        mouse.x = correct.x < bounds.width ? correct.x < 0 ? 0 : correct.x : bounds.width;
        mouse.y = correct.y < bounds.height ? correct.y < 0 ? 0 : correct.y : bounds.height;
        mouse.normY = 1 - mouse.y / bounds.height;
        mouse.normX = mouse.x / bounds.width;
      } else {
        mouse.x = correct.x;
        mouse.y = correct.y;
      }
    }
    return {
      svg,
      area,
      mouse
    };
  }

  // .vitepress/use/noise.js
  var types = { brown: "brown", pink: "pink", white: "white" };
  var filterTypes = { lowpass: "LP", highpass: "HP", bandpass: "BP" };
  var filterLFOTypes = {
    sine: "SIN",
    triangle: "TRI",
    square: "SQR",
    sawtooth: "SAW"
  };
  var options = useStorage2("noise-options", {
    noise: {
      type: "pink"
    },
    envelope: {
      attack: 0.1,
      decay: 0.1,
      sustain: 0.9,
      release: 1
    },
    volume: 1
  });
  var filterOptions = useStorage2("filter-options", {
    on: false,
    play: false,
    volume: 0.5,
    baseFrequency: 50,
    depth: 0.1,
    frequency: 1,
    octaves: 2,
    wet: 1,
    type: "sine",
    filter: {
      Q: 1,
      type: "lowpass"
    }
  });
  var pannerOptions = useStorage2("panner-options", {
    on: false,
    play: false,
    wet: 1,
    frequency: 1,
    depth: 1,
    volume: 1
  });
  var crusherOptions = useStorage2("bit-options", {
    on: false,
    bits: 16,
    wet: 1,
    volume: 1
  });
  function useNoise() {
    const active = ref(false);
    const fftData = ref([]);
    const fftFreq = ref([]);
    const { channel } = createChannel("noise");
    const fft = new FFT({ size: 512, smoothing: 0.2 }).connect(channel);
    for (let j2 = 0; j2 < 32; j2++) {
      fftFreq.value[j2] = fft.getFrequencyOfIndex(j2);
    }
    const gain = new Gain(options.value.volume).connect(fft);
    const filterGain = new Gain(filterOptions.value.volume).connect(fft);
    const pannerGain = new Gain(pannerOptions.value.volume).connect(fft);
    const crusherGain = new Gain(crusherOptions.value.volume).connect(fft);
    const panner = new AutoPanner(pannerOptions.value).connect(pannerGain);
    const crusher = new BitCrusher(crusherOptions.value).connect(crusherGain).connect(panner);
    const filter2 = new AutoFilter(filterOptions.value).connect(filterGain).connect(crusher);
    const synth2 = new NoiseSynth(options.value).connect(gain).connect(filter2);
    const { pause, resume } = useRafFn2(() => {
      let arr = fft.getValue();
      for (let j2 = 0; j2 < 32; j2++) {
        fftData.value[j2] = dbToGain(arr[j2]) * 10;
      }
    });
    onKeyStroke(" ", (e8) => {
      e8.preventDefault();
      active.value = true;
    }, { eventName: "keydown" });
    onKeyStroke(" ", (e8) => {
      active.value = false;
    }, { eventName: "keyup" });
    watch(active, (act) => {
      if (act) {
        synth2.triggerAttack();
      } else {
        synth2.triggerRelease();
      }
    });
    watch(options.value, () => {
      synth2.set(options.value);
    });
    watch(() => options.value.volume, (vol) => {
      gain.gain.rampTo(vol, 1);
    });
    onBeforeUnmount(() => {
      synth2.triggerRelease();
    });
    watch(filterOptions.value, (opt) => {
      opt.play ? filter2.start() : filter2.stop();
      if (opt.on) {
        filterGain.gain.rampTo(filterOptions.value.volume, 0.2);
      } else {
        filterGain.gain.rampTo(0, 0.2);
      }
      filter2.set(opt);
    });
    watch(pannerOptions.value, (opt) => {
      opt.play ? panner.start() : panner.stop();
      opt.on ? pannerGain.gain.rampTo(pannerOptions.value.volume, 0.2) : pannerGain.gain.rampTo(0, 0.2);
      panner.set(opt);
    });
    watch(crusherOptions.value, (opt) => {
      opt.on ? crusherGain.gain.rampTo(crusherOptions.value.volume, 0.2) : crusherGain.gain.rampTo(0, 0.2);
      crusher.set(opt);
    });
    return {
      options,
      filterOptions,
      pannerOptions,
      crusherOptions,
      active,
      fftData,
      fftFreq,
      types,
      filterTypes,
      filterLFOTypes
    };
  }

  // .vitepress/use/piano.js
  var piano;
  function usePiano() {
    init2();
    return { init: init2, piano, pianoOnce, pianoAttack, pianoRelease, pianoReleaseAll };
  }
  function init2() {
    start();
    if (piano)
      return;
    const { channel } = createChannel("piano");
    piano = new Sampler({
      urls: {
        A0: "A0.mp3",
        C1: "C1.mp3",
        "D#1": "Ds1.mp3",
        "F#1": "Fs1.mp3",
        A1: "A1.mp3",
        C2: "C2.mp3",
        "D#2": "Ds2.mp3",
        "F#2": "Fs2.mp3",
        A2: "A2.mp3",
        C3: "C3.mp3",
        "D#3": "Ds3.mp3",
        "F#3": "Fs3.mp3",
        A3: "A3.mp3",
        C4: "C4.mp3",
        "D#4": "Ds4.mp3",
        "F#4": "Fs4.mp3",
        A4: "A4.mp3",
        C5: "C5.mp3",
        "D#5": "Ds5.mp3",
        "F#5": "Fs5.mp3",
        A5: "A5.mp3",
        C6: "C6.mp3",
        "D#6": "Ds6.mp3",
        "F#6": "Fs6.mp3",
        A6: "A6.mp3",
        C7: "C7.mp3",
        "D#7": "Ds7.mp3",
        "F#7": "Fs7.mp3",
        A7: "A7.mp3",
        C8: "C8.mp3"
      },
      release: 1,
      volume: -10,
      baseUrl: "/audio/piano/"
    }).connect(channel);
  }
  function pianoOnce(note3 = "A4", duration2 = "8n", time) {
    if (!piano)
      return init2();
    piano.triggerAttackRelease(note3, duration2, time);
  }
  function pianoAttack(note3, velocity) {
    if (!piano)
      return init2();
    piano.triggerAttack(note3, now(), velocity);
  }
  function pianoRelease(note3) {
    if (!piano)
      return init2();
    piano.triggerRelease(note3);
  }
  function pianoReleaseAll() {
    if (!piano)
      return init2();
    piano.releaseAll();
  }

  // .vitepress/use/sequence.js
  var tracks = reactive([]);
  function useSequence(metre = {
    over: 4,
    under: 4,
    sound: "A",
    volume: 1
  }, order = 0, mode2 = "bar") {
    let pan = order % 2 == 1 ? -0.5 : 0.5;
    const audio2 = {
      meter: null,
      mic: null,
      recorder: null,
      panner: null,
      synth: null
    };
    const { channel } = createChannel(`sequence-${mode2}-${order}`);
    audio2.panner = new PanVol(pan, 0).connect(channel);
    audio2.synth = new Sampler({
      urls: {
        A1: "tongue/high.wav",
        A2: "tongue/low.wav",
        B1: "synth/high.wav",
        B2: "synth/low.wav",
        C1: "seiko/high.wav",
        C2: "seiko/low.wav",
        D1: "/ping/high.wav",
        D2: "/ping/low.wav",
        E1: "/logic/high.wav",
        E2: "/logic/low.wav"
      },
      volume: 1,
      envelope: {
        attack: 1e-3,
        release: 2
      },
      baseUrl: "/audio/metronome/"
    }).connect(audio2.panner);
    audio2.recorder = new Recorder();
    const recorder2 = reactive({
      recording: false,
      main: false,
      accent: false,
      both: computed(() => recorder2.main && recorder2.accent),
      async load(pos = "main", blob) {
        let arr = await blob.arrayBuffer();
        let buff = await audio2.recorder.context.decodeAudioData(arr);
        audio2.synth.add(pos == "main" ? "F1" : "F2", buff);
        recorder2[pos] = true;
        recorder2.recording = false;
      },
      async rec(pos = "main") {
        if (!recorder2.recording) {
          audio2.meter = new Meter().connect(audio2.recorder);
          audio2.mic = new UserMedia(1).connect(audio2.meter);
          audio2.mic.open().then(() => {
            recorder2.recording = pos;
            audio2.recorder.start();
          }).catch((e8) => {
            console.log("mic not open");
          });
        } else {
          let blob = await audio2.recorder.stop();
          let arr = await blob.arrayBuffer();
          let buff = await audio2.recorder.context.decodeAudioData(arr);
          audio2.synth.add(pos == "main" ? "F1" : "F2", buff);
          recorder2[pos] = true;
          recorder2.recording = false;
        }
      }
    });
    watch(() => metre.sound, (sound) => {
      if (sound != "F") {
        recorder2.main = false;
        recorder2.accent = false;
      }
    });
    const current = ref("0-0");
    const steps = reactive([["0-1"], ["1-1"], ["2-1"], ["3-1"]]);
    const mutes = useStorage(`metro-${mode2}-mutes-${order}`, []);
    const accents = useStorage(`metro-${mode2}-accents-${order}`, [true]);
    const volume = useClamp(useStorage(`metro-${mode2}-vol-${order}`, metre.volume || 1), 0, 1);
    const panning = useClamp(useStorage(`metro-${mode2}-pan-${order}`, pan), -1, 1);
    const mutesCount = computed(() => mutes.value.reduce((acc, val) => {
      if (!val) {
        acc++;
      }
      return acc;
    }, 0));
    const euclidSeq = computed(() => mutesCount.value > 0 && mutesCount.value < steps.length ? getEuclideanRhythm(mutesCount.value, steps.length) : new Array(steps.length).fill("1").join(""));
    const currentSeq = computed(() => mutes.value.reduce((acc, val) => val ? acc + "0" : acc + "1", ""));
    const isEuclidean = computed(() => euclidSeq.value == currentSeq.value);
    function reset2() {
      let arr = [];
      euclidSeq.value.split("").forEach((e8, i8) => {
        arr[i8] = e8 != false && e8 != null ? false : true;
      });
      mutes.value = arr;
    }
    let sequence = new Sequence((time, step) => {
      beatClick(step, time);
    }, steps, metre.under + "n").start(0);
    watch(() => metre.under, () => {
      sequence.stop().dispose();
      sequence = new Sequence((time, step) => {
        beatClick(step, time);
      }, steps, metre.under + "n").start(0);
    });
    watch(() => metre.over, () => {
      steps.length = 0;
      for (let i8 = 0; i8 < metre.over; i8++) {
        steps.push([`${i8}-1`]);
      }
      sequence.events = steps;
    }, { immediate: true });
    watchEffect(() => {
      sequence.events = steps;
      accents.value.length = steps.length;
      mutes.value.length = steps.length;
    });
    watchEffect(() => {
      if (tempo.stopped) {
        current.value = "1000-1";
      }
    });
    watch(volume, (vol) => {
      audio2.panner.volume.targetRampTo(gainToDb(vol), 1);
    }, { immediate: true });
    watch(panning, (p6) => {
      audio2.panner.pan.targetRampTo(p6, 1);
    }, { immediate: true });
    const progress = computed(() => {
      if (tempo.ticks) {
        return sequence.progress;
      } else {
        return 0;
      }
    });
    function beatClick(step, time) {
      if (context.state == "suspended") {
        start();
      }
      let mainStep = typeof step == "string" ? +step.split("-")[0] : step;
      Draw2.schedule(() => {
        current.value = step;
      }, time);
      let accented = accents.value[mainStep] && step.split("-")[1] == "1";
      if (mutes.value[mainStep])
        return;
      if (mutes.value[step])
        return;
      if (metre.sound == "F" && !accented && !recorder2.main)
        return;
      if (metre.sound == "F" && accented && !recorder2.accent)
        return;
      let note3 = `${metre.sound}${accented ? 2 : 1}`;
      audio2.synth.triggerAttackRelease(note3, metre.under + "n", time);
    }
    const lastHit = ref(0);
    onKeyStroke("Shift", () => {
      lastHit.value = progress.value;
    });
    onBeforeUnmount(() => {
      sequence.stop().dispose();
      audio2.panner.dispose();
      audio2.synth.dispose();
    });
    tracks[order] = reactive({
      metre: computed(() => metre),
      steps,
      mutes,
      accents,
      mutesCount,
      isEuclidean,
      reset: reset2
    });
    return {
      progress,
      current,
      steps,
      mutes,
      accents,
      volume,
      panning,
      recorder: recorder2,
      lastHit,
      reset: reset2,
      isEuclidean
    };
  }
  function _getEuclideanRhythm(m3, k2, input2) {
    input2 = input2 || new Array(m3).fill("1").concat(new Array(k2).fill("0"));
    const output = [];
    for (let i8 = 0; i8 < Math.min(m3, k2); i8++) {
      output.push(input2.shift() + input2.pop());
    }
    if (input2.length > 1) {
      return _getEuclideanRhythm(output.length, input2.length, output.concat(input2));
    }
    return output.concat(input2);
  }
  function getEuclideanRhythm(x4, total) {
    return _getEuclideanRhythm(x4, total - x4).join("");
  }

  // .vitepress/use/tuner.js
  var import_meyda = __toESM(require_main());
  var noteStrings = [
    "C",
    "C\u266F",
    "D",
    "D\u266F",
    "E",
    "F",
    "F\u266F",
    "G",
    "G\u266F",
    "A",
    "A\u266F",
    "B"
  ];
  var settings = {
    middleA: 440,
    semitone: 69
  };
  var tuner = reactive({
    initiated: false,
    stream: null,
    middleA: settings.middleA,
    semitone: settings.semitone,
    note: {
      name: "A",
      value: 69,
      cents: 0,
      octave: 4,
      frequency: 440,
      color: freqColor2(440),
      silent: false
    },
    span: 64,
    bufferSize: 4096,
    tempoBufferSize: 512,
    frequencyData: null,
    running: false,
    frame: 0,
    beat: 0,
    bpm: 0,
    confidence: 0,
    listenBeat: false,
    prevBeat: 0,
    blink: false,
    chroma: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    spec: [],
    rms: 0
  });
  var chain = {};
  function useTuner() {
    initGetUserMedia();
    return {
      init: init3,
      tuner,
      chain
    };
  }
  function init3() {
    tuner.initiated = true;
    chain.audioContext = new window.AudioContext();
    chain.analyser = chain.audioContext.createAnalyser();
    chain.scriptProcessor = chain.audioContext.createScriptProcessor(tuner.bufferSize, 1, 1);
    chain.beatProcessor = chain.audioContext.createScriptProcessor(tuner.tempoBufferSize, 1, 1);
    watch(() => tuner.frame, () => {
      if (!tuner.listen)
        return;
      if (tuner.beat > tuner.prevBeat) {
        tuner.prevBeat = tuner.beat;
        tuner.blink = true;
        setTimeout(() => {
          tuner.blink = false;
        }, 60);
      }
    });
    chain.meyda = import_meyda.default.createMeydaAnalyzer({
      audioContext: chain.audioContext,
      source: chain.analyser,
      bufferSize: 4096,
      featureExtractors: ["chroma", "amplitudeSpectrum", "rms"],
      callback: (features) => {
        tuner.rms = features.rms;
        tuner.chroma = features.chroma;
        tuner.spec = features.amplitudeSpectrum;
      }
    });
    chain.meyda.start();
    tuner.frequencyData = new Uint8Array(chain.analyser.frequencyBinCount);
    aubio_default().then(function(aubio) {
      chain.pitchDetector = new aubio.Pitch("default", tuner.bufferSize, 1, chain.audioContext.sampleRate);
      chain.tempoAnalyzer = new aubio.Tempo(tuner.tempoBufferSize * 4, tuner.tempoBufferSize, chain.audioContext.sampleRate);
      tuner.running = true;
      start2();
    });
  }
  function start2() {
    navigator.mediaDevices.getUserMedia({ audio: true }).then(function(stream) {
      tuner.stream = stream;
      const mediaStream = chain.audioContext.createMediaStreamSource(stream).connect(chain.analyser);
      chain.analyser.connect(chain.scriptProcessor);
      chain.analyser.connect(chain.beatProcessor);
      chain.scriptProcessor.connect(chain.audioContext.destination);
      chain.beatProcessor.connect(chain.audioContext.destination);
      chain.beatProcessor.addEventListener("audioprocess", (e8) => {
        const tempo2 = chain.tempoAnalyzer.do(e8.inputBuffer.getChannelData(0));
        if (tempo2) {
          tuner.beat++;
          tuner.confidence = chain.tempoAnalyzer.getConfidence();
          tuner.bpm = chain.tempoAnalyzer.getBpm();
        }
      });
      chain.scriptProcessor.addEventListener("audioprocess", function(event) {
        const frequency = chain.pitchDetector.do(event.inputBuffer.getChannelData(0));
        tuner.frame++;
        if (frequency) {
          const note3 = getNote(frequency);
          tuner.note = {
            name: noteStrings[note3 % 12],
            value: note3,
            cents: getCents2(frequency, note3),
            octave: parseInt(note3 / 12) - 1,
            frequency,
            color: freqColor2(frequency),
            silent: false
          };
        } else {
          tuner.note.silent = true;
        }
      });
    }).catch(function(error) {
      console.log(error.name + ": " + error.message);
    });
  }
  function getNote(frequency) {
    const note3 = 12 * (Math.log(frequency / tuner.middleA) / Math.log(2));
    return Math.round(note3) + tuner.semitone;
  }
  function getStandardFrequency2(note3) {
    return tuner.middleA * Math.pow(2, (note3 - tuner.semitone) / 12);
  }
  function getCents2(frequency, note3) {
    return Math.floor(1200 * Math.log(frequency / getStandardFrequency2(note3)) / Math.log(2));
  }
  function freqColor2(frequency) {
    const note3 = getRawNote(frequency);
    if (!note3)
      return "#333";
    const octave2 = parseInt(note3 / 12) + 2;
    const color = pitchColor(note3, octave2);
    return color;
  }
  function getRawNote(frequency) {
    return 12 * (Math.log(frequency / settings.middleA) / Math.log(2)) % 12;
  }
})();
/**
 * CanvasRecorder is a standalone class used by {@link RecordRTC} to bring HTML5-Canvas recording into video WebM. It uses HTML2Canvas library and runs top over {@link Whammy}.
 * @summary HTML2Canvas recording into video WebM.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef CanvasRecorder
 * @class
 * @example
 * var recorder = new CanvasRecorder(htmlElement, { disableLogs: true, useWhammyRecorder: true });
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {HTMLElement} htmlElement - querySelector/getElementById/getElementsByTagName[0]/etc.
 * @param {object} config - {disableLogs:true, initCallback: function}
 */
/**
 * DiskStorage is a standalone object used by {@link RecordRTC} to store recorded blobs in IndexedDB storage.
 * @summary Writing blobs into IndexedDB.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @example
 * DiskStorage.Store({
 *     audioBlob: yourAudioBlob,
 *     videoBlob: yourVideoBlob,
 *     gifBlob  : yourGifBlob
 * });
 * DiskStorage.Fetch(function(dataURL, type) {
 *     if(type === 'audioBlob') { }
 *     if(type === 'videoBlob') { }
 *     if(type === 'gifBlob')   { }
 * });
 * // DiskStorage.dataStoreName = 'recordRTC';
 * // DiskStorage.onError = function(error) { };
 * @property {function} init - This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.
 * @property {function} Fetch - This method fetches stored blobs from IndexedDB.
 * @property {function} Store - This method stores blobs in IndexedDB.
 * @property {function} onError - This function is invoked for any known/unknown error.
 * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */
/**
 * GifRecorder is standalone calss used by {@link RecordRTC} to record video or canvas into animated gif.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef GifRecorder
 * @class
 * @example
 * var recorder = new GifRecorder(mediaStream || canvas || context, { onGifPreview: function, onGifRecordingStarted: function, width: 1280, height: 720, frameRate: 200, quality: 10 });
 * recorder.record();
 * recorder.stop(function(blob) {
 *     img.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object or HTMLCanvasElement or CanvasRenderingContext2D.
 * @param {object} config - {disableLogs:true, initCallback: function, width: 320, height: 240, frameRate: 200, quality: 10}
 */
/**
 * MRecordRTC runs on top of {@link RecordRTC} to bring multiple recordings in a single place, by providing simple API.
 * @summary MRecordRTC stands for "Multiple-RecordRTC".
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef MRecordRTC
 * @class
 * @example
 * var recorder = new MRecordRTC();
 * recorder.addStream(MediaStream);
 * recorder.mediaType = {
 *     audio: true, // or StereoAudioRecorder or MediaStreamRecorder
 *     video: true, // or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder
 *     gif: true    // or GifRecorder
 * };
 * // mimeType is optional and should be set only in advance cases.
 * recorder.mimeType = {
 *     audio: 'audio/wav',
 *     video: 'video/webm',
 *     gif:   'image/gif'
 * };
 * recorder.startRecording();
 * @see For further information:
 * @see {@link https://github.com/muaz-khan/RecordRTC/tree/master/MRecordRTC|MRecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @requires {@link RecordRTC}
 */
/**
 * MediaStreamRecorder is an abstraction layer for {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}. It is used by {@link RecordRTC} to record MediaStream(s) in both Chrome and Firefox.
 * @summary Runs top over {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://github.com/muaz-khan|Muaz Khan}
 * @typedef MediaStreamRecorder
 * @class
 * @example
 * var config = {
 *     mimeType: 'video/webm', // vp8, vp9, h264, mkv, opus/vorbis
 *     audioBitsPerSecond : 256 * 8 * 1024,
 *     videoBitsPerSecond : 256 * 8 * 1024,
 *     bitsPerSecond: 256 * 8 * 1024,  // if this is provided, skip above two
 *     checkForInactiveTracks: true,
 *     timeSlice: 1000, // concatenate intervals based blobs
 *     ondataavailable: function() {} // get intervals based blobs
 * }
 * var recorder = new MediaStreamRecorder(mediaStream, config);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 *
 *     // or
 *     var blob = recorder.blob;
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {disableLogs:true, initCallback: function, mimeType: "video/webm", timeSlice: 1000}
 * @throws Will throw an error if first argument "MediaStream" is missing. Also throws error if "MediaRecorder API" are not supported by the browser.
 */
/**
 * MultiStreamRecorder can record multiple videos in single container.
 * @summary Multi-videos recorder.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef MultiStreamRecorder
 * @class
 * @example
 * var options = {
 *     mimeType: 'video/webm'
 * }
 * var recorder = new MultiStreamRecorder(ArrayOfMediaStreams, options);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 *
 *     // or
 *     var blob = recorder.blob;
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStreams} mediaStreams - Array of MediaStreams.
 * @param {object} config - {disableLogs:true, frameInterval: 1, mimeType: "video/webm"}
 */
/**
 * RecordRTCPromisesHandler adds promises support in {@link RecordRTC}. Try a {@link https://github.com/muaz-khan/RecordRTC/blob/master/simple-demos/RecordRTCPromisesHandler.html|demo here}
 * @summary Promises for {@link RecordRTC}
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef RecordRTCPromisesHandler
 * @class
 * @example
 * var recorder = new RecordRTCPromisesHandler(mediaStream, options);
 * recorder.startRecording()
 *         .then(successCB)
 *         .catch(errorCB);
 * // Note: You can access all RecordRTC API using "recorder.recordRTC" e.g. 
 * recorder.recordRTC.onStateChanged = function(state) {};
 * recorder.recordRTC.setRecordingDuration(5000);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
 * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
 * @throws Will throw an error if "new" keyword is not used to initiate "RecordRTCPromisesHandler". Also throws error if first argument "MediaStream" is missing.
 * @requires {@link RecordRTC}
 */
/**
 * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring "stereo" audio-recording in chrome.
 * @summary JavaScript standalone object for stereo audio recording.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef StereoAudioRecorder
 * @class
 * @example
 * var recorder = new StereoAudioRecorder(MediaStream, {
 *     sampleRate: 44100,
 *     bufferSize: 4096
 * });
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {sampleRate: 44100, bufferSize: 4096, numberOfAudioChannels: 1, etc.}
 */
/**
 * Storage is a standalone object used by {@link RecordRTC} to store reusable objects e.g. "new AudioContext".
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @example
 * Storage.AudioContext === webkitAudioContext
 * @property {webkitAudioContext} AudioContext - Keeps a reference to AudioContext object.
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */
/**
 * The `Enumerations` class contains enumerations and arrays of elements used throughout the
 * library. All properties are static and should be referenced using the class name. For example:
 * `Enumerations.MIDI_CHANNEL_MESSAGES`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `Forwarder` class allows the forwarding of MIDI messages to predetermined outputs. When you
 * call its [`forward()`](#forward) method, it will send the specified [`Message`](Message) object
 * to all the outputs listed in its [`destinations`](#destinations) property.
 *
 * If specific channels or message types have been defined in the [`channels`](#channels) or
 * [`types`](#types) properties, only messages matching the channels/types will be forwarded.
 *
 * While it can be manually instantiated, you are more likely to come across a `Forwarder` object as
 * the return value of the [`Input.addForwarder()`](Input#addForwarder) method.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `InputChannel` class represents a single MIDI input channel (1-16) from a single input
 * device. This object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `InputChannel` objects can be found inside the input's [`channels`](Input#channels)
 * property.
 *
 * @fires InputChannel#midimessage
 * @fires InputChannel#unknownmessage
 *
 * @fires InputChannel#noteoff
 * @fires InputChannel#noteon
 * @fires InputChannel#keyaftertouch
 * @fires InputChannel#programchange
 * @fires InputChannel#event:controlchange-controllerxxx
 * @fires InputChannel#channelaftertouch
 * @fires InputChannel#pitchbend
 * @fires InputChannel#controlchange
 *
 * @fires InputChannel#allnotesoff
 * @fires InputChannel#allsoundoff
 * @fires InputChannel#localcontrol
 * @fires InputChannel#monomode
 * @fires InputChannel#omnimode
 * @fires InputChannel#resetallcontrollers
 *
 * @fires InputChannel#event:nrpn
 * @fires InputChannel#event:nrpn-dataentrycoarse
 * @fires InputChannel#event:nrpn-dataentryfine
 * @fires InputChannel#event:nrpn-databuttonincrement
 * @fires InputChannel#event:nrpn-databuttondecrement
 * @fires InputChannel#event:rpn
 * @fires InputChannel#event:rpn-dataentrycoarse
 * @fires InputChannel#event:rpn-dataentryfine
 * @fires InputChannel#event:rpn-databuttonincrement
 * @fires InputChannel#event:rpn-databuttondecrement
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `Input` class represents a single MIDI input port. This object is automatically instantiated
 * by the library according to the host's MIDI subsystem and does not need to be directly
 * instantiated. Instead, you can access all `Input` objects by referring to the
 * [`WebMidi.inputs`](WebMidi#inputs) array. You can also retrieve inputs by using methods such as
 * [`WebMidi.getInputByName()`](WebMidi#getInputByName) and
 * [`WebMidi.getInputById()`](WebMidi#getInputById).
 *
 * Note that a single MIDI device may expose several inputs and/or outputs.
 *
 * **Important**: the `Input` class does not directly fire channel-specific MIDI messages
 * (such as [`noteon`](InputChannel#event:noteon) or
 * [`controlchange`](InputChannel#event:controlchange), etc.). The [`InputChannel`](InputChannel)
 * object does that. However, you can still use the
 * [`Input.addListener()`](#addListener) method to listen to channel-specific events on multiple
 * [`InputChannel`](InputChannel) objects at once.
 *
 * @fires Input#opened
 * @fires Input#disconnected
 * @fires Input#closed
 * @fires Input#midimessage
 *
 * @fires Input#sysex
 * @fires Input#timecode
 * @fires Input#songposition
 * @fires Input#songselect
 * @fires Input#tunerequest
 * @fires Input#clock
 * @fires Input#start
 * @fires Input#continue
 * @fires Input#stop
 * @fires Input#activesensing
 * @fires Input#reset
 *
 * @fires Input#unknownmidimessage
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
/**
 * The `Message` class represents a single MIDI message. It has several properties that make it
 * easy to make sense of the binary data it contains.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `Note` class represents a single musical note such as `"D3"`, `"G#4"`, `"F-1"`, `"Gb7"`, etc.
 *
 * `Note` objects can be played back on a single channel by calling
 * [`OutputChannel.playNote()`]{@link OutputChannel#playNote} or, on multiple channels of the same
 * output, by calling [`Output.playNote()`]{@link Output#playNote}.
 *
 * The note has [`attack`](#attack) and [`release`](#release) velocities set at `0.5` by default.
 * These can be changed by passing in the appropriate option. It is also possible to set a
 * system-wide default for attack and release velocities by using the
 * [`WebMidi.defaults`](WebMidi#defaults) property.
 *
 * If you prefer to work with raw MIDI values (`0` to `127`), you can use [`rawAttack`](#rawAttack) and
 * [`rawRelease`](#rawRelease) to both get and set the values.
 *
 * The note may have a [`duration`](#duration). If it does, playback will be automatically stopped
 * when the duration has elapsed by sending a `"noteoff"` event. By default, the duration is set to
 * `Infinity`. In this case, it will never stop playing unless explicitly stopped by calling a
 * method such as [`OutputChannel.stopNote()`]{@link OutputChannel#stopNote},
 * [`Output.stopNote()`]{@link Output#stopNote} or similar.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `OutputChannel` class represents a single output MIDI channel. `OutputChannel` objects are
 * provided by an [`Output`](Output) port which, itself, is made available by a device. The
 * `OutputChannel` object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `OutputChannel` objects can be found inside the parent output's
 * [`channels`]{@link Output#channels} property.
 *
 * @param {Output} output The [`Output`](Output) this channel belongs to.
 * @param {number} number The MIDI channel number (`1` - `16`).
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `Output` class represents a single MIDI output port (not to be confused with a MIDI channel).
 * A port is made available by a MIDI device. A MIDI device can advertise several input and output
 * ports. Each port has 16 MIDI channels which can be accessed via the [`channels`](#channels)
 * property.
 *
 * The `Output` object is automatically instantiated by the library according to the host's MIDI
 * subsystem and should not be directly instantiated.
 *
 * You can access all available `Output` objects by referring to the
 * [`WebMidi.outputs`](WebMidi#outputs) array or by using methods such as
 * [`WebMidi.getOutputByName()`](WebMidi#getOutputByName) or
 * [`WebMidi.getOutputById()`](WebMidi#getOutputById).
 *
 * @fires Output#opened
 * @fires Output#disconnected
 * @fires Output#closed
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
/**
 * The `Utilities` class contains general-purpose utility methods. All methods are static and
 * should be called using the class name. For example: `Utilities.getNoteDetails("C4")`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `WebMidi` object makes it easier to work with the low-level Web MIDI API. Basically, it
 * simplifies sending outgoing MIDI messages and reacting to incoming MIDI messages.
 *
 * When using the WebMidi.js library, you should know that the `WebMidi` class has already been
 * instantiated. You cannot instantiate it yourself. If you use the **IIFE** version, you should
 * simply use the global object called `WebMidi`. If you use the **CJS** (CommonJS) or **ESM** (ES6
 * module) version, you get an already-instantiated object when you import the module.
 *
 * @fires WebMidi#connected
 * @fires WebMidi#disabled
 * @fires WebMidi#disconnected
 * @fires WebMidi#enabled
 * @fires WebMidi#error
 * @fires WebMidi#midiaccessgranted
 * @fires WebMidi#portschanged
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */
/**
 * WebAssemblyRecorder lets you create webm videos in JavaScript via WebAssembly. The library consumes raw RGBA32 buffers (4 bytes per pixel) and turns them into a webm video with the given framerate and quality. This makes it compatible out-of-the-box with ImageData from a CANVAS. With realtime mode you can also use webm-wasm for streaming webm videos.
 * @summary Video recording feature in Chrome, Firefox and maybe Edge.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef WebAssemblyRecorder
 * @class
 * @example
 * var recorder = new WebAssemblyRecorder(mediaStream);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {webAssemblyPath:'webm-wasm.wasm',workerPath: 'webm-worker.js', frameRate: 30, width: 1920, height: 1080, bitrate: 1024, realtime: true}
 */
/**
 * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}
 * @summary A real time javascript webm encoder based on a canvas hack.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef Whammy
 * @class
 * @example
 * var recorder = new Whammy().Video(15);
 * recorder.add(context || canvas || dataURL);
 * var output = recorder.compile();
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */
/**
 * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.
 * @summary Video recording feature in Chrome.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef WhammyRecorder
 * @class
 * @example
 * var recorder = new WhammyRecorder(mediaStream);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {disableLogs: true, initCallback: function, video: HTMLVideoElement, etc.}
 */
/**
 * {@link GetRecorderType} is an inner/private helper for {@link RecordRTC}.
 * @summary It returns best recorder-type available for your browser.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef GetRecorderType
 * @class
 * @example
 * var RecorderType = GetRecorderType(options);
 * var recorder = new RecorderType(options);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
 */
/**
 * {@link RecordRTCConfiguration} is an inner/private helper for {@link RecordRTC}.
 * @summary It configures the 2nd parameter passed over {@link RecordRTC} and returns a valid "config" object.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef RecordRTCConfiguration
 * @class
 * @example
 * var options = RecordRTCConfiguration(mediaStream, options);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, getNativeBlob:true, etc.}
 */
/**
 * {@link https://github.com/muaz-khan/RecordRTC|RecordRTC} is a WebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows. 
 * @summary Record audio, video or screen inside the browser.
 * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
 * @author {@link https://MuazKhan.com|Muaz Khan}
 * @typedef RecordRTC
 * @class
 * @example
 * var recorder = RecordRTC(mediaStream or [arrayOfMediaStream], {
 *     type: 'video', // audio or video or gif or canvas
 *     recorderType: MediaStreamRecorder || CanvasRecorder || StereoAudioRecorder || Etc
 * });
 * recorder.startRecording();
 * @see For further information:
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
 * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, desiredSampRate: 16000, video: HTMLVideoElement, etc.}
 */
//# sourceMappingURL=index.global.js.map