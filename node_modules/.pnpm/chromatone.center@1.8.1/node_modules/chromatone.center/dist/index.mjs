var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// .vitepress/use/aubio.js
var Aubio = function(Aubio2) {
  Aubio2 = Aubio2 || {};
  var c;
  c || (c = typeof Aubio2 !== "undefined" ? Aubio2 : {});
  var n = {}, r;
  for (r in c)
    c.hasOwnProperty(r) && (n[r] = c[r]);
  c.arguments = [];
  c.thisProgram = "./this.program";
  c.quit = function(a, b) {
    throw b;
  };
  c.preRun = [];
  c.postRun = [];
  var u = false, v = false, aa = false, ba = false;
  u = typeof window === "object";
  v = typeof importScripts === "function";
  aa = typeof process === "object" && typeof __require === "function" && !u && !v;
  ba = !u && !aa && !v;
  var w = "";
  function ca(a) {
    return c.locateFile ? c.locateFile(a, w) : w + a;
  }
  if (aa) {
    w = __dirname + "/";
    var da, ea;
    c.read = function(a, b) {
      da || (da = __require("fs"));
      ea || (ea = __require("path"));
      a = ea.normalize(a);
      a = da.readFileSync(a);
      return b ? a : a.toString();
    };
    c.readBinary = function(a) {
      a = c.read(a, true);
      a.buffer || (a = new Uint8Array(a));
      assert(a.buffer);
      return a;
    };
    1 < process.argv.length && (c.thisProgram = process.argv[1].replace(/\\/g, "/"));
    c.arguments = process.argv.slice(2);
    process.on("uncaughtException", function(a) {
      throw a;
    });
    process.on("unhandledRejection", function() {
      process.exit(1);
    });
    c.quit = function(a) {
      process.exit(a);
    };
    c.inspect = function() {
      return "[Emscripten Module object]";
    };
  } else if (ba)
    typeof read != "undefined" && (c.read = function(a) {
      return read(a);
    }), c.readBinary = function(a) {
      if (typeof readbuffer === "function")
        return new Uint8Array(readbuffer(a));
      a = read(a, "binary");
      assert(typeof a === "object");
      return a;
    }, typeof scriptArgs != "undefined" ? c.arguments = scriptArgs : typeof arguments != "undefined" && (c.arguments = arguments), typeof quit === "function" && (c.quit = function(a) {
      quit(a);
    });
  else if (u || v) {
    if (u) {
      var fa = this._currentScript;
      fa.src.indexOf("blob:") !== 0 && (w = "/");
    } else
      v && (w = "/");
    c.read = function(a) {
      var b = new XMLHttpRequest();
      b.open("GET", a, false);
      b.send(null);
      return b.responseText;
    };
    v && (c.readBinary = function(a) {
      var b = new XMLHttpRequest();
      b.open("GET", a, false);
      b.responseType = "arraybuffer";
      b.send(null);
      return new Uint8Array(b.response);
    });
    c.readAsync = function(a, b, d) {
      var e = new XMLHttpRequest();
      e.open("GET", a, true);
      e.responseType = "arraybuffer";
      e.onload = function() {
        e.status == 200 || e.status == 0 && e.response ? b(e.response) : d();
      };
      e.onerror = d;
      e.send(null);
    };
    c.setWindowTitle = function(a) {
      let title = a;
    };
  }
  var ha = c.print || (typeof console !== "undefined" ? console.log.bind(console) : typeof print !== "undefined" ? print : null), x = c.printErr || (typeof printErr !== "undefined" ? printErr : typeof console !== "undefined" && console.warn.bind(console) || ha);
  for (r in n)
    n.hasOwnProperty(r) && (c[r] = n[r]);
  n = void 0;
  function ia(a) {
    var b;
    b || (b = 16);
    return Math.ceil(a / b) * b;
  }
  var ja = {
    "f64-rem": function(a, b) {
      return a % b;
    },
    debugger: function() {
      debugger;
    }
  }, ka = 0;
  function assert(a, b) {
    a || y("Assertion failed: " + b);
  }
  var la = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  typeof TextDecoder !== "undefined" && new TextDecoder("utf-16le");
  var buffer, ma, z, na, oa, A, B, pa, qa;
  function ra() {
    c.HEAP8 = ma = new Int8Array(buffer);
    c.HEAP16 = na = new Int16Array(buffer);
    c.HEAP32 = A = new Int32Array(buffer);
    c.HEAPU8 = z = new Uint8Array(buffer);
    c.HEAPU16 = oa = new Uint16Array(buffer);
    c.HEAPU32 = B = new Uint32Array(buffer);
    c.HEAPF32 = pa = new Float32Array(buffer);
    c.HEAPF64 = qa = new Float64Array(buffer);
  }
  var sa, C, ta, ua, va, wa, xa;
  sa = C = ta = ua = va = wa = xa = 0;
  function ya() {
    y("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + E + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
  }
  var za = c.TOTAL_STACK || 5242880, E = c.TOTAL_MEMORY || 16777216;
  E < za && x("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + E + "! (TOTAL_STACK=" + za + ")");
  c.buffer ? buffer = c.buffer : (typeof WebAssembly === "object" && typeof WebAssembly.Memory === "function" ? (c.wasmMemory = new WebAssembly.Memory({
    initial: E / 65536,
    maximum: E / 65536
  }), buffer = c.wasmMemory.buffer) : buffer = new ArrayBuffer(E), c.buffer = buffer);
  ra();
  function Aa(a) {
    for (; 0 < a.length; ) {
      var b = a.shift();
      if (typeof b == "function")
        b();
      else {
        var d = b.B;
        typeof d === "number" ? b.F === void 0 ? c.dynCall_v(d) : c.dynCall_vi(d, b.F) : d(b.F === void 0 ? null : b.F);
      }
    }
  }
  var Ba = [], Ca = [], Da = [], Ea = [], Fa = false;
  function Ga() {
    var a = c.preRun.shift();
    Ba.unshift(a);
  }
  var Ha = Math.cos, Ia = Math.sin, F = 0, Ja = null, G = null;
  c.preloadedImages = {};
  c.preloadedAudios = {};
  function Ka(a) {
    return String.prototype.startsWith ? a.startsWith("data:application/octet-stream;base64,") : a.indexOf("data:application/octet-stream;base64,") === 0;
  }
  ;
  (function() {
    function a() {
      try {
        if (c.wasmBinary)
          return new Uint8Array(c.wasmBinary);
        if (c.readBinary)
          return c.readBinary(f);
        throw "both async and sync fetching of the wasm failed";
      } catch (g) {
        y(g);
      }
    }
    function b() {
      return c.wasmBinary || !u && !v || typeof fetch !== "function" ? new Promise(function(b2) {
        b2(a());
      }) : fetch(f, { credentials: "same-origin" }).then(function(a2) {
        if (!a2.ok)
          throw "failed to load wasm binary file at '" + f + "'";
        return a2.arrayBuffer();
      }).catch(function() {
        return a();
      });
    }
    function d(a2) {
      function d2(a3) {
        k = a3.exports;
        if (k.memory) {
          a3 = k.memory;
          var b2 = c.buffer;
          a3.byteLength < b2.byteLength && x("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");
          b2 = new Int8Array(b2);
          new Int8Array(a3).set(b2);
          c.buffer = buffer = a3;
          ra();
        }
        c.asm = k;
        c.usingWasm = true;
        F--;
        c.monitorRunDependencies && c.monitorRunDependencies(F);
        F == 0 && (Ja !== null && (clearInterval(Ja), Ja = null), G && (a3 = G, G = null, a3()));
      }
      function e2(a3) {
        d2(a3.instance);
      }
      function g(a3) {
        b().then(function(a4) {
          return WebAssembly.instantiate(a4, h);
        }).then(a3).catch(function(a4) {
          x("failed to asynchronously prepare wasm: " + a4);
          y(a4);
        });
      }
      if (typeof WebAssembly !== "object")
        return x("no native wasm support detected"), false;
      if (!(c.wasmMemory instanceof WebAssembly.Memory))
        return x("no native wasm Memory in use"), false;
      a2.memory = c.wasmMemory;
      h.global = { NaN: NaN, Infinity: Infinity };
      h["global.Math"] = Math;
      h.env = a2;
      F++;
      c.monitorRunDependencies && c.monitorRunDependencies(F);
      if (c.instantiateWasm)
        try {
          return c.instantiateWasm(h, d2);
        } catch (vb) {
          return x("Module.instantiateWasm callback failed with error: " + vb), false;
        }
      c.wasmBinary || typeof WebAssembly.instantiateStreaming !== "function" || Ka(f) || typeof fetch !== "function" ? g(e2) : WebAssembly.instantiateStreaming(fetch(f, { credentials: "same-origin" }), h).then(e2).catch(function(a3) {
        x("wasm streaming compile failed: " + a3);
        x("falling back to ArrayBuffer instantiation");
        g(e2);
      });
      return {};
    }
    var e = "aubio.wast", f = "aubio.wasm", l = "aubio.temp.asm.js";
    Ka(e) || (e = ca(e));
    Ka(f) || (f = ca(f));
    Ka(l) || (l = ca(l));
    var h = { global: null, env: null, asm2wasm: ja, parent: c }, k = null;
    c.asmPreload = c.asm;
    var m = c.reallocBuffer;
    c.reallocBuffer = function(a2) {
      if (p === "asmjs")
        var b2 = m(a2);
      else
        a: {
          var d2 = c.usingWasm ? 65536 : 16777216;
          0 < a2 % d2 && (a2 += d2 - a2 % d2);
          d2 = c.buffer.byteLength;
          if (c.usingWasm)
            try {
              b2 = c.wasmMemory.grow((a2 - d2) / 65536) !== -1 ? c.buffer = c.wasmMemory.buffer : null;
              break a;
            } catch (t) {
              b2 = null;
              break a;
            }
          b2 = void 0;
        }
      return b2;
    };
    var p = "";
    c.asm = function(a2, b2) {
      if (!b2.table) {
        a2 = c.wasmTableSize;
        a2 === void 0 && (a2 = 1024);
        var e2 = c.wasmMaxTableSize;
        b2.table = typeof WebAssembly === "object" && typeof WebAssembly.Table === "function" ? e2 !== void 0 ? new WebAssembly.Table({
          initial: a2,
          maximum: e2,
          element: "anyfunc"
        }) : new WebAssembly.Table({ initial: a2, element: "anyfunc" }) : Array(a2);
        c.wasmTable = b2.table;
      }
      b2.memoryBase || (b2.memoryBase = c.STATIC_BASE);
      b2.tableBase || (b2.tableBase = 0);
      b2 = d(b2);
      assert(b2, "no binaryen method succeeded.");
      return b2;
    };
  })();
  sa = 1024;
  C = sa + 9312;
  Ca.push({
    B: function() {
      La();
    }
  }, {
    B: function() {
      Ma();
    }
  }, {
    B: function() {
      Na();
    }
  }, {
    B: function() {
      Oa();
    }
  });
  c.STATIC_BASE = sa;
  c.STATIC_BUMP = 9312;
  C += 16;
  var H = 0;
  function I() {
    H += 4;
    return A[H - 4 >> 2];
  }
  var Pa = {};
  function J(a, b) {
    H = b;
    try {
      var d = I(), e = I(), f = I();
      a = 0;
      J.J || (J.J = [null, [], []], J.P = function(a2, b2) {
        var d2 = J.J[a2];
        assert(d2);
        if (b2 === 0 || b2 === 10) {
          a2 = a2 === 1 ? ha : x;
          a: {
            for (var e2 = b2 = 0; d2[e2]; )
              ++e2;
            if (16 < e2 - b2 && d2.subarray && la)
              b2 = la.decode(d2.subarray(b2, e2));
            else
              for (e2 = ""; ; ) {
                var f2 = d2[b2++];
                if (!f2) {
                  b2 = e2;
                  break a;
                }
                if (f2 & 128) {
                  var k2 = d2[b2++] & 63;
                  if ((f2 & 224) == 192)
                    e2 += String.fromCharCode((f2 & 31) << 6 | k2);
                  else {
                    var l2 = d2[b2++] & 63;
                    if ((f2 & 240) == 224)
                      f2 = (f2 & 15) << 12 | k2 << 6 | l2;
                    else {
                      var h2 = d2[b2++] & 63;
                      if ((f2 & 248) == 240)
                        f2 = (f2 & 7) << 18 | k2 << 12 | l2 << 6 | h2;
                      else {
                        var bb = d2[b2++] & 63;
                        if ((f2 & 252) == 248)
                          f2 = (f2 & 3) << 24 | k2 << 18 | l2 << 12 | h2 << 6 | bb;
                        else {
                          var m = d2[b2++] & 63;
                          f2 = (f2 & 1) << 30 | k2 << 24 | l2 << 18 | h2 << 12 | bb << 6 | m;
                        }
                      }
                    }
                    65536 > f2 ? e2 += String.fromCharCode(f2) : (f2 -= 65536, e2 += String.fromCharCode(55296 | f2 >> 10, 56320 | f2 & 1023));
                  }
                } else
                  e2 += String.fromCharCode(f2);
              }
          }
          a2(b2);
          d2.length = 0;
        } else
          d2.push(b2);
      });
      for (b = 0; b < f; b++) {
        for (var l = A[e + 8 * b >> 2], h = A[e + (8 * b + 4) >> 2], k = 0; k < h; k++)
          J.P(d, z[l + k]);
        a += h;
      }
      return a;
    } catch (m) {
      return typeof FS !== "undefined" && m instanceof FS.I || y(m), -m.L;
    }
  }
  function Qa(a) {
    switch (a) {
      case 1:
        return 0;
      case 2:
        return 1;
      case 4:
        return 2;
      case 8:
        return 3;
      default:
        throw new TypeError("Unknown type size: " + a);
    }
  }
  var Ra = void 0;
  function K(a) {
    for (var b = ""; z[a]; )
      b += Ra[z[a++]];
    return b;
  }
  var L = {}, M = {}, Sa = {};
  function Ta(a) {
    if (a === void 0)
      return "_unknown";
    a = a.replace(/[^a-zA-Z0-9_]/g, "$");
    var b = a.charCodeAt(0);
    return 48 <= b && 57 >= b ? "_" + a : a;
  }
  function Ua(a, b) {
    a = Ta(a);
    return new Function("body", "return function " + a + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(b);
  }
  function Va(a) {
    var b = Error, d = Ua(a, function(b2) {
      this.name = a;
      this.message = b2;
      b2 = Error(b2).stack;
      b2 !== void 0 && (this.stack = this.toString() + "\n" + b2.replace(/^Error(:[^\n]*)?\n/, ""));
    });
    d.prototype = Object.create(b.prototype);
    d.prototype.constructor = d;
    d.prototype.toString = function() {
      return this.message === void 0 ? this.name : this.name + ": " + this.message;
    };
    return d;
  }
  var O = void 0;
  function P(a) {
    throw new O(a);
  }
  var Wa = void 0;
  function Xa(a) {
    throw new Wa(a);
  }
  function Ya(a, b, d) {
    function e(b2) {
      b2 = d(b2);
      b2.length !== a.length && Xa("Mismatched type converter count");
      for (var e2 = 0; e2 < a.length; ++e2)
        Q(a[e2], b2[e2]);
    }
    a.forEach(function(a2) {
      Sa[a2] = b;
    });
    var f = Array(b.length), l = [], h = 0;
    b.forEach(function(a2, b2) {
      M.hasOwnProperty(a2) ? f[b2] = M[a2] : (l.push(a2), L.hasOwnProperty(a2) || (L[a2] = []), L[a2].push(function() {
        f[b2] = M[a2];
        ++h;
        h === l.length && e(f);
      }));
    });
    l.length === 0 && e(f);
  }
  function Q(a, b, d) {
    d = d || {};
    if (!("argPackAdvance" in b))
      throw new TypeError("registerType registeredInstance requires argPackAdvance");
    var e = b.name;
    a || P('type "' + e + '" must have a positive integer typeid pointer');
    if (M.hasOwnProperty(a)) {
      if (d.X)
        return;
      P("Cannot register type '" + e + "' twice");
    }
    M[a] = b;
    delete Sa[a];
    L.hasOwnProperty(a) && (b = L[a], delete L[a], b.forEach(function(a2) {
      a2();
    }));
  }
  function Za(a) {
    P(a.a.f.b.name + " instance already deleted");
  }
  var $a = void 0, ab = [];
  function cb() {
    for (; ab.length; ) {
      var a = ab.pop();
      a.a.s = false;
      a["delete"]();
    }
  }
  function R() {
  }
  var db = {};
  function eb(a, b, d) {
    if (a[b].j === void 0) {
      var e = a[b];
      a[b] = function() {
        a[b].j.hasOwnProperty(arguments.length) || P("Function '" + d + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[b].j + ")!");
        return a[b].j[arguments.length].apply(this, arguments);
      };
      a[b].j = [];
      a[b].j[e.A] = e;
    }
  }
  function fb(a, b) {
    c.hasOwnProperty(a) ? (P("Cannot register public name '" + a + "' twice"), eb(c, a, a), c.hasOwnProperty(void 0) && P("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), c[a].j[void 0] = b) : c[a] = b;
  }
  function gb(a, b, d, e, f, l, h, k) {
    this.name = a;
    this.constructor = b;
    this.u = d;
    this.o = e;
    this.i = f;
    this.T = l;
    this.w = h;
    this.S = k;
    this.Z = [];
  }
  function hb(a, b, d) {
    for (; b !== d; )
      b.w || P("Expected null or instance of " + d.name + ", got an instance of " + b.name), a = b.w(a), b = b.i;
    return a;
  }
  function ib(a, b) {
    if (b === null)
      return this.G && P("null is not a valid " + this.name), 0;
    b.a || P('Cannot pass "' + S(b) + '" as a ' + this.name);
    b.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
    return hb(b.a.c, b.a.f.b, this.b);
  }
  function jb(a, b) {
    if (b === null) {
      this.G && P("null is not a valid " + this.name);
      if (this.D) {
        var d = this.$();
        a !== null && a.push(this.o, d);
        return d;
      }
      return 0;
    }
    b.a || P('Cannot pass "' + S(b) + '" as a ' + this.name);
    b.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
    !this.C && b.a.f.C && P("Cannot convert argument of type " + (b.a.h ? b.a.h.name : b.a.f.name) + " to parameter type " + this.name);
    d = hb(b.a.c, b.a.f.b, this.b);
    if (this.D)
      switch (b.a.g === void 0 && P("Passing raw pointer to smart pointer is illegal"), this.ba) {
        case 0:
          b.a.h === this ? d = b.a.g : P("Cannot convert argument of type " + (b.a.h ? b.a.h.name : b.a.f.name) + " to parameter type " + this.name);
          break;
        case 1:
          d = b.a.g;
          break;
        case 2:
          if (b.a.h === this)
            d = b.a.g;
          else {
            var e = b.clone();
            d = this.aa(d, T(function() {
              e["delete"]();
            }));
            a !== null && a.push(this.o, d);
          }
          break;
        default:
          P("Unsupporting sharing policy");
      }
    return d;
  }
  function kb(a, b) {
    if (b === null)
      return this.G && P("null is not a valid " + this.name), 0;
    b.a || P('Cannot pass "' + S(b) + '" as a ' + this.name);
    b.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
    b.a.f.C && P("Cannot convert argument of type " + b.a.f.name + " to parameter type " + this.name);
    return hb(b.a.c, b.a.f.b, this.b);
  }
  function lb(a) {
    return this.fromWireType(B[a >> 2]);
  }
  function ob(a, b, d) {
    if (b === d)
      return a;
    if (d.i === void 0)
      return null;
    a = ob(a, b, d.i);
    return a === null ? null : d.S(a);
  }
  var pb = {};
  function qb(a, b) {
    for (b === void 0 && P("ptr should not be undefined"); a.i; )
      b = a.w(b), a = a.i;
    return pb[b];
  }
  function rb(a, b) {
    ;
    b.f && b.c || Xa("makeClassHandle requires ptr and ptrType");
    !!b.h !== !!b.g && Xa("Both smartPtrType and smartPtr must be specified");
    b.count = { value: 1 };
    return Object.create(a, { a: { value: b } });
  }
  function U(a, b, d, e, f, l, h, k, m, p, g) {
    this.name = a;
    this.b = b;
    this.G = d;
    this.C = e;
    this.D = f;
    this.Y = l;
    this.ba = h;
    this.M = k;
    this.$ = m;
    this.aa = p;
    this.o = g;
    f || b.i !== void 0 ? this.toWireType = jb : (this.toWireType = e ? ib : kb, this.l = null);
  }
  function sb(a, b) {
    c.hasOwnProperty(a) || Xa("Replacing nonexistant public symbol");
    c[a] = b;
    c[a].A = void 0;
  }
  function V(a, b) {
    a = K(a);
    if (c["FUNCTION_TABLE_" + a] !== void 0)
      var d = c["FUNCTION_TABLE_" + a][b];
    else if (typeof FUNCTION_TABLE !== "undefined")
      d = FUNCTION_TABLE[b];
    else {
      d = c.asm["dynCall_" + a];
      d === void 0 && (d = c.asm["dynCall_" + a.replace(/f/g, "d")], d === void 0 && P("No dynCall invoker for signature: " + a));
      for (var e = [], f = 1; f < a.length; ++f)
        e.push("a" + f);
      f = "return function " + ("dynCall_" + a + "_" + b) + "(" + e.join(", ") + ") {\n";
      f += "    return dynCall(rawFunction" + (e.length ? ", " : "") + e.join(", ") + ");\n";
      d = new Function("dynCall", "rawFunction", f + "};\n")(d, b);
    }
    typeof d !== "function" && P("unknown function pointer with signature " + a + ": " + b);
    return d;
  }
  var tb = void 0;
  function ub(a) {
    a = wb(a);
    var b = K(a);
    X(a);
    return b;
  }
  function xb(a, b) {
    function d(a2) {
      f[a2] || M[a2] || (Sa[a2] ? Sa[a2].forEach(d) : (e.push(a2), f[a2] = true));
    }
    var e = [], f = {};
    b.forEach(d);
    throw new tb(a + ": " + e.map(ub).join([", "]));
  }
  function yb(a, b) {
    for (var d = [], e = 0; e < a; e++)
      d.push(A[(b >> 2) + e]);
    return d;
  }
  function zb(a) {
    for (; a.length; ) {
      var b = a.pop();
      a.pop()(b);
    }
  }
  function Ab(a) {
    var b = Function;
    if (!(b instanceof Function))
      throw new TypeError("new_ called with constructor type " + typeof b + " which is not a function");
    var d = Ua(b.name || "unknownFunctionName", function() {
    });
    d.prototype = b.prototype;
    d = new d();
    a = b.apply(d, a);
    return a instanceof Object ? a : d;
  }
  var Bb = [], Y = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
  function Cb(a) {
    4 < a && --Y[a].H === 0 && (Y[a] = void 0, Bb.push(a));
  }
  function T(a) {
    switch (a) {
      case void 0:
        return 1;
      case null:
        return 2;
      case true:
        return 3;
      case false:
        return 4;
      default:
        var b = Bb.length ? Bb.pop() : Y.length;
        Y[b] = { H: 1, value: a };
        return b;
    }
  }
  function S(a) {
    if (a === null)
      return "null";
    var b = typeof a;
    return b === "object" || b === "array" || b === "function" ? a.toString() : "" + a;
  }
  function Db(a, b) {
    switch (b) {
      case 2:
        return function(a2) {
          return this.fromWireType(pa[a2 >> 2]);
        };
      case 3:
        return function(a2) {
          return this.fromWireType(qa[a2 >> 3]);
        };
      default:
        throw new TypeError("Unknown float type: " + a);
    }
  }
  function Eb(a, b, d) {
    switch (b) {
      case 0:
        return d ? function(a2) {
          return ma[a2];
        } : function(a2) {
          return z[a2];
        };
      case 1:
        return d ? function(a2) {
          return na[a2 >> 1];
        } : function(a2) {
          return oa[a2 >> 1];
        };
      case 2:
        return d ? function(a2) {
          return A[a2 >> 2];
        } : function(a2) {
          return B[a2 >> 2];
        };
      default:
        throw new TypeError("Unknown integer type: " + a);
    }
  }
  function Z(a) {
    a || P("Cannot use deleted val. handle = " + a);
    return Y[a].value;
  }
  function Fb(a, b) {
    var d = M[a];
    d === void 0 && P(b + " has unknown type " + ub(a));
    return d;
  }
  for (var Gb = {}, Hb = Array(256), Ib = 0; 256 > Ib; ++Ib)
    Hb[Ib] = String.fromCharCode(Ib);
  Ra = Hb;
  O = c.BindingError = Va("BindingError");
  Wa = c.InternalError = Va("InternalError");
  R.prototype.isAliasOf = function(a) {
    if (!(this instanceof R && a instanceof R))
      return false;
    var b = this.a.f.b, d = this.a.c, e = a.a.f.b;
    for (a = a.a.c; b.i; )
      d = b.w(d), b = b.i;
    for (; e.i; )
      a = e.w(a), e = e.i;
    return b === e && d === a;
  };
  R.prototype.clone = function() {
    this.a.c || Za(this);
    if (this.a.v)
      return this.a.count.value += 1, this;
    var a = this.a;
    a = Object.create(Object.getPrototypeOf(this), {
      a: {
        value: {
          count: a.count,
          s: a.s,
          v: a.v,
          c: a.c,
          f: a.f,
          g: a.g,
          h: a.h
        }
      }
    });
    a.a.count.value += 1;
    a.a.s = false;
    return a;
  };
  R.prototype["delete"] = function() {
    this.a.c || Za(this);
    this.a.s && !this.a.v && P("Object already scheduled for deletion");
    --this.a.count.value;
    if (this.a.count.value === 0) {
      var a = this.a;
      a.g ? a.h.o(a.g) : a.f.b.o(a.c);
    }
    this.a.v || (this.a.g = void 0, this.a.c = void 0);
  };
  R.prototype.isDeleted = function() {
    return !this.a.c;
  };
  R.prototype.deleteLater = function() {
    this.a.c || Za(this);
    this.a.s && !this.a.v && P("Object already scheduled for deletion");
    ab.push(this);
    ab.length === 1 && $a && $a(cb);
    this.a.s = true;
    return this;
  };
  U.prototype.U = function(a) {
    this.M && (a = this.M(a));
    return a;
  };
  U.prototype.K = function(a) {
    this.o && this.o(a);
  };
  U.prototype.argPackAdvance = 8;
  U.prototype.readValueFromPointer = lb;
  U.prototype.deleteObject = function(a) {
    if (a !== null)
      a["delete"]();
  };
  U.prototype.fromWireType = function(a) {
    function b() {
      return this.D ? rb(this.b.u, { f: this.Y, c: d, h: this, g: a }) : rb(this.b.u, { f: this, c: a });
    }
    var d = this.U(a);
    if (!d)
      return this.K(a), null;
    var e = qb(this.b, d);
    if (e !== void 0) {
      if (e.a.count.value === 0)
        return e.a.c = d, e.a.g = a, e.clone();
      e = e.clone();
      this.K(a);
      return e;
    }
    e = this.b.T(d);
    e = db[e];
    if (!e)
      return b.call(this);
    e = this.C ? e.R : e.pointerType;
    var f = ob(d, this.b, e.b);
    return f === null ? b.call(this) : this.D ? rb(e.b.u, { f: e, c: f, h: this, g: a }) : rb(e.b.u, { f: e, c: f });
  };
  c.getInheritedInstanceCount = function() {
    return Object.keys(pb).length;
  };
  c.getLiveInheritedInstances = function() {
    var a = [], b;
    for (b in pb)
      pb.hasOwnProperty(b) && a.push(pb[b]);
    return a;
  };
  c.flushPendingDeletes = cb;
  c.setDelayFunction = function(a) {
    $a = a;
    ab.length && $a && $a(cb);
  };
  tb = c.UnboundTypeError = Va("UnboundTypeError");
  c.count_emval_handles = function() {
    for (var a = 0, b = 5; b < Y.length; ++b)
      Y[b] !== void 0 && ++a;
    return a;
  };
  c.get_first_emval = function() {
    for (var a = 5; a < Y.length; ++a)
      if (Y[a] !== void 0)
        return Y[a];
    return null;
  };
  var Jb = C;
  C = C + 4 + 15 & -16;
  xa = Jb;
  ta = ua = ia(C);
  va = ta + za;
  wa = ia(va);
  A[xa >> 2] = wa;
  c.wasmTableSize = 83;
  c.wasmMaxTableSize = 83;
  c.N = {};
  c.O = {
    abort: y,
    enlargeMemory: function() {
      ya();
    },
    getTotalMemory: function() {
      return E;
    },
    abortOnCannotGrowMemory: ya,
    ___setErrNo: function(a) {
      c.___errno_location && (A[c.___errno_location() >> 2] = a);
      return a;
    },
    ___syscall140: function(a, b) {
      H = b;
      try {
        var d = Pa.V();
        I();
        var e = I(), f = I(), l = I();
        FS.ea(d, e, l);
        A[f >> 2] = d.position;
        d.W && e === 0 && l === 0 && (d.W = null);
        return 0;
      } catch (h) {
        return typeof FS !== "undefined" && h instanceof FS.I || y(h), -h.L;
      }
    },
    ___syscall146: J,
    ___syscall54: function(a, b) {
      H = b;
      return 0;
    },
    ___syscall6: function(a, b) {
      H = b;
      try {
        var d = Pa.V();
        FS.close(d);
        return 0;
      } catch (e) {
        return typeof FS !== "undefined" && e instanceof FS.I || y(e), -e.L;
      }
    },
    __embind_register_bool: function(a, b, d, e, f) {
      var l = Qa(d);
      b = K(b);
      Q(a, {
        name: b,
        fromWireType: function(a2) {
          return !!a2;
        },
        toWireType: function(a2, b2) {
          return b2 ? e : f;
        },
        argPackAdvance: 8,
        readValueFromPointer: function(a2) {
          if (d === 1)
            var e2 = ma;
          else if (d === 2)
            e2 = na;
          else if (d === 4)
            e2 = A;
          else
            throw new TypeError("Unknown boolean type size: " + b);
          return this.fromWireType(e2[a2 >> l]);
        },
        l: null
      });
    },
    __embind_register_class: function(a, b, d, e, f, l, h, k, m, p, g, q, D) {
      g = K(g);
      l = V(f, l);
      k && (k = V(h, k));
      p && (p = V(m, p));
      D = V(q, D);
      var t = Ta(g);
      fb(t, function() {
        xb("Cannot construct " + g + " due to unbound types", [e]);
      });
      Ya([a, b, d], e ? [e] : [], function(b2) {
        b2 = b2[0];
        if (e) {
          var d2 = b2.b;
          var f2 = d2.u;
        } else
          f2 = R.prototype;
        b2 = Ua(t, function() {
          if (Object.getPrototypeOf(this) !== h2)
            throw new O("Use 'new' to construct " + g);
          if (m2.m === void 0)
            throw new O(g + " has no accessible constructor");
          var a2 = m2.m[arguments.length];
          if (a2 === void 0)
            throw new O("Tried to invoke ctor of " + g + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(m2.m).toString() + ") parameters instead!");
          return a2.apply(this, arguments);
        });
        var h2 = Object.create(f2, { constructor: { value: b2 } });
        b2.prototype = h2;
        var m2 = new gb(g, b2, h2, D, d2, l, k, p);
        d2 = new U(g, m2, true, false, false);
        f2 = new U(g + "*", m2, false, false, false);
        var q2 = new U(g + " const*", m2, false, true, false);
        db[a] = { pointerType: f2, R: q2 };
        sb(t, b2);
        return [d2, f2, q2];
      });
    },
    __embind_register_class_constructor: function(a, b, d, e, f, l) {
      var h = yb(b, d);
      f = V(e, f);
      Ya([], [a], function(a2) {
        a2 = a2[0];
        var d2 = "constructor " + a2.name;
        a2.b.m === void 0 && (a2.b.m = []);
        if (a2.b.m[b - 1] !== void 0)
          throw new O("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + a2.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        a2.b.m[b - 1] = function() {
          xb("Cannot construct " + a2.name + " due to unbound types", h);
        };
        Ya([], h, function(e2) {
          a2.b.m[b - 1] = function() {
            arguments.length !== b - 1 && P(d2 + " called with " + arguments.length + " arguments, expected " + (b - 1));
            var a3 = [], h2 = Array(b);
            h2[0] = l;
            for (var k = 1; k < b; ++k)
              h2[k] = e2[k].toWireType(a3, arguments[k - 1]);
            h2 = f.apply(null, h2);
            zb(a3);
            return e2[0].fromWireType(h2);
          };
          return [];
        });
        return [];
      });
    },
    __embind_register_class_function: function(a, b, d, e, f, l, h, k) {
      var m = yb(d, e);
      b = K(b);
      l = V(f, l);
      Ya([], [a], function(a2) {
        function e2() {
          xb("Cannot call " + f2 + " due to unbound types", m);
        }
        a2 = a2[0];
        var f2 = a2.name + "." + b;
        k && a2.b.Z.push(b);
        var p = a2.b.u, t = p[b];
        t === void 0 || t.j === void 0 && t.className !== a2.name && t.A === d - 2 ? (e2.A = d - 2, e2.className = a2.name, p[b] = e2) : (eb(p, b, f2), p[b].j[d - 2] = e2);
        Ya([], m, function(e3) {
          var k2 = f2, g = a2, m2 = l, q = e3.length;
          2 > q && P("argTypes array size mismatch! Must at least get return value and 'this' types!");
          var t2 = e3[1] !== null && g !== null, D = false;
          for (g = 1; g < e3.length; ++g)
            if (e3[g] !== null && e3[g].l === void 0) {
              D = true;
              break;
            }
          var mb = e3[0].name !== "void", N = "", W = "";
          for (g = 0; g < q - 2; ++g)
            N += (g !== 0 ? ", " : "") + "arg" + g, W += (g !== 0 ? ", " : "") + "arg" + g + "Wired";
          k2 = "return function " + Ta(k2) + "(" + N + ") {\nif (arguments.length !== " + (q - 2) + ") {\nthrowBindingError('function " + k2 + " called with ' + arguments.length + ' arguments, expected " + (q - 2) + " args!');\n}\n";
          D && (k2 += "var destructors = [];\n");
          var nb = D ? "destructors" : "null";
          N = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
          m2 = [P, m2, h, zb, e3[0], e3[1]];
          t2 && (k2 += "var thisWired = classParam.toWireType(" + nb + ", this);\n");
          for (g = 0; g < q - 2; ++g)
            k2 += "var arg" + g + "Wired = argType" + g + ".toWireType(" + nb + ", arg" + g + "); // " + e3[g + 2].name + "\n", N.push("argType" + g), m2.push(e3[g + 2]);
          t2 && (W = "thisWired" + (0 < W.length ? ", " : "") + W);
          k2 += (mb ? "var rv = " : "") + "invoker(fn" + (0 < W.length ? ", " : "") + W + ");\n";
          if (D)
            k2 += "runDestructors(destructors);\n";
          else
            for (g = t2 ? 1 : 2; g < e3.length; ++g)
              q = g === 1 ? "thisWired" : "arg" + (g - 2) + "Wired", e3[g].l !== null && (k2 += q + "_dtor(" + q + "); // " + e3[g].name + "\n", N.push(q + "_dtor"), m2.push(e3[g].l));
          mb && (k2 += "var ret = retType.fromWireType(rv);\nreturn ret;\n");
          N.push(k2 + "}\n");
          e3 = Ab(N).apply(null, m2);
          p[b].j === void 0 ? (e3.A = d - 2, p[b] = e3) : p[b].j[d - 2] = e3;
          return [];
        });
        return [];
      });
    },
    __embind_register_emval: function(a, b) {
      b = K(b);
      Q(a, {
        name: b,
        fromWireType: function(a2) {
          var b2 = Y[a2].value;
          Cb(a2);
          return b2;
        },
        toWireType: function(a2, b2) {
          return T(b2);
        },
        argPackAdvance: 8,
        readValueFromPointer: lb,
        l: null
      });
    },
    __embind_register_float: function(a, b, d) {
      d = Qa(d);
      b = K(b);
      Q(a, {
        name: b,
        fromWireType: function(a2) {
          return a2;
        },
        toWireType: function(a2, b2) {
          if (typeof b2 !== "number" && typeof b2 !== "boolean")
            throw new TypeError('Cannot convert "' + S(b2) + '" to ' + this.name);
          return b2;
        },
        argPackAdvance: 8,
        readValueFromPointer: Db(b, d),
        l: null
      });
    },
    __embind_register_integer: function(a, b, d, e, f) {
      function l(a2) {
        return a2;
      }
      b = K(b);
      f === -1 && (f = 4294967295);
      var h = Qa(d);
      if (e === 0) {
        var k = 32 - 8 * d;
        l = function(a2) {
          return a2 << k >>> k;
        };
      }
      var m = b.indexOf("unsigned") != -1;
      Q(a, {
        name: b,
        fromWireType: l,
        toWireType: function(a2, d2) {
          if (typeof d2 !== "number" && typeof d2 !== "boolean")
            throw new TypeError('Cannot convert "' + S(d2) + '" to ' + this.name);
          if (d2 < e || d2 > f)
            throw new TypeError('Passing a number "' + S(d2) + '" from JS side to C/C++ side to an argument of type "' + b + '", which is outside the valid range [' + e + ", " + f + "]!");
          return m ? d2 >>> 0 : d2 | 0;
        },
        argPackAdvance: 8,
        readValueFromPointer: Eb(b, h, e !== 0),
        l: null
      });
    },
    __embind_register_memory_view: function(a, b, d) {
      function e(a2) {
        a2 >>= 2;
        var b2 = B;
        return new f(b2.buffer, b2[a2 + 1], b2[a2]);
      }
      var f = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ][b];
      d = K(d);
      Q(a, {
        name: d,
        fromWireType: e,
        argPackAdvance: 8,
        readValueFromPointer: e
      }, { X: true });
    },
    __embind_register_std_string: function(a, b) {
      b = K(b);
      Q(a, {
        name: b,
        fromWireType: function(a2) {
          for (var b2 = B[a2 >> 2], d = Array(b2), l = 0; l < b2; ++l)
            d[l] = String.fromCharCode(z[a2 + 4 + l]);
          X(a2);
          return d.join("");
        },
        toWireType: function(a2, b2) {
          function d(a3, b3) {
            return a3[b3];
          }
          function e(a3, b3) {
            return a3.charCodeAt(b3);
          }
          b2 instanceof ArrayBuffer && (b2 = new Uint8Array(b2));
          var h;
          b2 instanceof Uint8Array ? h = d : b2 instanceof Uint8ClampedArray ? h = d : b2 instanceof Int8Array ? h = d : typeof b2 === "string" ? h = e : P("Cannot pass non-string to std::string");
          var k = b2.length, m = Kb(4 + k);
          B[m >> 2] = k;
          for (var p = 0; p < k; ++p) {
            var g = h(b2, p);
            255 < g && (X(m), P("String has UTF-16 code units that do not fit in 8 bits"));
            z[m + 4 + p] = g;
          }
          a2 !== null && a2.push(X, m);
          return m;
        },
        argPackAdvance: 8,
        readValueFromPointer: lb,
        l: function(a2) {
          X(a2);
        }
      });
    },
    __embind_register_std_wstring: function(a, b, d) {
      d = K(d);
      if (b === 2) {
        var e = function() {
          return oa;
        };
        var f = 1;
      } else
        b === 4 && (e = function() {
          return B;
        }, f = 2);
      Q(a, {
        name: d,
        fromWireType: function(a2) {
          for (var b2 = e(), d2 = B[a2 >> 2], l = Array(d2), p = a2 + 4 >> f, g = 0; g < d2; ++g)
            l[g] = String.fromCharCode(b2[p + g]);
          X(a2);
          return l.join("");
        },
        toWireType: function(a2, d2) {
          var k = e(), h = d2.length, l = Kb(4 + h * b);
          B[l >> 2] = h;
          for (var g = l + 4 >> f, q = 0; q < h; ++q)
            k[g + q] = d2.charCodeAt(q);
          a2 !== null && a2.push(X, l);
          return l;
        },
        argPackAdvance: 8,
        readValueFromPointer: lb,
        l: function(a2) {
          X(a2);
        }
      });
    },
    __embind_register_void: function(a, b) {
      b = K(b);
      Q(a, {
        da: true,
        name: b,
        argPackAdvance: 0,
        fromWireType: function() {
        },
        toWireType: function() {
        }
      });
    },
    __emval_as: function(a, b, d) {
      a = Z(a);
      b = Fb(b, "emval::as");
      var e = [], f = T(e);
      A[d >> 2] = f;
      return b.toWireType(e, a);
    },
    __emval_decref: Cb,
    __emval_get_property: function(a, b) {
      a = Z(a);
      b = Z(b);
      return T(a[b]);
    },
    __emval_incref: function(a) {
      4 < a && (Y[a].H += 1);
    },
    __emval_new_array: function() {
      return T([]);
    },
    __emval_new_cstring: function(a) {
      var b = Gb[a];
      return T(b === void 0 ? K(a) : b);
    },
    __emval_new_object: function() {
      return T({});
    },
    __emval_run_destructors: function(a) {
      zb(Y[a].value);
      Cb(a);
    },
    __emval_set_property: function(a, b, d) {
      a = Z(a);
      b = Z(b);
      d = Z(d);
      a[b] = d;
    },
    __emval_take_value: function(a, b) {
      a = Fb(a, "_emval_take_value");
      a = a.readValueFromPointer(b);
      return T(a);
    },
    _abort: function() {
      c.abort();
    },
    _emscripten_memcpy_big: function(a, b, d) {
      z.set(z.subarray(b, b + d), a);
      return a;
    },
    _llvm_cos_f32: Ha,
    _llvm_log10_f32: function(a) {
      return Math.log(a) / Math.LN10;
    },
    _llvm_sin_f32: Ia,
    DYNAMICTOP_PTR: xa,
    STACKTOP: ua
  };
  var Lb = c.asm(c.N, c.O, buffer);
  c.asm = Lb;
  var Oa = c.__GLOBAL__sub_I_bind_cpp = function() {
    return c.asm.__GLOBAL__sub_I_bind_cpp.apply(null, arguments);
  }, La = c.__GLOBAL__sub_I_fft_cc = function() {
    return c.asm.__GLOBAL__sub_I_fft_cc.apply(null, arguments);
  }, Na = c.__GLOBAL__sub_I_pitch_cc = function() {
    return c.asm.__GLOBAL__sub_I_pitch_cc.apply(null, arguments);
  }, Ma = c.__GLOBAL__sub_I_tempo_cc = function() {
    return c.asm.__GLOBAL__sub_I_tempo_cc.apply(null, arguments);
  }, wb = c.___getTypeName = function() {
    return c.asm.___getTypeName.apply(null, arguments);
  }, X = c._free = function() {
    return c.asm._free.apply(null, arguments);
  }, Kb = c._malloc = function() {
    return c.asm._malloc.apply(null, arguments);
  };
  c.dynCall_ffii = function() {
    return c.asm.dynCall_ffii.apply(null, arguments);
  };
  c.dynCall_fi = function() {
    return c.asm.dynCall_fi.apply(null, arguments);
  };
  c.dynCall_fii = function() {
    return c.asm.dynCall_fii.apply(null, arguments);
  };
  c.dynCall_fiii = function() {
    return c.asm.dynCall_fiii.apply(null, arguments);
  };
  c.dynCall_ii = function() {
    return c.asm.dynCall_ii.apply(null, arguments);
  };
  c.dynCall_iii = function() {
    return c.asm.dynCall_iii.apply(null, arguments);
  };
  c.dynCall_iiii = function() {
    return c.asm.dynCall_iiii.apply(null, arguments);
  };
  c.dynCall_iiiii = function() {
    return c.asm.dynCall_iiiii.apply(null, arguments);
  };
  c.dynCall_iiiiii = function() {
    return c.asm.dynCall_iiiiii.apply(null, arguments);
  };
  c.dynCall_v = function() {
    return c.asm.dynCall_v.apply(null, arguments);
  };
  c.dynCall_vi = function() {
    return c.asm.dynCall_vi.apply(null, arguments);
  };
  c.dynCall_viii = function() {
    return c.asm.dynCall_viii.apply(null, arguments);
  };
  c.asm = Lb;
  c.then = function(a) {
    if (c.calledRun)
      a(c);
    else {
      var b = c.onRuntimeInitialized;
      c.onRuntimeInitialized = function() {
        b && b();
        a(c);
      };
    }
    return c;
  };
  G = function Mb() {
    c.calledRun || Nb();
    c.calledRun || (G = Mb);
  };
  function Nb() {
    function a() {
      if (!c.calledRun && (c.calledRun = true, !ka)) {
        Fa || (Fa = true, Aa(Ca));
        Aa(Da);
        if (c.onRuntimeInitialized)
          c.onRuntimeInitialized();
        if (c.postRun)
          for (typeof c.postRun == "function" && (c.postRun = [c.postRun]); c.postRun.length; ) {
            var a2 = c.postRun.shift();
            Ea.unshift(a2);
          }
        Aa(Ea);
      }
    }
    if (!(0 < F)) {
      if (c.preRun)
        for (typeof c.preRun == "function" && (c.preRun = [c.preRun]); c.preRun.length; )
          Ga();
      Aa(Ba);
      0 < F || c.calledRun || (c.setStatus ? (c.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          c.setStatus("");
        }, 1);
        a();
      }, 1)) : a());
    }
  }
  c.run = Nb;
  function y(a) {
    if (c.onAbort)
      c.onAbort(a);
    a !== void 0 ? (ha(a), x(a), a = JSON.stringify(a)) : a = "";
    ka = true;
    throw "abort(" + a + "). Build with -s ASSERTIONS=1 for more info.";
  }
  c.abort = y;
  if (c.preInit)
    for (typeof c.preInit == "function" && (c.preInit = [c.preInit]); 0 < c.preInit.length; )
      c.preInit.pop()();
  c.noExitRuntime = true;
  Nb();
  return Aubio2;
};
var aubio_default = Aubio.bind({
  _currentScript: {
    src: "/aubio.js"
  }
});

// .vitepress/use/audio.js
import { getDestination, start, gainToDb, Meter, context, Reverb, Limiter, Channel, Solo, Gain } from "tone";

// .vitepress/use/recorder.js
import { Recorder } from "tone";
import { useLastChanged, useTimestamp as useTimestamp2 } from "@vueuse/core";

// .vitepress/use/cast.js
import { useTimestamp } from "@vueuse/core";
import { useDevicesList, useEventListener, useStorage as useStorage2 } from "@vueuse/core";
var currentCamera = useStorage2("cast-camera", "default");
var currentMic = useStorage2("cast-mic", "default");
var showRecordingDialog = ref();
var recordingName = ref("");
var recordCamera = ref(true);
var mimeType = useStorage2("slidev-record-mimetype", "video/webm");
var mimeExtMap = {
  "video/webm": "webm",
  "video/webm;codecs=h264": "mp4",
  "video/x-matroska;codecs=avc1": "mkv"
};
function getFilename(media, mimeType2) {
  const d = new Date();
  const pad = (v) => `${v}`.padStart(2, "0");
  const date = `${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}`;
  const ext = mimeType2 ? mimeExtMap[mimeType2] : "webm";
  return `${[date, media, recordingName.value].filter((el) => !!el).join("-")}.${ext}`;
}
function getSupportedMimeTypes() {
  if (MediaRecorder && typeof (MediaRecorder == null ? void 0 : MediaRecorder.isTypeSupported) === "function") {
    return Object.keys(mimeExtMap).filter((mime) => MediaRecorder.isTypeSupported(mime));
  }
  return [];
}
var fileNames = reactive({
  screen: computed(() => getFilename("screen", mimeType.value)),
  camera: computed(() => getFilename("camera", mimeType.value))
});
var {
  devices,
  videoInputs: cameras,
  audioInputs: microphones,
  ensurePermissions: ensureDevicesListPermissions
} = useDevicesList({
  onUpdated: function() {
    var _a, _b;
    if (currentCamera.value !== "none") {
      if (!cameras.value.find((i) => i.deviceId === currentCamera.value))
        currentCamera.value = ((_a = cameras.value[0]) == null ? void 0 : _a.deviceId) || "default";
    }
    if (currentMic.value !== "none") {
      if (!microphones.value.find((i) => i.deviceId === currentMic.value))
        currentMic.value = ((_b = microphones.value[0]) == null ? void 0 : _b.deviceId) || "default";
    }
  }
});
function download(name, url) {
  const a = document.createElement("a");
  a.setAttribute("href", url);
  a.setAttribute("download", name);
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}
function useRecording() {
  const recording2 = ref(false);
  const recordingStartedAt = ref();
  const timestamp2 = useTimestamp();
  watch(recording2, (r) => r ? recordingStartedAt.value = Date.now() : recordingStartedAt.value = null);
  const recordingTime = computed(() => {
    if (!recordingStartedAt.value)
      return 0;
    return timestamp2.value - recordingStartedAt.value;
  });
  const showAvatar = ref(false);
  const recorderCamera = shallowRef();
  const recorderSlides = shallowRef();
  const streamCamera = shallowRef();
  const streamCapture = shallowRef();
  const streamSlides = shallowRef();
  const config = {
    type: "video",
    bitsPerSecond: 4 * 256 * 8 * 1024,
    timeSlice: 24 * 60 * 60 * 1e3
  };
  async function toggleAvatar() {
    if (currentCamera.value === "none")
      return;
    if (showAvatar.value) {
      showAvatar.value = false;
      if (!recording2.value)
        closeStream(streamCamera);
    } else {
      await startCameraStream();
      if (streamCamera.value)
        showAvatar.value = !!streamCamera.value;
    }
  }
  async function startCameraStream() {
    await ensureDevicesListPermissions();
    await nextTick();
    if (!streamCamera.value) {
      if (currentCamera.value === "none" && currentMic.value === "none")
        return;
      streamCamera.value = await navigator.mediaDevices.getUserMedia({
        video: currentCamera.value === "none" || recordCamera.value !== true ? false : {
          deviceId: currentCamera.value
        },
        audio: currentMic.value === "none" ? false : {
          deviceId: currentMic.value
        }
      });
    }
  }
  watch(currentCamera, async (v) => {
    if (v === "none") {
      closeStream(streamCamera);
    } else {
      if (recording2.value)
        return;
      if (streamCamera.value) {
        closeStream(streamCamera);
        await startCameraStream();
      }
    }
  });
  async function startRecording(customConfig) {
    var _a;
    await ensureDevicesListPermissions();
    const { default: Recorder3 } = await import("recordrtc");
    await startCameraStream();
    streamCapture.value = await navigator.mediaDevices.getDisplayMedia({
      video: {
        frameRate: 30,
        width: 3840,
        height: 2160,
        cursor: "motion",
        resizeMode: "crop-and-scale"
      }
    });
    streamCapture.value.addEventListener("inactive", stopRecording);
    streamSlides.value = new MediaStream();
    streamCapture.value.getVideoTracks().forEach((videoTrack) => streamSlides.value.addTrack(videoTrack));
    Object.assign(config, customConfig);
    if (streamCamera.value) {
      streamSlides.value.addTrack((_a = master.stream.stream.getAudioTracks()) == null ? void 0 : _a[0]);
      recorderCamera.value = new Recorder3(streamCamera.value, config);
      recorderCamera.value.startRecording();
    }
    recorderSlides.value = new Recorder3(streamSlides.value, config);
    recorderSlides.value.startRecording();
    recording2.value = true;
  }
  async function stopRecording() {
    var _a, _b;
    recording2.value = false;
    (_a = recorderCamera.value) == null ? void 0 : _a.stopRecording(() => {
      if (recordCamera.value) {
        const blob = recorderCamera.value.getBlob();
        const url = URL.createObjectURL(blob);
        download(getFilename("camera", config.mimeType), url);
        window.URL.revokeObjectURL(url);
      }
      recorderCamera.value = void 0;
      if (!showAvatar.value)
        closeStream(streamCamera);
    });
    (_b = recorderSlides.value) == null ? void 0 : _b.stopRecording(() => {
      const blob = recorderSlides.value.getBlob();
      const url = URL.createObjectURL(blob);
      download(getFilename("screen", config.mimeType), url);
      window.URL.revokeObjectURL(url);
      closeStream(streamCapture);
      closeStream(streamSlides);
      recorderSlides.value = void 0;
    });
  }
  function closeStream(stream) {
    const s = stream.value;
    if (!s)
      return;
    s.getTracks().forEach((i) => {
      i.stop();
      s.removeTrack(i);
    });
    stream.value = void 0;
  }
  function toggleRecording() {
    if (recording2.value)
      stopRecording();
    else
      startRecording();
  }
  useEventListener("beforeunload", (event) => {
    if (!recording2.value)
      return;
    if (confirm("Recording is not saved yet, do you want to leave?"))
      return;
    event.preventDefault();
    event.returnValue = "";
  });
  return {
    recording: recording2,
    recordingTime,
    showAvatar,
    toggleRecording,
    startRecording,
    stopRecording,
    toggleAvatar,
    recorderCamera,
    recorderSlides,
    streamCamera,
    streamCapture,
    streamSlides
  };
}
var cast = useRecording();

// .vitepress/use/recorder.js
var recorder;
var recording = ref(false);
var toggled = useLastChanged(recording);
var timestamp = useTimestamp2();
var duration = computed(() => timestamp.value - toggled.value);
var record = {
  start() {
    if (!recorder)
      useRecorder();
    recorder.start();
    recording.value = true;
  },
  async stop() {
    const date = new Date();
    recording.value = false;
    const rec = await recorder.stop();
    const url = URL.createObjectURL(rec);
    const anchor = document.createElement("a");
    anchor.download = getFilename("rec");
    anchor.href = url;
    anchor.click();
  }
};
function useRecorder() {
  if (!recorder) {
    recorder = new Recorder();
  }
  return { recorder, record, recording, toggled, duration };
}

// .vitepress/use/audio.js
var audio = reactive({
  initiated: false,
  mute: useStorage("mute", false),
  volume: useClamp(useStorage("main-vol", 1), 0, 2),
  meter: 0
});
var master = shallowReactive({});
var channels = shallowReactive({});
function useAudio() {
  if (!audio.initiated) {
    start();
    const { recorder: recorder2 } = useRecorder();
    master.stream = context.createMediaStreamDestination();
    master.meter = new Meter().toDestination();
    master.meter.normalRange = true;
    master.meter.connect(master.stream);
    master.meter.connect(recorder2);
    useRafFn(() => {
      audio.meter = master.meter.getValue();
    });
    master.limiter = new Limiter(-18).connect(master.meter);
    master.reverb = new Reverb({
      decay: 1,
      wet: 0.5
    }).connect(master.meter);
    master.limiter.connect(master.reverb);
    watchEffect(() => {
      getDestination().mute = audio.mute;
    });
    watchEffect(() => {
      getDestination().volume.targetRampTo(gainToDb(audio.volume), 0.1);
    });
    audio.initiated = true;
  }
  return { audio, master, channels };
}
function createChannel(title = (Math.random() * 1e3).toFixed(0), options2) {
  const { master: master2 } = useAudio();
  const channel = new Limiter(options2).connect(master2.limiter);
  channels[title] = channel;
  return { channel };
}
function initGetUserMedia() {
  window.AudioContext = window.AudioContext || window.webkitAudioContext;
  if (!window.AudioContext) {
    return alert("AudioContext not supported");
  }
  if (navigator.mediaDevices === void 0) {
    navigator.mediaDevices = {};
  }
  if (navigator.mediaDevices.getUserMedia === void 0) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
      if (!getUserMedia) {
        alert("getUserMedia is not implemented in this browser");
      }
      return new Promise(function(resolve, reject) {
        getUserMedia.call(navigator, constraints, resolve, reject);
      });
    };
  }
}

// .vitepress/use/calculations.js
var midiA = 69;
function pitchNoteOctave(pitch) {
  return {
    note: pitch > 0 ? pitch % 12 : 12 + pitch % 12,
    octave: Math.floor(pitch / 12) + 4
  };
}
function pitchFreq(pitch = 0, octave = 3, middleA = 440, tuning = "equal") {
  let hz = 0;
  const justCents = [0, 112, 204, 316, 386, 498, 590, 702, 814, 884, 1017, 1088];
  if (tuning == "equal") {
    hz = Number(middleA * Math.pow(2, octave - 3 + pitch / 12));
  }
  if (tuning == "just") {
    let diff = Number(Math.pow(Math.pow(2, 1 / 1200), justCents[pitch]));
    hz = Number(middleA * Math.pow(2, octave - 4) * diff);
  }
  return hz;
}
function pitchColor(pitch = 0, octave, velocity = 1, alpha = 1) {
  octave = octave || Math.floor(pitch / 12) + 4;
  return `hsla(${pitch % 12 * 30},${velocity * 100}%,${Math.abs(octave + 2) * 8}%,${alpha})`;
}
function freqColor(freq) {
  return pitchColor(freqPitch(freq));
}
function freqPitch(freq, middleA = 440) {
  return 12 * (Math.log(freq / middleA) / Math.log(2));
}
function isInChroma(chroma, tonic, note) {
  return chroma.split("")[(24 + note - tonic) % 12] == "1";
}
function getCircleCoord(n = 0, total = 12, radius = 35, width = 100) {
  let angle = (n - total / 4) / (total / 2) * Math.PI;
  let x = radius * Math.cos(angle) + width / 2;
  let y = radius * Math.sin(angle) + width / 2;
  return { x, y };
}
function rotateArray(arr, count = 1) {
  return [...arr.slice(count, arr.length), ...arr.slice(0, count)];
}
function clampNum(main, delta, min = 0, max = 100) {
  return Math.max(min, Math.min(Number(main) + Number(delta), max));
}
function getCents(frequency, pitch) {
  return Math.floor(1200 * Math.log(frequency / getStandardFrequency(pitch)) / Math.log(2));
}
function getStandardFrequency(pitch, middleA = 440) {
  return middleA * Math.pow(2, (pitch - 69) / 12);
}

// .vitepress/use/chroma.js
import { Frequency } from "tone";

// .vitepress/use/midi.js
import { WebMidi, Note } from "webmidi";
import { useStorage as useStorage3 } from "@vueuse/core";

// .vitepress/use/keyboard.js
var noteKeys = {
  "KeyQ": { note: "F", offset: 1 },
  "Digit2": { note: "F#", offset: 1 },
  "KeyW": { note: "G", offset: 1 },
  "Digit3": { note: "G#", offset: 1 },
  "KeyE": { note: "A", offset: 1 },
  "Digit4": { note: "A#", offset: 1 },
  "KeyR": { note: "B", offset: 1 },
  "KeyT": { note: "C", offset: 2 },
  "Digit6": { note: "C#", offset: 2 },
  "KeyY": { note: "D", offset: 2 },
  "Digit7": { note: "D#", offset: 2 },
  "KeyU": { note: "E", offset: 2 },
  "KeyI": { note: "F", offset: 2 },
  "Digit9": { note: "F#", offset: 2 },
  "KeyO": { note: "G", offset: 2 },
  "Digit0": { note: "G#", offset: 2 },
  "KeyP": { note: "A", offset: 2 },
  "Minus": { note: "A#", offset: 2 },
  "BracketLeft": { note: "B", offset: 2 },
  "BracketRIght": { note: "C", offset: 3 },
  "KeyZ": { note: "C", offset: 0 },
  "KeyS": { note: "C#", offset: 0 },
  "KeyX": { note: "D", offset: 0 },
  "KeyD": { note: "D#", offset: 0 },
  "KeyC": { note: "E", offset: 0 },
  "KeyV": { note: "F", offset: 0 },
  "KeyG": { note: "F#", offset: 0 },
  "KeyB": { note: "G", offset: 0 },
  "KeyH": { note: "G#", offset: 0 },
  "KeyN": { note: "A", offset: 0 },
  "KeyJ": { note: "A#", offset: 0 },
  "KeyM": { note: "B", offset: 0 },
  "Comma": { note: "C", offset: 1 },
  "KeyL": { note: "C#", offset: 1 },
  "Period": { note: "D", offset: 1 },
  "Semicolon": { note: "D#", offset: 1 },
  "Slash": { note: "E", offset: 1 }
};
function setupKeyboard() {
  document.addEventListener("keydown", (e) => {
    if (e.code == "Digit1")
      midi.offset--;
    if (e.code == "Equal")
      midi.offset++;
    if (e.repeat || !midi.keyboard || !noteKeys[e.code])
      return;
    if (e.ctrlKey || e.altKey || e.metaKey)
      return;
    if (e.code == "Slash")
      e.preventDefault();
    playKey(noteKeys[e.code].note, noteKeys[e.code].offset);
  });
  document.addEventListener("keyup", (e) => {
    if (!noteKeys[e.code])
      return;
    playKey(noteKeys[e.code].note, noteKeys[e.code].offset, true);
  });
}

// .vitepress/use/midi.js
import { useClamp as useClamp2 } from "@vueuse/core";
var midi = reactive({
  enabled: false,
  initiated: false,
  out: true,
  inputs: {},
  outputs: {},
  forwards: {},
  playing: false,
  channels: {},
  channel: useStorage3("global-midi-channel", 1),
  note: {
    pitch: 0,
    channel: 1
  },
  offset: useClamp2(0, -2, 2),
  keyboard: true,
  cc: {},
  ccLearn: {},
  message: null,
  log: [],
  clock: 0,
  filter: useStorage3("global-midi-filter", {}),
  available: computed(() => Object.entries(midi.outputs).length > 0),
  activeNotes: computed(() => {
    let notes2 = {};
    for (let ch in midi.channels) {
      for (let num in midi.channels[ch].activeNotes) {
        notes2[num] = midi.channels[ch].activeNotes[num];
      }
    }
    return notes2;
  }),
  activeChroma: computed(() => {
    let chroma = new Array(12);
    for (let num in midi.activeNotes) {
      chroma[(num - 9) % 12] = num;
    }
    return chroma;
  })
});
function learnCC({ param, number, channel } = {}) {
  const val = ref(0);
  watch(() => midi.cc, (cc) => {
    if (channel && cc.channel != channel)
      return;
    if (number == cc.number)
      val.value = cc.value;
  });
  return val;
}
function playKey(name, offset = 0, off, velocity = 1) {
  let noteName = name + (4 + offset + midi.offset);
  const note = new Note(noteName, {
    attack: off ? 0 : velocity,
    release: off ? 0 : velocity
  });
  const ev = {
    type: off ? "noteoff" : "noteon",
    note,
    port: { id: "PC Keyboard" },
    timestamp: midi.time,
    target: { number: 0 }
  };
  noteInOn(ev);
}
function useMidi() {
  if (!midi.initiated) {
    setupKeyboard();
    onMounted(() => {
      if (WebMidi.supported) {
        setupMidi();
      }
    });
    watchEffect(() => {
      if (!midi.out)
        return;
      let outs = Object.values(WebMidi.outputs);
      if (midi.playing) {
        outs.forEach((output) => {
          output.sendContinue();
        });
      } else {
        outs.forEach((output) => {
          output.sendStop();
        });
      }
    });
    midi.initiated = true;
  }
  return {
    midi,
    midiAttack,
    midiRelease,
    midiOnce: midiOnce2,
    setCC,
    WebMidi
  };
}
function setupMidi() {
  WebMidi.enable();
  WebMidi.addListener("enabled", (e) => {
    midi.enabled = true;
    initMidi();
  });
  WebMidi.addListener("connected", (e) => {
    initMidi();
  });
  WebMidi.addListener("disconnected", (e) => {
    delete midi[e.port.type + "s"][e.port.id];
  });
  midi.initiated = true;
}
function initMidi() {
  midi.inputs = reactive({});
  WebMidi.inputs.forEach((input2) => {
    midi.enabled = true;
    midi.inputs[input2.id] = {
      name: input2.name,
      manufacturer: input2.manufacturer,
      forwarder: input2.addForwarder(),
      event: null,
      note: null,
      cc: null
    };
    input2.removeListener();
    input2.addListener("start", () => {
      midi.playing = true;
    });
    input2.addListener("stop", () => {
      midi.playing = false;
      midi.channels = {};
    });
    input2.addListener("midimessage", (ev) => {
      var _a;
      if (((_a = ev == null ? void 0 : ev.message) == null ? void 0 : _a.type) == "clock")
        return;
      midi.inputs[input2.id].event = ev;
      midi.message = ev.message;
      midi.log.unshift(ev);
      if (midi.log.length > 100)
        midi.log.pop();
    });
    input2.addListener("noteon", (ev) => {
      midi.inputs[input2.id].note = noteInOn(ev);
    }, {
      channels: "all"
    });
    input2.addListener("noteoff", (ev) => {
      midi.inputs[input2.id].note = noteInOn(ev);
    }, { channels: "all" });
    input2.addListener("controlchange", (ev) => {
      const cc = ccIn(ev);
      if (!cc)
        return;
      midi.inputs[input2.id].cc = cc;
      midi.cc = cc;
    }, {
      channels: "all"
    });
    input2.addListener("clock", (ev) => {
      midi.clock = ev.timestamp;
    });
  });
  midi.outputs = reactive({});
  WebMidi.outputs.forEach((output) => {
    midi.outputs[output.id] = {
      name: output.name,
      manufacturer: output.manufacturer
    };
  });
}
function noteInOn(ev) {
  let note = ev.note;
  note.port = ev.port.id;
  note.type = ev.type;
  note.timestamp = ev.timestamp;
  note.channel = ev.target.number;
  if (midi.filter[note.channel])
    return;
  createChannel2(note.channel);
  midi.channels[note.channel].notes[note.number] = note;
  if (ev.type == "noteoff") {
    note.velocity = 0;
    delete midi.channels[note.channel].activeNotes[note.number];
  } else {
    note.velocity = 120 * (ev.note.attack || 1);
    midi.channels[note.channel].activeNotes[note.number] = true;
  }
  note.pitch = (note.number + 3) % 12;
  note.octA = Math.floor((note.number + 3) / 12) - 1;
  midi.note = note;
  return note;
}
function ccIn(ev) {
  if (midi.filter[ev.target.number])
    return;
  let cc = {
    channel: ev.target.number,
    timestamp: ev.timestamp,
    number: ev.controller.number,
    value: ev.value,
    raw: ev.rawValue,
    port: ev.port.id
  };
  createChannel2(cc.channel);
  midi.channels[cc.channel].cc[cc.number] = cc;
  return cc;
}
function createChannel2(ch) {
  if (!midi.channels[ch]) {
    midi.channels[ch] = reactive({ num: ch, activeNotes: {}, notes: {}, cc: {} });
  }
}
function setVelocity(channel, note, velocity) {
  var _a, _b, _c;
  if ((_c = (_b = (_a = midi.channels) == null ? void 0 : _a[channel]) == null ? void 0 : _b.notes) == null ? void 0 : _c[note]) {
    midi.channels[channel].notes[note].velocity = velocity;
  }
}
function midiAttack(note, options2) {
  if (!midi.out)
    return;
  let channel = (note == null ? void 0 : note.channel) || midi.channel;
  setVelocity(channel, note == null ? void 0 : note.number, 100);
  WebMidi.outputs.forEach((output) => {
    output.playNote(note.number, {
      channels: channel,
      ...options2
    });
  });
}
function midiPlay(note, options2) {
  if (!midi.out)
    return;
  WebMidi.outputs.forEach((output) => {
    output.playNote(note, {
      channels: midi.channel,
      ...options2
    });
  });
}
function midiStop(note, options2) {
  if (!midi.out)
    return;
  if (note) {
    WebMidi.outputs.forEach((output) => {
      output.stopNote(note, { channels: midi.channel, ...options2 });
    });
  } else {
    WebMidi.outputs.forEach((output) => {
      output.sendAllNotesOff();
      output.sendAllSoundOff({ time: "+1" });
    });
  }
}
function midiRelease(note) {
  if (!midi.out)
    return;
  if (note) {
    let channel = (note == null ? void 0 : note.channel) || midi.channel;
    setVelocity(channel, note == null ? void 0 : note.number, 0);
    WebMidi.outputs.forEach((output) => {
      output.stopNote(note.number, { channels: channel });
    });
  } else {
    WebMidi.outputs.forEach((output) => {
      output.sendAllNotesOff();
      output.sendAllSoundOff({ time: "+1" });
    });
  }
}
function midiOnce2(note, options2) {
  if (!midi.out || midi.filter[midi.channel])
    return;
  midiPlay(note, options2);
  setTimeout(() => {
    midiStop(note, options2);
  }, 300);
}
function setCC(cc, value) {
  if (!midi.out)
    return;
  WebMidi.outputs.forEach((output) => {
    output.sendControlChange(Number(cc.number), value, cc.channel);
  });
}
function stopAll() {
  if (!midi.out)
    return;
  midi.channels = {};
  midi.playing = false;
  WebMidi.outputs.forEach((output) => {
    output.sendAllNotesOff();
    output.sendAllSoundOff({ time: "+1" });
    output.sendReset();
  });
}
function forwardMidi(iid, oid) {
  var _a, _b;
  const output = WebMidi.outputs.find((out) => out.id == oid);
  const destinations = midi.inputs[iid].forwarder.destinations;
  const index = destinations.indexOf(output);
  if (index == -1) {
    destinations.push(output);
    midi.forwards[iid] = midi.forwards[iid] || {};
    midi.forwards[iid][oid] = true;
  } else {
    destinations.splice(index, 1);
    (_b = (_a = midi.forwards) == null ? void 0 : _a[iid]) == null ? true : delete _b[oid];
  }
}

// .vitepress/use/synth.js
import { PolySynth, MonoSynth, start as start2, now, Midi, AutoPanner, Reverb as Reverb2, gainToDb as gainToDb2, StereoWidener, PingPongDelay, Compressor, Gain as Gain2 } from "tone";
import { useStorage as useStorage4, useCycleList } from "@vueuse/core";
import { onKeyDown } from "@vueuse/core";
import { useClamp as useClamp3 } from "@vueuse/core";
var quantizeModes = ["+0", "@8n", "@16n", "@32n"];
var synth = {
  state: reactive({
    midi: useStorage4("synth-midi", true),
    initiated: false,
    mute: false,
    quantize: useCycleList(quantizeModes, { initialValue: "+0" }),
    volume: useClamp3(1, 0, 2)
  }),
  params: reactive({
    maxPolyphony: 50,
    oscillator: {
      type: useStorage4("synth-osc", "sawtooth8")
    },
    volume: -30,
    envelope: {
      attack: 0.01,
      decay: 0.1,
      sustain: 0.6,
      release: 1
    },
    filterEnvelope: {
      attack: 1e-3,
      decay: 0.7,
      sustain: 0.5,
      release: 1,
      baseFrequency: 60,
      octaves: 5
    }
  })
};
function useSynth() {
  if (!synth.state.initiated) {
    onKeyDown("Escape", () => {
      synthReleaseAll();
    });
    watch(() => synth.state.volume, (vol) => synth.poly && synth.poly.volume.rampTo(gainToDb2(vol)));
    watch(synth.params, (params) => {
      if (synth.poly) {
        synth.poly.set(params);
      }
    }, { deep: true, immediate: true });
    watch(() => midi.note, (note) => {
      if (!synth.state.midi)
        return;
      if (note.velocity > 0) {
        synthAttack(Midi(note.number).toFrequency(), note.velocity / 127);
      } else {
        synthRelease(Midi(note.number).toFrequency());
      }
    });
    watch(() => midi.playing, (play) => {
      if (!play)
        synthReleaseAll();
    });
  }
  return { init, synth, synthOnce, synthAttack, synthRelease, synthReleaseAll };
}
function init() {
  start2();
  if (synth == null ? void 0 : synth.poly)
    return;
  const { channel } = createChannel("synth");
  synth.widener = new StereoWidener(0.7).connect(channel);
  synth.reverb = new Reverb2(3).connect(synth.widener);
  synth.delay = new PingPongDelay({ delayTime: "16n", feedback: 0.3, wet: 0.3, maxDelay: "4n" }).connect(synth.widener);
  synth.pan = new AutoPanner({ frequency: "4n", depth: 0.4 }).connect(synth.reverb).connect(synth.delay).connect(synth.widener);
  synth.compressor = new Compressor().connect(synth.pan);
  synth.poly = new PolySynth(MonoSynth, synth.params).connect(synth.compressor);
  synth.pan.start();
}
function synthOnce(note = "A4", duration2 = "8n", time) {
  if (!synth.poly || synth.state.mute)
    return init();
  synth.poly.triggerAttackRelease(note, duration2, time);
}
function synthAttack(note, velocity) {
  if (!synth.poly || synth.state.mute)
    return init();
  synth.poly.triggerAttack(note, synth.state.quantize.state, velocity);
}
function synthRelease(note) {
  if (!synth.poly || synth.state.mute)
    return init();
  synth.poly.triggerRelease(note, synth.state.quantize.state);
}
function synthReleaseAll() {
  if (!synth.poly || synth.state.mute)
    return init();
  synth.poly.releaseAll();
}

// .vitepress/use/theory.js
import { ChordType, ScaleType } from "@tonaljs/tonal";
ChordType.add(["1P", "2m"], ["2m"], "minor second");
ChordType.add(["1P", "2M"], ["2M"], "major second");
ChordType.add(["1P", "3m"], ["3m"], "minor third");
ChordType.add(["1P", "3M"], ["3M"], "major third");
ChordType.add(["1P", "4P"], ["4P"], "perfect fourth");
ChordType.add(["1P", "5d"], ["TT"], "tritone");
ChordType.add(["1P", "5P"], ["5P"], "perfect fifth");
ChordType.add(["1P", "6m"], ["6m"], "minor sixth");
ChordType.add(["1P", "6M"], ["6M"], "major sixth");
ChordType.add(["1P", "7m"], ["7m"], "minor seventh");
ChordType.add(["1P", "7M"], ["7M"], "major seventh");
var chordType = ChordType;
var scaleType = ScaleType;
var chordList = ChordType.all();
var scaleList = ScaleType.all();
var intervals = ["1P", "2m", "2M", "3m", "3M", "4P", "TT", "5P", "6m", "6M", "7m", "7M"];
var noteNames = [];
var naturals = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
var sharps = ["G##", "A#", "A##", "B#", "C#", "C##", "D#", "D##", "E#", "F#", "F##", "G#"];
var flats = ["Bbb", "Bb", "Cb", "Dbb", "Db", "Ebb", "Eb", "Fb", "Gbb", "Gb", "Abb", "Ab"];
naturals.forEach((note, n) => {
  noteNames[note] = n;
});
sharps.forEach((note, n) => {
  noteNames[note] = n;
});
flats.forEach((note, n) => {
  noteNames[note] = n;
});
var notes = naturals;
var chords = {
  min: { handle: "min", name: "Minor", semitones: [0, 3, 7] },
  maj: { handle: "maj", name: "Major", semitones: [0, 4, 7] },
  aug: { handle: "aug", name: "Augmented", semitones: [0, 4, 8] },
  dim: { handle: "dim", name: "Diminished", semitones: [0, 3, 6] },
  M7: { handle: "M7", name: "Major 7th", semitones: [0, 4, 7, 11] },
  m7: { handle: "m7", name: "Minor 7th", semitones: [0, 3, 7, 10] },
  "7": { handle: "7", name: "Dominant 7th", semitones: [0, 4, 7, 10] },
  "+7": { handle: "+7", name: "Augmented 7th", semitones: [0, 4, 8, 10] },
  o7: { handle: "o7", name: "Diminished 7th", semitones: [0, 3, 6, 9] },
  "07": { handle: "07", name: "Half-diminished 7th", semitones: [0, 3, 6, 10] },
  "+M7": { handle: "+M7", name: "Augmented major 7th", semitones: [0, 3, 7, 11] },
  "6": { handle: "6", name: "Major 6th", semitones: [0, 4, 7, 9] },
  m6: { handle: "m6", name: "Minor 6th", semitones: [0, 3, 7, 9] },
  sus2: { handle: "sus2", name: "Suspended 2nd", semitones: [0, 2, 7] },
  sus4: { handle: "sus4", name: "Suspended 4th", semitones: [0, 5, 7] },
  "9": { handle: "9", name: "9th", semitones: [0, 3, 7, 13] }
};
var scales = {
  major: {
    handle: "major",
    name: "Major (Ionian)",
    chords: ["maj", "", "min", "", "min", "maj", "", "7", "", "min", "", "dim"],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]
  },
  minor: {
    handle: "minor",
    name: "Minor (Aeolian)",
    chords: ["min", "", "dim", "maj", "", "min", "", "min", "maj", "", "7", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]
  },
  dorian: {
    handle: "dorian",
    name: "Dorian",
    chords: ["min", "", "min", "maj", "", "7", "", "min", "", "dim", "maj", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0]
  },
  phrygian: {
    handle: "phrygian",
    name: "Phrygian",
    chords: ["min", "maj", "", "7", "", "min", "", "dim", "maj", "", "min", ""],
    steps: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0]
  },
  lydian: {
    handle: "lydian",
    name: "Lydian",
    chords: ["maj", "", "7", "", "min", "", "dim", "maj", "", "min", "", "min"],
    steps: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1]
  },
  mixolydian: {
    handle: "mixolydian",
    name: "Mixolydian",
    chords: ["7", "", "min", "", "dim", "maj", "", "min", "", "min", "maj", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0]
  },
  locrian: {
    handle: "locrian",
    name: "Locrian",
    chords: ["dim", "maj", "", "min", "", "min", "maj", "", "7", "", "min", ""],
    steps: [1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0]
  },
  majorPenta: {
    handle: "majorPenta",
    name: "Major pentatonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0]
  },
  minorPenta: {
    handle: "minorPenta",
    name: "Minor pentatonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0]
  },
  acoustic: {
    handle: "acoustic",
    name: "Acoustic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0]
  },
  adonai: {
    handle: "adonai",
    name: "Adonai malakh",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0]
  },
  algerian: {
    handle: "algerian",
    name: "Algerian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]
  },
  augmented: {
    handle: "augmented",
    name: "Augmented",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1]
  },
  bebopDom: {
    handle: "bebopDom",
    name: "Bebop dominant",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1]
  },
  bebopMaj: {
    handle: "bebopMaj",
    name: "Bebop major",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1]
  },
  bluesHexa: {
    handle: "bluesHexa",
    name: "Blues hexatonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0]
  },
  doubleHarmonic: {
    handle: "doubleHarmonic",
    name: "Double harmonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1]
  },
  enigmatic: {
    handle: "enigmatic",
    name: "Enigmatic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1]
  },
  gypsy: {
    handle: "gypsy",
    name: "Gypsy",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0]
  },
  halfDim: {
    handle: "halfDim",
    name: "Half diminished",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0]
  },
  harmonicMaj: {
    handle: "harmonicMaj",
    name: "Harmonic major",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1]
  },
  harmonicMin: {
    handle: "harmonicMin",
    name: "Harmonic minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1]
  },
  hungarianMin: {
    handle: "hungarianMin",
    name: "Hungarian minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]
  },
  istrian: {
    handle: "istrian",
    name: "Istrian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0]
  },
  lydianAug: {
    handle: "lydianAug",
    name: "Lydian augmented",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1]
  },
  majLocrian: {
    handle: "majLocrian",
    name: "Major locrian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0]
  },
  jazzMin: {
    handle: "jazzMin",
    name: "Jazz minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1]
  },
  neapolitanMaj: {
    handle: "neapolitanMaj",
    name: "Neapolitan major",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
  },
  neapolitanMin: {
    handle: "neapolitanMin",
    name: "Neapolitan minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1]
  },
  octatonic: {
    handle: "octatonic",
    name: "Octatonic (diminished)",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1]
  },
  persian: {
    handle: "persian",
    name: "Persian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1]
  },
  phrygianDom: {
    handle: "phrygianDom",
    name: "Phrygian dominant",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0]
  },
  prometheus: {
    handle: "prometheus",
    name: "Prometheus",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0]
  },
  tritone: {
    handle: "tritone",
    name: "Tritone",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0]
  },
  ukranianDorian: {
    handle: "ukranianDorian",
    name: "Ukranian dorian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0]
  },
  wholeTone: {
    handle: "wholeTone",
    name: "Whole tone",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
  },
  chromatic: {
    handle: "chromatic",
    name: "Chromatic",
    chords: [
      "1/1",
      "25/24",
      "9/8",
      "6/5",
      "5/4",
      "4/3",
      "45/32",
      "3/2",
      "8/5",
      "5/3",
      "9/5",
      "15/8"
    ],
    steps: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  }
};

// .vitepress/use/chroma.js
import { Note as Note2, ChordType as ChordType2, ScaleType as ScaleType2, Scale, Pcset } from "@tonaljs/tonal";
import { useClamp as useClamp4 } from "@vueuse/core";
var allNotes = [...notes].map((n, i) => ({ name: n, pitch: i }));
var globalScale = reactive({
  tonic: useClamp4(useStorage("global-tonic", 0), 0, 11),
  note: computed(() => allNotes[globalScale.tonic]),
  chroma: useStorage("global-chroma", "101011010101"),
  set: computed(() => ScaleType2.get(globalScale.chroma)),
  full: computed(() => {
    let sc = globalScale.note.name + "4 " + globalScale.set.name;
    return Scale.get(sc);
  }),
  pcs: computed(() => Scale.scaleNotes(globalScale.full.notes)),
  isIn: computed(() => Pcset.isNoteIncludedIn(globalScale.pcs))
});
function getChromaNotes(chroma = "100010010000", tonic = globalScale.tonic) {
  let shiftChroma = rotateArray(chroma.split(""), -tonic);
  let chOct = rotateArray(allNotes, -tonic).map((n, i) => {
    let noteName = Frequency(n.pitch + tonic + 57, "midi").toNote();
    return noteName;
  });
  let filtered = chOct.filter((val, i) => {
    if (shiftChroma[i] == "1") {
      return true;
    }
  });
  return Note2.sortedNames(filtered);
}
function playChromaOnce(chroma, tonic) {
  let notes2 = getChromaNotes(chroma, tonic);
  notes2.forEach((name, i) => {
    midiOnce(name);
  });
  synthOnce(notes2, "4n");
}
function playChroma(chroma, tonic) {
  let notes2 = getChromaNotes(chroma, tonic);
  notes2.forEach((name) => {
    midiPlay(name);
  });
  synthAttack(notes2);
}
function stopChroma(chroma, tonic) {
  let notes2 = getChromaNotes(chroma, tonic);
  notes2.forEach((name) => {
    midiStop(name);
  });
  synthRelease(notes2);
}
function playNote(name) {
  midiPlay(name);
  synthAttack(name);
}
function stopNote(name) {
  midiStop(name);
  synthRelease(name);
}

// .vitepress/use/colors.js
import { colord, extend } from "colord";
import lchPlugin from "colord/plugins/lch";
import mixPlugin from "colord/plugins/mix";
import namesPlugin from "colord/plugins/names";
import labPlugin from "colord/plugins/lab";
import cmykPlugin from "colord/plugins/cmyk";
import hwbPlugin from "colord/plugins/hwb";
extend([mixPlugin, lchPlugin, namesPlugin, labPlugin, cmykPlugin, hwbPlugin]);
function lchToHsl(n = 0, total = 12, a = 1, s = 20, lightness = 60) {
  let lch = `lch(${lightness}% ${s} ${n * (360 / total)} / ${a})`;
  let hsl = colord(lch).toHslString();
  return hsl;
}
function getColorInfo(color) {
  const cld = colord(color);
  let info = {
    dark: cld.isDark(),
    hex: cld.toHex(),
    rgb: cld.toRgbString(),
    name: cld.toName({ closest: true }),
    cmyk: cld.toCmykString(),
    hsl: cld.toHslString(),
    lab: cld.toLab()
  };
  return info;
}
function levelColor(i = 0, n = 3, a = "0.5", s = "0.8", l = "0.5", reverse = false) {
  if (reverse) {
    i = n - i - 1;
  }
  return `hsla(${i * (360 / n)}, ${s * 100}%, ${l * 100}%, ${a})`;
}
function chromaColorMix(chroma, tonic, part = 0.3) {
  let hsl = colord(pitchColor(tonic));
  let lch = colord(lchToHsl(tonic, 12, 1));
  chroma.split("").forEach((bit, i) => {
    if (isInChroma(chroma, tonic, i)) {
      hsl = hsl.mix(pitchColor(i), part);
      lch = lch.mix(lchToHsl(i, 12, 1), part);
    }
  });
  return {
    hsl: hsl.toHslString(),
    lch: lch.toHslString()
  };
}

// .vitepress/use/tempo.js
import { reactive as reactive2, computed as computed2, watch as watch2, onMounted as onMounted2 } from "vue";
import { Transport, start as start3, Frequency as Frequency2, Loop, Sampler, gainToDb as gainToDb3 } from "tone";
import { Note as Note3 } from "@tonaljs/tonal";
import { useStorage as useStorage5 } from "@vueuse/core";
import { useRafFn as useRafFn2 } from "@vueuse/core";
var tempo = reactive2({
  initialized: false,
  bpm: useClamp(useStorage5("tempo-bpm", 100), 10, 500),
  blink: false,
  started: false,
  playing: false,
  stopped: false,
  mute: useStorage5("tempo-mute", true),
  volume: useClamp(useStorage5("tempo-volume", 0.5), 0, 1),
  progress: 0,
  position: 0,
  ticks: 0,
  metre: {
    over: 4,
    under: 4,
    num: computed2(() => (tempo.metre.over / (tempo.metre.under / 4)).toFixed(2))
  },
  hz: computed2(() => (tempo.bpm / 60).toFixed(2)),
  note: computed2(() => Note3.pitchClass(Frequency2(tempo.hz).toNote())),
  tune: computed2(() => {
    return Note3.pitchClass(tempo.note) + 4;
  }),
  pitch: computed2(() => freqPitch(tempo.hz)),
  digit: computed2(() => (Frequency2(tempo.hz).toMidi() + 12 * 10 + 3) % 12),
  color: computed2(() => pitchColor(tempo.digit)),
  tap: {
    last: 0,
    diff: 0,
    timeout: 2e3,
    times: [],
    bpm: null
  },
  set(diff) {
    tempo.bpm = Math.round(diff + tempo.bpm);
  }
});
function useTempo() {
  if (tempo.initialized)
    return tempo;
  const metro = shallowReactive({
    counter: 0
  });
  onMounted2(() => {
    const { channel } = createChannel("tempo-tick");
    metro.channel = channel;
    metro.pluck = new Sampler({
      urls: {
        E1: "/logic/high.wav",
        E2: "/logic/low.wav"
      },
      volume: -20,
      envelope: {
        attack: 1e-3,
        release: 2
      },
      baseUrl: "/audio/metronome/"
    }).connect(channel);
    metro.loop = new Loop((time) => {
      let even = metro.counter % 2 == 0;
      if (even)
        tempo.blink = true;
      if (!tempo.mute) {
        metro.pluck.triggerAttackRelease(even ? "E1" : "E2", "16n", time, even ? 1 : 0.2);
      }
      metro.counter++;
      setTimeout(() => {
        tempo.blink = false;
      }, 60);
    }, "8n").start(0);
    useRafFn2(() => {
      tempo.position = Transport.position;
      tempo.ticks = Transport.ticks;
      tempo.progress = metro.loop.progress;
    });
  });
  watch2(() => tempo.volume, (vol) => metro.pluck.volume.rampTo(gainToDb3(tempo.volume)));
  watch2(() => tempo.bpm, (bpm) => Transport.bpm.rampTo(bpm, "4n"), { immediate: true });
  watch2(() => tempo.stopped, (stop) => {
    if (stop) {
      Transport.stop();
      tempo.playing = false;
    }
  });
  watch2(() => tempo.playing, (playing) => {
    if (playing) {
      if (!tempo.started) {
        start3();
        tempo.started = true;
      }
      tempo.stopped = false;
      Transport.start();
    } else {
      Transport.pause();
    }
  }, {
    immediate: true
  });
  tempo.initialized = true;
  return tempo;
}
function tap() {
  var time = performance.now();
  if (tempo.tap.last) {
    tempo.tap.diff = time - tempo.tap.last;
    tempo.tap.times.push(tempo.tap.diff);
    refresh();
  }
  tempo.tap.last = time;
  beginTimeout();
}
function refresh() {
  if (tempo.tap.times.length > 2) {
    var average = tempo.tap.times.reduce((result, t) => result += t) / tempo.tap.times.length;
    var bpm = 1 / (average / 1e3) * 60;
    tempo.tap.bpm = bpm;
  }
}
var timer = null;
function beginTimeout() {
  clearTimeout(timer);
  timer = setTimeout(function() {
    tempo.tap.times = [tempo.tap.diff];
    tempo.tap.last = null;
  }, tempo.tap.timeout);
}

// .vitepress/use/loop.js
import {
  Sequence,
  PanVol,
  gainToDb as gainToDb4,
  Draw,
  PolySynth as PolySynth2,
  context as context2,
  start as start4,
  Midi as Midi3,
  Frequency as Frequency3,
  Time
} from "tone";

// .vitepress/use/midiRender.js
import { Writer, Track, NoteEvent } from "midi-writer-js";
import { Midi as Midi2 } from "@tonejs/midi";
function createAndDownloadBlobFile(body, filename, extension = "mid") {
  const blob = new Blob([body]);
  const fileName = `${filename}.${extension}`;
  if (navigator.msSaveBlob) {
    navigator.msSaveBlob(blob, fileName);
  } else {
    const link = document.createElement("a");
    if (link.download !== void 0) {
      const url = URL.createObjectURL(blob);
      link.setAttribute("href", url);
      link.setAttribute("download", fileName);
      link.style.visibility = "hidden";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }
}

// .vitepress/use/loop.js
import { Writer as Writer2, Track as Track2, NoteEvent as NoteEvent2 } from "midi-writer-js";
var loops = reactive([]);
function useLoop(order = 0) {
  const loop = reactive({
    pitch: computed(() => globalScale.tonic),
    chroma: computed(() => globalScale.set.chroma),
    metre: {
      over: useStorage(`grid-${order}-over`, 4),
      under: useStorage(`grid-${order}-under`, 4)
    },
    octave: useStorage(`grid-${order}-octave`, 3),
    volume: useStorage(`grid-${order}-vol`, 1),
    pan: useStorage(`grid-${order}-pan`, order % 2 == 1 ? -0.5 : 0.5),
    probability: useStorage(`grid-${order}-probability`, 1),
    tonic: computed(() => {
      return loop.pitch + 12 * loop.octave - 3;
    }),
    steps: useStorage(`grid-${order}-steps`, []),
    current: [],
    progress: computed(() => {
      if (tempo.ticks) {
        return sequence == null ? void 0 : sequence.progress;
      } else {
        return 0;
      }
    }),
    clear() {
      loop.steps.forEach((step, s) => {
        loop.steps[s] = [{}];
      });
    },
    rotate(way = 1) {
      loop.steps = rotateArray(loop.steps, way);
    }
  });
  loops[order] = loop;
  const { channel } = createChannel(`grid-loop-${order}`);
  const panner = new PanVol(loop.pan, 0).connect(channel);
  const synth2 = new PolySynth2({
    envelope: {
      attack: 0.5,
      release: 0.2
    },
    filterEnvelope: {
      attack: 0.1,
      release: 0.2
    }
  }).connect(panner);
  synth2.maxPolyphony = 100;
  let sequence = new Sequence((time, step) => {
    beatClick(step, time);
  }, loop.steps, loop.metre.under + "n").start(0);
  watch(() => loop.metre.under, () => {
    sequence.stop().dispose();
    sequence = new Sequence((time, step) => {
      beatClick(step, time);
    }, loop.steps, loop.metre.under + "n").start(0);
    sequence.probability = loop.probability;
  });
  watch(() => loop.metre.over, () => {
    if (loop.steps.length > loop.metre.over) {
      loop.steps.length = loop.metre.over;
    } else {
      for (let i = loop.steps.length; i < loop.metre.over; i++) {
        loop.steps.push([{}]);
      }
    }
    sequence.events = loop.steps;
  }, { immediate: true });
  watchEffect(() => {
    sequence.events = loop.steps;
  });
  watchEffect(() => {
    if (tempo.stopped) {
      loop.current = null;
    }
  });
  watchEffect(() => {
    sequence.probability = loop.probability;
    panner.volume.targetRampTo(gainToDb4(loop.volume), 1);
    panner.pan.targetRampTo(loop.pan, 1);
  });
  function beatClick(step, time) {
    if (context2.state == "suspended") {
      start4();
    }
    let notes2 = Object.entries(step).map((entry) => {
      if (entry[0] == "sub")
        return;
      return entry[1] ? Midi3(Number(entry[0]) + loop.tonic) : null;
    }).filter(Number);
    synth2.triggerAttackRelease(notes2, { [loop.metre.under + "n"]: 1 / (step.sub || 1) }, time);
    Draw.schedule(() => {
      let dur = Time({
        [loop.metre.under + "n"]: 1 / (step.sub || 1)
      }).toMilliseconds();
      let midiNotes = notes2.map((n) => n.toMidi());
      midiPlay(midiNotes, { duration: dur, attack: loop.volume });
    }, time);
  }
  onBeforeUnmount(() => {
    loops.splice(order, 1);
    sequence.stop().dispose();
    panner.dispose();
    synth2.dispose();
  });
  return loop;
}

// .vitepress/use/mic.js
import { useRafFn as useRafFn3 } from "@vueuse/core";
import { Meter as Meter2, UserMedia, gainToDb as gainToDb5, Gate, Compressor as Compressor2, StereoWidener as StereoWidener2 } from "tone";
import { useClamp as useClamp5 } from "@vueuse/core";
var mic = reactive({
  initiated: false,
  open: false,
  opened: false,
  monitor: false,
  meter: 0,
  volume: useClamp5(useStorage("mic-vol", 1), 0, 2),
  gate: useClamp5(useStorage("mic-gate", -60), -100, -40)
});
var meter;
var input;
var gate;
var compressor;
function useMic() {
  if (!mic.initiated) {
    meter = new Meter2();
    meter.normalRange = true;
    input = new UserMedia();
    compressor = new Compressor2({ threshold: -20, ratio: 2 }).connect(meter);
    gate = new Gate({ threshold: -60, smoothing: 1 });
    input.connect(gate);
    gate.connect(compressor);
    const { channel } = createChannel("mic");
    watch(() => mic.open, (o) => {
      if (o) {
        input.open().then(() => {
          mic.opened = true;
          useRafFn3(() => {
            mic.meter = meter.getValue();
          });
        });
      } else {
        input.close();
        mic.opened = false;
      }
    });
    watch(() => mic.monitor, (mon) => mon ? meter.connect(channel) : meter.disconnect(channel));
    watch(() => mic.volume, (vol) => input.volume.rampTo(gainToDb5(vol)), { immediate: true });
    watch(() => mic.gate, (g) => gate.threshold = g, { immediate: true });
  }
  return { mic, input };
}

// .vitepress/use/mouse.js
import { useMousePressed, useMouseInElement } from "@vueuse/core";
function useSvgMouse() {
  const svg = ref(null);
  const area = ref(null);
  const { pressed } = useMousePressed();
  const mouse = reactive({
    x: 0,
    y: 0,
    normX: 0,
    normY: 0,
    pressed,
    inside: false
  });
  onMounted(() => {
    svg.value.addEventListener("mousemove", getCursorPosition);
    const { isOutside } = useMouseInElement(area);
    watch(isOutside, (out) => {
      mouse.inside = !out;
    });
  });
  function getCursorPosition(event, svgElement = svg.value, rect = area.value) {
    if (!svgElement)
      return;
    var svgPoint = svgElement.createSVGPoint();
    svgPoint.x = event.clientX;
    svgPoint.y = event.clientY;
    let correct = svgPoint.matrixTransform(svgElement.getScreenCTM().inverse());
    if (rect) {
      let bounds = rect.getBBox();
      mouse.x = correct.x < bounds.width ? correct.x < 0 ? 0 : correct.x : bounds.width;
      mouse.y = correct.y < bounds.height ? correct.y < 0 ? 0 : correct.y : bounds.height;
      mouse.normY = 1 - mouse.y / bounds.height;
      mouse.normX = mouse.x / bounds.width;
    } else {
      mouse.x = correct.x;
      mouse.y = correct.y;
    }
  }
  return {
    svg,
    area,
    mouse
  };
}

// .vitepress/use/noise.js
import {
  NoiseSynth,
  gainToDb as gainToDb6,
  dbToGain,
  FFT,
  Gain as Gain3,
  AutoFilter,
  AutoPanner as AutoPanner2,
  BitCrusher
} from "tone";
import { useStorage as useStorage6, useRafFn as useRafFn4, onKeyStroke } from "@vueuse/core";
var types = { brown: "brown", pink: "pink", white: "white" };
var filterTypes = { lowpass: "LP", highpass: "HP", bandpass: "BP" };
var filterLFOTypes = {
  sine: "SIN",
  triangle: "TRI",
  square: "SQR",
  sawtooth: "SAW"
};
var options = useStorage6("noise-options", {
  noise: {
    type: "pink"
  },
  envelope: {
    attack: 0.1,
    decay: 0.1,
    sustain: 0.9,
    release: 1
  },
  volume: 1
});
var filterOptions = useStorage6("filter-options", {
  on: false,
  play: false,
  volume: 0.5,
  baseFrequency: 50,
  depth: 0.1,
  frequency: 1,
  octaves: 2,
  wet: 1,
  type: "sine",
  filter: {
    Q: 1,
    type: "lowpass"
  }
});
var pannerOptions = useStorage6("panner-options", {
  on: false,
  play: false,
  wet: 1,
  frequency: 1,
  depth: 1,
  volume: 1
});
var crusherOptions = useStorage6("bit-options", {
  on: false,
  bits: 16,
  wet: 1,
  volume: 1
});
function useNoise() {
  const active = ref(false);
  const fftData = ref([]);
  const fftFreq = ref([]);
  const { channel } = createChannel("noise");
  const fft = new FFT({ size: 512, smoothing: 0.2 }).connect(channel);
  for (let j = 0; j < 32; j++) {
    fftFreq.value[j] = fft.getFrequencyOfIndex(j);
  }
  const gain = new Gain3(options.value.volume).connect(fft);
  const filterGain = new Gain3(filterOptions.value.volume).connect(fft);
  const pannerGain = new Gain3(pannerOptions.value.volume).connect(fft);
  const crusherGain = new Gain3(crusherOptions.value.volume).connect(fft);
  const panner = new AutoPanner2(pannerOptions.value).connect(pannerGain);
  const crusher = new BitCrusher(crusherOptions.value).connect(crusherGain).connect(panner);
  const filter = new AutoFilter(filterOptions.value).connect(filterGain).connect(crusher);
  const synth2 = new NoiseSynth(options.value).connect(gain).connect(filter);
  const { pause, resume } = useRafFn4(() => {
    let arr = fft.getValue();
    for (let j = 0; j < 32; j++) {
      fftData.value[j] = dbToGain(arr[j]) * 10;
    }
  });
  onKeyStroke(" ", (e) => {
    e.preventDefault();
    active.value = true;
  }, { eventName: "keydown" });
  onKeyStroke(" ", (e) => {
    active.value = false;
  }, { eventName: "keyup" });
  watch(active, (act) => {
    if (act) {
      synth2.triggerAttack();
    } else {
      synth2.triggerRelease();
    }
  });
  watch(options.value, () => {
    synth2.set(options.value);
  });
  watch(() => options.value.volume, (vol) => {
    gain.gain.rampTo(vol, 1);
  });
  onBeforeUnmount(() => {
    synth2.triggerRelease();
  });
  watch(filterOptions.value, (opt) => {
    opt.play ? filter.start() : filter.stop();
    if (opt.on) {
      filterGain.gain.rampTo(filterOptions.value.volume, 0.2);
    } else {
      filterGain.gain.rampTo(0, 0.2);
    }
    filter.set(opt);
  });
  watch(pannerOptions.value, (opt) => {
    opt.play ? panner.start() : panner.stop();
    opt.on ? pannerGain.gain.rampTo(pannerOptions.value.volume, 0.2) : pannerGain.gain.rampTo(0, 0.2);
    panner.set(opt);
  });
  watch(crusherOptions.value, (opt) => {
    opt.on ? crusherGain.gain.rampTo(crusherOptions.value.volume, 0.2) : crusherGain.gain.rampTo(0, 0.2);
    crusher.set(opt);
  });
  return {
    options,
    filterOptions,
    pannerOptions,
    crusherOptions,
    active,
    fftData,
    fftFreq,
    types,
    filterTypes,
    filterLFOTypes
  };
}

// .vitepress/use/piano.js
import { Sampler as Sampler2, start as start5, now as now2 } from "tone";
var piano;
function usePiano() {
  init2();
  return { init: init2, piano, pianoOnce, pianoAttack, pianoRelease, pianoReleaseAll };
}
function init2() {
  start5();
  if (piano)
    return;
  const { channel } = createChannel("piano");
  piano = new Sampler2({
    urls: {
      A0: "A0.mp3",
      C1: "C1.mp3",
      "D#1": "Ds1.mp3",
      "F#1": "Fs1.mp3",
      A1: "A1.mp3",
      C2: "C2.mp3",
      "D#2": "Ds2.mp3",
      "F#2": "Fs2.mp3",
      A2: "A2.mp3",
      C3: "C3.mp3",
      "D#3": "Ds3.mp3",
      "F#3": "Fs3.mp3",
      A3: "A3.mp3",
      C4: "C4.mp3",
      "D#4": "Ds4.mp3",
      "F#4": "Fs4.mp3",
      A4: "A4.mp3",
      C5: "C5.mp3",
      "D#5": "Ds5.mp3",
      "F#5": "Fs5.mp3",
      A5: "A5.mp3",
      C6: "C6.mp3",
      "D#6": "Ds6.mp3",
      "F#6": "Fs6.mp3",
      A6: "A6.mp3",
      C7: "C7.mp3",
      "D#7": "Ds7.mp3",
      "F#7": "Fs7.mp3",
      A7: "A7.mp3",
      C8: "C8.mp3"
    },
    release: 1,
    volume: -10,
    baseUrl: "/audio/piano/"
  }).connect(channel);
}
function pianoOnce(note = "A4", duration2 = "8n", time) {
  if (!piano)
    return init2();
  piano.triggerAttackRelease(note, duration2, time);
}
function pianoAttack(note, velocity) {
  if (!piano)
    return init2();
  piano.triggerAttack(note, now2(), velocity);
}
function pianoRelease(note) {
  if (!piano)
    return init2();
  piano.triggerRelease(note);
}
function pianoReleaseAll() {
  if (!piano)
    return init2();
  piano.releaseAll();
}

// .vitepress/use/sequence.js
import { onKeyStroke as onKeyStroke2 } from "@vueuse/core";
import {
  Sequence as Sequence2,
  PanVol as PanVol2,
  gainToDb as gainToDb7,
  Draw as Draw2,
  Sampler as Sampler3,
  context as context3,
  start as start6,
  Recorder as Recorder2,
  Meter as Meter3,
  UserMedia as UserMedia2
} from "tone";
var tracks = reactive([]);
function useSequence(metre = {
  over: 4,
  under: 4,
  sound: "A",
  volume: 1
}, order = 0, mode = "bar") {
  let pan = order % 2 == 1 ? -0.5 : 0.5;
  const audio2 = {
    meter: null,
    mic: null,
    recorder: null,
    panner: null,
    synth: null
  };
  const { channel } = createChannel(`sequence-${mode}-${order}`);
  audio2.panner = new PanVol2(pan, 0).connect(channel);
  audio2.synth = new Sampler3({
    urls: {
      A1: "tongue/high.wav",
      A2: "tongue/low.wav",
      B1: "synth/high.wav",
      B2: "synth/low.wav",
      C1: "seiko/high.wav",
      C2: "seiko/low.wav",
      D1: "/ping/high.wav",
      D2: "/ping/low.wav",
      E1: "/logic/high.wav",
      E2: "/logic/low.wav"
    },
    volume: 1,
    envelope: {
      attack: 1e-3,
      release: 2
    },
    baseUrl: "/audio/metronome/"
  }).connect(audio2.panner);
  audio2.recorder = new Recorder2();
  const recorder2 = reactive({
    recording: false,
    main: false,
    accent: false,
    both: computed(() => recorder2.main && recorder2.accent),
    async load(pos = "main", blob) {
      let arr = await blob.arrayBuffer();
      let buff = await audio2.recorder.context.decodeAudioData(arr);
      audio2.synth.add(pos == "main" ? "F1" : "F2", buff);
      recorder2[pos] = true;
      recorder2.recording = false;
    },
    async rec(pos = "main") {
      if (!recorder2.recording) {
        audio2.meter = new Meter3().connect(audio2.recorder);
        audio2.mic = new UserMedia2(1).connect(audio2.meter);
        audio2.mic.open().then(() => {
          recorder2.recording = pos;
          audio2.recorder.start();
        }).catch((e) => {
          console.log("mic not open");
        });
      } else {
        let blob = await audio2.recorder.stop();
        let arr = await blob.arrayBuffer();
        let buff = await audio2.recorder.context.decodeAudioData(arr);
        audio2.synth.add(pos == "main" ? "F1" : "F2", buff);
        recorder2[pos] = true;
        recorder2.recording = false;
      }
    }
  });
  watch(() => metre.sound, (sound) => {
    if (sound != "F") {
      recorder2.main = false;
      recorder2.accent = false;
    }
  });
  const current = ref("0-0");
  const steps = reactive([["0-1"], ["1-1"], ["2-1"], ["3-1"]]);
  const mutes = useStorage(`metro-${mode}-mutes-${order}`, []);
  const accents = useStorage(`metro-${mode}-accents-${order}`, [true]);
  const volume = useClamp(useStorage(`metro-${mode}-vol-${order}`, metre.volume || 1), 0, 1);
  const panning = useClamp(useStorage(`metro-${mode}-pan-${order}`, pan), -1, 1);
  const mutesCount = computed(() => mutes.value.reduce((acc, val) => {
    if (!val) {
      acc++;
    }
    return acc;
  }, 0));
  const euclidSeq = computed(() => mutesCount.value > 0 && mutesCount.value < steps.length ? getEuclideanRhythm(mutesCount.value, steps.length) : new Array(steps.length).fill("1").join(""));
  const currentSeq = computed(() => mutes.value.reduce((acc, val) => val ? acc + "0" : acc + "1", ""));
  const isEuclidean = computed(() => euclidSeq.value == currentSeq.value);
  function reset() {
    let arr = [];
    euclidSeq.value.split("").forEach((e, i) => {
      arr[i] = e != false && e != null ? false : true;
    });
    mutes.value = arr;
  }
  let sequence = new Sequence2((time, step) => {
    beatClick(step, time);
  }, steps, metre.under + "n").start(0);
  watch(() => metre.under, () => {
    sequence.stop().dispose();
    sequence = new Sequence2((time, step) => {
      beatClick(step, time);
    }, steps, metre.under + "n").start(0);
  });
  watch(() => metre.over, () => {
    steps.length = 0;
    for (let i = 0; i < metre.over; i++) {
      steps.push([`${i}-1`]);
    }
    sequence.events = steps;
  }, { immediate: true });
  watchEffect(() => {
    sequence.events = steps;
    accents.value.length = steps.length;
    mutes.value.length = steps.length;
  });
  watchEffect(() => {
    if (tempo.stopped) {
      current.value = "1000-1";
    }
  });
  watch(volume, (vol) => {
    audio2.panner.volume.targetRampTo(gainToDb7(vol), 1);
  }, { immediate: true });
  watch(panning, (p) => {
    audio2.panner.pan.targetRampTo(p, 1);
  }, { immediate: true });
  const progress = computed(() => {
    if (tempo.ticks) {
      return sequence.progress;
    } else {
      return 0;
    }
  });
  function beatClick(step, time) {
    if (context3.state == "suspended") {
      start6();
    }
    let mainStep = typeof step == "string" ? +step.split("-")[0] : step;
    Draw2.schedule(() => {
      current.value = step;
    }, time);
    let accented = accents.value[mainStep] && step.split("-")[1] == "1";
    if (mutes.value[mainStep])
      return;
    if (mutes.value[step])
      return;
    if (metre.sound == "F" && !accented && !recorder2.main)
      return;
    if (metre.sound == "F" && accented && !recorder2.accent)
      return;
    let note = `${metre.sound}${accented ? 2 : 1}`;
    audio2.synth.triggerAttackRelease(note, metre.under + "n", time);
  }
  const lastHit = ref(0);
  onKeyStroke2("Shift", () => {
    lastHit.value = progress.value;
  });
  onBeforeUnmount(() => {
    sequence.stop().dispose();
    audio2.panner.dispose();
    audio2.synth.dispose();
  });
  tracks[order] = reactive({
    metre: computed(() => metre),
    steps,
    mutes,
    accents,
    mutesCount,
    isEuclidean,
    reset
  });
  return {
    progress,
    current,
    steps,
    mutes,
    accents,
    volume,
    panning,
    recorder: recorder2,
    lastHit,
    reset,
    isEuclidean
  };
}
function _getEuclideanRhythm(m, k, input2) {
  input2 = input2 || new Array(m).fill("1").concat(new Array(k).fill("0"));
  const output = [];
  for (let i = 0; i < Math.min(m, k); i++) {
    output.push(input2.shift() + input2.pop());
  }
  if (input2.length > 1) {
    return _getEuclideanRhythm(output.length, input2.length, output.concat(input2));
  }
  return output.concat(input2);
}
function getEuclideanRhythm(x, total) {
  return _getEuclideanRhythm(x, total - x).join("");
}

// .vitepress/use/tuner.js
import Meyda from "meyda";
var noteStrings = [
  "C",
  "C\u266F",
  "D",
  "D\u266F",
  "E",
  "F",
  "F\u266F",
  "G",
  "G\u266F",
  "A",
  "A\u266F",
  "B"
];
var settings = {
  middleA: 440,
  semitone: 69
};
var tuner = reactive({
  initiated: false,
  stream: null,
  middleA: settings.middleA,
  semitone: settings.semitone,
  note: {
    name: "A",
    value: 69,
    cents: 0,
    octave: 4,
    frequency: 440,
    color: freqColor2(440),
    silent: false
  },
  span: 64,
  bufferSize: 4096,
  tempoBufferSize: 512,
  frequencyData: null,
  running: false,
  frame: 0,
  beat: 0,
  bpm: 0,
  confidence: 0,
  listenBeat: false,
  prevBeat: 0,
  blink: false,
  chroma: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  spec: [],
  rms: 0
});
var chain = {};
function useTuner() {
  initGetUserMedia();
  return {
    init: init3,
    tuner,
    chain
  };
}
function init3() {
  tuner.initiated = true;
  chain.audioContext = new window.AudioContext();
  chain.analyser = chain.audioContext.createAnalyser();
  chain.scriptProcessor = chain.audioContext.createScriptProcessor(tuner.bufferSize, 1, 1);
  chain.beatProcessor = chain.audioContext.createScriptProcessor(tuner.tempoBufferSize, 1, 1);
  watch(() => tuner.frame, () => {
    if (!tuner.listen)
      return;
    if (tuner.beat > tuner.prevBeat) {
      tuner.prevBeat = tuner.beat;
      tuner.blink = true;
      setTimeout(() => {
        tuner.blink = false;
      }, 60);
    }
  });
  chain.meyda = Meyda.createMeydaAnalyzer({
    audioContext: chain.audioContext,
    source: chain.analyser,
    bufferSize: 4096,
    featureExtractors: ["chroma", "amplitudeSpectrum", "rms"],
    callback: (features) => {
      tuner.rms = features.rms;
      tuner.chroma = features.chroma;
      tuner.spec = features.amplitudeSpectrum;
    }
  });
  chain.meyda.start();
  tuner.frequencyData = new Uint8Array(chain.analyser.frequencyBinCount);
  aubio_default().then(function(aubio) {
    chain.pitchDetector = new aubio.Pitch("default", tuner.bufferSize, 1, chain.audioContext.sampleRate);
    chain.tempoAnalyzer = new aubio.Tempo(tuner.tempoBufferSize * 4, tuner.tempoBufferSize, chain.audioContext.sampleRate);
    tuner.running = true;
    start7();
  });
}
function start7() {
  navigator.mediaDevices.getUserMedia({ audio: true }).then(function(stream) {
    tuner.stream = stream;
    const mediaStream = chain.audioContext.createMediaStreamSource(stream).connect(chain.analyser);
    chain.analyser.connect(chain.scriptProcessor);
    chain.analyser.connect(chain.beatProcessor);
    chain.scriptProcessor.connect(chain.audioContext.destination);
    chain.beatProcessor.connect(chain.audioContext.destination);
    chain.beatProcessor.addEventListener("audioprocess", (e) => {
      const tempo2 = chain.tempoAnalyzer.do(e.inputBuffer.getChannelData(0));
      if (tempo2) {
        tuner.beat++;
        tuner.confidence = chain.tempoAnalyzer.getConfidence();
        tuner.bpm = chain.tempoAnalyzer.getBpm();
      }
    });
    chain.scriptProcessor.addEventListener("audioprocess", function(event) {
      const frequency = chain.pitchDetector.do(event.inputBuffer.getChannelData(0));
      tuner.frame++;
      if (frequency) {
        const note = getNote(frequency);
        tuner.note = {
          name: noteStrings[note % 12],
          value: note,
          cents: getCents2(frequency, note),
          octave: parseInt(note / 12) - 1,
          frequency,
          color: freqColor2(frequency),
          silent: false
        };
      } else {
        tuner.note.silent = true;
      }
    });
  }).catch(function(error) {
    console.log(error.name + ": " + error.message);
  });
}
function getNote(frequency) {
  const note = 12 * (Math.log(frequency / tuner.middleA) / Math.log(2));
  return Math.round(note) + tuner.semitone;
}
function getStandardFrequency2(note) {
  return tuner.middleA * Math.pow(2, (note - tuner.semitone) / 12);
}
function getCents2(frequency, note) {
  return Math.floor(1200 * Math.log(frequency / getStandardFrequency2(note)) / Math.log(2));
}
function freqColor2(frequency) {
  const note = getRawNote(frequency);
  if (!note)
    return "#333";
  const octave = parseInt(note / 12) + 2;
  const color = pitchColor(note, octave);
  return color;
}
function getRawNote(frequency) {
  return 12 * (Math.log(frequency / settings.middleA) / Math.log(2)) % 12;
}
export {
  cameras,
  cast,
  channels,
  chordList,
  chordType,
  chords,
  chromaColorMix,
  clampNum,
  createAndDownloadBlobFile,
  createChannel,
  currentCamera,
  currentMic,
  devices,
  download,
  ensureDevicesListPermissions,
  fileNames,
  forwardMidi,
  freqColor,
  freqPitch,
  getCents,
  getCircleCoord,
  getColorInfo,
  getEuclideanRhythm,
  getFilename,
  getStandardFrequency,
  getSupportedMimeTypes,
  globalScale,
  initGetUserMedia,
  intervals,
  isInChroma,
  lchToHsl,
  learnCC,
  levelColor,
  master,
  mic,
  microphones,
  midi,
  midiA,
  midiAttack,
  midiOnce2 as midiOnce,
  midiPlay,
  midiRelease,
  midiStop,
  mimeExtMap,
  mimeType,
  noteNames,
  notes,
  pianoAttack,
  pianoOnce,
  pianoRelease,
  pianoReleaseAll,
  pitchColor,
  pitchFreq,
  pitchNoteOctave,
  playChroma,
  playChromaOnce,
  playKey,
  playNote,
  quantizeModes,
  record,
  recordCamera,
  recorder,
  recording,
  recordingName,
  rotateArray,
  scaleList,
  scaleType,
  scales,
  setCC,
  setupKeyboard,
  showRecordingDialog,
  stopAll,
  stopChroma,
  stopNote,
  synth,
  synthAttack,
  synthOnce,
  synthRelease,
  synthReleaseAll,
  tap,
  tempo,
  tracks,
  tuner,
  useAudio,
  useLoop,
  useMic,
  useMidi,
  useNoise,
  usePiano,
  useRecorder,
  useRecording,
  useSequence,
  useSvgMouse,
  useSynth,
  useTempo,
  useTuner
};
//# sourceMappingURL=index.mjs.map