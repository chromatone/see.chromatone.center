import { unref, ref, watch, isRef, getCurrentScope, onScopeDispose, getCurrentInstance, onMounted, nextTick, shallowRef, computed, reactive, shallowReactive, watchEffect, onBeforeUnmount } from "vue";
import { R as Recorder, s as start$1, c as context, M as Meter, L as Limiter, a as Reverb, g as getDestination, b as gainToDb, d as Midi$1, S as StereoWidener, P as PingPongDelay, A as AutoPanner, C as Compressor, e as PolySynth, f as MonoSynth, F as Frequency, h as Sampler, i as Loop, T as Transport, j as PanVol, k as Sequence, D as Draw, l as Time, U as UserMedia, G as Gate, m as FFT, n as Gain, B as BitCrusher, o as AutoFilter, N as NoiseSynth, p as dbToGain, q as now } from "./tone.js";
var Aubio = function(Aubio2) {
  Aubio2 = Aubio2 || {};
  var c2;
  c2 || (c2 = typeof Aubio2 !== "undefined" ? Aubio2 : {});
  var n2 = {}, r2;
  for (r2 in c2)
    c2.hasOwnProperty(r2) && (n2[r2] = c2[r2]);
  c2.arguments = [];
  c2.thisProgram = "./this.program";
  c2.quit = function(a2, b2) {
    throw b2;
  };
  c2.preRun = [];
  c2.postRun = [];
  var u2 = false, v2 = false, aa = false, ba = false;
  u2 = typeof window === "object";
  v2 = typeof importScripts === "function";
  aa = typeof process === "object" && typeof require === "function" && !u2 && !v2;
  ba = !u2 && !aa && !v2;
  var w2 = "";
  function ca(a2) {
    return c2.locateFile ? c2.locateFile(a2, w2) : w2 + a2;
  }
  if (aa) {
    w2 = __dirname + "/";
    var da, ea;
    c2.read = function(a2, b2) {
      da || (da = require("fs"));
      ea || (ea = require("path"));
      a2 = ea.normalize(a2);
      a2 = da.readFileSync(a2);
      return b2 ? a2 : a2.toString();
    };
    c2.readBinary = function(a2) {
      a2 = c2.read(a2, true);
      a2.buffer || (a2 = new Uint8Array(a2));
      assert(a2.buffer);
      return a2;
    };
    1 < process.argv.length && (c2.thisProgram = process.argv[1].replace(/\\/g, "/"));
    c2.arguments = process.argv.slice(2);
    process.on("uncaughtException", function(a2) {
      throw a2;
    });
    process.on("unhandledRejection", function() {
      process.exit(1);
    });
    c2.quit = function(a2) {
      process.exit(a2);
    };
    c2.inspect = function() {
      return "[Emscripten Module object]";
    };
  } else if (ba)
    typeof read != "undefined" && (c2.read = function(a2) {
      return read(a2);
    }), c2.readBinary = function(a2) {
      if (typeof readbuffer === "function")
        return new Uint8Array(readbuffer(a2));
      a2 = read(a2, "binary");
      assert(typeof a2 === "object");
      return a2;
    }, typeof scriptArgs != "undefined" ? c2.arguments = scriptArgs : typeof arguments != "undefined" && (c2.arguments = arguments), typeof quit === "function" && (c2.quit = function(a2) {
      quit(a2);
    });
  else if (u2 || v2) {
    if (u2) {
      var fa = this._currentScript;
      fa.src.indexOf("blob:") !== 0 && (w2 = "/");
    } else
      v2 && (w2 = "/");
    c2.read = function(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("GET", a2, false);
      b2.send(null);
      return b2.responseText;
    };
    v2 && (c2.readBinary = function(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("GET", a2, false);
      b2.responseType = "arraybuffer";
      b2.send(null);
      return new Uint8Array(b2.response);
    });
    c2.readAsync = function(a2, b2, d2) {
      var e2 = new XMLHttpRequest();
      e2.open("GET", a2, true);
      e2.responseType = "arraybuffer";
      e2.onload = function() {
        e2.status == 200 || e2.status == 0 && e2.response ? b2(e2.response) : d2();
      };
      e2.onerror = d2;
      e2.send(null);
    };
    c2.setWindowTitle = function(a2) {
    };
  }
  var ha = c2.print || (typeof console !== "undefined" ? console.log.bind(console) : typeof print !== "undefined" ? print : null), x2 = c2.printErr || (typeof printErr !== "undefined" ? printErr : typeof console !== "undefined" && console.warn.bind(console) || ha);
  for (r2 in n2)
    n2.hasOwnProperty(r2) && (c2[r2] = n2[r2]);
  n2 = void 0;
  function ia(a2) {
    var b2;
    b2 || (b2 = 16);
    return Math.ceil(a2 / b2) * b2;
  }
  var ja = {
    "f64-rem": function(a2, b2) {
      return a2 % b2;
    },
    debugger: function() {
      debugger;
    }
  }, ka = 0;
  function assert(a2, b2) {
    a2 || y2("Assertion failed: " + b2);
  }
  var la = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  typeof TextDecoder !== "undefined" && new TextDecoder("utf-16le");
  var buffer, ma, z, na, oa, A, B, pa, qa;
  function ra() {
    c2.HEAP8 = ma = new Int8Array(buffer);
    c2.HEAP16 = na = new Int16Array(buffer);
    c2.HEAP32 = A = new Int32Array(buffer);
    c2.HEAPU8 = z = new Uint8Array(buffer);
    c2.HEAPU16 = oa = new Uint16Array(buffer);
    c2.HEAPU32 = B = new Uint32Array(buffer);
    c2.HEAPF32 = pa = new Float32Array(buffer);
    c2.HEAPF64 = qa = new Float64Array(buffer);
  }
  var sa, C, ta, ua, va, wa, xa;
  sa = C = ta = ua = va = wa = xa = 0;
  function ya() {
    y2("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + E + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
  }
  var za = c2.TOTAL_STACK || 5242880, E = c2.TOTAL_MEMORY || 16777216;
  E < za && x2("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + E + "! (TOTAL_STACK=" + za + ")");
  c2.buffer ? buffer = c2.buffer : (typeof WebAssembly === "object" && typeof WebAssembly.Memory === "function" ? (c2.wasmMemory = new WebAssembly.Memory({
    initial: E / 65536,
    maximum: E / 65536
  }), buffer = c2.wasmMemory.buffer) : buffer = new ArrayBuffer(E), c2.buffer = buffer);
  ra();
  function Aa(a2) {
    for (; 0 < a2.length; ) {
      var b2 = a2.shift();
      if (typeof b2 == "function")
        b2();
      else {
        var d2 = b2.B;
        typeof d2 === "number" ? b2.F === void 0 ? c2.dynCall_v(d2) : c2.dynCall_vi(d2, b2.F) : d2(b2.F === void 0 ? null : b2.F);
      }
    }
  }
  var Ba = [], Ca = [], Da = [], Ea = [], Fa = false;
  function Ga() {
    var a2 = c2.preRun.shift();
    Ba.unshift(a2);
  }
  var Ha = Math.cos, Ia = Math.sin, F = 0, G = null;
  c2.preloadedImages = {};
  c2.preloadedAudios = {};
  function Ka(a2) {
    return String.prototype.startsWith ? a2.startsWith("data:application/octet-stream;base64,") : a2.indexOf("data:application/octet-stream;base64,") === 0;
  }
  (function() {
    function a2() {
      try {
        if (c2.wasmBinary)
          return new Uint8Array(c2.wasmBinary);
        if (c2.readBinary)
          return c2.readBinary(f2);
        throw "both async and sync fetching of the wasm failed";
      } catch (g2) {
        y2(g2);
      }
    }
    function b2() {
      return c2.wasmBinary || !u2 && !v2 || typeof fetch !== "function" ? new Promise(function(b3) {
        b3(a2());
      }) : fetch(f2, { credentials: "same-origin" }).then(function(a3) {
        if (!a3.ok)
          throw "failed to load wasm binary file at '" + f2 + "'";
        return a3.arrayBuffer();
      }).catch(function() {
        return a2();
      });
    }
    function d2(a3) {
      function d3(a4) {
        k2 = a4.exports;
        if (k2.memory) {
          a4 = k2.memory;
          var b3 = c2.buffer;
          a4.byteLength < b3.byteLength && x2("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");
          b3 = new Int8Array(b3);
          new Int8Array(a4).set(b3);
          c2.buffer = buffer = a4;
          ra();
        }
        c2.asm = k2;
        c2.usingWasm = true;
        F--;
        c2.monitorRunDependencies && c2.monitorRunDependencies(F);
        F == 0 && (G && (a4 = G, G = null, a4()));
      }
      function e3(a4) {
        d3(a4.instance);
      }
      function g2(a4) {
        b2().then(function(a5) {
          return WebAssembly.instantiate(a5, h2);
        }).then(a4).catch(function(a5) {
          x2("failed to asynchronously prepare wasm: " + a5);
          y2(a5);
        });
      }
      if (typeof WebAssembly !== "object")
        return x2("no native wasm support detected"), false;
      if (!(c2.wasmMemory instanceof WebAssembly.Memory))
        return x2("no native wasm Memory in use"), false;
      a3.memory = c2.wasmMemory;
      h2.global = { NaN: NaN, Infinity: Infinity };
      h2["global.Math"] = Math;
      h2.env = a3;
      F++;
      c2.monitorRunDependencies && c2.monitorRunDependencies(F);
      if (c2.instantiateWasm)
        try {
          return c2.instantiateWasm(h2, d3);
        } catch (vb) {
          return x2("Module.instantiateWasm callback failed with error: " + vb), false;
        }
      c2.wasmBinary || typeof WebAssembly.instantiateStreaming !== "function" || Ka(f2) || typeof fetch !== "function" ? g2(e3) : WebAssembly.instantiateStreaming(fetch(f2, { credentials: "same-origin" }), h2).then(e3).catch(function(a4) {
        x2("wasm streaming compile failed: " + a4);
        x2("falling back to ArrayBuffer instantiation");
        g2(e3);
      });
      return {};
    }
    var e2 = "aubio.wast", f2 = "aubio.wasm", l2 = "aubio.temp.asm.js";
    Ka(e2) || (e2 = ca(e2));
    Ka(f2) || (f2 = ca(f2));
    Ka(l2) || (l2 = ca(l2));
    var h2 = { global: null, env: null, asm2wasm: ja, parent: c2 }, k2 = null;
    c2.asmPreload = c2.asm;
    var m2 = c2.reallocBuffer;
    c2.reallocBuffer = function(a3) {
      if (p2 === "asmjs")
        var b3 = m2(a3);
      else
        a: {
          var d3 = c2.usingWasm ? 65536 : 16777216;
          0 < a3 % d3 && (a3 += d3 - a3 % d3);
          d3 = c2.buffer.byteLength;
          if (c2.usingWasm)
            try {
              b3 = c2.wasmMemory.grow((a3 - d3) / 65536) !== -1 ? c2.buffer = c2.wasmMemory.buffer : null;
              break a;
            } catch (t2) {
              b3 = null;
              break a;
            }
          b3 = void 0;
        }
      return b3;
    };
    var p2 = "";
    c2.asm = function(a3, b3) {
      if (!b3.table) {
        a3 = c2.wasmTableSize;
        a3 === void 0 && (a3 = 1024);
        var e3 = c2.wasmMaxTableSize;
        b3.table = typeof WebAssembly === "object" && typeof WebAssembly.Table === "function" ? e3 !== void 0 ? new WebAssembly.Table({
          initial: a3,
          maximum: e3,
          element: "anyfunc"
        }) : new WebAssembly.Table({ initial: a3, element: "anyfunc" }) : Array(a3);
        c2.wasmTable = b3.table;
      }
      b3.memoryBase || (b3.memoryBase = c2.STATIC_BASE);
      b3.tableBase || (b3.tableBase = 0);
      b3 = d2(b3);
      assert(b3, "no binaryen method succeeded.");
      return b3;
    };
  })();
  sa = 1024;
  C = sa + 9312;
  Ca.push({
    B: function() {
      La();
    }
  }, {
    B: function() {
      Ma();
    }
  }, {
    B: function() {
      Na();
    }
  }, {
    B: function() {
      Oa();
    }
  });
  c2.STATIC_BASE = sa;
  c2.STATIC_BUMP = 9312;
  C += 16;
  var H2 = 0;
  function I() {
    H2 += 4;
    return A[H2 - 4 >> 2];
  }
  var Pa = {};
  function J(a2, b2) {
    H2 = b2;
    try {
      var d2 = I(), e2 = I(), f2 = I();
      a2 = 0;
      J.J || (J.J = [null, [], []], J.P = function(a3, b3) {
        var d3 = J.J[a3];
        assert(d3);
        if (b3 === 0 || b3 === 10) {
          a3 = a3 === 1 ? ha : x2;
          a: {
            for (var e3 = b3 = 0; d3[e3]; )
              ++e3;
            if (16 < e3 - b3 && d3.subarray && la)
              b3 = la.decode(d3.subarray(b3, e3));
            else
              for (e3 = ""; ; ) {
                var f3 = d3[b3++];
                if (!f3) {
                  b3 = e3;
                  break a;
                }
                if (f3 & 128) {
                  var k3 = d3[b3++] & 63;
                  if ((f3 & 224) == 192)
                    e3 += String.fromCharCode((f3 & 31) << 6 | k3);
                  else {
                    var l3 = d3[b3++] & 63;
                    if ((f3 & 240) == 224)
                      f3 = (f3 & 15) << 12 | k3 << 6 | l3;
                    else {
                      var h3 = d3[b3++] & 63;
                      if ((f3 & 248) == 240)
                        f3 = (f3 & 7) << 18 | k3 << 12 | l3 << 6 | h3;
                      else {
                        var bb = d3[b3++] & 63;
                        if ((f3 & 252) == 248)
                          f3 = (f3 & 3) << 24 | k3 << 18 | l3 << 12 | h3 << 6 | bb;
                        else {
                          var m2 = d3[b3++] & 63;
                          f3 = (f3 & 1) << 30 | k3 << 24 | l3 << 18 | h3 << 12 | bb << 6 | m2;
                        }
                      }
                    }
                    65536 > f3 ? e3 += String.fromCharCode(f3) : (f3 -= 65536, e3 += String.fromCharCode(55296 | f3 >> 10, 56320 | f3 & 1023));
                  }
                } else
                  e3 += String.fromCharCode(f3);
              }
          }
          a3(b3);
          d3.length = 0;
        } else
          d3.push(b3);
      });
      for (b2 = 0; b2 < f2; b2++) {
        for (var l2 = A[e2 + 8 * b2 >> 2], h2 = A[e2 + (8 * b2 + 4) >> 2], k2 = 0; k2 < h2; k2++)
          J.P(d2, z[l2 + k2]);
        a2 += h2;
      }
      return a2;
    } catch (m2) {
      return typeof FS !== "undefined" && m2 instanceof FS.I || y2(m2), -m2.L;
    }
  }
  function Qa(a2) {
    switch (a2) {
      case 1:
        return 0;
      case 2:
        return 1;
      case 4:
        return 2;
      case 8:
        return 3;
      default:
        throw new TypeError("Unknown type size: " + a2);
    }
  }
  var Ra = void 0;
  function K(a2) {
    for (var b2 = ""; z[a2]; )
      b2 += Ra[z[a2++]];
    return b2;
  }
  var L = {}, M2 = {}, Sa = {};
  function Ta(a2) {
    if (a2 === void 0)
      return "_unknown";
    a2 = a2.replace(/[^a-zA-Z0-9_]/g, "$");
    var b2 = a2.charCodeAt(0);
    return 48 <= b2 && 57 >= b2 ? "_" + a2 : a2;
  }
  function Ua(a2, b2) {
    a2 = Ta(a2);
    return new Function("body", "return function " + a2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(b2);
  }
  function Va(a2) {
    var b2 = Error, d2 = Ua(a2, function(b3) {
      this.name = a2;
      this.message = b3;
      b3 = Error(b3).stack;
      b3 !== void 0 && (this.stack = this.toString() + "\n" + b3.replace(/^Error(:[^\n]*)?\n/, ""));
    });
    d2.prototype = Object.create(b2.prototype);
    d2.prototype.constructor = d2;
    d2.prototype.toString = function() {
      return this.message === void 0 ? this.name : this.name + ": " + this.message;
    };
    return d2;
  }
  var O = void 0;
  function P(a2) {
    throw new O(a2);
  }
  var Wa = void 0;
  function Xa(a2) {
    throw new Wa(a2);
  }
  function Ya(a2, b2, d2) {
    function e2(b3) {
      b3 = d2(b3);
      b3.length !== a2.length && Xa("Mismatched type converter count");
      for (var e3 = 0; e3 < a2.length; ++e3)
        Q(a2[e3], b3[e3]);
    }
    a2.forEach(function(a3) {
      Sa[a3] = b2;
    });
    var f2 = Array(b2.length), l2 = [], h2 = 0;
    b2.forEach(function(a3, b3) {
      M2.hasOwnProperty(a3) ? f2[b3] = M2[a3] : (l2.push(a3), L.hasOwnProperty(a3) || (L[a3] = []), L[a3].push(function() {
        f2[b3] = M2[a3];
        ++h2;
        h2 === l2.length && e2(f2);
      }));
    });
    l2.length === 0 && e2(f2);
  }
  function Q(a2, b2, d2) {
    d2 = d2 || {};
    if (!("argPackAdvance" in b2))
      throw new TypeError("registerType registeredInstance requires argPackAdvance");
    var e2 = b2.name;
    a2 || P('type "' + e2 + '" must have a positive integer typeid pointer');
    if (M2.hasOwnProperty(a2)) {
      if (d2.X)
        return;
      P("Cannot register type '" + e2 + "' twice");
    }
    M2[a2] = b2;
    delete Sa[a2];
    L.hasOwnProperty(a2) && (b2 = L[a2], delete L[a2], b2.forEach(function(a3) {
      a3();
    }));
  }
  function Za(a2) {
    P(a2.a.f.b.name + " instance already deleted");
  }
  var $a = void 0, ab = [];
  function cb() {
    for (; ab.length; ) {
      var a2 = ab.pop();
      a2.a.s = false;
      a2["delete"]();
    }
  }
  function R() {
  }
  var db = {};
  function eb(a2, b2, d2) {
    if (a2[b2].j === void 0) {
      var e2 = a2[b2];
      a2[b2] = function() {
        a2[b2].j.hasOwnProperty(arguments.length) || P("Function '" + d2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a2[b2].j + ")!");
        return a2[b2].j[arguments.length].apply(this, arguments);
      };
      a2[b2].j = [];
      a2[b2].j[e2.A] = e2;
    }
  }
  function fb(a2, b2) {
    c2.hasOwnProperty(a2) ? (P("Cannot register public name '" + a2 + "' twice"), eb(c2, a2, a2), c2.hasOwnProperty(void 0) && P("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), c2[a2].j[void 0] = b2) : c2[a2] = b2;
  }
  function gb(a2, b2, d2, e2, f2, l2, h2, k2) {
    this.name = a2;
    this.constructor = b2;
    this.u = d2;
    this.o = e2;
    this.i = f2;
    this.T = l2;
    this.w = h2;
    this.S = k2;
    this.Z = [];
  }
  function hb(a2, b2, d2) {
    for (; b2 !== d2; )
      b2.w || P("Expected null or instance of " + d2.name + ", got an instance of " + b2.name), a2 = b2.w(a2), b2 = b2.i;
    return a2;
  }
  function ib(a2, b2) {
    if (b2 === null)
      return this.G && P("null is not a valid " + this.name), 0;
    b2.a || P('Cannot pass "' + S2(b2) + '" as a ' + this.name);
    b2.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
    return hb(b2.a.c, b2.a.f.b, this.b);
  }
  function jb(a2, b2) {
    if (b2 === null) {
      this.G && P("null is not a valid " + this.name);
      if (this.D) {
        var d2 = this.$();
        a2 !== null && a2.push(this.o, d2);
        return d2;
      }
      return 0;
    }
    b2.a || P('Cannot pass "' + S2(b2) + '" as a ' + this.name);
    b2.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
    !this.C && b2.a.f.C && P("Cannot convert argument of type " + (b2.a.h ? b2.a.h.name : b2.a.f.name) + " to parameter type " + this.name);
    d2 = hb(b2.a.c, b2.a.f.b, this.b);
    if (this.D)
      switch (b2.a.g === void 0 && P("Passing raw pointer to smart pointer is illegal"), this.ba) {
        case 0:
          b2.a.h === this ? d2 = b2.a.g : P("Cannot convert argument of type " + (b2.a.h ? b2.a.h.name : b2.a.f.name) + " to parameter type " + this.name);
          break;
        case 1:
          d2 = b2.a.g;
          break;
        case 2:
          if (b2.a.h === this)
            d2 = b2.a.g;
          else {
            var e2 = b2.clone();
            d2 = this.aa(d2, T(function() {
              e2["delete"]();
            }));
            a2 !== null && a2.push(this.o, d2);
          }
          break;
        default:
          P("Unsupporting sharing policy");
      }
    return d2;
  }
  function kb(a2, b2) {
    if (b2 === null)
      return this.G && P("null is not a valid " + this.name), 0;
    b2.a || P('Cannot pass "' + S2(b2) + '" as a ' + this.name);
    b2.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
    b2.a.f.C && P("Cannot convert argument of type " + b2.a.f.name + " to parameter type " + this.name);
    return hb(b2.a.c, b2.a.f.b, this.b);
  }
  function lb(a2) {
    return this.fromWireType(B[a2 >> 2]);
  }
  function ob(a2, b2, d2) {
    if (b2 === d2)
      return a2;
    if (d2.i === void 0)
      return null;
    a2 = ob(a2, b2, d2.i);
    return a2 === null ? null : d2.S(a2);
  }
  var pb = {};
  function qb(a2, b2) {
    for (b2 === void 0 && P("ptr should not be undefined"); a2.i; )
      b2 = a2.w(b2), a2 = a2.i;
    return pb[b2];
  }
  function rb(a2, b2) {
    b2.f && b2.c || Xa("makeClassHandle requires ptr and ptrType");
    !!b2.h !== !!b2.g && Xa("Both smartPtrType and smartPtr must be specified");
    b2.count = { value: 1 };
    return Object.create(a2, { a: { value: b2 } });
  }
  function U(a2, b2, d2, e2, f2, l2, h2, k2, m2, p2, g2) {
    this.name = a2;
    this.b = b2;
    this.G = d2;
    this.C = e2;
    this.D = f2;
    this.Y = l2;
    this.ba = h2;
    this.M = k2;
    this.$ = m2;
    this.aa = p2;
    this.o = g2;
    f2 || b2.i !== void 0 ? this.toWireType = jb : (this.toWireType = e2 ? ib : kb, this.l = null);
  }
  function sb(a2, b2) {
    c2.hasOwnProperty(a2) || Xa("Replacing nonexistant public symbol");
    c2[a2] = b2;
    c2[a2].A = void 0;
  }
  function V(a2, b2) {
    a2 = K(a2);
    if (c2["FUNCTION_TABLE_" + a2] !== void 0)
      var d2 = c2["FUNCTION_TABLE_" + a2][b2];
    else if (typeof FUNCTION_TABLE !== "undefined")
      d2 = FUNCTION_TABLE[b2];
    else {
      d2 = c2.asm["dynCall_" + a2];
      d2 === void 0 && (d2 = c2.asm["dynCall_" + a2.replace(/f/g, "d")], d2 === void 0 && P("No dynCall invoker for signature: " + a2));
      for (var e2 = [], f2 = 1; f2 < a2.length; ++f2)
        e2.push("a" + f2);
      f2 = "return function " + ("dynCall_" + a2 + "_" + b2) + "(" + e2.join(", ") + ") {\n";
      f2 += "    return dynCall(rawFunction" + (e2.length ? ", " : "") + e2.join(", ") + ");\n";
      d2 = new Function("dynCall", "rawFunction", f2 + "};\n")(d2, b2);
    }
    typeof d2 !== "function" && P("unknown function pointer with signature " + a2 + ": " + b2);
    return d2;
  }
  var tb = void 0;
  function ub(a2) {
    a2 = wb(a2);
    var b2 = K(a2);
    X(a2);
    return b2;
  }
  function xb(a2, b2) {
    function d2(a3) {
      f2[a3] || M2[a3] || (Sa[a3] ? Sa[a3].forEach(d2) : (e2.push(a3), f2[a3] = true));
    }
    var e2 = [], f2 = {};
    b2.forEach(d2);
    throw new tb(a2 + ": " + e2.map(ub).join([", "]));
  }
  function yb(a2, b2) {
    for (var d2 = [], e2 = 0; e2 < a2; e2++)
      d2.push(A[(b2 >> 2) + e2]);
    return d2;
  }
  function zb(a2) {
    for (; a2.length; ) {
      var b2 = a2.pop();
      a2.pop()(b2);
    }
  }
  function Ab(a2) {
    var b2 = Function;
    if (!(b2 instanceof Function))
      throw new TypeError("new_ called with constructor type " + typeof b2 + " which is not a function");
    var d2 = Ua(b2.name || "unknownFunctionName", function() {
    });
    d2.prototype = b2.prototype;
    d2 = new d2();
    a2 = b2.apply(d2, a2);
    return a2 instanceof Object ? a2 : d2;
  }
  var Bb = [], Y = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
  function Cb(a2) {
    4 < a2 && --Y[a2].H === 0 && (Y[a2] = void 0, Bb.push(a2));
  }
  function T(a2) {
    switch (a2) {
      case void 0:
        return 1;
      case null:
        return 2;
      case true:
        return 3;
      case false:
        return 4;
      default:
        var b2 = Bb.length ? Bb.pop() : Y.length;
        Y[b2] = { H: 1, value: a2 };
        return b2;
    }
  }
  function S2(a2) {
    if (a2 === null)
      return "null";
    var b2 = typeof a2;
    return b2 === "object" || b2 === "array" || b2 === "function" ? a2.toString() : "" + a2;
  }
  function Db(a2, b2) {
    switch (b2) {
      case 2:
        return function(a3) {
          return this.fromWireType(pa[a3 >> 2]);
        };
      case 3:
        return function(a3) {
          return this.fromWireType(qa[a3 >> 3]);
        };
      default:
        throw new TypeError("Unknown float type: " + a2);
    }
  }
  function Eb(a2, b2, d2) {
    switch (b2) {
      case 0:
        return d2 ? function(a3) {
          return ma[a3];
        } : function(a3) {
          return z[a3];
        };
      case 1:
        return d2 ? function(a3) {
          return na[a3 >> 1];
        } : function(a3) {
          return oa[a3 >> 1];
        };
      case 2:
        return d2 ? function(a3) {
          return A[a3 >> 2];
        } : function(a3) {
          return B[a3 >> 2];
        };
      default:
        throw new TypeError("Unknown integer type: " + a2);
    }
  }
  function Z(a2) {
    a2 || P("Cannot use deleted val. handle = " + a2);
    return Y[a2].value;
  }
  function Fb(a2, b2) {
    var d2 = M2[a2];
    d2 === void 0 && P(b2 + " has unknown type " + ub(a2));
    return d2;
  }
  for (var Gb = {}, Hb = Array(256), Ib = 0; 256 > Ib; ++Ib)
    Hb[Ib] = String.fromCharCode(Ib);
  Ra = Hb;
  O = c2.BindingError = Va("BindingError");
  Wa = c2.InternalError = Va("InternalError");
  R.prototype.isAliasOf = function(a2) {
    if (!(this instanceof R && a2 instanceof R))
      return false;
    var b2 = this.a.f.b, d2 = this.a.c, e2 = a2.a.f.b;
    for (a2 = a2.a.c; b2.i; )
      d2 = b2.w(d2), b2 = b2.i;
    for (; e2.i; )
      a2 = e2.w(a2), e2 = e2.i;
    return b2 === e2 && d2 === a2;
  };
  R.prototype.clone = function() {
    this.a.c || Za(this);
    if (this.a.v)
      return this.a.count.value += 1, this;
    var a2 = this.a;
    a2 = Object.create(Object.getPrototypeOf(this), {
      a: {
        value: {
          count: a2.count,
          s: a2.s,
          v: a2.v,
          c: a2.c,
          f: a2.f,
          g: a2.g,
          h: a2.h
        }
      }
    });
    a2.a.count.value += 1;
    a2.a.s = false;
    return a2;
  };
  R.prototype["delete"] = function() {
    this.a.c || Za(this);
    this.a.s && !this.a.v && P("Object already scheduled for deletion");
    --this.a.count.value;
    if (this.a.count.value === 0) {
      var a2 = this.a;
      a2.g ? a2.h.o(a2.g) : a2.f.b.o(a2.c);
    }
    this.a.v || (this.a.g = void 0, this.a.c = void 0);
  };
  R.prototype.isDeleted = function() {
    return !this.a.c;
  };
  R.prototype.deleteLater = function() {
    this.a.c || Za(this);
    this.a.s && !this.a.v && P("Object already scheduled for deletion");
    ab.push(this);
    ab.length === 1 && $a && $a(cb);
    this.a.s = true;
    return this;
  };
  U.prototype.U = function(a2) {
    this.M && (a2 = this.M(a2));
    return a2;
  };
  U.prototype.K = function(a2) {
    this.o && this.o(a2);
  };
  U.prototype.argPackAdvance = 8;
  U.prototype.readValueFromPointer = lb;
  U.prototype.deleteObject = function(a2) {
    if (a2 !== null)
      a2["delete"]();
  };
  U.prototype.fromWireType = function(a2) {
    function b2() {
      return this.D ? rb(this.b.u, { f: this.Y, c: d2, h: this, g: a2 }) : rb(this.b.u, { f: this, c: a2 });
    }
    var d2 = this.U(a2);
    if (!d2)
      return this.K(a2), null;
    var e2 = qb(this.b, d2);
    if (e2 !== void 0) {
      if (e2.a.count.value === 0)
        return e2.a.c = d2, e2.a.g = a2, e2.clone();
      e2 = e2.clone();
      this.K(a2);
      return e2;
    }
    e2 = this.b.T(d2);
    e2 = db[e2];
    if (!e2)
      return b2.call(this);
    e2 = this.C ? e2.R : e2.pointerType;
    var f2 = ob(d2, this.b, e2.b);
    return f2 === null ? b2.call(this) : this.D ? rb(e2.b.u, { f: e2, c: f2, h: this, g: a2 }) : rb(e2.b.u, { f: e2, c: f2 });
  };
  c2.getInheritedInstanceCount = function() {
    return Object.keys(pb).length;
  };
  c2.getLiveInheritedInstances = function() {
    var a2 = [], b2;
    for (b2 in pb)
      pb.hasOwnProperty(b2) && a2.push(pb[b2]);
    return a2;
  };
  c2.flushPendingDeletes = cb;
  c2.setDelayFunction = function(a2) {
    $a = a2;
    ab.length && $a && $a(cb);
  };
  tb = c2.UnboundTypeError = Va("UnboundTypeError");
  c2.count_emval_handles = function() {
    for (var a2 = 0, b2 = 5; b2 < Y.length; ++b2)
      Y[b2] !== void 0 && ++a2;
    return a2;
  };
  c2.get_first_emval = function() {
    for (var a2 = 5; a2 < Y.length; ++a2)
      if (Y[a2] !== void 0)
        return Y[a2];
    return null;
  };
  var Jb = C;
  C = C + 4 + 15 & -16;
  xa = Jb;
  ta = ua = ia(C);
  va = ta + za;
  wa = ia(va);
  A[xa >> 2] = wa;
  c2.wasmTableSize = 83;
  c2.wasmMaxTableSize = 83;
  c2.N = {};
  c2.O = {
    abort: y2,
    enlargeMemory: function() {
      ya();
    },
    getTotalMemory: function() {
      return E;
    },
    abortOnCannotGrowMemory: ya,
    ___setErrNo: function(a2) {
      c2.___errno_location && (A[c2.___errno_location() >> 2] = a2);
      return a2;
    },
    ___syscall140: function(a2, b2) {
      H2 = b2;
      try {
        var d2 = Pa.V();
        I();
        var e2 = I(), f2 = I(), l2 = I();
        FS.ea(d2, e2, l2);
        A[f2 >> 2] = d2.position;
        d2.W && e2 === 0 && l2 === 0 && (d2.W = null);
        return 0;
      } catch (h2) {
        return typeof FS !== "undefined" && h2 instanceof FS.I || y2(h2), -h2.L;
      }
    },
    ___syscall146: J,
    ___syscall54: function(a2, b2) {
      H2 = b2;
      return 0;
    },
    ___syscall6: function(a2, b2) {
      H2 = b2;
      try {
        var d2 = Pa.V();
        FS.close(d2);
        return 0;
      } catch (e2) {
        return typeof FS !== "undefined" && e2 instanceof FS.I || y2(e2), -e2.L;
      }
    },
    __embind_register_bool: function(a2, b2, d2, e2, f2) {
      var l2 = Qa(d2);
      b2 = K(b2);
      Q(a2, {
        name: b2,
        fromWireType: function(a3) {
          return !!a3;
        },
        toWireType: function(a3, b3) {
          return b3 ? e2 : f2;
        },
        argPackAdvance: 8,
        readValueFromPointer: function(a3) {
          if (d2 === 1)
            var e3 = ma;
          else if (d2 === 2)
            e3 = na;
          else if (d2 === 4)
            e3 = A;
          else
            throw new TypeError("Unknown boolean type size: " + b2);
          return this.fromWireType(e3[a3 >> l2]);
        },
        l: null
      });
    },
    __embind_register_class: function(a2, b2, d2, e2, f2, l2, h2, k2, m2, p2, g2, q, D) {
      g2 = K(g2);
      l2 = V(f2, l2);
      k2 && (k2 = V(h2, k2));
      p2 && (p2 = V(m2, p2));
      D = V(q, D);
      var t2 = Ta(g2);
      fb(t2, function() {
        xb("Cannot construct " + g2 + " due to unbound types", [e2]);
      });
      Ya([a2, b2, d2], e2 ? [e2] : [], function(b3) {
        b3 = b3[0];
        if (e2) {
          var d3 = b3.b;
          var f3 = d3.u;
        } else
          f3 = R.prototype;
        b3 = Ua(t2, function() {
          if (Object.getPrototypeOf(this) !== h3)
            throw new O("Use 'new' to construct " + g2);
          if (m3.m === void 0)
            throw new O(g2 + " has no accessible constructor");
          var a3 = m3.m[arguments.length];
          if (a3 === void 0)
            throw new O("Tried to invoke ctor of " + g2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(m3.m).toString() + ") parameters instead!");
          return a3.apply(this, arguments);
        });
        var h3 = Object.create(f3, { constructor: { value: b3 } });
        b3.prototype = h3;
        var m3 = new gb(g2, b3, h3, D, d3, l2, k2, p2);
        d3 = new U(g2, m3, true, false, false);
        f3 = new U(g2 + "*", m3, false, false, false);
        var q2 = new U(g2 + " const*", m3, false, true, false);
        db[a2] = { pointerType: f3, R: q2 };
        sb(t2, b3);
        return [d3, f3, q2];
      });
    },
    __embind_register_class_constructor: function(a2, b2, d2, e2, f2, l2) {
      var h2 = yb(b2, d2);
      f2 = V(e2, f2);
      Ya([], [a2], function(a3) {
        a3 = a3[0];
        var d3 = "constructor " + a3.name;
        a3.b.m === void 0 && (a3.b.m = []);
        if (a3.b.m[b2 - 1] !== void 0)
          throw new O("Cannot register multiple constructors with identical number of parameters (" + (b2 - 1) + ") for class '" + a3.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        a3.b.m[b2 - 1] = function() {
          xb("Cannot construct " + a3.name + " due to unbound types", h2);
        };
        Ya([], h2, function(e3) {
          a3.b.m[b2 - 1] = function() {
            arguments.length !== b2 - 1 && P(d3 + " called with " + arguments.length + " arguments, expected " + (b2 - 1));
            var a4 = [], h3 = Array(b2);
            h3[0] = l2;
            for (var k2 = 1; k2 < b2; ++k2)
              h3[k2] = e3[k2].toWireType(a4, arguments[k2 - 1]);
            h3 = f2.apply(null, h3);
            zb(a4);
            return e3[0].fromWireType(h3);
          };
          return [];
        });
        return [];
      });
    },
    __embind_register_class_function: function(a2, b2, d2, e2, f2, l2, h2, k2) {
      var m2 = yb(d2, e2);
      b2 = K(b2);
      l2 = V(f2, l2);
      Ya([], [a2], function(a3) {
        function e3() {
          xb("Cannot call " + f3 + " due to unbound types", m2);
        }
        a3 = a3[0];
        var f3 = a3.name + "." + b2;
        k2 && a3.b.Z.push(b2);
        var p2 = a3.b.u, t2 = p2[b2];
        t2 === void 0 || t2.j === void 0 && t2.className !== a3.name && t2.A === d2 - 2 ? (e3.A = d2 - 2, e3.className = a3.name, p2[b2] = e3) : (eb(p2, b2, f3), p2[b2].j[d2 - 2] = e3);
        Ya([], m2, function(e4) {
          var k3 = f3, g2 = a3, m3 = l2, q = e4.length;
          2 > q && P("argTypes array size mismatch! Must at least get return value and 'this' types!");
          var t3 = e4[1] !== null && g2 !== null, D = false;
          for (g2 = 1; g2 < e4.length; ++g2)
            if (e4[g2] !== null && e4[g2].l === void 0) {
              D = true;
              break;
            }
          var mb = e4[0].name !== "void", N2 = "", W = "";
          for (g2 = 0; g2 < q - 2; ++g2)
            N2 += (g2 !== 0 ? ", " : "") + "arg" + g2, W += (g2 !== 0 ? ", " : "") + "arg" + g2 + "Wired";
          k3 = "return function " + Ta(k3) + "(" + N2 + ") {\nif (arguments.length !== " + (q - 2) + ") {\nthrowBindingError('function " + k3 + " called with ' + arguments.length + ' arguments, expected " + (q - 2) + " args!');\n}\n";
          D && (k3 += "var destructors = [];\n");
          var nb = D ? "destructors" : "null";
          N2 = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
          m3 = [P, m3, h2, zb, e4[0], e4[1]];
          t3 && (k3 += "var thisWired = classParam.toWireType(" + nb + ", this);\n");
          for (g2 = 0; g2 < q - 2; ++g2)
            k3 += "var arg" + g2 + "Wired = argType" + g2 + ".toWireType(" + nb + ", arg" + g2 + "); // " + e4[g2 + 2].name + "\n", N2.push("argType" + g2), m3.push(e4[g2 + 2]);
          t3 && (W = "thisWired" + (0 < W.length ? ", " : "") + W);
          k3 += (mb ? "var rv = " : "") + "invoker(fn" + (0 < W.length ? ", " : "") + W + ");\n";
          if (D)
            k3 += "runDestructors(destructors);\n";
          else
            for (g2 = t3 ? 1 : 2; g2 < e4.length; ++g2)
              q = g2 === 1 ? "thisWired" : "arg" + (g2 - 2) + "Wired", e4[g2].l !== null && (k3 += q + "_dtor(" + q + "); // " + e4[g2].name + "\n", N2.push(q + "_dtor"), m3.push(e4[g2].l));
          mb && (k3 += "var ret = retType.fromWireType(rv);\nreturn ret;\n");
          N2.push(k3 + "}\n");
          e4 = Ab(N2).apply(null, m3);
          p2[b2].j === void 0 ? (e4.A = d2 - 2, p2[b2] = e4) : p2[b2].j[d2 - 2] = e4;
          return [];
        });
        return [];
      });
    },
    __embind_register_emval: function(a2, b2) {
      b2 = K(b2);
      Q(a2, {
        name: b2,
        fromWireType: function(a3) {
          var b3 = Y[a3].value;
          Cb(a3);
          return b3;
        },
        toWireType: function(a3, b3) {
          return T(b3);
        },
        argPackAdvance: 8,
        readValueFromPointer: lb,
        l: null
      });
    },
    __embind_register_float: function(a2, b2, d2) {
      d2 = Qa(d2);
      b2 = K(b2);
      Q(a2, {
        name: b2,
        fromWireType: function(a3) {
          return a3;
        },
        toWireType: function(a3, b3) {
          if (typeof b3 !== "number" && typeof b3 !== "boolean")
            throw new TypeError('Cannot convert "' + S2(b3) + '" to ' + this.name);
          return b3;
        },
        argPackAdvance: 8,
        readValueFromPointer: Db(b2, d2),
        l: null
      });
    },
    __embind_register_integer: function(a2, b2, d2, e2, f2) {
      function l2(a3) {
        return a3;
      }
      b2 = K(b2);
      f2 === -1 && (f2 = 4294967295);
      var h2 = Qa(d2);
      if (e2 === 0) {
        var k2 = 32 - 8 * d2;
        l2 = function(a3) {
          return a3 << k2 >>> k2;
        };
      }
      var m2 = b2.indexOf("unsigned") != -1;
      Q(a2, {
        name: b2,
        fromWireType: l2,
        toWireType: function(a3, d3) {
          if (typeof d3 !== "number" && typeof d3 !== "boolean")
            throw new TypeError('Cannot convert "' + S2(d3) + '" to ' + this.name);
          if (d3 < e2 || d3 > f2)
            throw new TypeError('Passing a number "' + S2(d3) + '" from JS side to C/C++ side to an argument of type "' + b2 + '", which is outside the valid range [' + e2 + ", " + f2 + "]!");
          return m2 ? d3 >>> 0 : d3 | 0;
        },
        argPackAdvance: 8,
        readValueFromPointer: Eb(b2, h2, e2 !== 0),
        l: null
      });
    },
    __embind_register_memory_view: function(a2, b2, d2) {
      function e2(a3) {
        a3 >>= 2;
        var b3 = B;
        return new f2(b3.buffer, b3[a3 + 1], b3[a3]);
      }
      var f2 = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ][b2];
      d2 = K(d2);
      Q(a2, {
        name: d2,
        fromWireType: e2,
        argPackAdvance: 8,
        readValueFromPointer: e2
      }, { X: true });
    },
    __embind_register_std_string: function(a2, b2) {
      b2 = K(b2);
      Q(a2, {
        name: b2,
        fromWireType: function(a3) {
          for (var b3 = B[a3 >> 2], d2 = Array(b3), l2 = 0; l2 < b3; ++l2)
            d2[l2] = String.fromCharCode(z[a3 + 4 + l2]);
          X(a3);
          return d2.join("");
        },
        toWireType: function(a3, b3) {
          function d2(a4, b4) {
            return a4[b4];
          }
          function e2(a4, b4) {
            return a4.charCodeAt(b4);
          }
          b3 instanceof ArrayBuffer && (b3 = new Uint8Array(b3));
          var h2;
          b3 instanceof Uint8Array ? h2 = d2 : b3 instanceof Uint8ClampedArray ? h2 = d2 : b3 instanceof Int8Array ? h2 = d2 : typeof b3 === "string" ? h2 = e2 : P("Cannot pass non-string to std::string");
          var k2 = b3.length, m2 = Kb(4 + k2);
          B[m2 >> 2] = k2;
          for (var p2 = 0; p2 < k2; ++p2) {
            var g2 = h2(b3, p2);
            255 < g2 && (X(m2), P("String has UTF-16 code units that do not fit in 8 bits"));
            z[m2 + 4 + p2] = g2;
          }
          a3 !== null && a3.push(X, m2);
          return m2;
        },
        argPackAdvance: 8,
        readValueFromPointer: lb,
        l: function(a3) {
          X(a3);
        }
      });
    },
    __embind_register_std_wstring: function(a2, b2, d2) {
      d2 = K(d2);
      if (b2 === 2) {
        var e2 = function() {
          return oa;
        };
        var f2 = 1;
      } else
        b2 === 4 && (e2 = function() {
          return B;
        }, f2 = 2);
      Q(a2, {
        name: d2,
        fromWireType: function(a3) {
          for (var b3 = e2(), d3 = B[a3 >> 2], l2 = Array(d3), p2 = a3 + 4 >> f2, g2 = 0; g2 < d3; ++g2)
            l2[g2] = String.fromCharCode(b3[p2 + g2]);
          X(a3);
          return l2.join("");
        },
        toWireType: function(a3, d3) {
          var k2 = e2(), h2 = d3.length, l2 = Kb(4 + h2 * b2);
          B[l2 >> 2] = h2;
          for (var g2 = l2 + 4 >> f2, q = 0; q < h2; ++q)
            k2[g2 + q] = d3.charCodeAt(q);
          a3 !== null && a3.push(X, l2);
          return l2;
        },
        argPackAdvance: 8,
        readValueFromPointer: lb,
        l: function(a3) {
          X(a3);
        }
      });
    },
    __embind_register_void: function(a2, b2) {
      b2 = K(b2);
      Q(a2, {
        da: true,
        name: b2,
        argPackAdvance: 0,
        fromWireType: function() {
        },
        toWireType: function() {
        }
      });
    },
    __emval_as: function(a2, b2, d2) {
      a2 = Z(a2);
      b2 = Fb(b2, "emval::as");
      var e2 = [], f2 = T(e2);
      A[d2 >> 2] = f2;
      return b2.toWireType(e2, a2);
    },
    __emval_decref: Cb,
    __emval_get_property: function(a2, b2) {
      a2 = Z(a2);
      b2 = Z(b2);
      return T(a2[b2]);
    },
    __emval_incref: function(a2) {
      4 < a2 && (Y[a2].H += 1);
    },
    __emval_new_array: function() {
      return T([]);
    },
    __emval_new_cstring: function(a2) {
      var b2 = Gb[a2];
      return T(b2 === void 0 ? K(a2) : b2);
    },
    __emval_new_object: function() {
      return T({});
    },
    __emval_run_destructors: function(a2) {
      zb(Y[a2].value);
      Cb(a2);
    },
    __emval_set_property: function(a2, b2, d2) {
      a2 = Z(a2);
      b2 = Z(b2);
      d2 = Z(d2);
      a2[b2] = d2;
    },
    __emval_take_value: function(a2, b2) {
      a2 = Fb(a2, "_emval_take_value");
      a2 = a2.readValueFromPointer(b2);
      return T(a2);
    },
    _abort: function() {
      c2.abort();
    },
    _emscripten_memcpy_big: function(a2, b2, d2) {
      z.set(z.subarray(b2, b2 + d2), a2);
      return a2;
    },
    _llvm_cos_f32: Ha,
    _llvm_log10_f32: function(a2) {
      return Math.log(a2) / Math.LN10;
    },
    _llvm_sin_f32: Ia,
    DYNAMICTOP_PTR: xa,
    STACKTOP: ua
  };
  var Lb = c2.asm(c2.N, c2.O, buffer);
  c2.asm = Lb;
  var Oa = c2.__GLOBAL__sub_I_bind_cpp = function() {
    return c2.asm.__GLOBAL__sub_I_bind_cpp.apply(null, arguments);
  }, La = c2.__GLOBAL__sub_I_fft_cc = function() {
    return c2.asm.__GLOBAL__sub_I_fft_cc.apply(null, arguments);
  }, Na = c2.__GLOBAL__sub_I_pitch_cc = function() {
    return c2.asm.__GLOBAL__sub_I_pitch_cc.apply(null, arguments);
  }, Ma = c2.__GLOBAL__sub_I_tempo_cc = function() {
    return c2.asm.__GLOBAL__sub_I_tempo_cc.apply(null, arguments);
  }, wb = c2.___getTypeName = function() {
    return c2.asm.___getTypeName.apply(null, arguments);
  }, X = c2._free = function() {
    return c2.asm._free.apply(null, arguments);
  }, Kb = c2._malloc = function() {
    return c2.asm._malloc.apply(null, arguments);
  };
  c2.dynCall_ffii = function() {
    return c2.asm.dynCall_ffii.apply(null, arguments);
  };
  c2.dynCall_fi = function() {
    return c2.asm.dynCall_fi.apply(null, arguments);
  };
  c2.dynCall_fii = function() {
    return c2.asm.dynCall_fii.apply(null, arguments);
  };
  c2.dynCall_fiii = function() {
    return c2.asm.dynCall_fiii.apply(null, arguments);
  };
  c2.dynCall_ii = function() {
    return c2.asm.dynCall_ii.apply(null, arguments);
  };
  c2.dynCall_iii = function() {
    return c2.asm.dynCall_iii.apply(null, arguments);
  };
  c2.dynCall_iiii = function() {
    return c2.asm.dynCall_iiii.apply(null, arguments);
  };
  c2.dynCall_iiiii = function() {
    return c2.asm.dynCall_iiiii.apply(null, arguments);
  };
  c2.dynCall_iiiiii = function() {
    return c2.asm.dynCall_iiiiii.apply(null, arguments);
  };
  c2.dynCall_v = function() {
    return c2.asm.dynCall_v.apply(null, arguments);
  };
  c2.dynCall_vi = function() {
    return c2.asm.dynCall_vi.apply(null, arguments);
  };
  c2.dynCall_viii = function() {
    return c2.asm.dynCall_viii.apply(null, arguments);
  };
  c2.asm = Lb;
  c2.then = function(a2) {
    if (c2.calledRun)
      a2(c2);
    else {
      var b2 = c2.onRuntimeInitialized;
      c2.onRuntimeInitialized = function() {
        b2 && b2();
        a2(c2);
      };
    }
    return c2;
  };
  G = function Mb() {
    c2.calledRun || Nb();
    c2.calledRun || (G = Mb);
  };
  function Nb() {
    function a2() {
      if (!c2.calledRun && (c2.calledRun = true, !ka)) {
        Fa || (Fa = true, Aa(Ca));
        Aa(Da);
        if (c2.onRuntimeInitialized)
          c2.onRuntimeInitialized();
        if (c2.postRun)
          for (typeof c2.postRun == "function" && (c2.postRun = [c2.postRun]); c2.postRun.length; ) {
            var a3 = c2.postRun.shift();
            Ea.unshift(a3);
          }
        Aa(Ea);
      }
    }
    if (!(0 < F)) {
      if (c2.preRun)
        for (typeof c2.preRun == "function" && (c2.preRun = [c2.preRun]); c2.preRun.length; )
          Ga();
      Aa(Ba);
      0 < F || c2.calledRun || (c2.setStatus ? (c2.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          c2.setStatus("");
        }, 1);
        a2();
      }, 1)) : a2());
    }
  }
  c2.run = Nb;
  function y2(a2) {
    if (c2.onAbort)
      c2.onAbort(a2);
    a2 !== void 0 ? (ha(a2), x2(a2), a2 = JSON.stringify(a2)) : a2 = "";
    ka = true;
    throw "abort(" + a2 + "). Build with -s ASSERTIONS=1 for more info.";
  }
  c2.abort = y2;
  if (c2.preInit)
    for (typeof c2.preInit == "function" && (c2.preInit = [c2.preInit]); 0 < c2.preInit.length; )
      c2.preInit.pop()();
  c2.noExitRuntime = true;
  Nb();
  return Aubio2;
};
var Aubio$1 = Aubio.bind({
  _currentScript: {
    src: "/aubio.js"
  }
});
var _a;
const isClient = typeof window !== "undefined";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const timestamp$1 = () => +Date.now();
const clamp = (n2, min, max) => Math.min(max, Math.max(min, n2));
const noop = () => {
};
isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    filter2(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function identity(arg) {
  return arg;
}
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useIntervalFn(cb, interval2 = 1e3, options2 = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options2;
  let timer2 = null;
  const isActive = ref(false);
  function clean() {
    if (timer2) {
      clearInterval(timer2);
      timer2 = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    if (unref(interval2) <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer2 = setInterval(cb, resolveUnref(interval2));
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval2)) {
    const stopWatch = watch(interval2, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useLastChanged(source, options2 = {}) {
  var _a2;
  const ms = ref((_a2 = options2.initialValue) != null ? _a2 : null);
  watch(source, () => ms.value = timestamp$1(), options2);
  return ms;
}
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options2 = {}) {
  const _a2 = options2, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$5(_a2, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$2.call(b2, prop))
      __defNormalProp$2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b2)) {
      if (__propIsEnum$2.call(b2, prop))
        __defNormalProp$2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$2 = (a2, b2) => __defProps$2(a2, __getOwnPropDescs$2(b2));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchPausable(source, cb, options2 = {}) {
  const _a2 = options2, {
    eventFilter: filter2
  } = _a2, watchOptions = __objRest$1(_a2, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
    eventFilter
  }));
  return { stop, pause, resume, isActive };
}
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
const defaultNavigator = isClient ? window.navigator : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options2;
  if (isString(args[0])) {
    [event, listener, options2] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options2] = args;
  }
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options2);
    cleanup = () => {
      el.removeEventListener(event, listener, options2);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
var __defProp$l = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
var __hasOwnProp$n = Object.prototype.hasOwnProperty;
var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$l = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$n.call(b2, prop))
      __defNormalProp$l(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(b2)) {
      if (__propIsEnum$n.call(b2, prop))
        __defNormalProp$l(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$8 = (a2, b2) => __defProps$8(a2, __getOwnPropDescs$8(b2));
const createKeyPredicate = (keyFilter) => {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  else if (keyFilter)
    return () => true;
  else
    return () => false;
};
function onKeyStroke(key, handler, options2 = {}) {
  const { target = defaultWindow, eventName = "keydown", passive = false } = options2;
  const predicate = createKeyPredicate(key);
  const listener = (e2) => {
    if (predicate(e2))
      handler(e2);
  };
  return useEventListener(target, eventName, listener, passive);
}
function onKeyDown(key, handler, options2 = {}) {
  return onKeyStroke(key, handler, __spreadProps$8(__spreadValues$l({}, options2), { eventName: "keydown" }));
}
function useSupported(callback, sync = false) {
  const isSupported = ref();
  const update = () => isSupported.value = Boolean(callback());
  update();
  tryOnMounted(update, sync);
  return isSupported;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
const handlers = _global[globalKey];
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
var __defProp$j = Object.defineProperty;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$j = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$l.call(b2, prop))
      __defNormalProp$j(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b2)) {
      if (__propIsEnum$l.call(b2, prop))
        __defNormalProp$j(a2, prop, b2[prop]);
    }
  return a2;
};
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2))
  },
  date: {
    read: (v2) => new Date(v2),
    write: (v2) => v2.toISOString()
  }
};
function useStorage(key, defaults, storage, options2 = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    }
  } = options2;
  const data = (shallow ? shallowRef : ref)(defaults);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e2) {
      onError(e2);
    }
  }
  if (!storage)
    return data;
  const rawInit = resolveUnref(defaults);
  const type = guessSerializerType(rawInit);
  const serializer = (_a2 = options2.serializer) != null ? _a2 : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(data, () => write(data.value), { flush, deep, eventFilter });
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", update);
  update();
  return data;
  function write(v2) {
    try {
      if (v2 == null)
        storage.removeItem(key);
      else
        storage.setItem(key, serializer.write(v2));
    } catch (e2) {
      onError(e2);
    }
  }
  function read2(event) {
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      const rawValue = event ? event.newValue : storage.getItem(key);
      if (rawValue == null) {
        if (writeDefaults && rawInit !== null)
          storage.setItem(key, serializer.write(rawInit));
        return rawInit;
      } else if (!event && mergeDefaults) {
        const value = serializer.read(rawValue);
        if (isFunction(mergeDefaults))
          return mergeDefaults(value, rawInit);
        else if (type === "object" && !Array.isArray(value))
          return __spreadValues$j(__spreadValues$j({}, rawInit), value);
        return value;
      } else if (typeof rawValue !== "string") {
        return rawValue;
      } else {
        return serializer.read(rawValue);
      }
    } catch (e2) {
      onError(e2);
    } finally {
      resumeWatch();
    }
  }
  function update(event) {
    if (event && event.key !== key)
      return;
    data.value = read2(event);
  }
}
function useCycleList(list, options2) {
  var _a2;
  const state = shallowRef((_a2 = options2 == null ? void 0 : options2.initialValue) != null ? _a2 : list[0]);
  const index2 = computed({
    get() {
      var _a22;
      let index22 = (options2 == null ? void 0 : options2.getIndexOf) ? options2.getIndexOf(state.value, list) : list.indexOf(state.value);
      if (index22 < 0)
        index22 = (_a22 = options2 == null ? void 0 : options2.fallbackIndex) != null ? _a22 : 0;
      return index22;
    },
    set(v2) {
      set(v2);
    }
  });
  function set(i2) {
    const length = list.length;
    const index22 = (i2 % length + length) % length;
    const value = list[index22];
    state.value = value;
    return value;
  }
  function shift(delta = 1) {
    return set(index2.value + delta);
  }
  function next(n2 = 1) {
    return shift(n2);
  }
  function prev(n2 = 1) {
    return shift(-n2);
  }
  return {
    state,
    index: index2,
    next,
    prev
  };
}
function usePermission(permissionDesc, options2 = {}) {
  const {
    controls = false,
    navigator: navigator2 = defaultNavigator
  } = options2;
  const isSupported = useSupported(() => navigator2 && "permissions" in navigator2);
  let permissionStatus;
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const state = ref();
  const onChange = () => {
    if (permissionStatus)
      state.value = permissionStatus.state;
  };
  const query = createSingletonPromise(async () => {
    if (!isSupported.value)
      return;
    if (!permissionStatus) {
      try {
        permissionStatus = await navigator2.permissions.query(desc);
        useEventListener(permissionStatus, "change", onChange);
        onChange();
      } catch (e2) {
        state.value = "prompt";
      }
    }
    return permissionStatus;
  });
  query();
  if (controls) {
    return {
      state,
      isSupported,
      query
    };
  } else {
    return state;
  }
}
function useDevicesList(options2 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    requestPermissions = false,
    constraints = { audio: true, video: true },
    onUpdated
  } = options2;
  const devices2 = ref([]);
  const videoInputs = computed(() => devices2.value.filter((i2) => i2.kind === "videoinput"));
  const audioInputs = computed(() => devices2.value.filter((i2) => i2.kind === "audioinput"));
  const audioOutputs = computed(() => devices2.value.filter((i2) => i2.kind === "audiooutput"));
  const isSupported = useSupported(() => navigator2 && navigator2.mediaDevices && navigator2.mediaDevices.enumerateDevices);
  const permissionGranted = ref(false);
  async function update() {
    if (!isSupported.value)
      return;
    devices2.value = await navigator2.mediaDevices.enumerateDevices();
    onUpdated == null ? void 0 : onUpdated(devices2.value);
  }
  async function ensurePermissions() {
    if (!isSupported.value)
      return false;
    if (permissionGranted.value)
      return true;
    const { state, query } = usePermission("camera", { controls: true });
    await query();
    if (state.value !== "granted") {
      const stream = await navigator2.mediaDevices.getUserMedia(constraints);
      stream.getTracks().forEach((t2) => t2.stop());
      update();
      permissionGranted.value = true;
    } else {
      permissionGranted.value = true;
    }
    return permissionGranted.value;
  }
  if (isSupported.value) {
    if (requestPermissions)
      ensurePermissions();
    useEventListener(navigator2.mediaDevices, "devicechange", update);
    update();
  }
  return {
    devices: devices2,
    ensurePermissions,
    permissionGranted,
    videoInputs,
    audioInputs,
    audioOutputs,
    isSupported
  };
}
function useRafFn(fn, options2 = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow
  } = options2;
  const isActive = ref(false);
  let rafId = null;
  function loop() {
    if (!isActive.value || !window2)
      return;
    fn();
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      loop();
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useMouse(options2 = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow,
    eventFilter
  } = options2;
  const x2 = ref(initialValue.x);
  const y2 = ref(initialValue.y);
  const sourceType = ref(null);
  const mouseHandler = (event) => {
    if (type === "page") {
      x2.value = event.pageX;
      y2.value = event.pageY;
    } else if (type === "client") {
      x2.value = event.clientX;
      y2.value = event.clientY;
    }
    sourceType.value = "mouse";
  };
  const reset = () => {
    x2.value = initialValue.x;
    y2.value = initialValue.y;
  };
  const touchHandler = (event) => {
    if (event.touches.length > 0) {
      const touch2 = event.touches[0];
      if (type === "page") {
        x2.value = touch2.pageX;
        y2.value = touch2.pageY;
      } else if (type === "client") {
        x2.value = touch2.clientX;
        y2.value = touch2.clientY;
      }
      sourceType.value = "touch";
    }
  };
  const mouseHandlerWrapper = (event) => {
    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});
  };
  const touchHandlerWrapper = (event) => {
    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});
  };
  if (window2) {
    useEventListener(window2, "mousemove", mouseHandlerWrapper, { passive: true });
    useEventListener(window2, "dragover", mouseHandlerWrapper, { passive: true });
    if (touch) {
      useEventListener(window2, "touchstart", touchHandlerWrapper, { passive: true });
      useEventListener(window2, "touchmove", touchHandlerWrapper, { passive: true });
      if (resetOnTouchEnds)
        useEventListener(window2, "touchend", reset, { passive: true });
    }
  }
  return {
    x: x2,
    y: y2,
    sourceType
  };
}
function useMouseInElement(target, options2 = {}) {
  const {
    handleOutside = true,
    window: window2 = defaultWindow
  } = options2;
  const { x: x2, y: y2, sourceType } = useMouse(options2);
  const targetRef = ref(target != null ? target : window2 == null ? void 0 : window2.document.body);
  const elementX = ref(0);
  const elementY = ref(0);
  const elementPositionX = ref(0);
  const elementPositionY = ref(0);
  const elementHeight = ref(0);
  const elementWidth = ref(0);
  const isOutside = ref(true);
  let stop = () => {
  };
  if (window2) {
    stop = watch([targetRef, x2, y2], () => {
      const el = unrefElement(targetRef);
      if (!el)
        return;
      const {
        left,
        top,
        width,
        height
      } = el.getBoundingClientRect();
      elementPositionX.value = left + window2.pageXOffset;
      elementPositionY.value = top + window2.pageYOffset;
      elementHeight.value = height;
      elementWidth.value = width;
      const elX = x2.value - elementPositionX.value;
      const elY = y2.value - elementPositionY.value;
      isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;
      if (handleOutside || !isOutside.value) {
        elementX.value = elX;
        elementY.value = elY;
      }
    }, { immediate: true });
  }
  return {
    x: x2,
    y: y2,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop
  };
}
function useMousePressed(options2 = {}) {
  const {
    touch = true,
    drag = true,
    initialValue = false,
    window: window2 = defaultWindow
  } = options2;
  const pressed = ref(initialValue);
  const sourceType = ref(null);
  if (!window2) {
    return {
      pressed,
      sourceType
    };
  }
  const onPressed = (srcType) => () => {
    pressed.value = true;
    sourceType.value = srcType;
  };
  const onReleased = () => {
    pressed.value = false;
    sourceType.value = null;
  };
  const target = computed(() => unrefElement(options2.target) || window2);
  useEventListener(target, "mousedown", onPressed("mouse"), { passive: true });
  useEventListener(window2, "mouseleave", onReleased, { passive: true });
  useEventListener(window2, "mouseup", onReleased, { passive: true });
  if (drag) {
    useEventListener(target, "dragstart", onPressed("mouse"), { passive: true });
    useEventListener(window2, "drop", onReleased, { passive: true });
    useEventListener(window2, "dragend", onReleased, { passive: true });
  }
  if (touch) {
    useEventListener(target, "touchstart", onPressed("touch"), { passive: true });
    useEventListener(window2, "touchend", onReleased, { passive: true });
    useEventListener(window2, "touchcancel", onReleased, { passive: true });
  }
  return {
    pressed,
    sourceType
  };
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop))
      __defNormalProp$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b2)) {
      if (__propIsEnum$1.call(b2, prop))
        __defNormalProp$1(a2, prop, b2[prop]);
    }
  return a2;
};
function useTimestamp(options2 = {}) {
  const {
    controls: exposeControls = false,
    offset = 0,
    immediate = true,
    interval: interval2 = "requestAnimationFrame"
  } = options2;
  const ts = ref(timestamp$1() + offset);
  const update = () => ts.value = timestamp$1() + offset;
  const controls = interval2 === "requestAnimationFrame" ? useRafFn(update, { immediate }) : useIntervalFn(update, interval2, { immediate });
  if (exposeControls) {
    return __spreadValues$1({
      timestamp: ts
    }, controls);
  } else {
    return ts;
  }
}
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
__spreadValues({
  linear: identity
}, _TransitionPresets);
function useClamp(value, min, max) {
  const _value = ref(value);
  return computed({
    get() {
      return _value.value = clamp(_value.value, resolveUnref(min), resolveUnref(max));
    },
    set(value2) {
      _value.value = clamp(value2, resolveUnref(min), resolveUnref(max));
    }
  });
}
const currentCamera = useStorage("cast-camera", "default");
const currentMic = useStorage("cast-mic", "default");
const showRecordingDialog = ref();
const recordingName = ref("");
const recordCamera = ref(true);
const mimeType = useStorage("slidev-record-mimetype", "video/webm");
const mimeExtMap = {
  "video/webm": "webm",
  "video/webm;codecs=h264": "mp4",
  "video/x-matroska;codecs=avc1": "mkv"
};
function getFilename(media, mimeType2) {
  const d2 = new Date();
  const pad = (v2) => `${v2}`.padStart(2, "0");
  const date = `${pad(d2.getMonth() + 1)}${pad(d2.getDate())}-${pad(d2.getHours())}${pad(d2.getMinutes())}`;
  const ext = mimeType2 ? mimeExtMap[mimeType2] : "webm";
  return `${[date, media, recordingName.value].filter((el) => !!el).join("-")}.${ext}`;
}
function getSupportedMimeTypes() {
  if (MediaRecorder && typeof (MediaRecorder == null ? void 0 : MediaRecorder.isTypeSupported) === "function") {
    return Object.keys(mimeExtMap).filter((mime) => MediaRecorder.isTypeSupported(mime));
  }
  return [];
}
const fileNames = reactive({
  screen: computed(() => getFilename("screen", mimeType.value)),
  camera: computed(() => getFilename("camera", mimeType.value))
});
const {
  devices,
  videoInputs: cameras,
  audioInputs: microphones,
  ensurePermissions: ensureDevicesListPermissions
} = useDevicesList({
  onUpdated: function() {
    var _a2, _b;
    if (currentCamera.value !== "none") {
      if (!cameras.value.find((i2) => i2.deviceId === currentCamera.value))
        currentCamera.value = ((_a2 = cameras.value[0]) == null ? void 0 : _a2.deviceId) || "default";
    }
    if (currentMic.value !== "none") {
      if (!microphones.value.find((i2) => i2.deviceId === currentMic.value))
        currentMic.value = ((_b = microphones.value[0]) == null ? void 0 : _b.deviceId) || "default";
    }
  }
});
function download(name2, url) {
  const a2 = document.createElement("a");
  a2.setAttribute("href", url);
  a2.setAttribute("download", name2);
  document.body.appendChild(a2);
  a2.click();
  document.body.removeChild(a2);
}
function useRecording() {
  const recording2 = ref(false);
  const recordingStartedAt = ref();
  const timestamp2 = useTimestamp();
  watch(recording2, (r2) => r2 ? recordingStartedAt.value = Date.now() : recordingStartedAt.value = null);
  const recordingTime = computed(() => {
    if (!recordingStartedAt.value)
      return 0;
    return timestamp2.value - recordingStartedAt.value;
  });
  const showAvatar = ref(false);
  const recorderCamera = shallowRef();
  const recorderSlides = shallowRef();
  const streamCamera = shallowRef();
  const streamCapture = shallowRef();
  const streamSlides = shallowRef();
  const config = {
    type: "video",
    bitsPerSecond: 4 * 256 * 8 * 1024,
    timeSlice: 24 * 60 * 60 * 1e3
  };
  async function toggleAvatar() {
    if (currentCamera.value === "none")
      return;
    if (showAvatar.value) {
      showAvatar.value = false;
      if (!recording2.value)
        closeStream(streamCamera);
    } else {
      await startCameraStream();
      if (streamCamera.value)
        showAvatar.value = !!streamCamera.value;
    }
  }
  async function startCameraStream() {
    await ensureDevicesListPermissions();
    await nextTick();
    if (!streamCamera.value) {
      if (currentCamera.value === "none" && currentMic.value === "none")
        return;
      streamCamera.value = await navigator.mediaDevices.getUserMedia({
        video: currentCamera.value === "none" || recordCamera.value !== true ? false : {
          deviceId: currentCamera.value
        },
        audio: currentMic.value === "none" ? false : {
          deviceId: currentMic.value
        }
      });
    }
  }
  watch(currentCamera, async (v2) => {
    if (v2 === "none") {
      closeStream(streamCamera);
    } else {
      if (recording2.value)
        return;
      if (streamCamera.value) {
        closeStream(streamCamera);
        await startCameraStream();
      }
    }
  });
  async function startRecording(customConfig) {
    var _a2;
    await ensureDevicesListPermissions();
    const { default: Recorder2 } = await import("./RecordRTC.js").then(function(n2) {
      return n2.R;
    });
    await startCameraStream();
    streamCapture.value = await navigator.mediaDevices.getDisplayMedia({
      video: {
        frameRate: 30,
        width: 3840,
        height: 2160,
        cursor: "motion",
        resizeMode: "crop-and-scale"
      }
    });
    streamCapture.value.addEventListener("inactive", stopRecording);
    streamSlides.value = new MediaStream();
    streamCapture.value.getVideoTracks().forEach((videoTrack) => streamSlides.value.addTrack(videoTrack));
    Object.assign(config, customConfig);
    if (streamCamera.value) {
      streamSlides.value.addTrack((_a2 = master.stream.stream.getAudioTracks()) == null ? void 0 : _a2[0]);
      recorderCamera.value = new Recorder2(streamCamera.value, config);
      recorderCamera.value.startRecording();
    }
    recorderSlides.value = new Recorder2(streamSlides.value, config);
    recorderSlides.value.startRecording();
    recording2.value = true;
  }
  async function stopRecording() {
    var _a2, _b;
    recording2.value = false;
    (_a2 = recorderCamera.value) == null ? void 0 : _a2.stopRecording(() => {
      if (recordCamera.value) {
        const blob = recorderCamera.value.getBlob();
        const url = URL.createObjectURL(blob);
        download(getFilename("camera", config.mimeType), url);
        window.URL.revokeObjectURL(url);
      }
      recorderCamera.value = void 0;
      if (!showAvatar.value)
        closeStream(streamCamera);
    });
    (_b = recorderSlides.value) == null ? void 0 : _b.stopRecording(() => {
      const blob = recorderSlides.value.getBlob();
      const url = URL.createObjectURL(blob);
      download(getFilename("screen", config.mimeType), url);
      window.URL.revokeObjectURL(url);
      closeStream(streamCapture);
      closeStream(streamSlides);
      recorderSlides.value = void 0;
    });
  }
  function closeStream(stream) {
    const s2 = stream.value;
    if (!s2)
      return;
    s2.getTracks().forEach((i2) => {
      i2.stop();
      s2.removeTrack(i2);
    });
    stream.value = void 0;
  }
  function toggleRecording() {
    if (recording2.value)
      stopRecording();
    else
      startRecording();
  }
  useEventListener("beforeunload", (event) => {
    if (!recording2.value)
      return;
    if (confirm("Recording is not saved yet, do you want to leave?"))
      return;
    event.preventDefault();
    event.returnValue = "";
  });
  return {
    recording: recording2,
    recordingTime,
    showAvatar,
    toggleRecording,
    startRecording,
    stopRecording,
    toggleAvatar,
    recorderCamera,
    recorderSlides,
    streamCamera,
    streamCapture,
    streamSlides
  };
}
const cast = useRecording();
let recorder;
const recording = ref(false);
const toggled = useLastChanged(recording);
const timestamp = useTimestamp();
const duration = computed(() => timestamp.value - toggled.value);
const record = {
  start() {
    if (!recorder)
      useRecorder();
    recorder.start();
    recording.value = true;
  },
  async stop() {
    recording.value = false;
    const rec = await recorder.stop();
    const url = URL.createObjectURL(rec);
    const anchor = document.createElement("a");
    anchor.download = getFilename("rec");
    anchor.href = url;
    anchor.click();
  }
};
function useRecorder() {
  if (!recorder) {
    recorder = new Recorder();
  }
  return { recorder, record, recording, toggled, duration };
}
const audio = reactive({
  initiated: false,
  mute: useStorage("mute", false),
  volume: useClamp(useStorage("main-vol", 1), 0, 2),
  meter: 0
});
const master = shallowReactive({});
const channels = shallowReactive({});
function useAudio() {
  if (!audio.initiated) {
    start$1();
    const { recorder: recorder2 } = useRecorder();
    master.stream = context.createMediaStreamDestination();
    master.meter = new Meter().toDestination();
    master.meter.normalRange = true;
    master.meter.connect(master.stream);
    master.meter.connect(recorder2);
    useRafFn(() => {
      audio.meter = master.meter.getValue();
    });
    master.limiter = new Limiter(-18).connect(master.meter);
    master.reverb = new Reverb({
      decay: 1,
      wet: 0.5
    }).connect(master.meter);
    master.limiter.connect(master.reverb);
    watchEffect(() => {
      getDestination().mute = audio.mute;
    });
    watchEffect(() => {
      getDestination().volume.targetRampTo(gainToDb(audio.volume), 0.1);
    });
    audio.initiated = true;
  }
  return { audio, master, channels };
}
function createChannel$1(title = (Math.random() * 1e3).toFixed(0), options2) {
  const { master: master2 } = useAudio();
  const channel = new Limiter(options2).connect(master2.limiter);
  channels[title] = channel;
  return { channel };
}
function initGetUserMedia() {
  window.AudioContext = window.AudioContext || window.webkitAudioContext;
  if (!window.AudioContext) {
    return alert("AudioContext not supported");
  }
  if (navigator.mediaDevices === void 0) {
    navigator.mediaDevices = {};
  }
  if (navigator.mediaDevices.getUserMedia === void 0) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
      if (!getUserMedia) {
        alert("getUserMedia is not implemented in this browser");
      }
      return new Promise(function(resolve, reject) {
        getUserMedia.call(navigator, constraints, resolve, reject);
      });
    };
  }
}
const midiA = 69;
function pitchNoteOctave(pitch) {
  return {
    note: pitch > 0 ? pitch % 12 : 12 + pitch % 12,
    octave: Math.floor(pitch / 12) + 4
  };
}
function pitchFreq(pitch = 0, octave2 = 3, middleA = 440, tuning = "equal") {
  let hz = 0;
  const justCents = [0, 112, 204, 316, 386, 498, 590, 702, 814, 884, 1017, 1088];
  if (tuning == "equal") {
    hz = Number(middleA * Math.pow(2, octave2 - 3 + pitch / 12));
  }
  if (tuning == "just") {
    let diff = Number(Math.pow(Math.pow(2, 1 / 1200), justCents[pitch]));
    hz = Number(middleA * Math.pow(2, octave2 - 4) * diff);
  }
  return hz;
}
function pitchColor(pitch = 0, octave2, velocity = 1, alpha = 1) {
  octave2 = octave2 || Math.floor(pitch / 12) + 4;
  return `hsla(${pitch % 12 * 30},${velocity * 100}%,${Math.abs(octave2 + 2) * 8}%,${alpha})`;
}
function freqColor$1(freq2) {
  return pitchColor(freqPitch(freq2));
}
function freqPitch(freq2, middleA = 440) {
  return 12 * (Math.log(freq2 / middleA) / Math.log(2));
}
function isInChroma(chroma2, tonic, note2) {
  return chroma2.split("")[(24 + note2 - tonic) % 12] == "1";
}
function getCircleCoord(n2 = 0, total = 12, radius = 35, width = 100) {
  let angle = (n2 - total / 4) / (total / 2) * Math.PI;
  let x2 = radius * Math.cos(angle) + width / 2;
  let y2 = radius * Math.sin(angle) + width / 2;
  return { x: x2, y: y2 };
}
function rotateArray(arr, count = 1) {
  return [...arr.slice(count, arr.length), ...arr.slice(0, count)];
}
function clampNum(main, delta, min = 0, max = 100) {
  return Math.max(min, Math.min(Number(main) + Number(delta), max));
}
function getCents$1(frequency, pitch) {
  return Math.floor(1200 * Math.log(frequency / getStandardFrequency$1(pitch)) / Math.log(2));
}
function getStandardFrequency$1(pitch, middleA = 440) {
  return middleA * Math.pow(2, (pitch - 69) / 12);
}
class e$6 {
  constructor(e2 = false) {
    this.eventMap = {}, this.eventsSuspended = e2 == 1;
  }
  addListener(n2, s2, r2 = {}) {
    if (typeof n2 == "string" && n2.length < 1 || n2 instanceof String && n2.length < 1 || typeof n2 != "string" && !(n2 instanceof String) && n2 !== e$6.ANY_EVENT)
      throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
    if (typeof s2 != "function")
      throw new TypeError("The callback must be a function.");
    const a2 = new t$6(n2, this, s2, r2);
    return this.eventMap[n2] || (this.eventMap[n2] = []), r2.prepend ? this.eventMap[n2].unshift(a2) : this.eventMap[n2].push(a2), a2;
  }
  addOneTimeListener(e2, t2, n2 = {}) {
    n2.remaining = 1, this.addListener(e2, t2, n2);
  }
  static get ANY_EVENT() {
    return Symbol.for("Any event");
  }
  hasListener(n2, s2) {
    if (n2 === void 0)
      return !!(this.eventMap[e$6.ANY_EVENT] && this.eventMap[e$6.ANY_EVENT].length > 0) || Object.entries(this.eventMap).some(([, e2]) => e2.length > 0);
    if (this.eventMap[n2] && this.eventMap[n2].length > 0) {
      if (s2 instanceof t$6) {
        return this.eventMap[n2].filter((e2) => e2 === s2).length > 0;
      }
      if (typeof s2 == "function") {
        return this.eventMap[n2].filter((e2) => e2.callback === s2).length > 0;
      }
      return s2 == null;
    }
    return false;
  }
  get eventNames() {
    return Object.keys(this.eventMap);
  }
  getListeners(e2) {
    return this.eventMap[e2] || [];
  }
  suspendEvent(e2) {
    this.getListeners(e2).forEach((e3) => {
      e3.suspended = true;
    });
  }
  unsuspendEvent(e2) {
    this.getListeners(e2).forEach((e3) => {
      e3.suspended = false;
    });
  }
  getListenerCount(e2) {
    return this.getListeners(e2).length;
  }
  emit(t2, ...n2) {
    if (typeof t2 != "string" && !(t2 instanceof String))
      throw new TypeError("The 'event' parameter must be a string.");
    if (this.eventsSuspended)
      return;
    let s2 = [], r2 = this.eventMap[e$6.ANY_EVENT] || [];
    return this.eventMap[t2] && (r2 = r2.concat(this.eventMap[t2])), r2.forEach((e2) => {
      if (e2.suspended)
        return;
      let t3 = [...n2];
      Array.isArray(e2.arguments) && (t3 = t3.concat(e2.arguments)), e2.remaining > 0 && (s2.push(e2.callback.apply(e2.context, t3)), e2.count++), --e2.remaining < 1 && e2.remove();
    }), s2;
  }
  removeListener(e2, t2, n2 = {}) {
    if (e2 === void 0)
      return void (this.eventMap = {});
    if (!this.eventMap[e2])
      return;
    let s2 = this.eventMap[e2].filter((e3) => t2 && e3.callback !== t2 || n2.remaining && n2.remaining !== e3.remaining || n2.context && n2.context !== e3.context);
    s2.length ? this.eventMap[e2] = s2 : delete this.eventMap[e2];
  }
  async waitFor(e2, t2 = {}) {
    return t2.duration = parseInt(t2.duration), (isNaN(t2.duration) || t2.duration <= 0) && (t2.duration = 1 / 0), new Promise((n2, s2) => {
      let r2, a2 = this.addListener(e2, () => {
        clearTimeout(r2), n2();
      }, { remaining: 1 });
      t2.duration !== 1 / 0 && (r2 = setTimeout(() => {
        a2.remove(), s2("The duration expired before the event was emitted.");
      }, t2.duration));
    });
  }
  get eventCount() {
    return Object.keys(this.eventMap).length;
  }
}
class t$6 {
  constructor(t2, n2, s2, r2 = {}) {
    if (typeof t2 != "string" && !(t2 instanceof String) && t2 !== e$6.ANY_EVENT)
      throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
    if (!n2)
      throw new ReferenceError("The 'target' parameter is mandatory.");
    if (typeof s2 != "function")
      throw new TypeError("The 'callback' must be a function.");
    r2.arguments === void 0 || Array.isArray(r2.arguments) || (r2.arguments = [r2.arguments]), (r2 = Object.assign({ context: n2, remaining: 1 / 0, arguments: void 0, duration: 1 / 0 }, r2)).duration !== 1 / 0 && setTimeout(() => this.remove(), r2.duration), this.arguments = r2.arguments, this.callback = s2, this.context = r2.context, this.count = 0, this.event = t2, this.remaining = parseInt(r2.remaining) >= 1 ? parseInt(r2.remaining) : 1 / 0, this.suspended = false, this.target = n2;
  }
  remove() {
    this.target.removeListener(this.event, this.callback, { context: this.context, remaining: this.remaining });
  }
}
/**
 * The `Enumerations` class contains enumerations and arrays of elements used throughout the
 * library. All properties are static and should be referenced using the class name. For example:
 * `Enumerations.MIDI_CHANNEL_MESSAGES`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class n$6 {
  static get MIDI_CHANNEL_MESSAGES() {
    return { noteoff: 8, noteon: 9, keyaftertouch: 10, controlchange: 11, programchange: 12, channelaftertouch: 13, pitchbend: 14 };
  }
  static get MIDI_CHANNEL_NUMBERS() {
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
  }
  static get MIDI_CHANNEL_MODE_MESSAGES() {
    return { allsoundoff: 120, resetallcontrollers: 121, localcontrol: 122, allnotesoff: 123, omnimodeoff: 124, omnimodeon: 125, monomodeon: 126, polymodeon: 127 };
  }
  static get MIDI_CONTROL_CHANGE_MESSAGES() {
    return { bankselectcoarse: 0, modulationwheelcoarse: 1, breathcontrollercoarse: 2, controller3: 3, footcontrollercoarse: 4, portamentotimecoarse: 5, dataentrycoarse: 6, volumecoarse: 7, balancecoarse: 8, controller9: 9, pancoarse: 10, expressioncoarse: 11, effectcontrol1coarse: 12, effectcontrol2coarse: 13, controller14: 14, controller15: 15, generalpurposeslider1: 16, generalpurposeslider2: 17, generalpurposeslider3: 18, generalpurposeslider4: 19, controller20: 20, controller21: 21, controller22: 22, controller23: 23, controller24: 24, controller25: 25, controller26: 26, controller27: 27, controller28: 28, controller29: 29, controller30: 30, controller31: 31, bankselectfine: 32, modulationwheelfine: 33, breathcontrollerfine: 34, controller35: 35, footcontrollerfine: 36, portamentotimefine: 37, dataentryfine: 38, volumefine: 39, balancefine: 40, controller41: 41, panfine: 42, expressionfine: 43, effectcontrol1fine: 44, effectcontrol2fine: 45, controller46: 46, controller47: 47, controller48: 48, controller49: 49, controller50: 50, controller51: 51, controller52: 52, controller53: 53, controller54: 54, controller55: 55, controller56: 56, controller57: 57, controller58: 58, controller59: 59, controller60: 60, controller61: 61, controller62: 62, controller63: 63, holdpedal: 64, portamento: 65, sustenutopedal: 66, softpedal: 67, legatopedal: 68, hold2pedal: 69, soundvariation: 70, resonance: 71, soundreleasetime: 72, soundattacktime: 73, brightness: 74, soundcontrol6: 75, soundcontrol7: 76, soundcontrol8: 77, soundcontrol9: 78, soundcontrol10: 79, generalpurposebutton1: 80, generalpurposebutton2: 81, generalpurposebutton3: 82, generalpurposebutton4: 83, controller84: 84, controller85: 85, controller86: 86, controller87: 87, controller88: 88, controller89: 89, controller90: 90, reverblevel: 91, tremololevel: 92, choruslevel: 93, celestelevel: 94, phaserlevel: 95, databuttonincrement: 96, databuttondecrement: 97, nonregisteredparametercoarse: 98, nonregisteredparameterfine: 99, registeredparametercoarse: 100, registeredparameterfine: 101, controller102: 102, controller103: 103, controller104: 104, controller105: 105, controller106: 106, controller107: 107, controller108: 108, controller109: 109, controller110: 110, controller111: 111, controller112: 112, controller113: 113, controller114: 114, controller115: 115, controller116: 116, controller117: 117, controller118: 118, controller119: 119, allsoundoff: 120, resetallcontrollers: 121, localcontrol: 122, allnotesoff: 123, omnimodeoff: 124, omnimodeon: 125, monomodeon: 126, polymodeon: 127 };
  }
  static get MIDI_REGISTERED_PARAMETERS() {
    return { pitchbendrange: [0, 0], channelfinetuning: [0, 1], channelcoarsetuning: [0, 2], tuningprogram: [0, 3], tuningbank: [0, 4], modulationrange: [0, 5], azimuthangle: [61, 0], elevationangle: [61, 1], gain: [61, 2], distanceratio: [61, 3], maximumdistance: [61, 4], maximumdistancegain: [61, 5], referencedistanceratio: [61, 6], panspreadangle: [61, 7], rollangle: [61, 8] };
  }
  static get MIDI_SYSTEM_MESSAGES() {
    return { sysex: 240, timecode: 241, songposition: 242, songselect: 243, tunerequest: 246, tuningrequest: 246, sysexend: 247, clock: 248, start: 250, continue: 251, stop: 252, activesensing: 254, reset: 255, midimessage: 0, unknownsystemmessage: -1 };
  }
  static get CHANNEL_EVENTS() {
    return ["noteoff", "controlchange", "noteon", "keyaftertouch", "programchange", "channelaftertouch", "pitchbend", "allnotesoff", "allsoundoff", "localcontrol", "monomode", "omnimode", "resetallcontrollers", "nrpn", "nrpn-dataentrycoarse", "nrpn-dataentryfine", "nrpn-databuttonincrement", "nrpn-databuttondecrement", "rpn", "rpn-dataentrycoarse", "rpn-dataentryfine", "rpn-databuttonincrement", "rpn-databuttondecrement"];
  }
}
/**
 * The `Note` class represents a single musical note such as `"D3"`, `"G#4"`, `"F-1"`, `"Gb7"`, etc.
 *
 * `Note` objects can be played back on a single channel by calling
 * [`OutputChannel.playNote()`]{@link OutputChannel#playNote} or, on multiple channels of the same
 * output, by calling [`Output.playNote()`]{@link Output#playNote}.
 *
 * The note has [`attack`](#attack) and [`release`](#release) velocities set at `0.5` by default.
 * These can be changed by passing in the appropriate option. It is also possible to set a
 * system-wide default for attack and release velocities by using the
 * [`WebMidi.defaults`](WebMidi#defaults) property.
 *
 * If you prefer to work with raw MIDI values (`0` to `127`), you can use [`rawAttack`](#rawAttack) and
 * [`rawRelease`](#rawRelease) to both get and set the values.
 *
 * The note may have a [`duration`](#duration). If it does, playback will be automatically stopped
 * when the duration has elapsed by sending a `"noteoff"` event. By default, the duration is set to
 * `Infinity`. In this case, it will never stop playing unless explicitly stopped by calling a
 * method such as [`OutputChannel.stopNote()`]{@link OutputChannel#stopNote},
 * [`Output.stopNote()`]{@link Output#stopNote} or similar.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class s$2 {
  constructor(e2, t2 = {}) {
    this.duration = d$3.defaults.note.duration, this.attack = d$3.defaults.note.attack, this.release = d$3.defaults.note.release, t2.duration != null && (this.duration = t2.duration), t2.attack != null && (this.attack = t2.attack), t2.rawAttack != null && (this.attack = r$6.from7bitToFloat(t2.rawAttack)), t2.release != null && (this.release = t2.release), t2.rawRelease != null && (this.release = r$6.from7bitToFloat(t2.rawRelease)), Number.isInteger(e2) ? this.identifier = r$6.toNoteIdentifier(e2) : this.identifier = e2;
  }
  get identifier() {
    return this._name + (this._accidental || "") + this._octave;
  }
  set identifier(e2) {
    const t2 = r$6.getNoteDetails(e2);
    if (d$3.validation && !e2)
      throw new Error("Invalid note identifier");
    this._name = t2.name, this._accidental = t2.accidental, this._octave = t2.octave;
  }
  get name() {
    return this._name;
  }
  set name(e2) {
    if (d$3.validation && (e2 = e2.toUpperCase(), !["C", "D", "E", "F", "G", "A", "B"].includes(e2)))
      throw new Error("Invalid name value");
    this._name = e2;
  }
  get accidental() {
    return this._accidental;
  }
  set accidental(e2) {
    if (d$3.validation && (e2 = e2.toLowerCase(), !["#", "##", "b", "bb"].includes(e2)))
      throw new Error("Invalid accidental value");
    this._accidental = e2;
  }
  get octave() {
    return this._octave;
  }
  set octave(e2) {
    if (d$3.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new Error("Invalid octave value");
    this._octave = e2;
  }
  get duration() {
    return this._duration;
  }
  set duration(e2) {
    if (d$3.validation && (e2 = parseFloat(e2), isNaN(e2) || e2 === null || e2 < 0))
      throw new RangeError("Invalid duration value.");
    this._duration = e2;
  }
  get attack() {
    return this._attack;
  }
  set attack(e2) {
    if (d$3.validation && (e2 = parseFloat(e2), isNaN(e2) || !(e2 >= 0 && e2 <= 1)))
      throw new RangeError("Invalid attack value.");
    this._attack = e2;
  }
  get release() {
    return this._release;
  }
  set release(e2) {
    if (d$3.validation && (e2 = parseFloat(e2), isNaN(e2) || !(e2 >= 0 && e2 <= 1)))
      throw new RangeError("Invalid release value.");
    this._release = e2;
  }
  get rawAttack() {
    return r$6.fromFloatTo7Bit(this._attack);
  }
  set rawAttack(e2) {
    this._attack = r$6.from7bitToFloat(e2);
  }
  get rawRelease() {
    return r$6.fromFloatTo7Bit(this._release);
  }
  set rawRelease(e2) {
    this._release = r$6.from7bitToFloat(e2);
  }
  get number() {
    return r$6.toNoteNumber(this.identifier);
  }
  getOffsetNumber(e2 = 0, t2 = 0) {
    return d$3.validation && (e2 = parseInt(e2) || 0, t2 = parseInt(t2) || 0), Math.min(Math.max(this.number + 12 * e2 + t2, 0), 127);
  }
}
/**
 * The `Utilities` class contains general-purpose utility methods. All methods are static and
 * should be called using the class name. For example: `Utilities.getNoteDetails("C4")`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class r$6 {
  static toNoteNumber(e2, t2 = 0) {
    if (t2 = t2 == null ? 0 : parseInt(t2), isNaN(t2))
      throw new RangeError("Invalid 'octaveOffset' value");
    typeof e2 != "string" && (e2 = "");
    const n2 = this.getNoteDetails(e2);
    if (!n2)
      throw new TypeError("Invalid note identifier");
    let s2 = 12 * (n2.octave + 1 + t2);
    if (s2 += { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 }[n2.name], n2.accidental && (n2.accidental.startsWith("b") ? s2 -= n2.accidental.length : s2 += n2.accidental.length), s2 < 0 || s2 > 127)
      throw new RangeError("Invalid octaveOffset value");
    return s2;
  }
  static getNoteDetails(e2) {
    Number.isInteger(e2) && (e2 = this.toNoteIdentifier(e2));
    const t2 = e2.match(/^([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)$/i);
    if (!t2)
      throw new TypeError("Invalid note identifier");
    const n2 = t2[1].toUpperCase(), s2 = parseInt(t2[3]);
    let r2 = t2[2].toLowerCase();
    return r2 = r2 === "" ? void 0 : r2, { accidental: r2, identifier: n2 + (r2 || "") + s2, name: n2, octave: s2 };
  }
  static sanitizeChannels(e2) {
    let t2;
    if (this.validation) {
      if (e2 === "all")
        t2 = ["all"];
      else if (e2 === "none")
        return [];
    }
    return t2 = Array.isArray(e2) ? e2 : [e2], t2.indexOf("all") > -1 && (t2 = n$6.MIDI_CHANNEL_NUMBERS), t2.map(function(e3) {
      return parseInt(e3);
    }).filter(function(e3) {
      return e3 >= 1 && e3 <= 16;
    });
  }
  static toTimestamp(e2) {
    let t2 = false;
    const n2 = parseFloat(e2);
    return !isNaN(n2) && (typeof e2 == "string" && e2.substring(0, 1) === "+" ? n2 >= 0 && (t2 = d$3.time + n2) : n2 >= 0 && (t2 = n2), t2);
  }
  static guessNoteNumber(e2, t2) {
    t2 = parseInt(t2) || 0;
    let n2 = false;
    if (Number.isInteger(e2) && e2 >= 0 && e2 <= 127)
      n2 = parseInt(e2);
    else if (parseInt(e2) >= 0 && parseInt(e2) <= 127)
      n2 = parseInt(e2);
    else if (typeof e2 == "string" || e2 instanceof String)
      try {
        n2 = this.toNoteNumber(e2.trim(), t2);
      } catch (e3) {
        return false;
      }
    return n2;
  }
  static toNoteIdentifier(e2, t2) {
    if (e2 = parseInt(e2), isNaN(e2) || e2 < 0 || e2 > 127)
      throw new RangeError("Invalid note number");
    if (t2 = t2 == null ? 0 : parseInt(t2), isNaN(t2))
      throw new RangeError("Invalid octaveOffset value");
    const n2 = Math.floor(e2 / 12 - 1) + t2;
    return ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"][e2 % 12] + n2.toString();
  }
  static buildNote(e2, t2 = {}) {
    if (t2.octaveOffset = parseInt(t2.octaveOffset) || 0, e2 instanceof s$2)
      return e2;
    let n2 = this.guessNoteNumber(e2, t2.octaveOffset);
    if (n2 === false)
      throw new TypeError(`The input could not be parsed as a note (${e2})`);
    return t2.octaveOffset = void 0, new s$2(n2, t2);
  }
  static buildNoteArray(e2, t2 = {}) {
    let n2 = [];
    return Array.isArray(e2) || (e2 = [e2]), e2.forEach((e3) => {
      n2.push(this.buildNote(e3, t2));
    }), n2;
  }
  static from7bitToFloat(e2) {
    return e2 === 1 / 0 && (e2 = 127), e2 = parseInt(e2) || 0, Math.min(Math.max(e2 / 127, 0), 1);
  }
  static fromFloatTo7Bit(e2) {
    return e2 === 1 / 0 && (e2 = 1), e2 = parseFloat(e2) || 0, Math.min(Math.max(Math.round(127 * e2), 0), 127);
  }
  static fromMsbLsbToFloat(e2, t2 = 0) {
    d$3.validation && (e2 = Math.min(Math.max(parseInt(e2) || 0, 0), 127), t2 = Math.min(Math.max(parseInt(t2) || 0, 0), 127));
    const n2 = ((e2 << 7) + t2) / 16383;
    return Math.min(Math.max(n2, 0), 1);
  }
  static fromFloatToMsbLsb(e2) {
    d$3.validation && (e2 = Math.min(Math.max(parseFloat(e2) || 0, 0), 1));
    const t2 = Math.round(16383 * e2);
    return { msb: t2 >> 7, lsb: 127 & t2 };
  }
  static offsetNumber(e2, t2 = 0, n2 = 0) {
    if (d$3.validation) {
      if (e2 = parseInt(e2), isNaN(e2))
        throw new Error("Invalid note number");
      t2 = parseInt(t2) || 0, n2 = parseInt(n2) || 0;
    }
    return Math.min(Math.max(e2 + 12 * t2 + n2, 0), 127);
  }
  static getPropertyByValue(e2, t2) {
    return Object.keys(e2).find((n2) => e2[n2] === t2);
  }
  static getCcNameByNumber(e2) {
    return r$6.getPropertyByValue(n$6.MIDI_CONTROL_CHANGE_MESSAGES, e2);
  }
  static getChannelModeByNumber(e2) {
    if (!(e2 >= 120 && e2 <= 127))
      return false;
    for (let t2 in n$6.MIDI_CHANNEL_MODE_MESSAGES)
      if (n$6.MIDI_CHANNEL_MODE_MESSAGES.hasOwnProperty(t2) && e2 === n$6.MIDI_CHANNEL_MODE_MESSAGES[t2])
        return t2;
    return false;
  }
  static get isNode() {
    return typeof process != "undefined" && process.versions != null && process.versions.node != null;
  }
  static get isBrowser() {
    return typeof window != "undefined" && window.document !== void 0;
  }
}
/**
 * The `OutputChannel` class represents a single output MIDI channel. `OutputChannel` objects are
 * provided by an [`Output`](Output) port which, itself, is made available by a device. The
 * `OutputChannel` object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `OutputChannel` objects can be found inside the parent output's
 * [`channels`]{@link Output#channels} property.
 *
 * @param {Output} output The [`Output`](Output) this channel belongs to.
 * @param {number} number The MIDI channel number (`1` - `16`).
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
class a$6 extends e$6 {
  constructor(e2, t2) {
    super(), this._output = e2, this._number = t2, this._octaveOffset = 0;
  }
  destroy() {
    this._output = null, this._number = null, this._octaveOffset = 0, this.removeListener();
  }
  send(e2, t2 = { time: 0 }) {
    return this.output.send(e2, t2), this;
  }
  sendKeyAftertouch(e2, t2, s2 = {}) {
    if (d$3.validation) {
      if (s2.useRawValue && (s2.rawValue = s2.useRawValue), isNaN(parseFloat(t2)))
        throw new RangeError("Invalid key aftertouch value.");
      if (s2.rawValue) {
        if (!(t2 >= 0 && t2 <= 127 && Number.isInteger(t2)))
          throw new RangeError("Key aftertouch raw value must be an integer between 0 and 127.");
      } else if (!(t2 >= 0 && t2 <= 1))
        throw new RangeError("Key aftertouch value must be a float between 0 and 1.");
    }
    s2.rawValue || (t2 = r$6.fromFloatTo7Bit(t2));
    const a2 = d$3.octaveOffset + this.output.octaveOffset + this.octaveOffset;
    return Array.isArray(e2) || (e2 = [e2]), r$6.buildNoteArray(e2).forEach((e3) => {
      this.send([(n$6.MIDI_CHANNEL_MESSAGES.keyaftertouch << 4) + (this.number - 1), e3.getOffsetNumber(a2), t2], { time: r$6.toTimestamp(s2.time) });
    }), this;
  }
  sendControlChange(e2, t2, s2 = {}) {
    if (typeof e2 == "string" && (e2 = n$6.MIDI_CONTROL_CHANGE_MESSAGES[e2]), Array.isArray(t2) || (t2 = [t2]), d$3.validation) {
      if (e2 === void 0)
        throw new TypeError("Control change must be identified with a valid name or an integer between 0 and 127.");
      if (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127))
        throw new TypeError("Control change number must be an integer between 0 and 127.");
      if ((t2 = t2.map((e3) => {
        const t3 = Math.min(Math.max(parseInt(e3), 0), 127);
        if (isNaN(t3))
          throw new TypeError("Values must be integers between 0 and 127");
        return t3;
      })).length === 2 && e2 >= 32)
        throw new TypeError("To use a value array, the controller must be between 0 and 31");
    }
    return t2.forEach((a2, i2) => {
      this.send([(n$6.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), e2 + 32 * i2, t2[i2]], { time: r$6.toTimestamp(s2.time) });
    }), this;
  }
  _selectNonRegisteredParameter(e2, t2 = {}) {
    return this.sendControlChange(99, e2[0], t2), this.sendControlChange(98, e2[1], t2), this;
  }
  _deselectRegisteredParameter(e2 = {}) {
    return this.sendControlChange(101, 127, e2), this.sendControlChange(100, 127, e2), this;
  }
  _deselectNonRegisteredParameter(e2 = {}) {
    return this.sendControlChange(101, 127, e2), this.sendControlChange(100, 127, e2), this;
  }
  _selectRegisteredParameter(e2, t2 = {}) {
    return this.sendControlChange(101, e2[0], t2), this.sendControlChange(100, e2[1], t2), this;
  }
  _setCurrentParameter(e2, t2 = {}) {
    return e2 = [].concat(e2), this.sendControlChange(6, e2[0], t2), e2.length < 2 || this.sendControlChange(38, e2[1], t2), this;
  }
  sendRpnDecrement(e2, t2 = {}) {
    if (Array.isArray(e2) || (e2 = n$6.MIDI_REGISTERED_PARAMETERS[e2]), d$3.validation) {
      if (e2 === void 0)
        throw new TypeError("The specified registered parameter is invalid.");
      let t3 = false;
      if (Object.getOwnPropertyNames(n$6.MIDI_REGISTERED_PARAMETERS).forEach((s2) => {
        n$6.MIDI_REGISTERED_PARAMETERS[s2][0] === e2[0] && n$6.MIDI_REGISTERED_PARAMETERS[s2][1] === e2[1] && (t3 = true);
      }), !t3)
        throw new TypeError("The specified registered parameter is invalid.");
    }
    return this._selectRegisteredParameter(e2, t2), this.sendControlChange(97, 0, t2), this._deselectRegisteredParameter(t2), this;
  }
  sendRpnIncrement(e2, t2 = {}) {
    if (Array.isArray(e2) || (e2 = n$6.MIDI_REGISTERED_PARAMETERS[e2]), d$3.validation) {
      if (e2 === void 0)
        throw new TypeError("The specified registered parameter is invalid.");
      let t3 = false;
      if (Object.getOwnPropertyNames(n$6.MIDI_REGISTERED_PARAMETERS).forEach((s2) => {
        n$6.MIDI_REGISTERED_PARAMETERS[s2][0] === e2[0] && n$6.MIDI_REGISTERED_PARAMETERS[s2][1] === e2[1] && (t3 = true);
      }), !t3)
        throw new TypeError("The specified registered parameter is invalid.");
    }
    return this._selectRegisteredParameter(e2, t2), this.sendControlChange(96, 0, t2), this._deselectRegisteredParameter(t2), this;
  }
  playNote(e2, t2 = {}) {
    if (this.sendNoteOn(e2, t2), t2.duration > 0 && isFinite(String(t2.duration).trim() || NaN)) {
      let n2 = { time: (r$6.toTimestamp(t2.time) || d$3.time) + t2.duration, release: t2.release, rawRelease: t2.rawRelease };
      this.sendNoteOff(e2, n2);
    }
    return this;
  }
  sendNoteOff(e2, t2 = {}) {
    if (d$3.validation) {
      if (t2.rawRelease != null && !(t2.rawRelease >= 0 && t2.rawRelease <= 127))
        throw new RangeError("The 'rawRelease' option must be an integer between 0 and 127");
      if (t2.release != null && !(t2.release >= 0 && t2.release <= 1))
        throw new RangeError("The 'release' option must be an number between 0 and 1");
      t2.rawVelocity && (t2.rawRelease = t2.velocity, console.warn("The 'rawVelocity' option is deprecated. Use 'rawRelease' instead.")), t2.velocity && (t2.release = t2.velocity, console.warn("The 'velocity' option is deprecated. Use 'attack' instead."));
    }
    let s2 = 64;
    t2.rawRelease != null ? s2 = t2.rawRelease : isNaN(t2.release) || (s2 = Math.round(127 * t2.release));
    const a2 = d$3.octaveOffset + this.output.octaveOffset + this.octaveOffset;
    return r$6.buildNoteArray(e2, { rawRelease: parseInt(s2) }).forEach((e3) => {
      this.send([(n$6.MIDI_CHANNEL_MESSAGES.noteoff << 4) + (this.number - 1), e3.getOffsetNumber(a2), e3.rawRelease], { time: r$6.toTimestamp(t2.time) });
    }), this;
  }
  stopNote(e2, t2 = {}) {
    return this.sendNoteOff(e2, t2);
  }
  sendNoteOn(e2, t2 = {}) {
    if (d$3.validation) {
      if (t2.rawAttack != null && !(t2.rawAttack >= 0 && t2.rawAttack <= 127))
        throw new RangeError("The 'rawAttack' option must be an integer between 0 and 127");
      if (t2.attack != null && !(t2.attack >= 0 && t2.attack <= 1))
        throw new RangeError("The 'attack' option must be an number between 0 and 1");
      t2.rawVelocity && (t2.rawAttack = t2.velocity, t2.rawRelease = t2.release, console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' or 'rawRelease'.")), t2.velocity && (t2.attack = t2.velocity, console.warn("The 'velocity' option is deprecated. Use 'attack' instead."));
    }
    let s2 = 64;
    t2.rawAttack != null ? s2 = t2.rawAttack : isNaN(t2.attack) || (s2 = Math.round(127 * t2.attack));
    const a2 = d$3.octaveOffset + this.output.octaveOffset + this.octaveOffset;
    return r$6.buildNoteArray(e2, { rawAttack: s2 }).forEach((e3) => {
      this.send([(n$6.MIDI_CHANNEL_MESSAGES.noteon << 4) + (this.number - 1), e3.getOffsetNumber(a2), e3.rawAttack], { time: r$6.toTimestamp(t2.time) });
    }), this;
  }
  sendChannelMode(e2, t2 = 0, s2 = {}) {
    if (typeof e2 == "string" && (e2 = n$6.MIDI_CHANNEL_MODE_MESSAGES[e2]), d$3.validation) {
      if (e2 === void 0)
        throw new TypeError("Invalid channel mode message name or number.");
      if (isNaN(e2) || !(e2 >= 120 && e2 <= 127))
        throw new TypeError("Invalid channel mode message number.");
      if (isNaN(parseInt(t2)) || t2 < 0 || t2 > 127)
        throw new RangeError("Value must be an integer between 0 and 127.");
    }
    return this.send([(n$6.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), e2, t2], { time: r$6.toTimestamp(s2.time) }), this;
  }
  sendOmniMode(e2, t2 = {}) {
    return e2 === void 0 || e2 ? this.sendChannelMode("omnimodeon", 0, t2) : this.sendChannelMode("omnimodeoff", 0, t2), this;
  }
  sendChannelAftertouch(e2, t2 = {}) {
    if (d$3.validation) {
      if (isNaN(parseFloat(e2)))
        throw new RangeError("Invalid channel aftertouch value.");
      if (t2.rawValue) {
        if (!(e2 >= 0 && e2 <= 127 && Number.isInteger(e2)))
          throw new RangeError("Channel aftertouch raw value must be an integer between 0 and 127.");
      } else if (!(e2 >= 0 && e2 <= 1))
        throw new RangeError("Channel aftertouch value must be a float between 0 and 1.");
    }
    return this.send([(n$6.MIDI_CHANNEL_MESSAGES.channelaftertouch << 4) + (this.number - 1), Math.round(127 * e2)], { time: r$6.toTimestamp(t2.time) }), this;
  }
  sendMasterTuning(e2, t2 = {}) {
    if (e2 = parseFloat(e2) || 0, d$3.validation && !(e2 > -65 && e2 < 64))
      throw new RangeError("The value must be a decimal number larger than -65 and smaller than 64.");
    let n2 = Math.floor(e2) + 64, s2 = e2 - Math.floor(e2);
    s2 = Math.round((s2 + 1) / 2 * 16383);
    let r2 = s2 >> 7 & 127, a2 = 127 & s2;
    return this.sendRpnValue("channelcoarsetuning", n2, t2), this.sendRpnValue("channelfinetuning", [r2, a2], t2), this;
  }
  sendModulationRange(e2, t2, n2 = {}) {
    if (d$3.validation) {
      if (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127))
        throw new RangeError("The semitones value must be an integer between 0 and 127.");
      if (!(t2 == null || Number.isInteger(t2) && t2 >= 0 && t2 <= 127))
        throw new RangeError("If specified, the cents value must be an integer between 0 and 127.");
    }
    return t2 >= 0 && t2 <= 127 || (t2 = 0), this.sendRpnValue("modulationrange", [e2, t2], n2), this;
  }
  sendNrpnValue(e2, t2, n2 = {}) {
    if (t2 = [].concat(t2), d$3.validation) {
      if (!Array.isArray(e2) || !Number.isInteger(e2[0]) || !Number.isInteger(e2[1]))
        throw new TypeError("The specified NRPN is invalid.");
      if (!(e2[0] >= 0 && e2[0] <= 127))
        throw new RangeError("The first byte of the NRPN must be between 0 and 127.");
      if (!(e2[1] >= 0 && e2[1] <= 127))
        throw new RangeError("The second byte of the NRPN must be between 0 and 127.");
      t2.forEach((e3) => {
        if (!(e3 >= 0 && e3 <= 127))
          throw new RangeError("The data bytes of the NRPN must be between 0 and 127.");
      });
    }
    return this._selectNonRegisteredParameter(e2, n2), this._setCurrentParameter(t2, n2), this._deselectNonRegisteredParameter(n2), this;
  }
  sendPitchBend(e2, t2 = {}) {
    if (d$3.validation)
      if (t2.rawValue && Array.isArray(e2)) {
        if (!(e2[0] >= 0 && e2[0] <= 127))
          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
        if (!(e2[1] >= 0 && e2[1] <= 127))
          throw new RangeError("The pitch bend LSB must be an integer between 0 and 127.");
      } else if (t2.rawValue && !Array.isArray(e2)) {
        if (!(e2 >= 0 && e2 <= 127))
          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
      } else {
        if (isNaN(e2) || e2 === null)
          throw new RangeError("Invalid pitch bend value.");
        if (!(e2 >= -1 && e2 <= 1))
          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
      }
    let s2 = 0, a2 = 0;
    if (t2.rawValue && Array.isArray(e2))
      s2 = e2[0], a2 = e2[1];
    else if (t2.rawValue && !Array.isArray(e2))
      s2 = e2;
    else {
      const t3 = r$6.fromFloatToMsbLsb((e2 + 1) / 2);
      s2 = t3.msb, a2 = t3.lsb;
    }
    return this.send([(n$6.MIDI_CHANNEL_MESSAGES.pitchbend << 4) + (this.number - 1), a2, s2], { time: r$6.toTimestamp(t2.time) }), this;
  }
  sendPitchBendRange(e2, t2, n2 = {}) {
    if (d$3.validation) {
      if (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127))
        throw new RangeError("The semitones value must be an integer between 0 and 127.");
      if (!Number.isInteger(t2) || !(t2 >= 0 && t2 <= 127))
        throw new RangeError("The cents value must be an integer between 0 and 127.");
    }
    return this.sendRpnValue("pitchbendrange", [e2, t2], n2), this;
  }
  sendProgramChange(e2, t2 = {}) {
    if (e2 = parseInt(e2) || 0, d$3.validation && !(e2 >= 0 && e2 <= 127))
      throw new RangeError("The program number must be between 0 and 127.");
    return this.send([(n$6.MIDI_CHANNEL_MESSAGES.programchange << 4) + (this.number - 1), e2], { time: r$6.toTimestamp(t2.time) }), this;
  }
  sendRpnValue(e2, t2, s2 = {}) {
    if (Array.isArray(e2) || (e2 = n$6.MIDI_REGISTERED_PARAMETERS[e2]), d$3.validation) {
      if (!Number.isInteger(e2[0]) || !Number.isInteger(e2[1]))
        throw new TypeError("The specified NRPN is invalid.");
      if (!(e2[0] >= 0 && e2[0] <= 127))
        throw new RangeError("The first byte of the RPN must be between 0 and 127.");
      if (!(e2[1] >= 0 && e2[1] <= 127))
        throw new RangeError("The second byte of the RPN must be between 0 and 127.");
      [].concat(t2).forEach((e3) => {
        if (!(e3 >= 0 && e3 <= 127))
          throw new RangeError("The data bytes of the RPN must be between 0 and 127.");
      });
    }
    return this._selectRegisteredParameter(e2, s2), this._setCurrentParameter(t2, s2), this._deselectRegisteredParameter(s2), this;
  }
  sendTuningBank(e2, t2 = {}) {
    if (d$3.validation && (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127)))
      throw new RangeError("The tuning bank number must be between 0 and 127.");
    return this.sendRpnValue("tuningbank", e2, t2), this;
  }
  sendTuningProgram(e2, t2 = {}) {
    if (d$3.validation && (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127)))
      throw new RangeError("The tuning program number must be between 0 and 127.");
    return this.sendRpnValue("tuningprogram", e2, t2), this;
  }
  sendLocalControl(e2, t2 = {}) {
    return e2 ? this.sendChannelMode("localcontrol", 127, t2) : this.sendChannelMode("localcontrol", 0, t2);
  }
  sendAllNotesOff(e2 = {}) {
    return this.sendChannelMode("allnotesoff", 0, e2);
  }
  sendAllSoundOff(e2 = {}) {
    return this.sendChannelMode("allsoundoff", 0, e2);
  }
  sendResetAllControllers(e2 = {}) {
    return this.sendChannelMode("resetallcontrollers", 0, e2);
  }
  sendPolyphonicMode(e2, t2 = {}) {
    return e2 === "mono" ? this.sendChannelMode("monomodeon", 0, t2) : this.sendChannelMode("polymodeon", 0, t2);
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
  get output() {
    return this._output;
  }
  get number() {
    return this._number;
  }
}
/**
 * The `Output` class represents a single MIDI output port (not to be confused with a MIDI channel).
 * A port is made available by a MIDI device. A MIDI device can advertise several input and output
 * ports. Each port has 16 MIDI channels which can be accessed via the [`channels`](#channels)
 * property.
 *
 * The `Output` object is automatically instantiated by the library according to the host's MIDI
 * subsystem and should not be directly instantiated.
 *
 * You can access all available `Output` objects by referring to the
 * [`WebMidi.outputs`](WebMidi#outputs) array or by using methods such as
 * [`WebMidi.getOutputByName()`](WebMidi#getOutputByName) or
 * [`WebMidi.getOutputById()`](WebMidi#getOutputById).
 *
 * @fires Output#opened
 * @fires Output#disconnected
 * @fires Output#closed
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
class i$6 extends e$6 {
  constructor(e2) {
    super(), this._midiOutput = e2, this._octaveOffset = 0, this.channels = [];
    for (let e3 = 1; e3 <= 16; e3++)
      this.channels[e3] = new a$6(this, e3);
    this._midiOutput.onstatechange = this._onStateChange.bind(this);
  }
  async destroy() {
    this.removeListener(), this.channels.forEach((e2) => e2.destroy()), this.channels = [], this._midiOutput.onstatechange = null, await this.close(), this._midiOutput = null;
  }
  _onStateChange(e2) {
    let t2 = { timestamp: d$3.time };
    e2.port.connection === "open" ? (t2.type = "opened", t2.target = this, t2.port = t2.target, this.emit("opened", t2)) : e2.port.connection === "closed" && e2.port.state === "connected" ? (t2.type = "closed", t2.target = this, t2.port = t2.target, this.emit("closed", t2)) : e2.port.connection === "closed" && e2.port.state === "disconnected" ? (t2.type = "disconnected", t2.port = { connection: e2.port.connection, id: e2.port.id, manufacturer: e2.port.manufacturer, name: e2.port.name, state: e2.port.state, type: e2.port.type }, this.emit("disconnected", t2)) : e2.port.connection === "pending" && e2.port.state === "disconnected" || console.warn("This statechange event was not caught:", e2.port.connection, e2.port.state);
  }
  async open() {
    try {
      return await this._midiOutput.open(), Promise.resolve(this);
    } catch (e2) {
      return Promise.reject(e2);
    }
  }
  async close() {
    this._midiOutput ? await this._midiOutput.close() : await Promise.resolve();
  }
  send(e2, t2 = { time: 0 }, n2 = 0) {
    if (e2 instanceof h$5 && (e2 = r$6.isNode ? e2.data : e2.rawData), e2 instanceof Uint8Array && r$6.isNode && (e2 = Array.from(e2)), d$3.validation) {
      if (Array.isArray(e2) || e2 instanceof Uint8Array || (e2 = [e2], Array.isArray(t2) && (e2 = e2.concat(t2)), t2 = isNaN(n2) ? { time: 0 } : { time: n2 }), !(parseInt(e2[0]) >= 128 && parseInt(e2[0]) <= 255))
        throw new RangeError("The first byte (status) must be an integer between 128 and 255.");
      e2.slice(1).forEach((e3) => {
        if (!((e3 = parseInt(e3)) >= 0 && e3 <= 255))
          throw new RangeError("Data bytes must be integers between 0 and 255.");
      }), t2 || (t2 = { time: 0 });
    }
    return this._midiOutput.send(e2, r$6.toTimestamp(t2.time)), this;
  }
  sendSysex(e2, t2 = [], s2 = {}) {
    if (e2 = [].concat(e2), t2 instanceof Uint8Array) {
      const r2 = new Uint8Array(1 + e2.length + t2.length + 1);
      r2[0] = n$6.MIDI_SYSTEM_MESSAGES.sysex, r2.set(Uint8Array.from(e2), 1), r2.set(t2, 1 + e2.length), r2[r2.length - 1] = n$6.MIDI_SYSTEM_MESSAGES.sysexend, this.send(r2, { time: s2.time });
    } else {
      const r2 = e2.concat(t2, n$6.MIDI_SYSTEM_MESSAGES.sysexend);
      this.send([n$6.MIDI_SYSTEM_MESSAGES.sysex].concat(r2), { time: s2.time });
    }
    return this;
  }
  clear() {
    return this._midiOutput.clear ? this._midiOutput.clear() : d$3.validation && console.warn("The 'clear()' method has not yet been implemented in your environment."), this;
  }
  sendTimecodeQuarterFrame(e2, t2 = {}) {
    if (d$3.validation && (e2 = parseInt(e2), isNaN(e2) || !(e2 >= 0 && e2 <= 127)))
      throw new RangeError("The value must be an integer between 0 and 127.");
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.timecode, e2], { time: t2.time }), this;
  }
  sendSongPosition(e2 = 0, t2 = {}) {
    var s2 = (e2 = Math.floor(e2) || 0) >> 7 & 127, r2 = 127 & e2;
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.songposition, s2, r2], { time: t2.time }), this;
  }
  sendSongSelect(e2 = 0, t2 = {}) {
    if (d$3.validation && (e2 = parseInt(e2), isNaN(e2) || !(e2 >= 0 && e2 <= 127)))
      throw new RangeError("The program value must be between 0 and 127");
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.songselect, e2], { time: t2.time }), this;
  }
  sendTuneRequest(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.tunerequest], { time: e2.time }), this;
  }
  sendClock(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.clock], { time: e2.time }), this;
  }
  sendStart(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.start], { time: e2.time }), this;
  }
  sendContinue(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.continue], { time: e2.time }), this;
  }
  sendStop(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.stop], { time: e2.time }), this;
  }
  sendActiveSensing(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.activesensing], { time: e2.time }), this;
  }
  sendReset(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.reset], { time: e2.time }), this;
  }
  sendTuningRequest(e2 = {}) {
    return d$3.validation && console.warn("The sendTuningRequest() method has been deprecated. Use sendTuningRequest() instead."), this.sendTuneRequest(e2);
  }
  sendKeyAftertouch(e2, t2, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendKeyAftertouch(e2, t2, s2);
    }), this;
  }
  sendControlChange(e2, t2, s2 = {}, a2 = {}) {
    if (d$3.validation && (Array.isArray(s2) || Number.isInteger(s2) || s2 === "all")) {
      const e3 = s2;
      (s2 = a2).channels = e3, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendControlChange(e2, t2, s2);
    }), this;
  }
  sendPitchBendRange(e2 = 0, t2 = 0, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendPitchBendRange(e2, t2, s2);
    }), this;
  }
  setPitchBendRange(e2 = 0, t2 = 0, s2 = "all", r2 = {}) {
    return d$3.validation && (console.warn("The setPitchBendRange() method is deprecated. Use sendPitchBendRange() instead."), r2.channels = s2, r2.channels === "all" && (r2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendPitchBendRange(e2, t2, r2);
  }
  sendRpnValue(e2, t2, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendRpnValue(e2, t2, s2);
    }), this;
  }
  setRegisteredParameter(e2, t2 = [], s2 = "all", r2 = {}) {
    return d$3.validation && (console.warn("The setRegisteredParameter() method is deprecated. Use sendRpnValue() instead."), r2.channels = s2, r2.channels === "all" && (r2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendRpnValue(e2, t2, r2);
  }
  sendChannelAftertouch(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendChannelAftertouch(e2, t2);
    }), this;
  }
  sendPitchBend(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendPitchBend(e2, t2);
    }), this;
  }
  sendProgramChange(e2 = 0, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendProgramChange(e2, t2);
    }), this;
  }
  sendModulationRange(e2, t2, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendModulationRange(e2, t2, s2);
    }), this;
  }
  setModulationRange(e2 = 0, t2 = 0, s2 = "all", r2 = {}) {
    return d$3.validation && (console.warn("The setModulationRange() method is deprecated. Use sendModulationRange() instead."), r2.channels = s2, r2.channels === "all" && (r2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendModulationRange(e2, t2, r2);
  }
  sendMasterTuning(e2, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendMasterTuning(e2, t2);
    }), this;
  }
  setMasterTuning(e2, t2 = {}, s2 = {}) {
    return d$3.validation && (console.warn("The setMasterTuning() method is deprecated. Use sendMasterTuning() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendMasterTuning(e2, s2);
  }
  sendTuningProgram(e2, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendTuningProgram(e2, t2);
    }), this;
  }
  setTuningProgram(e2, t2 = "all", s2 = {}) {
    return d$3.validation && (console.warn("The setTuningProgram() method is deprecated. Use sendTuningProgram() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendTuningProgram(e2, s2);
  }
  sendTuningBank(e2 = 0, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendTuningBank(e2, t2);
    }), this;
  }
  setTuningBank(e2, t2 = "all", s2 = {}) {
    return d$3.validation && (console.warn("The setTuningBank() method is deprecated. Use sendTuningBank() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendTuningBank(e2, s2);
  }
  sendChannelMode(e2, t2 = 0, s2 = {}, a2 = {}) {
    if (d$3.validation && (Array.isArray(s2) || Number.isInteger(s2) || s2 === "all")) {
      const e3 = s2;
      (s2 = a2).channels = e3, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendChannelMode(e2, t2, s2);
    }), this;
  }
  sendAllSoundOff(e2 = {}) {
    return e2.channels == null && (e2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(e2.channels).forEach((t2) => {
      this.channels[t2].sendAllSoundOff(e2);
    }), this;
  }
  sendAllNotesOff(e2 = {}) {
    return e2.channels == null && (e2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(e2.channels).forEach((t2) => {
      this.channels[t2].sendAllNotesOff(e2);
    }), this;
  }
  sendResetAllControllers(e2 = {}, t2 = {}) {
    if (d$3.validation && (Array.isArray(e2) || Number.isInteger(e2) || e2 === "all")) {
      const s2 = e2;
      (e2 = t2).channels = s2, e2.channels === "all" && (e2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return e2.channels == null && (e2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(e2.channels).forEach((t3) => {
      this.channels[t3].sendResetAllControllers(e2);
    }), this;
  }
  sendPolyphonicMode(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendPolyphonicMode(e2, t2);
    }), this;
  }
  sendLocalControl(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendLocalControl(e2, t2);
    }), this;
  }
  sendOmniMode(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendOmniMode(e2, t2);
    }), this;
  }
  sendNrpnValue(e2, t2, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendNrpnValue(e2, t2, s2);
    }), this;
  }
  setNonRegisteredParameter(e2, t2 = [], s2 = "all", r2 = {}) {
    return d$3.validation && (console.warn("The setNonRegisteredParameter() method is deprecated. Use sendNrpnValue() instead."), r2.channels = s2, r2.channels === "all" && (r2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendNrpnValue(e2, t2, r2);
  }
  sendRpnIncrement(e2, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendRpnIncrement(e2, t2);
    }), this;
  }
  incrementRegisteredParameter(e2, t2 = "all", s2 = {}) {
    return d$3.validation && (console.warn("The incrementRegisteredParameter() method is deprecated. Use sendRpnIncrement() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendRpnIncrement(e2, s2);
  }
  sendRpnDecrement(e2, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendRpnDecrement(e2, t2);
    }), this;
  }
  decrementRegisteredParameter(e2, t2 = "all", s2 = {}) {
    return d$3.validation && (console.warn("The decrementRegisteredParameter() method is deprecated. Use sendRpnDecrement() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendRpnDecrement(e2, s2);
  }
  sendNoteOff(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendNoteOff(e2, t2);
    }), this;
  }
  stopNote(e2, t2) {
    return this.sendNoteOff(e2, t2);
  }
  playNote(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (t2.rawVelocity && console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' instead."), t2.velocity && console.warn("The 'velocity' option is deprecated. Use 'velocity' instead."), Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].playNote(e2, t2);
    }), this;
  }
  sendNoteOn(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendNoteOn(e2, t2);
    }), this;
  }
  get name() {
    return this._midiOutput.name;
  }
  get id() {
    return this._midiOutput.id;
  }
  get connection() {
    return this._midiOutput.connection;
  }
  get manufacturer() {
    return this._midiOutput.manufacturer;
  }
  get state() {
    return this._midiOutput.state;
  }
  get type() {
    return this._midiOutput.type;
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
}
/**
 * The `Forwarder` class allows the forwarding of MIDI messages to predetermined outputs. When you
 * call its [`forward()`](#forward) method, it will send the specified [`Message`](Message) object
 * to all the outputs listed in its [`destinations`](#destinations) property.
 *
 * If specific channels or message types have been defined in the [`channels`](#channels) or
 * [`types`](#types) properties, only messages matching the channels/types will be forwarded.
 *
 * While it can be manually instantiated, you are more likely to come across a `Forwarder` object as
 * the return value of the [`Input.addForwarder()`](Input#addForwarder) method.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class o$6 {
  constructor(e2 = [], t2 = {}) {
    this.destinations = [], this.types = [...Object.keys(n$6.MIDI_SYSTEM_MESSAGES), ...Object.keys(n$6.MIDI_CHANNEL_MESSAGES)], this.channels = n$6.MIDI_CHANNEL_NUMBERS, this.suspended = false, Array.isArray(e2) || (e2 = [e2]), t2.types && !Array.isArray(t2.types) && (t2.types = [t2.types]), t2.channels && !Array.isArray(t2.channels) && (t2.channels = [t2.channels]), d$3.validation && (e2.forEach((e3) => {
      if (!(e3 instanceof i$6))
        throw new TypeError("Destinations must be of type 'Output'.");
    }), t2.types !== void 0 && t2.types.forEach((e3) => {
      if (!n$6.MIDI_SYSTEM_MESSAGES.hasOwnProperty(e3) && !n$6.MIDI_CHANNEL_MESSAGES.hasOwnProperty(e3))
        throw new TypeError("Type must be a valid message type.");
    }), t2.channels !== void 0 && t2.channels.forEach((e3) => {
      if (!n$6.MIDI_CHANNEL_NUMBERS.includes(e3))
        throw new TypeError("MIDI channel must be between 1 and 16.");
    })), this.destinations = e2, t2.types && (this.types = t2.types), t2.channels && (this.channels = t2.channels);
  }
  forward(e2) {
    this.suspended || this.types.includes(e2.type) && (e2.channel && !this.channels.includes(e2.channel) || this.destinations.forEach((t2) => {
      (!d$3.validation || t2 instanceof i$6) && t2.send(e2);
    }));
  }
}
/**
 * The `InputChannel` class represents a single MIDI input channel (1-16) from a single input
 * device. This object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `InputChannel` objects can be found inside the input's [`channels`](Input#channels)
 * property.
 *
 * @fires InputChannel#midimessage
 * @fires InputChannel#unknownmessage
 *
 * @fires InputChannel#noteoff
 * @fires InputChannel#noteon
 * @fires InputChannel#keyaftertouch
 * @fires InputChannel#programchange
 * @fires InputChannel#event:controlchange-controllerxxx
 * @fires InputChannel#channelaftertouch
 * @fires InputChannel#pitchbend
 * @fires InputChannel#controlchange
 *
 * @fires InputChannel#allnotesoff
 * @fires InputChannel#allsoundoff
 * @fires InputChannel#localcontrol
 * @fires InputChannel#monomode
 * @fires InputChannel#omnimode
 * @fires InputChannel#resetallcontrollers
 *
 * @fires InputChannel#event:nrpn
 * @fires InputChannel#event:nrpn-dataentrycoarse
 * @fires InputChannel#event:nrpn-dataentryfine
 * @fires InputChannel#event:nrpn-databuttonincrement
 * @fires InputChannel#event:nrpn-databuttondecrement
 * @fires InputChannel#event:rpn
 * @fires InputChannel#event:rpn-dataentrycoarse
 * @fires InputChannel#event:rpn-dataentryfine
 * @fires InputChannel#event:rpn-databuttonincrement
 * @fires InputChannel#event:rpn-databuttondecrement
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
class l$3 extends e$6 {
  constructor(e2, t2) {
    super(), this._input = e2, this._number = t2, this._octaveOffset = 0, this._nrpnBuffer = [], this._rpnBuffer = [], this.parameterNumberEventsEnabled = true, this.notesState = new Array(128).fill(false);
  }
  destroy() {
    this._input = null, this._number = null, this._octaveOffset = 0, this._nrpnBuffer = [], this.notesState = new Array(128).fill(false), this.parameterNumberEventsEnabled = false, this.removeListener();
  }
  _processMidiMessageEvent(e2) {
    const t2 = Object.assign({}, e2);
    t2.port = this.input, t2.target = this, t2.type = "midimessage", this.emit(t2.type, t2), this._parseEventForStandardMessages(t2);
  }
  _parseEventForStandardMessages(e2) {
    const t2 = Object.assign({}, e2);
    t2.type = t2.message.type || "unknownmessage";
    const n2 = e2.message.dataBytes[0], a2 = e2.message.dataBytes[1];
    if (t2.type === "noteoff" || t2.type === "noteon" && a2 === 0)
      this.notesState[n2] = false, t2.type = "noteoff", t2.note = new s$2(r$6.offsetNumber(n2, this.octaveOffset + this.input.octaveOffset + d$3.octaveOffset), { rawAttack: 0, rawRelease: a2 }), t2.value = r$6.from7bitToFloat(a2), t2.rawValue = a2, t2.velocity = t2.note.release, t2.rawVelocity = t2.note.rawRelease;
    else if (t2.type === "noteon")
      this.notesState[n2] = true, t2.note = new s$2(r$6.offsetNumber(n2, this.octaveOffset + this.input.octaveOffset + d$3.octaveOffset), { rawAttack: a2 }), t2.value = r$6.from7bitToFloat(a2), t2.rawValue = a2, t2.velocity = t2.note.attack, t2.rawVelocity = t2.note.rawAttack;
    else if (t2.type === "keyaftertouch")
      t2.note = new s$2(r$6.offsetNumber(n2, this.octaveOffset + this.input.octaveOffset + d$3.octaveOffset)), t2.value = r$6.from7bitToFloat(a2), t2.rawValue = a2, t2.identifier = t2.note.identifier, t2.key = t2.note.number, t2.rawKey = n2;
    else if (t2.type === "controlchange") {
      t2.controller = { number: n2, name: r$6.getCcNameByNumber(n2) }, t2.subtype = t2.controller.name || "controller" + n2, t2.value = r$6.from7bitToFloat(a2), t2.rawValue = a2;
      const e3 = Object.assign({}, t2);
      e3.type = `${t2.type}-controller${n2}`, delete e3.subtype, this.emit(e3.type, e3), t2.message.dataBytes[0] >= 120 && this._parseChannelModeMessage(t2), this.parameterNumberEventsEnabled && this._isRpnOrNrpnController(t2.message.dataBytes[0]) && this._parseEventForParameterNumber(t2);
    } else
      t2.type === "programchange" ? (t2.value = n2, t2.rawValue = t2.value) : t2.type === "channelaftertouch" ? (t2.value = r$6.from7bitToFloat(n2), t2.rawValue = n2) : t2.type === "pitchbend" ? (t2.value = ((a2 << 7) + n2 - 8192) / 8192, t2.rawValue = (a2 << 7) + n2) : t2.type = "unknownmessage";
    this.emit(t2.type, t2);
  }
  _parseChannelModeMessage(e2) {
    const t2 = Object.assign({}, e2);
    t2.type = t2.controller.name, t2.type === "localcontrol" && (t2.value = t2.message.data[2] === 127, t2.rawValue = t2.message.data[2]), t2.type === "omnimodeon" ? (t2.type = "omnimode", t2.value = true, t2.rawValue = t2.message.data[2]) : t2.type === "omnimodeoff" && (t2.type = "omnimode", t2.value = false, t2.rawValue = t2.message.data[2]), t2.type === "monomodeon" ? (t2.type = "monomode", t2.value = true, t2.rawValue = t2.message.data[2]) : t2.type === "polymodeon" && (t2.type = "monomode", t2.value = false, t2.rawValue = t2.message.data[2]), this.emit(t2.type, t2);
  }
  _parseEventForParameterNumber(e2) {
    const t2 = e2.message.dataBytes[0], s2 = e2.message.dataBytes[1], r2 = n$6.MIDI_CONTROL_CHANGE_MESSAGES;
    t2 === r2.nonregisteredparameterfine || t2 === r2.registeredparameterfine ? (this._nrpnBuffer = [], this._rpnBuffer = [], t2 === r2.nonregisteredparameterfine ? this._nrpnBuffer = [e2.message] : s2 !== 127 && (this._rpnBuffer = [e2.message])) : t2 === r2.nonregisteredparametercoarse || t2 === r2.registeredparametercoarse ? t2 === r2.nonregisteredparametercoarse ? (this._rpnBuffer = [], this._nrpnBuffer.length === 1 ? this._nrpnBuffer.push(e2.message) : this._nrpnBuffer = []) : (this._nrpnBuffer = [], this._rpnBuffer.length === 1 && s2 !== 127 ? this._rpnBuffer.push(e2.message) : this._rpnBuffer = []) : t2 !== r2.dataentrycoarse && t2 !== r2.dataentryfine && t2 !== r2.databuttonincrement && t2 !== r2.databuttondecrement || (this._rpnBuffer.length === 2 ? this._dispatchParameterNumberEvent("rpn", this._rpnBuffer[0].dataBytes[1], this._rpnBuffer[1].dataBytes[1], e2) : this._nrpnBuffer.length === 2 ? this._dispatchParameterNumberEvent("nrpn", this._nrpnBuffer[0].dataBytes[1], this._nrpnBuffer[1].dataBytes[1], e2) : (this._nrpnBuffer = [], this._rpnBuffer = []));
  }
  _isRpnOrNrpnController(e2) {
    return e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.dataentrycoarse || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.dataentryfine || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.databuttonincrement || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.databuttondecrement || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparametercoarse || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparameterfine || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.registeredparametercoarse || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.registeredparameterfine;
  }
  _dispatchParameterNumberEvent(e2, t2, s2, a2) {
    e2 = e2 === "nrpn" ? "nrpn" : "rpn";
    const i2 = { target: a2.target, timestamp: a2.timestamp, message: a2.message, parameterMsb: t2, parameterLsb: s2, value: r$6.from7bitToFloat(a2.message.dataBytes[1]), rawValue: a2.message.dataBytes[1] };
    i2.parameter = e2 === "rpn" ? Object.keys(n$6.MIDI_REGISTERED_PARAMETERS).find((e3) => n$6.MIDI_REGISTERED_PARAMETERS[e3][0] === t2 && n$6.MIDI_REGISTERED_PARAMETERS[e3][1] === s2) : (t2 << 7) + s2;
    const o2 = r$6.getPropertyByValue(n$6.MIDI_CONTROL_CHANGE_MESSAGES, a2.message.dataBytes[0]);
    i2.type = `${e2}-${o2}`, this.emit(i2.type, i2), i2.type = e2, i2.subtype = o2, this.emit(i2.type, i2);
  }
  getChannelModeByNumber(e2) {
    return d$3.validation && (console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class."), e2 = Math.floor(e2)), r$6.getChannelModeByNumber(e2);
  }
  getCcNameByNumber(e2) {
    if (d$3.validation && (console.warn("The 'getCcNameByNumber()' method has been moved to the 'Utilities' class."), !((e2 = parseInt(e2)) >= 0 && e2 <= 127)))
      throw new RangeError("Invalid control change number.");
    return r$6.getCcNameByNumber(e2);
  }
  getNoteState(e2) {
    e2 instanceof s$2 && (e2 = e2.identifier);
    const t2 = r$6.guessNoteNumber(e2, d$3.octaveOffset + this.input.octaveOffset + this.octaveOffset);
    return this.notesState[t2];
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
  get input() {
    return this._input;
  }
  get number() {
    return this._number;
  }
  get nrpnEventsEnabled() {
    return this.parameterNumberEventsEnabled;
  }
  set nrpnEventsEnabled(e2) {
    this.validation && (e2 = !!e2), this.parameterNumberEventsEnabled = e2;
  }
}
/**
 * The `Message` class represents a single MIDI message. It has several properties that make it
 * easy to make sense of the binary data it contains.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class h$5 {
  constructor(e2) {
    this.rawData = e2, this.data = Array.from(this.rawData), this.statusByte = this.rawData[0], this.rawDataBytes = this.rawData.slice(1), this.dataBytes = this.data.slice(1), this.isChannelMessage = false, this.isSystemMessage = false, this.command = void 0, this.channel = void 0, this.manufacturerId = void 0, this.type = void 0, this.statusByte < 240 ? (this.isChannelMessage = true, this.command = this.statusByte >> 4, this.channel = 1 + (15 & this.statusByte)) : (this.isSystemMessage = true, this.command = this.statusByte), this.isChannelMessage ? this.type = r$6.getPropertyByValue(n$6.MIDI_CHANNEL_MESSAGES, this.command) : this.isSystemMessage && (this.type = r$6.getPropertyByValue(n$6.MIDI_SYSTEM_MESSAGES, this.command)), this.statusByte === n$6.MIDI_SYSTEM_MESSAGES.sysex && (this.dataBytes[0] === 0 ? (this.manufacturerId = this.dataBytes.slice(0, 3), this.dataBytes = this.dataBytes.slice(3, this.rawDataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(3, this.rawDataBytes.length - 1)) : (this.manufacturerId = [this.dataBytes[0]], this.dataBytes = this.dataBytes.slice(1, this.dataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(1, this.rawDataBytes.length - 1)));
  }
}
/**
 * The `Input` class represents a single MIDI input port. This object is automatically instantiated
 * by the library according to the host's MIDI subsystem and does not need to be directly
 * instantiated. Instead, you can access all `Input` objects by referring to the
 * [`WebMidi.inputs`](WebMidi#inputs) array. You can also retrieve inputs by using methods such as
 * [`WebMidi.getInputByName()`](WebMidi#getInputByName) and
 * [`WebMidi.getInputById()`](WebMidi#getInputById).
 *
 * Note that a single MIDI device may expose several inputs and/or outputs.
 *
 * **Important**: the `Input` class does not directly fire channel-specific MIDI messages
 * (such as [`noteon`](InputChannel#event:noteon) or
 * [`controlchange`](InputChannel#event:controlchange), etc.). The [`InputChannel`](InputChannel)
 * object does that. However, you can still use the
 * [`Input.addListener()`](#addListener) method to listen to channel-specific events on multiple
 * [`InputChannel`](InputChannel) objects at once.
 *
 * @fires Input#opened
 * @fires Input#disconnected
 * @fires Input#closed
 * @fires Input#midimessage
 *
 * @fires Input#sysex
 * @fires Input#timecode
 * @fires Input#songposition
 * @fires Input#songselect
 * @fires Input#tunerequest
 * @fires Input#clock
 * @fires Input#start
 * @fires Input#continue
 * @fires Input#stop
 * @fires Input#activesensing
 * @fires Input#reset
 *
 * @fires Input#unknownmidimessage
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
class c$4 extends e$6 {
  constructor(e2) {
    super(), this._midiInput = e2, this._octaveOffset = 0, this.channels = [];
    for (let e3 = 1; e3 <= 16; e3++)
      this.channels[e3] = new l$3(this, e3);
    this._forwarders = [], this._midiInput.onstatechange = this._onStateChange.bind(this), this._midiInput.onmidimessage = this._onMidiMessage.bind(this);
  }
  async destroy() {
    this.removeListener(), this.channels.forEach((e2) => e2.destroy()), this.channels = [], this._forwarders = [], this._midiInput && (this._midiInput.onstatechange = null, this._midiInput.onmidimessage = null), await this.close(), this._midiInput = null;
  }
  _onStateChange(e2) {
    let t2 = { timestamp: d$3.time, target: this, port: this };
    e2.port.connection === "open" ? (t2.type = "opened", this.emit("opened", t2)) : e2.port.connection === "closed" && e2.port.state === "connected" ? (t2.type = "closed", this.emit("closed", t2)) : e2.port.connection === "closed" && e2.port.state === "disconnected" ? (t2.type = "disconnected", t2.port = { connection: e2.port.connection, id: e2.port.id, manufacturer: e2.port.manufacturer, name: e2.port.name, state: e2.port.state, type: e2.port.type }, this.emit("disconnected", t2)) : e2.port.connection === "pending" && e2.port.state === "disconnected" || console.warn("This statechange event was not caught: ", e2.port.connection, e2.port.state);
  }
  _onMidiMessage(e2) {
    const t2 = new h$5(e2.data), n2 = { port: this, target: this, message: t2, timestamp: e2.timeStamp, type: "midimessage", data: t2.data, rawData: t2.data, statusByte: t2.data[0], dataBytes: t2.dataBytes };
    this.emit("midimessage", n2), t2.isSystemMessage ? this._parseEvent(n2) : t2.isChannelMessage && this.channels[t2.channel]._processMidiMessageEvent(n2), this._forwarders.forEach((e3) => e3.forward(t2));
  }
  _parseEvent(e2) {
    const t2 = Object.assign({}, e2);
    t2.type = t2.message.type || "unknownmidimessage", t2.type === "songselect" && (t2.song = e2.data[1] + 1, t2.value = e2.data[1], t2.rawValue = t2.value), this.emit(t2.type, t2);
  }
  async open() {
    try {
      await this._midiInput.open();
    } catch (e2) {
      return Promise.reject(e2);
    }
    return Promise.resolve(this);
  }
  async close() {
    if (!this._midiInput)
      return Promise.resolve(this);
    try {
      await this._midiInput.close();
    } catch (e2) {
      return Promise.reject(e2);
    }
    return Promise.resolve(this);
  }
  getChannelModeByNumber() {
    d$3.validation && console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class.");
  }
  addListener(e2, t2, s2 = {}) {
    if (d$3.validation && typeof s2 == "function") {
      let e3 = t2 != null ? [].concat(t2) : void 0;
      t2 = s2, s2 = { channels: e3 };
    }
    if (n$6.CHANNEL_EVENTS.includes(e2)) {
      s2.channels === void 0 && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS);
      let a2 = [];
      return r$6.sanitizeChannels(s2.channels).forEach((n2) => {
        a2.push(this.channels[n2].addListener(e2, t2, s2));
      }), a2;
    }
    return super.addListener(e2, t2, s2);
  }
  addOneTimeListener(e2, t2, n2 = {}) {
    return n2.remaining = 1, this.addListener(e2, t2, n2);
  }
  on(e2, t2, n2, s2) {
    return this.addListener(e2, t2, n2, s2);
  }
  hasListener(e2, t2, s2 = {}) {
    if (d$3.validation && typeof s2 == "function") {
      let e3 = [].concat(t2);
      t2 = s2, s2 = { channels: e3 };
    }
    return n$6.CHANNEL_EVENTS.includes(e2) ? (s2.channels === void 0 && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).every((n2) => this.channels[n2].hasListener(e2, t2))) : super.hasListener(e2, t2);
  }
  removeListener(e2, t2, s2 = {}) {
    if (d$3.validation && typeof s2 == "function") {
      let e3 = [].concat(t2);
      t2 = s2, s2 = { channels: e3 };
    }
    if (s2.channels === void 0 && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), e2 == null)
      return r$6.sanitizeChannels(s2.channels).forEach((e3) => {
        this.channels[e3] && this.channels[e3].removeListener();
      }), super.removeListener();
    n$6.CHANNEL_EVENTS.includes(e2) ? r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].removeListener(e2, t2, s2);
    }) : super.removeListener(e2, t2, s2);
  }
  addForwarder(e2, t2 = {}) {
    let n2;
    return n2 = e2 instanceof o$6 ? e2 : new o$6(e2, t2), this._forwarders.push(n2), n2;
  }
  removeForwarder(e2) {
    this._forwarders = this._forwarders.filter((t2) => t2 !== e2);
  }
  hasForwarder(e2) {
    return this._forwarders.includes(e2);
  }
  get name() {
    return this._midiInput.name;
  }
  get id() {
    return this._midiInput.id;
  }
  get connection() {
    return this._midiInput.connection;
  }
  get manufacturer() {
    return this._midiInput.manufacturer;
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
  get state() {
    return this._midiInput.state;
  }
  get type() {
    return this._midiInput.type;
  }
  get nrpnEventsEnabled() {
    return d$3.validation && console.warn("The 'nrpnEventsEnabled' property has been moved to the 'InputChannel' class."), false;
  }
}
/**
 * The `WebMidi` object makes it easier to work with the low-level Web MIDI API. Basically, it
 * simplifies sending outgoing MIDI messages and reacting to incoming MIDI messages.
 *
 * When using the WebMidi.js library, you should know that the `WebMidi` class has already been
 * instantiated. You cannot instantiate it yourself. If you use the **IIFE** version, you should
 * simply use the global object called `WebMidi`. If you use the **CJS** (CommonJS) or **ESM** (ES6
 * module) version, you get an already-instantiated object when you import the module.
 *
 * @fires WebMidi#connected
 * @fires WebMidi#disabled
 * @fires WebMidi#disconnected
 * @fires WebMidi#enabled
 * @fires WebMidi#error
 * @fires WebMidi#midiaccessgranted
 * @fires WebMidi#portschanged
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
const d$3 = new class extends e$6 {
  constructor() {
    super(), this.defaults = { note: { attack: r$6.from7bitToFloat(64), release: r$6.from7bitToFloat(64), duration: 1 / 0 } }, this.interface = null, this.validation = true, this._inputs = [], this._disconnectedInputs = [], this._outputs = [], this._disconnectedOutputs = [], this._stateChangeQueue = [], this._octaveOffset = 0;
  }
  async enable(e2 = {}, t2 = false) {
    if (r$6.isNode) {
      try {
        window.navigator;
      } catch (e3) {
        global.navigator = await Object.getPrototypeOf(async function() {
        }).constructor('\n        let jzz = await import("jzz");\n        return jzz.default;\n        ')();
      }
      try {
        performance;
      } catch (e3) {
        global.performance = await Object.getPrototypeOf(async function() {
        }).constructor('\n        let perf_hooks = await import("perf_hooks");\n        return perf_hooks.performance;\n        ')();
      }
    }
    if (this.validation = e2.validation !== false, this.validation && (typeof e2 == "function" && (e2 = { callback: e2, sysex: t2 }), t2 && (e2.sysex = true)), this.enabled)
      return typeof e2.callback == "function" && e2.callback(), Promise.resolve();
    const n2 = { timestamp: this.time, target: this, type: "error", error: void 0 }, s2 = { timestamp: this.time, target: this, type: "midiaccessgranted" }, a2 = { timestamp: this.time, target: this, type: "enabled" };
    try {
      typeof e2.requestMIDIAccessFunction == "function" ? this.interface = await e2.requestMIDIAccessFunction({ sysex: e2.sysex, software: e2.software }) : this.interface = await navigator.requestMIDIAccess({ sysex: e2.sysex, software: e2.software });
    } catch (t3) {
      return n2.error = t3, this.emit("error", n2), typeof e2.callback == "function" && e2.callback(t3), Promise.reject(t3);
    }
    this.emit("midiaccessgranted", s2), this.interface.onstatechange = this._onInterfaceStateChange.bind(this);
    try {
      await this._updateInputsAndOutputs();
    } catch (t3) {
      return n2.error = t3, this.emit("error", n2), typeof e2.callback == "function" && e2.callback(t3), Promise.reject(t3);
    }
    return this.emit("enabled", a2), typeof e2.callback == "function" && e2.callback(), Promise.resolve(this);
  }
  async disable() {
    return this._destroyInputsAndOutputs().then(() => {
      navigator && typeof navigator.close == "function" && navigator.close(), this.interface && (this.interface.onstatechange = void 0), this.interface = null;
      let e2 = { timestamp: this.time, target: this, type: "disabled" };
      this.emit("disabled", e2), this.removeListener();
    });
  }
  getInputById(e2, t2 = { disconnected: false }) {
    if (this.validation) {
      if (!this.enabled)
        throw new Error("WebMidi is not enabled.");
      if (!e2)
        return;
    }
    if (t2.disconnected) {
      for (let t3 = 0; t3 < this._disconnectedInputs.length; t3++)
        if (this._disconnectedInputs[t3].id === e2.toString())
          return this._disconnectedInputs[t3];
    } else
      for (let t3 = 0; t3 < this.inputs.length; t3++)
        if (this.inputs[t3].id === e2.toString())
          return this.inputs[t3];
  }
  getInputByName(e2, t2 = { disconnected: false }) {
    if (this.validation) {
      if (!this.enabled)
        throw new Error("WebMidi is not enabled.");
      if (!e2)
        return;
      e2 = e2.toString();
    }
    if (t2.disconnected) {
      for (let t3 = 0; t3 < this._disconnectedInputs.length; t3++)
        if (~this._disconnectedInputs[t3].name.indexOf(e2))
          return this._disconnectedInputs[t3];
    } else
      for (let t3 = 0; t3 < this.inputs.length; t3++)
        if (~this.inputs[t3].name.indexOf(e2))
          return this.inputs[t3];
  }
  getOutputByName(e2, t2 = { disconnected: false }) {
    if (this.validation) {
      if (!this.enabled)
        throw new Error("WebMidi is not enabled.");
      if (!e2)
        return;
      e2 = e2.toString();
    }
    if (t2.disconnected) {
      for (let t3 = 0; t3 < this._disconnectedOutputs.length; t3++)
        if (~this._disconnectedOutputs[t3].name.indexOf(e2))
          return this._disconnectedOutputs[t3];
    } else
      for (let t3 = 0; t3 < this.outputs.length; t3++)
        if (~this.outputs[t3].name.indexOf(e2))
          return this.outputs[t3];
  }
  getOutputById(e2, t2 = { disconnected: false }) {
    if (this.validation) {
      if (!this.enabled)
        throw new Error("WebMidi is not enabled.");
      if (!e2)
        return;
    }
    if (t2.disconnected) {
      for (let t3 = 0; t3 < this._disconnectedOutputs.length; t3++)
        if (this._disconnectedOutputs[t3].id === e2.toString())
          return this._disconnectedOutputs[t3];
    } else
      for (let t3 = 0; t3 < this.outputs.length; t3++)
        if (this.outputs[t3].id === e2.toString())
          return this.outputs[t3];
  }
  noteNameToNumber(e2) {
    return this.validation && console.warn("The noteNameToNumber() method is deprecated. Use Utilities.toNoteNumber() instead."), r$6.toNoteNumber(e2, this.octaveOffset);
  }
  getOctave(e2) {
    return this.validation && (console.warn("The getOctave()is deprecated. Use Utilities.getNoteDetails() instead"), e2 = parseInt(e2)), !isNaN(e2) && e2 >= 0 && e2 <= 127 && r$6.getNoteDetails(r$6.offsetNumber(e2, this.octaveOffset)).octave;
  }
  sanitizeChannels(e2) {
    return this.validation && console.warn("The sanitizeChannels() method has been moved to the utilities class."), r$6.sanitizeChannels(e2);
  }
  toMIDIChannels(e2) {
    return this.validation && console.warn("The toMIDIChannels() method has been deprecated. Use Utilities.sanitizeChannels() instead."), r$6.sanitizeChannels(e2);
  }
  guessNoteNumber(e2) {
    return this.validation && console.warn("The guessNoteNumber() method has been deprecated. Use Utilities.guessNoteNumber() instead."), r$6.guessNoteNumber(e2, this.octaveOffset);
  }
  getValidNoteArray(e2, t2 = {}) {
    return this.validation && console.warn("The getValidNoteArray() method has been moved to the Utilities.buildNoteArray()"), r$6.buildNoteArray(e2, t2);
  }
  convertToTimestamp(e2) {
    return this.validation && console.warn("The convertToTimestamp() method has been moved to Utilities.toTimestamp()."), r$6.toTimestamp(e2);
  }
  async _destroyInputsAndOutputs() {
    let e2 = [];
    return this.inputs.forEach((t2) => e2.push(t2.destroy())), this.outputs.forEach((t2) => e2.push(t2.destroy())), Promise.all(e2).then(() => {
      this._inputs = [], this._outputs = [];
    });
  }
  _onInterfaceStateChange(e2) {
    this._updateInputsAndOutputs();
    let t2 = { timestamp: e2.timeStamp, type: e2.port.state, target: this };
    if (e2.port.state === "connected" && e2.port.connection === "open") {
      e2.port.type === "output" ? t2.port = this.getOutputById(e2.port.id) : e2.port.type === "input" && (t2.port = this.getInputById(e2.port.id)), this.emit(e2.port.state, t2);
      const n2 = Object.assign({}, t2);
      n2.type = "portschanged", this.emit(n2.type, n2);
    } else if (e2.port.state === "disconnected" && e2.port.connection === "pending") {
      e2.port.type === "input" ? t2.port = this.getInputById(e2.port.id, { disconnected: true }) : e2.port.type === "output" && (t2.port = this.getOutputById(e2.port.id, { disconnected: true })), this.emit(e2.port.state, t2);
      const n2 = Object.assign({}, t2);
      n2.type = "portschanged", this.emit(n2.type, n2);
    }
  }
  async _updateInputsAndOutputs() {
    return Promise.all([this._updateInputs(), this._updateOutputs()]);
  }
  async _updateInputs() {
    if (!this.interface)
      return;
    for (let e3 = this._inputs.length - 1; e3 >= 0; e3--) {
      const t2 = this._inputs[e3];
      Array.from(this.interface.inputs.values()).find((e4) => e4 === t2._midiInput) || (this._disconnectedInputs.push(t2), this._inputs.splice(e3, 1));
    }
    let e2 = [];
    return this.interface.inputs.forEach((t2) => {
      if (!this._inputs.find((e3) => e3._midiInput === t2)) {
        let n2 = this._disconnectedInputs.find((e3) => e3._midiInput === t2);
        n2 || (n2 = new c$4(t2)), this._inputs.push(n2), e2.push(n2.open());
      }
    }), Promise.all(e2);
  }
  async _updateOutputs() {
    if (!this.interface)
      return;
    for (let e3 = this._outputs.length - 1; e3 >= 0; e3--) {
      const t2 = this._outputs[e3];
      Array.from(this.interface.outputs.values()).find((e4) => e4 === t2._midiOutput) || (this._disconnectedOutputs.push(t2), this._outputs.splice(e3, 1));
    }
    let e2 = [];
    return this.interface.outputs.forEach((t2) => {
      if (!this._outputs.find((e3) => e3._midiOutput === t2)) {
        let n2 = this._disconnectedOutputs.find((e3) => e3._midiOutput === t2);
        n2 || (n2 = new i$6(t2)), this._outputs.push(n2), e2.push(n2.open());
      }
    }), Promise.all(e2);
  }
  get enabled() {
    return this.interface !== null;
  }
  get inputs() {
    return this._inputs;
  }
  get isNode() {
    return this.validation && console.warn("WebMidi.isNode has been deprecated. Use Utilities.isNode instead."), r$6.isNode;
  }
  get isBrowser() {
    return this.validation && console.warn("WebMidi.isBrowser has been deprecated. Use Utilities.isBrowser instead."), r$6.isBrowser;
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
  get outputs() {
    return this._outputs;
  }
  get supported() {
    return typeof navigator != "undefined" && navigator.requestMIDIAccess;
  }
  get sysexEnabled() {
    return !(!this.interface || !this.interface.sysexEnabled);
  }
  get time() {
    return performance.now();
  }
  get version() {
    return "3.0.21";
  }
  get CHANNEL_EVENTS() {
    return this.validation && console.warn("The CHANNEL_EVENTS enum has been moved to Enumerations.CHANNEL_EVENTS."), n$6.CHANNEL_EVENTS;
  }
  get MIDI_SYSTEM_MESSAGES() {
    return this.validation && console.warn("The MIDI_SYSTEM_MESSAGES enum has been moved to Enumerations.MIDI_SYSTEM_MESSAGES."), n$6.MIDI_SYSTEM_MESSAGES;
  }
  get MIDI_CHANNEL_MODE_MESSAGES() {
    return this.validation && console.warn("The MIDI_CHANNEL_MODE_MESSAGES enum has been moved to Enumerations.MIDI_CHANNEL_MODE_MESSAGES."), n$6.MIDI_CHANNEL_MODE_MESSAGES;
  }
  get MIDI_CONTROL_CHANGE_MESSAGES() {
    return this.validation && console.warn("The MIDI_CONTROL_CHANGE_MESSAGES enum has been moved to Enumerations.MIDI_CONTROL_CHANGE_MESSAGES."), n$6.MIDI_CONTROL_CHANGE_MESSAGES;
  }
  get MIDI_REGISTERED_PARAMETER() {
    return this.validation && console.warn("The MIDI_REGISTERED_PARAMETER enum has been moved to Enumerations.MIDI_REGISTERED_PARAMETERS."), this.MIDI_REGISTERED_PARAMETERS;
  }
  get NOTES() {
    return this.validation && console.warn("The NOTES enum has been deprecated."), ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  }
}();
d$3.constructor = null;
const noteKeys = {
  "KeyQ": { note: "F", offset: 1 },
  "Digit2": { note: "F#", offset: 1 },
  "KeyW": { note: "G", offset: 1 },
  "Digit3": { note: "G#", offset: 1 },
  "KeyE": { note: "A", offset: 1 },
  "Digit4": { note: "A#", offset: 1 },
  "KeyR": { note: "B", offset: 1 },
  "KeyT": { note: "C", offset: 2 },
  "Digit6": { note: "C#", offset: 2 },
  "KeyY": { note: "D", offset: 2 },
  "Digit7": { note: "D#", offset: 2 },
  "KeyU": { note: "E", offset: 2 },
  "KeyI": { note: "F", offset: 2 },
  "Digit9": { note: "F#", offset: 2 },
  "KeyO": { note: "G", offset: 2 },
  "Digit0": { note: "G#", offset: 2 },
  "KeyP": { note: "A", offset: 2 },
  "Minus": { note: "A#", offset: 2 },
  "BracketLeft": { note: "B", offset: 2 },
  "BracketRIght": { note: "C", offset: 3 },
  "KeyZ": { note: "C", offset: 0 },
  "KeyS": { note: "C#", offset: 0 },
  "KeyX": { note: "D", offset: 0 },
  "KeyD": { note: "D#", offset: 0 },
  "KeyC": { note: "E", offset: 0 },
  "KeyV": { note: "F", offset: 0 },
  "KeyG": { note: "F#", offset: 0 },
  "KeyB": { note: "G", offset: 0 },
  "KeyH": { note: "G#", offset: 0 },
  "KeyN": { note: "A", offset: 0 },
  "KeyJ": { note: "A#", offset: 0 },
  "KeyM": { note: "B", offset: 0 },
  "Comma": { note: "C", offset: 1 },
  "KeyL": { note: "C#", offset: 1 },
  "Period": { note: "D", offset: 1 },
  "Semicolon": { note: "D#", offset: 1 },
  "Slash": { note: "E", offset: 1 }
};
function setupKeyboard() {
  document.addEventListener("keydown", (e2) => {
    if (e2.code == "Digit1")
      midi$1.offset--;
    if (e2.code == "Equal")
      midi$1.offset++;
    if (e2.repeat || !midi$1.keyboard || !noteKeys[e2.code])
      return;
    if (e2.ctrlKey || e2.altKey || e2.metaKey)
      return;
    if (e2.code == "Slash")
      e2.preventDefault();
    playKey(noteKeys[e2.code].note, noteKeys[e2.code].offset);
  });
  document.addEventListener("keyup", (e2) => {
    if (!noteKeys[e2.code])
      return;
    playKey(noteKeys[e2.code].note, noteKeys[e2.code].offset, true);
  });
}
const midi$1 = reactive({
  enabled: false,
  initiated: false,
  out: true,
  inputs: {},
  outputs: {},
  forwards: {},
  playing: false,
  channels: {},
  channel: useStorage("global-midi-channel", 1),
  note: {
    pitch: 0,
    channel: 1
  },
  offset: useClamp(0, -2, 2),
  keyboard: true,
  cc: {},
  ccLearn: {},
  message: null,
  log: [],
  clock: 0,
  filter: useStorage("global-midi-filter", {}),
  available: computed(() => Object.entries(midi$1.outputs).length > 0),
  activeNotes: computed(() => {
    let notes2 = {};
    for (let ch in midi$1.channels) {
      for (let num2 in midi$1.channels[ch].activeNotes) {
        notes2[num2] = midi$1.channels[ch].activeNotes[num2];
      }
    }
    return notes2;
  }),
  activeChroma: computed(() => {
    let chroma2 = new Array(12);
    for (let num2 in midi$1.activeNotes) {
      chroma2[(num2 - 9) % 12] = num2;
    }
    return chroma2;
  })
});
function learnCC({ param, number, channel } = {}) {
  const val = ref(0);
  watch(() => midi$1.cc, (cc) => {
    if (channel && cc.channel != channel)
      return;
    if (number == cc.number)
      val.value = cc.value;
  });
  return val;
}
function playKey(name2, offset = 0, off, velocity = 1) {
  let noteName = name2 + (4 + offset + midi$1.offset);
  const note2 = new s$2(noteName, {
    attack: off ? 0 : velocity,
    release: off ? 0 : velocity
  });
  const ev = {
    type: off ? "noteoff" : "noteon",
    note: note2,
    port: { id: "PC Keyboard" },
    timestamp: midi$1.time,
    target: { number: 0 }
  };
  noteInOn(ev);
}
function useMidi() {
  if (!midi$1.initiated) {
    setupKeyboard();
    onMounted(() => {
      if (d$3.supported) {
        setupMidi();
      }
    });
    watchEffect(() => {
      if (!midi$1.out)
        return;
      let outs = Object.values(d$3.outputs);
      if (midi$1.playing) {
        outs.forEach((output) => {
          output.sendContinue();
        });
      } else {
        outs.forEach((output) => {
          output.sendStop();
        });
      }
    });
    midi$1.initiated = true;
  }
  return {
    midi: midi$1,
    midiAttack,
    midiRelease,
    midiOnce: midiOnce$1,
    setCC,
    WebMidi: d$3
  };
}
function setupMidi() {
  d$3.enable();
  d$3.addListener("enabled", (e2) => {
    midi$1.enabled = true;
    initMidi();
  });
  d$3.addListener("connected", (e2) => {
    initMidi();
  });
  d$3.addListener("disconnected", (e2) => {
    delete midi$1[e2.port.type + "s"][e2.port.id];
  });
  midi$1.initiated = true;
}
function initMidi() {
  midi$1.inputs = reactive({});
  d$3.inputs.forEach((input2) => {
    midi$1.enabled = true;
    midi$1.inputs[input2.id] = {
      name: input2.name,
      manufacturer: input2.manufacturer,
      forwarder: input2.addForwarder(),
      event: null,
      note: null,
      cc: null
    };
    input2.removeListener();
    input2.addListener("start", () => {
      midi$1.playing = true;
    });
    input2.addListener("stop", () => {
      midi$1.playing = false;
      midi$1.channels = {};
    });
    input2.addListener("midimessage", (ev) => {
      var _a2;
      if (((_a2 = ev == null ? void 0 : ev.message) == null ? void 0 : _a2.type) == "clock")
        return;
      midi$1.inputs[input2.id].event = ev;
      midi$1.message = ev.message;
      midi$1.log.unshift(ev);
      if (midi$1.log.length > 100)
        midi$1.log.pop();
    });
    input2.addListener("noteon", (ev) => {
      midi$1.inputs[input2.id].note = noteInOn(ev);
    }, {
      channels: "all"
    });
    input2.addListener("noteoff", (ev) => {
      midi$1.inputs[input2.id].note = noteInOn(ev);
    }, { channels: "all" });
    input2.addListener("controlchange", (ev) => {
      const cc = ccIn(ev);
      if (!cc)
        return;
      midi$1.inputs[input2.id].cc = cc;
      midi$1.cc = cc;
    }, {
      channels: "all"
    });
    input2.addListener("clock", (ev) => {
      midi$1.clock = ev.timestamp;
    });
  });
  midi$1.outputs = reactive({});
  d$3.outputs.forEach((output) => {
    midi$1.outputs[output.id] = {
      name: output.name,
      manufacturer: output.manufacturer
    };
  });
}
function noteInOn(ev) {
  let note2 = ev.note;
  note2.port = ev.port.id;
  note2.type = ev.type;
  note2.timestamp = ev.timestamp;
  note2.channel = ev.target.number;
  if (midi$1.filter[note2.channel])
    return;
  createChannel(note2.channel);
  midi$1.channels[note2.channel].notes[note2.number] = note2;
  if (ev.type == "noteoff") {
    note2.velocity = 0;
    delete midi$1.channels[note2.channel].activeNotes[note2.number];
  } else {
    note2.velocity = 120 * (ev.note.attack || 1);
    midi$1.channels[note2.channel].activeNotes[note2.number] = true;
  }
  note2.pitch = (note2.number + 3) % 12;
  note2.octA = Math.floor((note2.number + 3) / 12) - 1;
  midi$1.note = note2;
  return note2;
}
function ccIn(ev) {
  if (midi$1.filter[ev.target.number])
    return;
  let cc = {
    channel: ev.target.number,
    timestamp: ev.timestamp,
    number: ev.controller.number,
    value: ev.value,
    raw: ev.rawValue,
    port: ev.port.id
  };
  createChannel(cc.channel);
  midi$1.channels[cc.channel].cc[cc.number] = cc;
  return cc;
}
function createChannel(ch) {
  if (!midi$1.channels[ch]) {
    midi$1.channels[ch] = reactive({ num: ch, activeNotes: {}, notes: {}, cc: {} });
  }
}
function setVelocity(channel, note2, velocity) {
  var _a2, _b, _c;
  if ((_c = (_b = (_a2 = midi$1.channels) == null ? void 0 : _a2[channel]) == null ? void 0 : _b.notes) == null ? void 0 : _c[note2]) {
    midi$1.channels[channel].notes[note2].velocity = velocity;
  }
}
function midiAttack(note2, options2) {
  if (!midi$1.out)
    return;
  let channel = (note2 == null ? void 0 : note2.channel) || midi$1.channel;
  setVelocity(channel, note2 == null ? void 0 : note2.number, 100);
  d$3.outputs.forEach((output) => {
    output.playNote(note2.number, {
      channels: channel,
      ...options2
    });
  });
}
function midiPlay(note2, options2) {
  if (!midi$1.out)
    return;
  d$3.outputs.forEach((output) => {
    output.playNote(note2, {
      channels: midi$1.channel,
      ...options2
    });
  });
}
function midiStop(note2, options2) {
  if (!midi$1.out)
    return;
  if (note2) {
    d$3.outputs.forEach((output) => {
      output.stopNote(note2, { channels: midi$1.channel, ...options2 });
    });
  } else {
    d$3.outputs.forEach((output) => {
      output.sendAllNotesOff();
      output.sendAllSoundOff({ time: "+1" });
    });
  }
}
function midiRelease(note2) {
  if (!midi$1.out)
    return;
  if (note2) {
    let channel = (note2 == null ? void 0 : note2.channel) || midi$1.channel;
    setVelocity(channel, note2 == null ? void 0 : note2.number, 0);
    d$3.outputs.forEach((output) => {
      output.stopNote(note2.number, { channels: channel });
    });
  } else {
    d$3.outputs.forEach((output) => {
      output.sendAllNotesOff();
      output.sendAllSoundOff({ time: "+1" });
    });
  }
}
function midiOnce$1(note2, options2) {
  if (!midi$1.out || midi$1.filter[midi$1.channel])
    return;
  midiPlay(note2, options2);
  setTimeout(() => {
    midiStop(note2, options2);
  }, 300);
}
function setCC(cc, value) {
  if (!midi$1.out)
    return;
  d$3.outputs.forEach((output) => {
    output.sendControlChange(Number(cc.number), value, cc.channel);
  });
}
function stopAll() {
  if (!midi$1.out)
    return;
  midi$1.channels = {};
  midi$1.playing = false;
  d$3.outputs.forEach((output) => {
    output.sendAllNotesOff();
    output.sendAllSoundOff({ time: "+1" });
    output.sendReset();
  });
}
function forwardMidi(iid, oid) {
  var _a2, _b;
  const output = d$3.outputs.find((out) => out.id == oid);
  const destinations = midi$1.inputs[iid].forwarder.destinations;
  const index2 = destinations.indexOf(output);
  if (index2 == -1) {
    destinations.push(output);
    midi$1.forwards[iid] = midi$1.forwards[iid] || {};
    midi$1.forwards[iid][oid] = true;
  } else {
    destinations.splice(index2, 1);
    (_b = (_a2 = midi$1.forwards) == null ? void 0 : _a2[iid]) == null ? true : delete _b[oid];
  }
}
const quantizeModes = ["+0", "@8n", "@16n", "@32n"];
const synth = {
  state: reactive({
    midi: useStorage("synth-midi", true),
    initiated: false,
    mute: false,
    quantize: useCycleList(quantizeModes, { initialValue: "+0" }),
    volume: useClamp(1, 0, 2)
  }),
  params: reactive({
    maxPolyphony: 50,
    oscillator: {
      type: useStorage("synth-osc", "sawtooth8")
    },
    volume: -30,
    envelope: {
      attack: 0.01,
      decay: 0.1,
      sustain: 0.6,
      release: 1
    },
    filterEnvelope: {
      attack: 1e-3,
      decay: 0.7,
      sustain: 0.5,
      release: 1,
      baseFrequency: 60,
      octaves: 5
    }
  })
};
function useSynth() {
  if (!synth.state.initiated) {
    onKeyDown("Escape", () => {
      synthReleaseAll();
    });
    watch(() => synth.state.volume, (vol) => synth.poly && synth.poly.volume.rampTo(gainToDb(vol)));
    watch(synth.params, (params) => {
      if (synth.poly) {
        synth.poly.set(params);
      }
    }, { deep: true, immediate: true });
    watch(() => midi$1.note, (note2) => {
      if (!synth.state.midi)
        return;
      if (note2.velocity > 0) {
        synthAttack(Midi$1(note2.number).toFrequency(), note2.velocity / 127);
      } else {
        synthRelease(Midi$1(note2.number).toFrequency());
      }
    });
    watch(() => midi$1.playing, (play) => {
      if (!play)
        synthReleaseAll();
    });
  }
  return { init: init$2, synth, synthOnce, synthAttack, synthRelease, synthReleaseAll };
}
function init$2() {
  start$1();
  if (synth == null ? void 0 : synth.poly)
    return;
  const { channel } = createChannel$1("synth");
  synth.widener = new StereoWidener(0.7).connect(channel);
  synth.reverb = new Reverb(3).connect(synth.widener);
  synth.delay = new PingPongDelay({ delayTime: "16n", feedback: 0.3, wet: 0.3, maxDelay: "4n" }).connect(synth.widener);
  synth.pan = new AutoPanner({ frequency: "4n", depth: 0.4 }).connect(synth.reverb).connect(synth.delay).connect(synth.widener);
  synth.compressor = new Compressor().connect(synth.pan);
  synth.poly = new PolySynth(MonoSynth, synth.params).connect(synth.compressor);
  synth.pan.start();
}
function synthOnce(note2 = "A4", duration2 = "8n", time) {
  if (!synth.poly || synth.state.mute)
    return init$2();
  synth.poly.triggerAttackRelease(note2, duration2, time);
}
function synthAttack(note2, velocity) {
  if (!synth.poly || synth.state.mute)
    return init$2();
  synth.poly.triggerAttack(note2, synth.state.quantize.state, velocity);
}
function synthRelease(note2) {
  if (!synth.poly || synth.state.mute)
    return init$2();
  synth.poly.triggerRelease(note2, synth.state.quantize.state);
}
function synthReleaseAll() {
  if (!synth.poly || synth.state.mute)
    return init$2();
  synth.poly.releaseAll();
}
const fillStr = (s2, n2) => Array(Math.abs(n2) + 1).join(s2);
function deprecate(original, alternative, fn) {
  return function(...args) {
    console.warn(`${original} is deprecated. Use ${alternative}.`);
    return fn.apply(this, args);
  };
}
function isNamed(src) {
  return src !== null && typeof src === "object" && typeof src.name === "string" ? true : false;
}
function isPitch(pitch) {
  return pitch !== null && typeof pitch === "object" && typeof pitch.step === "number" && typeof pitch.alt === "number" ? true : false;
}
const FIFTHS = [0, 2, 4, -1, 1, 3, 5];
const STEPS_TO_OCTS = FIFTHS.map((fifths) => Math.floor(fifths * 7 / 12));
function encode$1(pitch) {
  const { step, alt, oct, dir = 1 } = pitch;
  const f2 = FIFTHS[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f2];
  }
  const o2 = oct - STEPS_TO_OCTS[step] - 4 * alt;
  return [dir * f2, dir * o2];
}
const FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];
function decode(coord) {
  const [f2, o2, dir] = coord;
  const step = FIFTHS_TO_STEPS[unaltered(f2)];
  const alt = Math.floor((f2 + 1) / 7);
  if (o2 === void 0) {
    return { step, alt, dir };
  }
  const oct = o2 + 4 * alt + STEPS_TO_OCTS[step];
  return { step, alt, oct, dir };
}
function unaltered(f2) {
  const i2 = (f2 + 1) % 7;
  return i2 < 0 ? 7 + i2 : i2;
}
const NoNote = { empty: true, name: "", pc: "", acc: "" };
const cache$1 = /* @__PURE__ */ new Map();
const stepToLetter = (step) => "CDEFGAB".charAt(step);
const altToAcc = (alt) => alt < 0 ? fillStr("b", -alt) : fillStr("#", alt);
const accToAlt = (acc) => acc[0] === "b" ? -acc.length : acc.length;
function note(src) {
  const cached = cache$1.get(src);
  if (cached) {
    return cached;
  }
  const value = typeof src === "string" ? parse$1(src) : isPitch(src) ? note(pitchName$1(src)) : isNamed(src) ? note(src.name) : NoNote;
  cache$1.set(src, value);
  return value;
}
const REGEX$1 = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function tokenizeNote(str) {
  const m2 = REGEX$1.exec(str);
  return [m2[1].toUpperCase(), m2[2].replace(/x/g, "##"), m2[3], m2[4]];
}
function coordToNote(noteCoord) {
  return note(decode(noteCoord));
}
const mod = (n2, m2) => (n2 % m2 + m2) % m2;
const SEMI = [0, 2, 4, 5, 7, 9, 11];
function parse$1(noteName) {
  const tokens = tokenizeNote(noteName);
  if (tokens[0] === "" || tokens[3] !== "") {
    return NoNote;
  }
  const letter = tokens[0];
  const acc = tokens[1];
  const octStr = tokens[2];
  const step = (letter.charCodeAt(0) + 3) % 7;
  const alt = accToAlt(acc);
  const oct = octStr.length ? +octStr : void 0;
  const coord = encode$1({ step, alt, oct });
  const name2 = letter + acc + octStr;
  const pc = letter + acc;
  const chroma2 = (SEMI[step] + alt + 120) % 12;
  const height = oct === void 0 ? mod(SEMI[step] + alt, 12) - 12 * 99 : SEMI[step] + alt + 12 * (oct + 1);
  const midi2 = height >= 0 && height <= 127 ? height : null;
  const freq2 = oct === void 0 ? null : Math.pow(2, (height - 69) / 12) * 440;
  return {
    empty: false,
    acc,
    alt,
    chroma: chroma2,
    coord,
    freq: freq2,
    height,
    letter,
    midi: midi2,
    name: name2,
    oct,
    pc,
    step
  };
}
function pitchName$1(props) {
  const { step, alt, oct } = props;
  const letter = stepToLetter(step);
  if (!letter) {
    return "";
  }
  const pc = letter + altToAcc(alt);
  return oct || oct === 0 ? pc + oct : pc;
}
const NoInterval = { empty: true, name: "", acc: "" };
const INTERVAL_TONAL_REGEX = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
const INTERVAL_SHORTHAND_REGEX = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
const REGEX$2 = new RegExp("^" + INTERVAL_TONAL_REGEX + "|" + INTERVAL_SHORTHAND_REGEX + "$");
function tokenizeInterval(str) {
  const m2 = REGEX$2.exec(`${str}`);
  if (m2 === null) {
    return ["", ""];
  }
  return m2[1] ? [m2[1], m2[2]] : [m2[4], m2[3]];
}
const cache$2 = {};
function interval(src) {
  return typeof src === "string" ? cache$2[src] || (cache$2[src] = parse(src)) : isPitch(src) ? interval(pitchName(src)) : isNamed(src) ? interval(src.name) : NoInterval;
}
const SIZES = [0, 2, 4, 5, 7, 9, 11];
const TYPES = "PMMPPMM";
function parse(str) {
  const tokens = tokenizeInterval(str);
  if (tokens[0] === "") {
    return NoInterval;
  }
  const num2 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num2) - 1) % 7;
  const t2 = TYPES[step];
  if (t2 === "M" && q === "P") {
    return NoInterval;
  }
  const type = t2 === "M" ? "majorable" : "perfectable";
  const name2 = "" + num2 + q;
  const dir = num2 < 0 ? -1 : 1;
  const simple = num2 === 8 || num2 === -8 ? num2 : dir * (step + 1);
  const alt = qToAlt(type, q);
  const oct = Math.floor((Math.abs(num2) - 1) / 7);
  const semitones = dir * (SIZES[step] + alt + 12 * oct);
  const chroma2 = (dir * (SIZES[step] + alt) % 12 + 12) % 12;
  const coord = encode$1({ step, alt, oct, dir });
  return {
    empty: false,
    name: name2,
    num: num2,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones,
    chroma: chroma2,
    coord,
    oct
  };
}
function qToAlt(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num2 = calcNum === 0 ? step + 1 : calcNum;
  const d2 = dir < 0 ? "-" : "";
  const type = TYPES[step] === "M" ? "majorable" : "perfectable";
  const name2 = d2 + num2 + altToQ(type, alt);
  return name2;
}
function altToQ(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr("A", alt);
  } else {
    return fillStr("d", type === "perfectable" ? alt : alt + 1);
  }
}
function transpose$1(noteName, intervalName) {
  const note$1 = note(noteName);
  const interval$1 = interval(intervalName);
  if (note$1.empty || interval$1.empty) {
    return "";
  }
  const noteCoord = note$1.coord;
  const intervalCoord = interval$1.coord;
  const tr2 = noteCoord.length === 1 ? [noteCoord[0] + intervalCoord[0]] : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];
  return coordToNote(tr2).name;
}
function ascR(b2, n2) {
  const a2 = [];
  for (; n2--; a2[n2] = n2 + b2)
    ;
  return a2;
}
function descR(b2, n2) {
  const a2 = [];
  for (; n2--; a2[n2] = b2 - n2)
    ;
  return a2;
}
function range(from, to) {
  return from < to ? ascR(from, to - from + 1) : descR(from, from - to + 1);
}
function rotate(times, arr) {
  const len = arr.length;
  const n2 = (times % len + len) % len;
  return arr.slice(n2, len).concat(arr.slice(0, n2));
}
function compact(arr) {
  return arr.filter((n2) => n2 === 0 || n2);
}
const EmptyPcset = {
  empty: true,
  name: "",
  setNum: 0,
  chroma: "000000000000",
  normalized: "000000000000",
  intervals: []
};
const setNumToChroma = (num2) => Number(num2).toString(2);
const chromaToNumber = (chroma2) => parseInt(chroma2, 2);
const REGEX = /^[01]{12}$/;
function isChroma(set) {
  return REGEX.test(set);
}
const isPcsetNum = (set) => typeof set === "number" && set >= 0 && set <= 4095;
const isPcset = (set) => set && isChroma(set.chroma);
const cache = { [EmptyPcset.chroma]: EmptyPcset };
function get$5(src) {
  const chroma2 = isChroma(src) ? src : isPcsetNum(src) ? setNumToChroma(src) : Array.isArray(src) ? listToChroma(src) : isPcset(src) ? src.chroma : EmptyPcset.chroma;
  return cache[chroma2] = cache[chroma2] || chromaToPcset(chroma2);
}
const pcset = deprecate("Pcset.pcset", "Pcset.get", get$5);
const chroma$1 = (set) => get$5(set).chroma;
const intervals$1 = (set) => get$5(set).intervals;
const num = (set) => get$5(set).setNum;
const IVLS = [
  "1P",
  "2m",
  "2M",
  "3m",
  "3M",
  "4P",
  "5d",
  "5P",
  "6m",
  "6M",
  "7m",
  "7M"
];
function chromaToIntervals(chroma2) {
  const intervals2 = [];
  for (let i2 = 0; i2 < 12; i2++) {
    if (chroma2.charAt(i2) === "1")
      intervals2.push(IVLS[i2]);
  }
  return intervals2;
}
function chromas() {
  return range(2048, 4095).map(setNumToChroma);
}
function modes$1(set, normalize = true) {
  const pcs = get$5(set);
  const binary = pcs.chroma.split("");
  return compact(binary.map((_, i2) => {
    const r2 = rotate(i2, binary);
    return normalize && r2[0] === "0" ? null : r2.join("");
  }));
}
function isEqual(s1, s2) {
  return get$5(s1).setNum === get$5(s2).setNum;
}
function isSubsetOf(set) {
  const s2 = get$5(set).setNum;
  return (notes2) => {
    const o2 = get$5(notes2).setNum;
    return s2 && s2 !== o2 && (o2 & s2) === o2;
  };
}
function isSupersetOf(set) {
  const s2 = get$5(set).setNum;
  return (notes2) => {
    const o2 = get$5(notes2).setNum;
    return s2 && s2 !== o2 && (o2 | s2) === o2;
  };
}
function isNoteIncludedIn(set) {
  const s2 = get$5(set);
  return (noteName) => {
    const n2 = note(noteName);
    return s2 && !n2.empty && s2.chroma.charAt(n2.chroma) === "1";
  };
}
function filter(set) {
  const isIncluded = isNoteIncludedIn(set);
  return (notes2) => {
    return notes2.filter(isIncluded);
  };
}
var index$5 = {
  get: get$5,
  chroma: chroma$1,
  num,
  intervals: intervals$1,
  chromas,
  isSupersetOf,
  isSubsetOf,
  isNoteIncludedIn,
  isEqual,
  filter,
  modes: modes$1,
  pcset
};
function chromaRotations(chroma2) {
  const binary = chroma2.split("");
  return binary.map((_, i2) => rotate(i2, binary).join(""));
}
function chromaToPcset(chroma2) {
  const setNum = chromaToNumber(chroma2);
  const normalizedNum = chromaRotations(chroma2).map(chromaToNumber).filter((n2) => n2 >= 2048).sort()[0];
  const normalized = setNumToChroma(normalizedNum);
  const intervals2 = chromaToIntervals(chroma2);
  return {
    empty: false,
    name: "",
    setNum,
    chroma: chroma2,
    normalized,
    intervals: intervals2
  };
}
function listToChroma(set) {
  if (set.length === 0) {
    return EmptyPcset.chroma;
  }
  let pitch;
  const binary = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (let i2 = 0; i2 < set.length; i2++) {
    pitch = note(set[i2]);
    if (pitch.empty)
      pitch = interval(set[i2]);
    if (!pitch.empty)
      binary[pitch.chroma] = 1;
  }
  return binary.join("");
}
const CHORDS = [
  ["1P 3M 5P", "major", "M ^ "],
  ["1P 3M 5P 7M", "major seventh", "maj7 \u0394 ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 \u03949 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth/ninth", "6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 \u0394#4 \u0394#11 M7#11 ^7#11 maj7#11"
  ],
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -\u03947 m\u0394 -^7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  ["1P 3m 5d", "diminished", "dim \xB0 o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 \xB07 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 \xF8 -7b5 h7 h"],
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 \u03949#11 ^9#11"
  ],
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
const NoChordType = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
let dictionary$1 = [];
let index$4 = {};
function get$4(type) {
  return index$4[type] || NoChordType;
}
const chordType$1 = deprecate("ChordType.chordType", "ChordType.get", get$4);
function names$3() {
  return dictionary$1.map((chord) => chord.name).filter((x2) => x2);
}
function symbols() {
  return dictionary$1.map((chord) => chord.aliases[0]).filter((x2) => x2);
}
function keys$1() {
  return Object.keys(index$4);
}
function all$1() {
  return dictionary$1.slice();
}
const entries$1 = deprecate("ChordType.entries", "ChordType.all", all$1);
function removeAll$1() {
  dictionary$1 = [];
  index$4 = {};
}
function add$1(intervals2, aliases, fullName) {
  const quality = getQuality(intervals2);
  const chord = {
    ...get$5(intervals2),
    name: fullName || "",
    quality,
    intervals: intervals2,
    aliases
  };
  dictionary$1.push(chord);
  if (chord.name) {
    index$4[chord.name] = chord;
  }
  index$4[chord.setNum] = chord;
  index$4[chord.chroma] = chord;
  chord.aliases.forEach((alias) => addAlias$1(chord, alias));
}
function addAlias$1(chord, alias) {
  index$4[alias] = chord;
}
function getQuality(intervals2) {
  const has = (interval2) => intervals2.indexOf(interval2) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
CHORDS.forEach(([ivls, fullName, names2]) => add$1(ivls.split(" "), names2.split(" "), fullName));
dictionary$1.sort((a2, b2) => a2.setNum - b2.setNum);
var index$1$2 = {
  names: names$3,
  symbols,
  get: get$4,
  all: all$1,
  add: add$1,
  removeAll: removeAll$1,
  keys: keys$1,
  entries: entries$1,
  chordType: chordType$1
};
const SCALES = [
  ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
  ["1P 3M 4P 5P 7M", "ionian pentatonic"],
  ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
  ["1P 2M 4P 5P 6M", "ritusen"],
  ["1P 2M 4P 5P 7m", "egyptian"],
  ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
  ["1P 3m 4P 5P 6m", "vietnamese 1"],
  ["1P 2m 3m 5P 6m", "pelog"],
  ["1P 2m 4P 5P 6m", "kumoijoshi"],
  ["1P 2M 3m 5P 6m", "hirajoshi"],
  ["1P 2m 4P 5d 7m", "iwato"],
  ["1P 2m 4P 5P 7m", "in-sen"],
  ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
  ["1P 3m 4P 6m 7m", "malkos raga"],
  ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
  ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
  ["1P 3m 4P 5P 6M", "minor six pentatonic"],
  ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
  ["1P 2M 3M 5P 6m", "flat six pentatonic"],
  ["1P 2m 3M 5P 6M", "scriabin"],
  ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
  ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
  ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
  ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
  ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
  ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
  ["1P 2A 3M 5P 5A 7M", "augmented"],
  ["1P 2M 3m 3M 5P 6M", "major blues"],
  ["1P 2M 4P 5P 6M 7m", "piongio"],
  ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
  ["1P 2M 3M 4A 6M 7m", "prometheus"],
  ["1P 2m 3M 5d 6m 7m", "mystery #1"],
  ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
  ["1P 2M 3M 4A 5A 7m", "whole tone", "messiaen's mode #1"],
  ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
  ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
  ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
  ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
  ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
  [
    "1P 2m 2A 3M 4A 6m 7m",
    "altered",
    "super locrian",
    "diminished whole tone",
    "pomeroy"
  ],
  ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
  [
    "1P 2M 3M 4P 5P 6m 7m",
    "mixolydian b6",
    "melodic minor fifth mode",
    "hindu"
  ],
  ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
  ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
  ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
  [
    "1P 2m 3m 4P 5P 6M 7m",
    "dorian b2",
    "phrygian #6",
    "melodic minor second mode"
  ],
  ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
  ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
  [
    "1P 2m 3m 4d 5d 6m 7d",
    "ultralocrian",
    "superlocrian bb7",
    "superlocrian diminished"
  ],
  ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
  ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
  [
    "1P 2M 3m 4A 5P 6M 7m",
    "dorian #4",
    "ukrainian dorian",
    "romanian minor",
    "altered dorian"
  ],
  ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
  ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
  ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
  ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
  ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
  ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
  ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
  ["1P 2M 3m 4P 5P 6m 7m", "aeolian", "minor"],
  ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
  ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
  ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
  ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
  ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
  ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
  ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
  ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
  ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
  ["1P 2m 3M 4P 5d 6m 7M", "persian"],
  ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
  ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
  [
    "1P 2M 3M 4P 5A 6M 7M",
    "major augmented",
    "major #5",
    "ionian augmented",
    "ionian #5"
  ],
  ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
  ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
  ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
  ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
  ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
  ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
  ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
  ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
  ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
  ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
  ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
  ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
  [
    "1P 2m 3m 3M 4A 5P 6M 7m",
    "half-whole diminished",
    "dominant diminished",
    "messiaen's mode #2"
  ],
  ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
  ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
  ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
  ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
  ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
  ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
];
const NoScaleType = {
  ...EmptyPcset,
  intervals: [],
  aliases: []
};
let dictionary = [];
let index$3 = {};
function names$2() {
  return dictionary.map((scale2) => scale2.name);
}
function get$3(type) {
  return index$3[type] || NoScaleType;
}
const scaleType$1 = deprecate("ScaleDictionary.scaleType", "ScaleType.get", get$3);
function all() {
  return dictionary.slice();
}
const entries = deprecate("ScaleDictionary.entries", "ScaleType.all", all);
function keys() {
  return Object.keys(index$3);
}
function removeAll() {
  dictionary = [];
  index$3 = {};
}
function add(intervals2, name2, aliases = []) {
  const scale2 = { ...get$5(intervals2), name: name2, intervals: intervals2, aliases };
  dictionary.push(scale2);
  index$3[scale2.name] = scale2;
  index$3[scale2.setNum] = scale2;
  index$3[scale2.chroma] = scale2;
  scale2.aliases.forEach((alias) => addAlias(scale2, alias));
  return scale2;
}
function addAlias(scale2, alias) {
  index$3[alias] = scale2;
}
SCALES.forEach(([ivls, name2, ...aliases]) => add(ivls.split(" "), name2, aliases));
var index$1$1 = {
  names: names$2,
  get: get$3,
  all,
  add,
  removeAll,
  keys,
  entries,
  scaleType: scaleType$1
};
const L2 = Math.log(2);
const L440 = Math.log(440);
function freqToMidi(freq2) {
  const v2 = 12 * (Math.log(freq2) - L440) / L2 + 69;
  return Math.round(v2 * 100) / 100;
}
const SHARPS = "C C# D D# E F F# G G# A A# B".split(" ");
const FLATS = "C Db D Eb E F Gb G Ab A Bb B".split(" ");
function midiToNoteName(midi2, options2 = {}) {
  if (isNaN(midi2) || midi2 === -Infinity || midi2 === Infinity)
    return "";
  midi2 = Math.round(midi2);
  const pcs = options2.sharps === true ? SHARPS : FLATS;
  const pc = pcs[midi2 % 12];
  if (options2.pitchClass) {
    return pc;
  }
  const o2 = Math.floor(midi2 / 12) - 1;
  return pc + o2;
}
const NAMES = ["C", "D", "E", "F", "G", "A", "B"];
const toName = (n2) => n2.name;
const onlyNotes = (array) => array.map(note).filter((n2) => !n2.empty);
function names$1(array) {
  if (array === void 0) {
    return NAMES.slice();
  } else if (!Array.isArray(array)) {
    return [];
  } else {
    return onlyNotes(array).map(toName);
  }
}
const get$2 = note;
const name = (note2) => get$2(note2).name;
const pitchClass = (note2) => get$2(note2).pc;
const accidentals = (note2) => get$2(note2).acc;
const octave = (note2) => get$2(note2).oct;
const midi = (note2) => get$2(note2).midi;
const freq = (note2) => get$2(note2).freq;
const chroma = (note2) => get$2(note2).chroma;
function fromMidi(midi2) {
  return midiToNoteName(midi2);
}
function fromFreq(freq2) {
  return midiToNoteName(freqToMidi(freq2));
}
function fromFreqSharps(freq2) {
  return midiToNoteName(freqToMidi(freq2), { sharps: true });
}
function fromMidiSharps(midi2) {
  return midiToNoteName(midi2, { sharps: true });
}
const transpose = transpose$1;
const tr = transpose$1;
const transposeBy = (interval2) => (note2) => transpose(note2, interval2);
const trBy = transposeBy;
const transposeFrom = (note2) => (interval2) => transpose(note2, interval2);
const trFrom = transposeFrom;
function transposeFifths(noteName, fifths) {
  const note2 = get$2(noteName);
  if (note2.empty) {
    return "";
  }
  const [nFifths, nOcts] = note2.coord;
  const transposed = nOcts === void 0 ? coordToNote([nFifths + fifths]) : coordToNote([nFifths + fifths, nOcts]);
  return transposed.name;
}
const trFifths = transposeFifths;
const ascending = (a2, b2) => a2.height - b2.height;
const descending = (a2, b2) => b2.height - a2.height;
function sortedNames(notes2, comparator) {
  comparator = comparator || ascending;
  return onlyNotes(notes2).sort(comparator).map(toName);
}
function sortedUniqNames(notes2) {
  return sortedNames(notes2, ascending).filter((n2, i2, a2) => i2 === 0 || n2 !== a2[i2 - 1]);
}
const simplify = (noteName) => {
  const note2 = get$2(noteName);
  if (note2.empty) {
    return "";
  }
  return midiToNoteName(note2.midi || note2.chroma, {
    sharps: note2.alt > 0,
    pitchClass: note2.midi === null
  });
};
function enharmonic(noteName, destName) {
  const src = get$2(noteName);
  if (src.empty) {
    return "";
  }
  const dest = get$2(destName || midiToNoteName(src.midi || src.chroma, {
    sharps: src.alt < 0,
    pitchClass: true
  }));
  if (dest.empty || dest.chroma !== src.chroma) {
    return "";
  }
  if (src.oct === void 0) {
    return dest.pc;
  }
  const srcChroma = src.chroma - src.alt;
  const destChroma = dest.chroma - dest.alt;
  const destOctOffset = srcChroma > 11 || destChroma < 0 ? -1 : srcChroma < 0 || destChroma > 11 ? 1 : 0;
  const destOct = src.oct + destOctOffset;
  return dest.pc + destOct;
}
var index$2 = {
  names: names$1,
  get: get$2,
  name,
  pitchClass,
  accidentals,
  octave,
  midi,
  ascending,
  descending,
  sortedNames,
  sortedUniqNames,
  fromMidi,
  fromMidiSharps,
  freq,
  fromFreq,
  fromFreqSharps,
  chroma,
  transpose,
  tr,
  transposeBy,
  trBy,
  transposeFrom,
  trFrom,
  transposeFifths,
  trFifths,
  simplify,
  enharmonic
};
Object.freeze([]);
const MODES = [
  [0, 2773, 0, "ionian", "", "Maj7", "major"],
  [1, 2902, 2, "dorian", "m", "m7"],
  [2, 3418, 4, "phrygian", "m", "m7"],
  [3, 2741, -1, "lydian", "", "Maj7"],
  [4, 2774, 1, "mixolydian", "", "7"],
  [5, 2906, 3, "aeolian", "m", "m7", "minor"],
  [6, 3434, 5, "locrian", "dim", "m7b5"]
];
const NoMode = {
  ...EmptyPcset,
  name: "",
  alt: 0,
  modeNum: NaN,
  triad: "",
  seventh: "",
  aliases: []
};
const modes = MODES.map(toMode);
const index$1 = {};
modes.forEach((mode) => {
  index$1[mode.name] = mode;
  mode.aliases.forEach((alias) => {
    index$1[alias] = mode;
  });
});
function get$1(name2) {
  return typeof name2 === "string" ? index$1[name2.toLowerCase()] || NoMode : name2 && name2.name ? get$1(name2.name) : NoMode;
}
function toMode(mode) {
  const [modeNum, setNum, alt, name2, triad, seventh, alias] = mode;
  const aliases = alias ? [alias] : [];
  const chroma2 = Number(setNum).toString(2);
  const intervals2 = get$3(name2).intervals;
  return {
    empty: false,
    intervals: intervals2,
    modeNum,
    chroma: chroma2,
    normalized: chroma2,
    name: name2,
    setNum,
    alt,
    triad,
    seventh,
    aliases
  };
}
function chords$1(chords2) {
  return (modeName, tonic) => {
    const mode = get$1(modeName);
    if (mode.empty)
      return [];
    const triads = rotate(mode.modeNum, chords2);
    const tonics = mode.intervals.map((i2) => transpose$1(tonic, i2));
    return triads.map((triad, i2) => tonics[i2] + triad);
  };
}
chords$1(MODES.map((x2) => x2[4]));
chords$1(MODES.map((x2) => x2[5]));
const NoScale = {
  empty: true,
  name: "",
  type: "",
  tonic: null,
  setNum: NaN,
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function tokenize(name2) {
  if (typeof name2 !== "string") {
    return ["", ""];
  }
  const i2 = name2.indexOf(" ");
  const tonic = note(name2.substring(0, i2));
  if (tonic.empty) {
    const n2 = note(name2);
    return n2.empty ? ["", name2] : [n2.name, ""];
  }
  const type = name2.substring(tonic.name.length + 1);
  return [tonic.name, type.length ? type : ""];
}
const names = names$2;
function get(src) {
  const tokens = Array.isArray(src) ? src : tokenize(src);
  const tonic = note(tokens[0]).name;
  const st = get$3(tokens[1]);
  if (st.empty) {
    return NoScale;
  }
  const type = st.name;
  const notes2 = tonic ? st.intervals.map((i2) => transpose$1(tonic, i2)) : [];
  const name2 = tonic ? tonic + " " + type : type;
  return { ...st, name: name2, type, tonic, notes: notes2 };
}
const scale = deprecate("Scale.scale", "Scale.get", get);
function scaleChords(name2) {
  const s2 = get(name2);
  const inScale = isSubsetOf(s2.chroma);
  return all$1().filter((chord) => inScale(chord.chroma)).map((chord) => chord.aliases[0]);
}
function extended(name2) {
  const s2 = get(name2);
  const isSuperset = isSupersetOf(s2.chroma);
  return all().filter((scale2) => isSuperset(scale2.chroma)).map((scale2) => scale2.name);
}
function reduced(name2) {
  const isSubset = isSubsetOf(get(name2).chroma);
  return all().filter((scale2) => isSubset(scale2.chroma)).map((scale2) => scale2.name);
}
function scaleNotes(notes2) {
  const pcset2 = notes2.map((n2) => note(n2).pc).filter((x2) => x2);
  const tonic = pcset2[0];
  const scale2 = sortedUniqNames(pcset2);
  return rotate(scale2.indexOf(tonic), scale2);
}
function modeNames(name2) {
  const s2 = get(name2);
  if (s2.empty) {
    return [];
  }
  const tonics = s2.tonic ? s2.notes : s2.intervals;
  return modes$1(s2.chroma).map((chroma2, i2) => {
    const modeName = get(chroma2).name;
    return modeName ? [tonics[i2], modeName] : ["", ""];
  }).filter((x2) => x2[0]);
}
function getNoteNameOf(scale2) {
  const names2 = Array.isArray(scale2) ? scaleNotes(scale2) : get(scale2).notes;
  const chromas2 = names2.map((name2) => note(name2).chroma);
  return (noteOrMidi) => {
    const currNote = typeof noteOrMidi === "number" ? note(fromMidi(noteOrMidi)) : note(noteOrMidi);
    const height = currNote.height;
    if (height === void 0)
      return void 0;
    const chroma2 = height % 12;
    const position = chromas2.indexOf(chroma2);
    if (position === -1)
      return void 0;
    return enharmonic(currNote.name, names2[position]);
  };
}
function rangeOf(scale2) {
  const getName = getNoteNameOf(scale2);
  return (fromNote, toNote) => {
    const from = note(fromNote).height;
    const to = note(toNote).height;
    if (from === void 0 || to === void 0)
      return [];
    return range(from, to).map(getName).filter((x2) => x2);
  };
}
var index = {
  get,
  names,
  extended,
  modeNames,
  reduced,
  scaleChords,
  scaleNotes,
  tokenize,
  rangeOf,
  scale
};
index$1$2.add(["1P", "2m"], ["2m"], "minor second");
index$1$2.add(["1P", "2M"], ["2M"], "major second");
index$1$2.add(["1P", "3m"], ["3m"], "minor third");
index$1$2.add(["1P", "3M"], ["3M"], "major third");
index$1$2.add(["1P", "4P"], ["4P"], "perfect fourth");
index$1$2.add(["1P", "5d"], ["TT"], "tritone");
index$1$2.add(["1P", "5P"], ["5P"], "perfect fifth");
index$1$2.add(["1P", "6m"], ["6m"], "minor sixth");
index$1$2.add(["1P", "6M"], ["6M"], "major sixth");
index$1$2.add(["1P", "7m"], ["7m"], "minor seventh");
index$1$2.add(["1P", "7M"], ["7M"], "major seventh");
const chordType = index$1$2;
const scaleType = index$1$1;
const chordList = index$1$2.all();
const scaleList = index$1$1.all();
const intervals = ["1P", "2m", "2M", "3m", "3M", "4P", "TT", "5P", "6m", "6M", "7m", "7M"];
const noteNames = [];
const naturals = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
const sharps = ["G##", "A#", "A##", "B#", "C#", "C##", "D#", "D##", "E#", "F#", "F##", "G#"];
const flats = ["Bbb", "Bb", "Cb", "Dbb", "Db", "Ebb", "Eb", "Fb", "Gbb", "Gb", "Abb", "Ab"];
naturals.forEach((note2, n2) => {
  noteNames[note2] = n2;
});
sharps.forEach((note2, n2) => {
  noteNames[note2] = n2;
});
flats.forEach((note2, n2) => {
  noteNames[note2] = n2;
});
const notes = naturals;
const chords = {
  min: { handle: "min", name: "Minor", semitones: [0, 3, 7] },
  maj: { handle: "maj", name: "Major", semitones: [0, 4, 7] },
  aug: { handle: "aug", name: "Augmented", semitones: [0, 4, 8] },
  dim: { handle: "dim", name: "Diminished", semitones: [0, 3, 6] },
  M7: { handle: "M7", name: "Major 7th", semitones: [0, 4, 7, 11] },
  m7: { handle: "m7", name: "Minor 7th", semitones: [0, 3, 7, 10] },
  "7": { handle: "7", name: "Dominant 7th", semitones: [0, 4, 7, 10] },
  "+7": { handle: "+7", name: "Augmented 7th", semitones: [0, 4, 8, 10] },
  o7: { handle: "o7", name: "Diminished 7th", semitones: [0, 3, 6, 9] },
  "07": { handle: "07", name: "Half-diminished 7th", semitones: [0, 3, 6, 10] },
  "+M7": { handle: "+M7", name: "Augmented major 7th", semitones: [0, 3, 7, 11] },
  "6": { handle: "6", name: "Major 6th", semitones: [0, 4, 7, 9] },
  m6: { handle: "m6", name: "Minor 6th", semitones: [0, 3, 7, 9] },
  sus2: { handle: "sus2", name: "Suspended 2nd", semitones: [0, 2, 7] },
  sus4: { handle: "sus4", name: "Suspended 4th", semitones: [0, 5, 7] },
  "9": { handle: "9", name: "9th", semitones: [0, 3, 7, 13] }
};
const scales = {
  major: {
    handle: "major",
    name: "Major (Ionian)",
    chords: ["maj", "", "min", "", "min", "maj", "", "7", "", "min", "", "dim"],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]
  },
  minor: {
    handle: "minor",
    name: "Minor (Aeolian)",
    chords: ["min", "", "dim", "maj", "", "min", "", "min", "maj", "", "7", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]
  },
  dorian: {
    handle: "dorian",
    name: "Dorian",
    chords: ["min", "", "min", "maj", "", "7", "", "min", "", "dim", "maj", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0]
  },
  phrygian: {
    handle: "phrygian",
    name: "Phrygian",
    chords: ["min", "maj", "", "7", "", "min", "", "dim", "maj", "", "min", ""],
    steps: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0]
  },
  lydian: {
    handle: "lydian",
    name: "Lydian",
    chords: ["maj", "", "7", "", "min", "", "dim", "maj", "", "min", "", "min"],
    steps: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1]
  },
  mixolydian: {
    handle: "mixolydian",
    name: "Mixolydian",
    chords: ["7", "", "min", "", "dim", "maj", "", "min", "", "min", "maj", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0]
  },
  locrian: {
    handle: "locrian",
    name: "Locrian",
    chords: ["dim", "maj", "", "min", "", "min", "maj", "", "7", "", "min", ""],
    steps: [1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0]
  },
  majorPenta: {
    handle: "majorPenta",
    name: "Major pentatonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0]
  },
  minorPenta: {
    handle: "minorPenta",
    name: "Minor pentatonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0]
  },
  acoustic: {
    handle: "acoustic",
    name: "Acoustic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0]
  },
  adonai: {
    handle: "adonai",
    name: "Adonai malakh",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0]
  },
  algerian: {
    handle: "algerian",
    name: "Algerian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]
  },
  augmented: {
    handle: "augmented",
    name: "Augmented",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1]
  },
  bebopDom: {
    handle: "bebopDom",
    name: "Bebop dominant",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1]
  },
  bebopMaj: {
    handle: "bebopMaj",
    name: "Bebop major",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1]
  },
  bluesHexa: {
    handle: "bluesHexa",
    name: "Blues hexatonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0]
  },
  doubleHarmonic: {
    handle: "doubleHarmonic",
    name: "Double harmonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1]
  },
  enigmatic: {
    handle: "enigmatic",
    name: "Enigmatic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1]
  },
  gypsy: {
    handle: "gypsy",
    name: "Gypsy",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0]
  },
  halfDim: {
    handle: "halfDim",
    name: "Half diminished",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0]
  },
  harmonicMaj: {
    handle: "harmonicMaj",
    name: "Harmonic major",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1]
  },
  harmonicMin: {
    handle: "harmonicMin",
    name: "Harmonic minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1]
  },
  hungarianMin: {
    handle: "hungarianMin",
    name: "Hungarian minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]
  },
  istrian: {
    handle: "istrian",
    name: "Istrian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0]
  },
  lydianAug: {
    handle: "lydianAug",
    name: "Lydian augmented",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1]
  },
  majLocrian: {
    handle: "majLocrian",
    name: "Major locrian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0]
  },
  jazzMin: {
    handle: "jazzMin",
    name: "Jazz minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1]
  },
  neapolitanMaj: {
    handle: "neapolitanMaj",
    name: "Neapolitan major",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
  },
  neapolitanMin: {
    handle: "neapolitanMin",
    name: "Neapolitan minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1]
  },
  octatonic: {
    handle: "octatonic",
    name: "Octatonic (diminished)",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1]
  },
  persian: {
    handle: "persian",
    name: "Persian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1]
  },
  phrygianDom: {
    handle: "phrygianDom",
    name: "Phrygian dominant",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0]
  },
  prometheus: {
    handle: "prometheus",
    name: "Prometheus",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0]
  },
  tritone: {
    handle: "tritone",
    name: "Tritone",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0]
  },
  ukranianDorian: {
    handle: "ukranianDorian",
    name: "Ukranian dorian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0]
  },
  wholeTone: {
    handle: "wholeTone",
    name: "Whole tone",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
  },
  chromatic: {
    handle: "chromatic",
    name: "Chromatic",
    chords: [
      "1/1",
      "25/24",
      "9/8",
      "6/5",
      "5/4",
      "4/3",
      "45/32",
      "3/2",
      "8/5",
      "5/3",
      "9/5",
      "15/8"
    ],
    steps: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  }
};
const allNotes = [...notes].map((n2, i2) => ({ name: n2, pitch: i2 }));
const globalScale = reactive({
  tonic: useClamp(useStorage("global-tonic", 0), 0, 11),
  note: computed(() => allNotes[globalScale.tonic]),
  chroma: useStorage("global-chroma", "101011010101"),
  set: computed(() => index$1$1.get(globalScale.chroma)),
  full: computed(() => {
    let sc = globalScale.note.name + "4 " + globalScale.set.name;
    return index.get(sc);
  }),
  pcs: computed(() => index.scaleNotes(globalScale.full.notes)),
  isIn: computed(() => index$5.isNoteIncludedIn(globalScale.pcs))
});
function getChromaNotes(chroma2 = "100010010000", tonic = globalScale.tonic) {
  let shiftChroma = rotateArray(chroma2.split(""), -tonic);
  let chOct = rotateArray(allNotes, -tonic).map((n2, i2) => {
    let noteName = Frequency(n2.pitch + tonic + 57, "midi").toNote();
    return noteName;
  });
  let filtered = chOct.filter((val, i2) => {
    if (shiftChroma[i2] == "1") {
      return true;
    }
  });
  return index$2.sortedNames(filtered);
}
function playChromaOnce(chroma2, tonic) {
  let notes2 = getChromaNotes(chroma2, tonic);
  notes2.forEach((name2, i2) => {
    midiOnce(name2);
  });
  synthOnce(notes2, "4n");
}
function playChroma(chroma2, tonic) {
  let notes2 = getChromaNotes(chroma2, tonic);
  notes2.forEach((name2) => {
    midiPlay(name2);
  });
  synthAttack(notes2);
}
function stopChroma(chroma2, tonic) {
  let notes2 = getChromaNotes(chroma2, tonic);
  notes2.forEach((name2) => {
    midiStop(name2);
  });
  synthRelease(notes2);
}
function playNote(name2) {
  midiPlay(name2);
  synthAttack(name2);
}
function stopNote(name2) {
  midiStop(name2);
  synthRelease(name2);
}
var r$5 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, t$5 = function(r2) {
  return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
}, n$5 = function(r2, t2, n2) {
  return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
}, e$5 = function(r2, t2, n2) {
  return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
}, u$5 = function(r2) {
  return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
}, a$5 = function(r2) {
  return { r: e$5(r2.r, 0, 255), g: e$5(r2.g, 0, 255), b: e$5(r2.b, 0, 255), a: e$5(r2.a) };
}, o$5 = function(r2) {
  return { r: n$5(r2.r), g: n$5(r2.g), b: n$5(r2.b), a: n$5(r2.a, 3) };
}, i$5 = /^#([0-9a-f]{3,8})$/i, s$1 = function(r2) {
  var t2 = r2.toString(16);
  return t2.length < 2 ? "0" + t2 : t2;
}, h$4 = function(r2) {
  var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
  return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
}, b$3 = function(r2) {
  var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
  t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
  var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
  return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
}, g = function(r2) {
  return { h: u$5(r2.h), s: e$5(r2.s, 0, 100), l: e$5(r2.l, 0, 100), a: e$5(r2.a) };
}, d$2 = function(r2) {
  return { h: n$5(r2.h), s: n$5(r2.s), l: n$5(r2.l), a: n$5(r2.a, 3) };
}, f$2 = function(r2) {
  return b$3((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
  var t2, n2, e2;
}, c$3 = function(r2) {
  return { h: (t2 = h$4(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
  var t2, n2, e2, u2;
}, l$2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, p$3 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, v$1 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, m$1 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, y$1 = { string: [[function(r2) {
  var t2 = i$5.exec(r2);
  return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: r2.length === 4 ? n$5(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : r2.length === 6 || r2.length === 8 ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: r2.length === 8 ? n$5(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r2) {
  var t2 = v$1.exec(r2) || m$1.exec(r2);
  return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a$5({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: t2[7] === void 0 ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t2) {
  var n2 = l$2.exec(t2) || p$3.exec(t2);
  if (!n2)
    return null;
  var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], u2 === void 0 && (u2 = "deg"), Number(e2) * (r$5[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: n2[5] === void 0 ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return f$2(a2);
}, "hsl"]], object: [[function(r2) {
  var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = o2 === void 0 ? 1 : o2;
  return t$5(n2) && t$5(e2) && t$5(u2) ? a$5({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
}, "rgb"], [function(r2) {
  var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = a2 === void 0 ? 1 : a2;
  if (!t$5(n2) || !t$5(e2) || !t$5(u2))
    return null;
  var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
  return f$2(i2);
}, "hsl"], [function(r2) {
  var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = i2 === void 0 ? 1 : i2;
  if (!t$5(n2) || !t$5(a2) || !t$5(o2))
    return null;
  var h2 = function(r3) {
    return { h: u$5(r3.h), s: e$5(r3.s, 0, 100), v: e$5(r3.v, 0, 100), a: e$5(r3.a) };
  }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
  return b$3(h2);
}, "hsv"]] }, N = function(r2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var e2 = t2[n2][0](r2);
    if (e2)
      return [e2, t2[n2][1]];
  }
  return [null, void 0];
}, x$2 = function(r2) {
  return typeof r2 == "string" ? N(r2.trim(), y$1.string) : typeof r2 == "object" && r2 !== null ? N(r2, y$1.object) : [null, void 0];
}, M$2 = function(r2, t2) {
  var n2 = c$3(r2);
  return { h: n2.h, s: e$5(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
}, H = function(r2) {
  return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
}, $ = function(r2, t2) {
  var n2 = c$3(r2);
  return { h: n2.h, s: n2.s, l: e$5(n2.l + 100 * t2, 0, 100), a: n2.a };
}, j = function() {
  function r2(r3) {
    this.parsed = x$2(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r2.prototype.isValid = function() {
    return this.parsed !== null;
  }, r2.prototype.brightness = function() {
    return n$5(H(this.rgba), 2);
  }, r2.prototype.isDark = function() {
    return H(this.rgba) < 0.5;
  }, r2.prototype.isLight = function() {
    return H(this.rgba) >= 0.5;
  }, r2.prototype.toHex = function() {
    return r3 = o$5(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s$1(n$5(255 * a2)) : "", "#" + s$1(t2) + s$1(e2) + s$1(u2) + i2;
    var r3, t2, e2, u2, a2, i2;
  }, r2.prototype.toRgb = function() {
    return o$5(this.rgba);
  }, r2.prototype.toRgbString = function() {
    return r3 = o$5(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsl = function() {
    return d$2(c$3(this.rgba));
  }, r2.prototype.toHslString = function() {
    return r3 = d$2(c$3(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsv = function() {
    return r3 = h$4(this.rgba), { h: n$5(r3.h), s: n$5(r3.s), v: n$5(r3.v), a: n$5(r3.a, 3) };
    var r3;
  }, r2.prototype.invert = function() {
    return w$1({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
    var r3;
  }, r2.prototype.saturate = function(r3) {
    return r3 === void 0 && (r3 = 0.1), w$1(M$2(this.rgba, r3));
  }, r2.prototype.desaturate = function(r3) {
    return r3 === void 0 && (r3 = 0.1), w$1(M$2(this.rgba, -r3));
  }, r2.prototype.grayscale = function() {
    return w$1(M$2(this.rgba, -1));
  }, r2.prototype.lighten = function(r3) {
    return r3 === void 0 && (r3 = 0.1), w$1($(this.rgba, r3));
  }, r2.prototype.darken = function(r3) {
    return r3 === void 0 && (r3 = 0.1), w$1($(this.rgba, -r3));
  }, r2.prototype.rotate = function(r3) {
    return r3 === void 0 && (r3 = 15), this.hue(this.hue() + r3);
  }, r2.prototype.alpha = function(r3) {
    return typeof r3 == "number" ? w$1({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n$5(this.rgba.a, 3);
    var t2;
  }, r2.prototype.hue = function(r3) {
    var t2 = c$3(this.rgba);
    return typeof r3 == "number" ? w$1({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n$5(t2.h);
  }, r2.prototype.isEqual = function(r3) {
    return this.toHex() === w$1(r3).toHex();
  }, r2;
}(), w$1 = function(r2) {
  return r2 instanceof j ? r2 : new j(r2);
}, S = [], k = function(r2) {
  r2.forEach(function(r3) {
    S.indexOf(r3) < 0 && (r3(j, y$1), S.push(r3));
  });
};
var r$4 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, t$4 = function(r2) {
  return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
}, a$4 = function(r2, t2, a2) {
  return t2 === void 0 && (t2 = 0), a2 === void 0 && (a2 = Math.pow(10, t2)), Math.round(a2 * r2) / a2 + 0;
}, n$4 = function(r2, t2, a2) {
  return t2 === void 0 && (t2 = 0), a2 === void 0 && (a2 = 1), r2 > a2 ? a2 : r2 > t2 ? r2 : t2;
}, u$4 = function(r2) {
  var t2 = r2 / 255;
  return t2 < 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
}, h$3 = function(r2) {
  return 255 * (r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : 12.92 * r2);
}, o$4 = 96.422, e$4 = 100, c$2 = 82.521, i$4 = function(r2) {
  var t2, a2, u2 = { x: 0.9555766 * (t2 = r2).x + -0.0230393 * t2.y + 0.0631636 * t2.z, y: -0.0282895 * t2.x + 1.0099416 * t2.y + 0.0210077 * t2.z, z: 0.0122982 * t2.x + -0.020483 * t2.y + 1.3299098 * t2.z };
  return a2 = { r: h$3(0.032404542 * u2.x - 0.015371385 * u2.y - 4985314e-9 * u2.z), g: h$3(-969266e-8 * u2.x + 0.018760108 * u2.y + 41556e-8 * u2.z), b: h$3(556434e-9 * u2.x - 2040259e-9 * u2.y + 0.010572252 * u2.z), a: r2.a }, { r: n$4(a2.r, 0, 255), g: n$4(a2.g, 0, 255), b: n$4(a2.b, 0, 255), a: n$4(a2.a) };
}, l$1 = function(r2) {
  var t2 = u$4(r2.r), a2 = u$4(r2.g), h2 = u$4(r2.b);
  return function(r3) {
    return { x: n$4(r3.x, 0, o$4), y: n$4(r3.y, 0, e$4), z: n$4(r3.z, 0, c$2), a: n$4(r3.a) };
  }(function(r3) {
    return { x: 1.0478112 * r3.x + 0.0228866 * r3.y + -0.050127 * r3.z, y: 0.0295424 * r3.x + 0.9904844 * r3.y + -0.0170491 * r3.z, z: -92345e-7 * r3.x + 0.0150436 * r3.y + 0.7521316 * r3.z, a: r3.a };
  }({ x: 100 * (0.4124564 * t2 + 0.3575761 * a2 + 0.1804375 * h2), y: 100 * (0.2126729 * t2 + 0.7151522 * a2 + 0.072175 * h2), z: 100 * (0.0193339 * t2 + 0.119192 * a2 + 0.9503041 * h2), a: r2.a }));
}, f$1 = 216 / 24389, b$2 = 24389 / 27, d$1 = function(r2) {
  return { l: n$4(r2.l, 0, 100), c: r2.c, h: (t2 = r2.h, (t2 = isFinite(t2) ? t2 % 360 : 0) > 0 ? t2 : t2 + 360), a: r2.a };
  var t2;
}, p$2 = function(r2) {
  return { l: a$4(r2.l, 2), c: a$4(r2.c, 2), h: a$4(r2.h, 2), a: a$4(r2.a, 3) };
}, v = function(r2) {
  var a2 = r2.l, n2 = r2.c, u2 = r2.h, h2 = r2.a, o2 = h2 === void 0 ? 1 : h2;
  if (!t$4(a2) || !t$4(n2) || !t$4(u2))
    return null;
  var e2 = d$1({ l: Number(a2), c: Number(n2), h: Number(u2), a: Number(o2) });
  return M$1(e2);
}, y = function(r2) {
  var t2 = function(r3) {
    var t3 = l$1(r3), a2 = t3.x / o$4, n3 = t3.y / e$4, u3 = t3.z / c$2;
    return a2 = a2 > f$1 ? Math.cbrt(a2) : (b$2 * a2 + 16) / 116, { l: 116 * (n3 = n3 > f$1 ? Math.cbrt(n3) : (b$2 * n3 + 16) / 116) - 16, a: 500 * (a2 - n3), b: 200 * (n3 - (u3 = u3 > f$1 ? Math.cbrt(u3) : (b$2 * u3 + 16) / 116)), alpha: t3.a };
  }(r2), n2 = a$4(t2.a, 3), u2 = a$4(t2.b, 3), h2 = Math.atan2(u2, n2) / Math.PI * 180;
  return { l: t2.l, c: Math.sqrt(n2 * n2 + u2 * u2), h: h2 < 0 ? h2 + 360 : h2, a: t2.alpha };
}, M$1 = function(r2) {
  return t2 = { l: r2.l, a: r2.c * Math.cos(r2.h * Math.PI / 180), b: r2.c * Math.sin(r2.h * Math.PI / 180), alpha: r2.a }, n2 = t2.a / 500 + (a2 = (t2.l + 16) / 116), u2 = a2 - t2.b / 200, i$4({ x: (Math.pow(n2, 3) > f$1 ? Math.pow(n2, 3) : (116 * n2 - 16) / b$2) * o$4, y: (t2.l > 8 ? Math.pow((t2.l + 16) / 116, 3) : t2.l / b$2) * e$4, z: (Math.pow(u2, 3) > f$1 ? Math.pow(u2, 3) : (116 * u2 - 16) / b$2) * c$2, a: t2.alpha });
  var t2, a2, n2, u2;
}, x$1 = /^lch\(\s*([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, s = function(t2) {
  var a2 = x$1.exec(t2);
  if (!a2)
    return null;
  var n2, u2, h2 = d$1({ l: Number(a2[1]), c: Number(a2[2]), h: (n2 = a2[3], u2 = a2[4], u2 === void 0 && (u2 = "deg"), Number(n2) * (r$4[u2] || 1)), a: a2[5] === void 0 ? 1 : Number(a2[5]) / (a2[6] ? 100 : 1) });
  return M$1(h2);
};
function lchPlugin(r2, t2) {
  r2.prototype.toLch = function() {
    return p$2(y(this.rgba));
  }, r2.prototype.toLchString = function() {
    return r3 = p$2(y(this.rgba)), t3 = r3.l, a2 = r3.c, n2 = r3.h, (u2 = r3.a) < 1 ? "lch(" + t3 + "% " + a2 + " " + n2 + " / " + u2 + ")" : "lch(" + t3 + "% " + a2 + " " + n2 + ")";
    var r3, t3, a2, n2, u2;
  }, t2.string.push([s, "lch"]), t2.object.push([v, "lch"]);
}
var t$3 = function(t2, a2, n2) {
  return a2 === void 0 && (a2 = 0), n2 === void 0 && (n2 = 1), t2 > n2 ? n2 : t2 > a2 ? t2 : a2;
}, a$3 = function(t2) {
  var a2 = t2 / 255;
  return a2 < 0.04045 ? a2 / 12.92 : Math.pow((a2 + 0.055) / 1.055, 2.4);
}, n$3 = function(t2) {
  return 255 * (t2 > 31308e-7 ? 1.055 * Math.pow(t2, 1 / 2.4) - 0.055 : 12.92 * t2);
}, r$3 = 96.422, o$3 = 100, u$3 = 82.521, e$3 = function(a2) {
  var r2, o2, u2 = { x: 0.9555766 * (r2 = a2).x + -0.0230393 * r2.y + 0.0631636 * r2.z, y: -0.0282895 * r2.x + 1.0099416 * r2.y + 0.0210077 * r2.z, z: 0.0122982 * r2.x + -0.020483 * r2.y + 1.3299098 * r2.z };
  return o2 = { r: n$3(0.032404542 * u2.x - 0.015371385 * u2.y - 4985314e-9 * u2.z), g: n$3(-969266e-8 * u2.x + 0.018760108 * u2.y + 41556e-8 * u2.z), b: n$3(556434e-9 * u2.x - 2040259e-9 * u2.y + 0.010572252 * u2.z), a: a2.a }, { r: t$3(o2.r, 0, 255), g: t$3(o2.g, 0, 255), b: t$3(o2.b, 0, 255), a: t$3(o2.a) };
}, i$3 = function(n2) {
  var e2 = a$3(n2.r), i2 = a$3(n2.g), p2 = a$3(n2.b);
  return function(a2) {
    return { x: t$3(a2.x, 0, r$3), y: t$3(a2.y, 0, o$3), z: t$3(a2.z, 0, u$3), a: t$3(a2.a) };
  }(function(t2) {
    return { x: 1.0478112 * t2.x + 0.0228866 * t2.y + -0.050127 * t2.z, y: 0.0295424 * t2.x + 0.9904844 * t2.y + -0.0170491 * t2.z, z: -92345e-7 * t2.x + 0.0150436 * t2.y + 0.7521316 * t2.z, a: t2.a };
  }({ x: 100 * (0.4124564 * e2 + 0.3575761 * i2 + 0.1804375 * p2), y: 100 * (0.2126729 * e2 + 0.7151522 * i2 + 0.072175 * p2), z: 100 * (0.0193339 * e2 + 0.119192 * i2 + 0.9503041 * p2), a: n2.a }));
}, p$1 = 216 / 24389, h$2 = 24389 / 27, f = function(t2) {
  var a2 = i$3(t2), n2 = a2.x / r$3, e2 = a2.y / o$3, f2 = a2.z / u$3;
  return n2 = n2 > p$1 ? Math.cbrt(n2) : (h$2 * n2 + 16) / 116, { l: 116 * (e2 = e2 > p$1 ? Math.cbrt(e2) : (h$2 * e2 + 16) / 116) - 16, a: 500 * (n2 - e2), b: 200 * (e2 - (f2 = f2 > p$1 ? Math.cbrt(f2) : (h$2 * f2 + 16) / 116)), alpha: a2.a };
}, c$1 = function(a2, n2, i2) {
  var c2, y2 = f(a2), x2 = f(n2);
  return function(t2) {
    var a3 = (t2.l + 16) / 116, n3 = t2.a / 500 + a3, i3 = a3 - t2.b / 200;
    return e$3({ x: (Math.pow(n3, 3) > p$1 ? Math.pow(n3, 3) : (116 * n3 - 16) / h$2) * r$3, y: (t2.l > 8 ? Math.pow((t2.l + 16) / 116, 3) : t2.l / h$2) * o$3, z: (Math.pow(i3, 3) > p$1 ? Math.pow(i3, 3) : (116 * i3 - 16) / h$2) * u$3, a: t2.alpha });
  }({ l: t$3((c2 = { l: y2.l * (1 - i2) + x2.l * i2, a: y2.a * (1 - i2) + x2.a * i2, b: y2.b * (1 - i2) + x2.b * i2, alpha: y2.alpha * (1 - i2) + x2.alpha * i2 }).l, 0, 400), a: c2.a, b: c2.b, alpha: t$3(c2.alpha) });
};
function mixPlugin(t2) {
  function a2(t3, a3, n2) {
    n2 === void 0 && (n2 = 5);
    for (var r2 = [], o2 = 1 / (n2 - 1), u2 = 0; u2 <= n2 - 1; u2++)
      r2.push(t3.mix(a3, o2 * u2));
    return r2;
  }
  t2.prototype.mix = function(a3, n2) {
    n2 === void 0 && (n2 = 0.5);
    var r2 = a3 instanceof t2 ? a3 : new t2(a3), o2 = c$1(this.toRgb(), r2.toRgb(), n2);
    return new t2(o2);
  }, t2.prototype.tints = function(t3) {
    return a2(this, "#fff", t3);
  }, t2.prototype.shades = function(t3) {
    return a2(this, "#000", t3);
  }, t2.prototype.tones = function(t3) {
    return a2(this, "#808080", t3);
  };
}
function namesPlugin(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a2)
    r2[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2)
      return n2;
    if (f3 == null ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length)
        for (var c2 in a2)
          l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d3 = r3 === "transparent" ? "#0000" : a2[r3];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}
var a$2 = function(a2) {
  return typeof a2 == "string" ? a2.length > 0 : typeof a2 == "number";
}, t$2 = function(a2, t2, o2) {
  return t2 === void 0 && (t2 = 0), o2 === void 0 && (o2 = Math.pow(10, t2)), Math.round(o2 * a2) / o2 + 0;
}, o$2 = function(a2, t2, o2) {
  return t2 === void 0 && (t2 = 0), o2 === void 0 && (o2 = 1), a2 > o2 ? o2 : a2 > t2 ? a2 : t2;
}, r$2 = function(a2) {
  var t2 = a2 / 255;
  return t2 < 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
}, h$1 = function(a2) {
  return 255 * (a2 > 31308e-7 ? 1.055 * Math.pow(a2, 1 / 2.4) - 0.055 : 12.92 * a2);
}, n$2 = 96.422, p = 100, M = 82.521, u$2 = function(a2) {
  var t2, r2, n2 = { x: 0.9555766 * (t2 = a2).x + -0.0230393 * t2.y + 0.0631636 * t2.z, y: -0.0282895 * t2.x + 1.0099416 * t2.y + 0.0210077 * t2.z, z: 0.0122982 * t2.x + -0.020483 * t2.y + 1.3299098 * t2.z };
  return r2 = { r: h$1(0.032404542 * n2.x - 0.015371385 * n2.y - 4985314e-9 * n2.z), g: h$1(-969266e-8 * n2.x + 0.018760108 * n2.y + 41556e-8 * n2.z), b: h$1(556434e-9 * n2.x - 2040259e-9 * n2.y + 0.010572252 * n2.z), a: a2.a }, { r: o$2(r2.r, 0, 255), g: o$2(r2.g, 0, 255), b: o$2(r2.b, 0, 255), a: o$2(r2.a) };
}, e$2 = function(a2) {
  var t2 = r$2(a2.r), h2 = r$2(a2.g), u2 = r$2(a2.b);
  return function(a3) {
    return { x: o$2(a3.x, 0, n$2), y: o$2(a3.y, 0, p), z: o$2(a3.z, 0, M), a: o$2(a3.a) };
  }(function(a3) {
    return { x: 1.0478112 * a3.x + 0.0228866 * a3.y + -0.050127 * a3.z, y: 0.0295424 * a3.x + 0.9904844 * a3.y + -0.0170491 * a3.z, z: -92345e-7 * a3.x + 0.0150436 * a3.y + 0.7521316 * a3.z, a: a3.a };
  }({ x: 100 * (0.4124564 * t2 + 0.3575761 * h2 + 0.1804375 * u2), y: 100 * (0.2126729 * t2 + 0.7151522 * h2 + 0.072175 * u2), z: 100 * (0.0193339 * t2 + 0.119192 * h2 + 0.9503041 * u2), a: a2.a }));
}, w = 216 / 24389, b$1 = 24389 / 27, i$2 = function(t2) {
  var r2 = t2.l, h2 = t2.a, n2 = t2.b, p2 = t2.alpha, M2 = p2 === void 0 ? 1 : p2;
  if (!a$2(r2) || !a$2(h2) || !a$2(n2))
    return null;
  var u2 = function(a2) {
    return { l: o$2(a2.l, 0, 400), a: a2.a, b: a2.b, alpha: o$2(a2.alpha) };
  }({ l: Number(r2), a: Number(h2), b: Number(n2), alpha: Number(M2) });
  return l(u2);
}, l = function(a2) {
  var t2 = (a2.l + 16) / 116, o2 = a2.a / 500 + t2, r2 = t2 - a2.b / 200;
  return u$2({ x: (Math.pow(o2, 3) > w ? Math.pow(o2, 3) : (116 * o2 - 16) / b$1) * n$2, y: (a2.l > 8 ? Math.pow((a2.l + 16) / 116, 3) : a2.l / b$1) * p, z: (Math.pow(r2, 3) > w ? Math.pow(r2, 3) : (116 * r2 - 16) / b$1) * M, a: a2.alpha });
};
function labPlugin(a2, r2) {
  a2.prototype.toLab = function() {
    return o2 = e$2(this.rgba), h2 = o2.y / p, u2 = o2.z / M, r3 = (r3 = o2.x / n$2) > w ? Math.cbrt(r3) : (b$1 * r3 + 16) / 116, a3 = { l: 116 * (h2 = h2 > w ? Math.cbrt(h2) : (b$1 * h2 + 16) / 116) - 16, a: 500 * (r3 - h2), b: 200 * (h2 - (u2 = u2 > w ? Math.cbrt(u2) : (b$1 * u2 + 16) / 116)), alpha: o2.a }, { l: t$2(a3.l, 2), a: t$2(a3.a, 2), b: t$2(a3.b, 2), alpha: t$2(a3.alpha, 3) };
    var a3, o2, r3, h2, u2;
  }, a2.prototype.delta = function(r3) {
    r3 === void 0 && (r3 = "#FFF");
    var h2 = r3 instanceof a2 ? r3 : new a2(r3), n2 = function(a3, t2) {
      var o2 = a3.l, r4 = a3.a, h3 = a3.b, n3 = t2.l, p2 = t2.a, M2 = t2.b, u2 = 180 / Math.PI, e2 = Math.PI / 180, w2 = Math.pow(Math.pow(r4, 2) + Math.pow(h3, 2), 0.5), b2 = Math.pow(Math.pow(p2, 2) + Math.pow(M2, 2), 0.5), i2 = (o2 + n3) / 2, l2 = Math.pow((w2 + b2) / 2, 7), c2 = 0.5 * (1 - Math.pow(l2 / (l2 + Math.pow(25, 7)), 0.5)), f2 = r4 * (1 + c2), y2 = p2 * (1 + c2), v2 = Math.pow(Math.pow(f2, 2) + Math.pow(h3, 2), 0.5), x2 = Math.pow(Math.pow(y2, 2) + Math.pow(M2, 2), 0.5), z = (v2 + x2) / 2, s2 = f2 === 0 && h3 === 0 ? 0 : Math.atan2(h3, f2) * u2, d2 = y2 === 0 && M2 === 0 ? 0 : Math.atan2(M2, y2) * u2;
      s2 < 0 && (s2 += 360), d2 < 0 && (d2 += 360);
      var g2 = d2 - s2, m2 = Math.abs(d2 - s2);
      m2 > 180 && d2 <= s2 ? g2 += 360 : m2 > 180 && d2 > s2 && (g2 -= 360);
      var N2 = s2 + d2;
      m2 <= 180 ? N2 /= 2 : N2 = (s2 + d2 < 360 ? N2 + 360 : N2 - 360) / 2;
      var F = 1 - 0.17 * Math.cos(e2 * (N2 - 30)) + 0.24 * Math.cos(2 * e2 * N2) + 0.32 * Math.cos(e2 * (3 * N2 + 6)) - 0.2 * Math.cos(e2 * (4 * N2 - 63)), L = n3 - o2, I = x2 - v2, P = 2 * Math.sin(e2 * g2 / 2) * Math.pow(v2 * x2, 0.5), j2 = 1 + 0.015 * Math.pow(i2 - 50, 2) / Math.pow(20 + Math.pow(i2 - 50, 2), 0.5), k2 = 1 + 0.045 * z, q = 1 + 0.015 * z * F, A = 30 * Math.exp(-1 * Math.pow((N2 - 275) / 25, 2)), B = -2 * Math.pow(l2 / (l2 + Math.pow(25, 7)), 0.5) * Math.sin(2 * e2 * A);
      return Math.pow(Math.pow(L / 1 / j2, 2) + Math.pow(I / 1 / k2, 2) + Math.pow(P / 1 / q, 2) + B * I * P / (1 * k2 * 1 * q), 0.5);
    }(this.toLab(), h2.toLab()) / 100;
    return o$2(t$2(n2, 3));
  }, r2.object.push([i$2, "lab"]);
}
var r$1 = function(r2) {
  return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
}, n$1 = function(r2, n2, t2) {
  return n2 === void 0 && (n2 = 0), t2 === void 0 && (t2 = Math.pow(10, n2)), Math.round(t2 * r2) / t2 + 0;
}, t$1 = function(r2, n2, t2) {
  return n2 === void 0 && (n2 = 0), t2 === void 0 && (t2 = 1), r2 > t2 ? t2 : r2 > n2 ? r2 : n2;
}, u$1 = function(r2) {
  return { c: t$1(r2.c, 0, 100), m: t$1(r2.m, 0, 100), y: t$1(r2.y, 0, 100), k: t$1(r2.k, 0, 100), a: t$1(r2.a) };
}, e$1 = function(r2) {
  return { c: n$1(r2.c, 2), m: n$1(r2.m, 2), y: n$1(r2.y, 2), k: n$1(r2.k, 2), a: n$1(r2.a, 3) };
};
function c(r2) {
  return { r: n$1(255 * (1 - r2.c / 100) * (1 - r2.k / 100)), g: n$1(255 * (1 - r2.m / 100) * (1 - r2.k / 100)), b: n$1(255 * (1 - r2.y / 100) * (1 - r2.k / 100)), a: r2.a };
}
function i$1(r2) {
  var t2 = 1 - Math.max(r2.r / 255, r2.g / 255, r2.b / 255), u2 = (1 - r2.r / 255 - t2) / (1 - t2), e2 = (1 - r2.g / 255 - t2) / (1 - t2), c2 = (1 - r2.b / 255 - t2) / (1 - t2);
  return { c: isNaN(u2) ? 0 : n$1(100 * u2), m: isNaN(e2) ? 0 : n$1(100 * e2), y: isNaN(c2) ? 0 : n$1(100 * c2), k: n$1(100 * t2), a: r2.a };
}
function o$1(n2) {
  var t2 = n2.c, e2 = n2.m, i2 = n2.y, o2 = n2.k, m2 = n2.a, a2 = m2 === void 0 ? 1 : m2;
  return r$1(t2) && r$1(e2) && r$1(i2) && r$1(o2) ? c(u$1({ c: Number(t2), m: Number(e2), y: Number(i2), k: Number(o2), a: Number(a2) })) : null;
}
var m = /^device-cmyk\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, a$1 = function(r2) {
  var n2 = m.exec(r2);
  return n2 ? c(u$1({ c: Number(n2[1]) * (n2[2] ? 1 : 100), m: Number(n2[3]) * (n2[4] ? 1 : 100), y: Number(n2[5]) * (n2[6] ? 1 : 100), k: Number(n2[7]) * (n2[8] ? 1 : 100), a: n2[9] === void 0 ? 1 : Number(n2[9]) / (n2[10] ? 100 : 1) })) : null;
};
function cmykPlugin(r2, n2) {
  r2.prototype.toCmyk = function() {
    return e$1(i$1(this.rgba));
  }, r2.prototype.toCmykString = function() {
    return r3 = e$1(i$1(this.rgba)), n3 = r3.c, t2 = r3.m, u2 = r3.y, c2 = r3.k, (o2 = r3.a) < 1 ? "device-cmyk(" + n3 + "% " + t2 + "% " + u2 + "% " + c2 + "% / " + o2 + ")" : "device-cmyk(" + n3 + "% " + t2 + "% " + u2 + "% " + c2 + "%)";
    var r3, n3, t2, u2, c2, o2;
  }, n2.object.push([o$1, "cmyk"]), n2.string.push([a$1, "cmyk"]);
}
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, t = function(r2) {
  return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
}, n = function(r2, t2, n2) {
  return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
}, u = function(r2, t2, n2) {
  return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
}, a = function(r2) {
  return { h: (t2 = r2.h, (t2 = isFinite(t2) ? t2 % 360 : 0) > 0 ? t2 : t2 + 360), w: u(r2.w, 0, 100), b: u(r2.b, 0, 100), a: u(r2.a) };
  var t2;
}, e = function(r2) {
  return { h: n(r2.h), w: n(r2.w), b: n(r2.b), a: n(r2.a, 3) };
}, b = function(r2) {
  return { h: function(r3) {
    var t2 = r3.r, n2 = r3.g, u2 = r3.b, a2 = r3.a, e2 = Math.max(t2, n2, u2), b2 = e2 - Math.min(t2, n2, u2), o2 = b2 ? e2 === t2 ? (n2 - u2) / b2 : e2 === n2 ? 2 + (u2 - t2) / b2 : 4 + (t2 - n2) / b2 : 0;
    return { h: 60 * (o2 < 0 ? o2 + 6 : o2), s: e2 ? b2 / e2 * 100 : 0, v: e2 / 255 * 100, a: a2 };
  }(r2).h, w: Math.min(r2.r, r2.g, r2.b) / 255 * 100, b: 100 - Math.max(r2.r, r2.g, r2.b) / 255 * 100, a: r2.a };
}, o = function(r2) {
  return function(r3) {
    var t2 = r3.h, n2 = r3.s, u2 = r3.v, a2 = r3.a;
    t2 = t2 / 360 * 6, n2 /= 100, u2 /= 100;
    var e2 = Math.floor(t2), b2 = u2 * (1 - n2), o2 = u2 * (1 - (t2 - e2) * n2), i2 = u2 * (1 - (1 - t2 + e2) * n2), h2 = e2 % 6;
    return { r: 255 * [u2, o2, b2, b2, i2, u2][h2], g: 255 * [i2, u2, u2, o2, b2, b2][h2], b: 255 * [b2, b2, i2, u2, u2, o2][h2], a: a2 };
  }({ h: r2.h, s: r2.b === 100 ? 0 : 100 - r2.w / (100 - r2.b) * 100, v: 100 - r2.b, a: r2.a });
}, i = function(r2) {
  var n2 = r2.h, u2 = r2.w, e2 = r2.b, b2 = r2.a, i2 = b2 === void 0 ? 1 : b2;
  if (!t(n2) || !t(u2) || !t(e2))
    return null;
  var h2 = a({ h: Number(n2), w: Number(u2), b: Number(e2), a: Number(i2) });
  return o(h2);
}, h = /^hwb\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, d = function(t2) {
  var n2 = h.exec(t2);
  if (!n2)
    return null;
  var u2, e2, b2 = a({ h: (u2 = n2[1], e2 = n2[2], e2 === void 0 && (e2 = "deg"), Number(u2) * (r[e2] || 1)), w: Number(n2[3]), b: Number(n2[4]), a: n2[5] === void 0 ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return o(b2);
};
function hwbPlugin(r2, t2) {
  r2.prototype.toHwb = function() {
    return e(b(this.rgba));
  }, r2.prototype.toHwbString = function() {
    return r3 = e(b(this.rgba)), t3 = r3.h, n2 = r3.w, u2 = r3.b, (a2 = r3.a) < 1 ? "hwb(" + t3 + " " + n2 + "% " + u2 + "% / " + a2 + ")" : "hwb(" + t3 + " " + n2 + "% " + u2 + "%)";
    var r3, t3, n2, u2, a2;
  }, t2.string.push([d, "hwb"]), t2.object.push([i, "hwb"]);
}
k([mixPlugin, lchPlugin, namesPlugin, labPlugin, cmykPlugin, hwbPlugin]);
function lchToHsl(n2 = 0, total = 12, a2 = 1, s2 = 20, lightness = 60) {
  let lch = `lch(${lightness}% ${s2} ${n2 * (360 / total)} / ${a2})`;
  let hsl = w$1(lch).toHslString();
  return hsl;
}
function getColorInfo(color) {
  const cld = w$1(color);
  let info = {
    dark: cld.isDark(),
    hex: cld.toHex(),
    rgb: cld.toRgbString(),
    name: cld.toName({ closest: true }),
    cmyk: cld.toCmykString(),
    hsl: cld.toHslString(),
    lab: cld.toLab()
  };
  return info;
}
function levelColor(i2 = 0, n2 = 3, a2 = "0.5", s2 = "0.8", l2 = "0.5", reverse = false) {
  if (reverse) {
    i2 = n2 - i2 - 1;
  }
  return `hsla(${i2 * (360 / n2)}, ${s2 * 100}%, ${l2 * 100}%, ${a2})`;
}
function chromaColorMix(chroma2, tonic, part = 0.3) {
  let hsl = w$1(pitchColor(tonic));
  let lch = w$1(lchToHsl(tonic, 12, 1));
  chroma2.split("").forEach((bit, i2) => {
    if (isInChroma(chroma2, tonic, i2)) {
      hsl = hsl.mix(pitchColor(i2), part);
      lch = lch.mix(lchToHsl(i2, 12, 1), part);
    }
  });
  return {
    hsl: hsl.toHslString(),
    lch: lch.toHslString()
  };
}
const tempo = reactive({
  initialized: false,
  bpm: useClamp(useStorage("tempo-bpm", 100), 10, 500),
  blink: false,
  started: false,
  playing: false,
  stopped: false,
  mute: useStorage("tempo-mute", true),
  volume: useClamp(useStorage("tempo-volume", 0.5), 0, 1),
  progress: 0,
  position: 0,
  ticks: 0,
  metre: {
    over: 4,
    under: 4,
    num: computed(() => (tempo.metre.over / (tempo.metre.under / 4)).toFixed(2))
  },
  hz: computed(() => (tempo.bpm / 60).toFixed(2)),
  note: computed(() => index$2.pitchClass(Frequency(tempo.hz).toNote())),
  tune: computed(() => {
    return index$2.pitchClass(tempo.note) + 4;
  }),
  pitch: computed(() => freqPitch(tempo.hz)),
  digit: computed(() => (Frequency(tempo.hz).toMidi() + 12 * 10 + 3) % 12),
  color: computed(() => pitchColor(tempo.digit)),
  tap: {
    last: 0,
    diff: 0,
    timeout: 2e3,
    times: [],
    bpm: null
  },
  set(diff) {
    tempo.bpm = Math.round(diff + tempo.bpm);
  }
});
function useTempo() {
  if (tempo.initialized)
    return tempo;
  const metro = shallowReactive({
    counter: 0
  });
  onMounted(() => {
    const { channel } = createChannel$1("tempo-tick");
    metro.channel = channel;
    metro.pluck = new Sampler({
      urls: {
        E1: "/logic/high.wav",
        E2: "/logic/low.wav"
      },
      volume: -20,
      envelope: {
        attack: 1e-3,
        release: 2
      },
      baseUrl: "/audio/metronome/"
    }).connect(channel);
    metro.loop = new Loop((time) => {
      let even = metro.counter % 2 == 0;
      if (even)
        tempo.blink = true;
      if (!tempo.mute) {
        metro.pluck.triggerAttackRelease(even ? "E1" : "E2", "16n", time, even ? 1 : 0.2);
      }
      metro.counter++;
      setTimeout(() => {
        tempo.blink = false;
      }, 60);
    }, "8n").start(0);
    useRafFn(() => {
      tempo.position = Transport.position;
      tempo.ticks = Transport.ticks;
      tempo.progress = metro.loop.progress;
    });
  });
  watch(() => tempo.volume, (vol) => metro.pluck.volume.rampTo(gainToDb(tempo.volume)));
  watch(() => tempo.bpm, (bpm) => Transport.bpm.rampTo(bpm, "4n"), { immediate: true });
  watch(() => tempo.stopped, (stop) => {
    if (stop) {
      Transport.stop();
      tempo.playing = false;
    }
  });
  watch(() => tempo.playing, (playing) => {
    if (playing) {
      if (!tempo.started) {
        start$1();
        tempo.started = true;
      }
      tempo.stopped = false;
      Transport.start();
    } else {
      Transport.pause();
    }
  }, {
    immediate: true
  });
  tempo.initialized = true;
  return tempo;
}
function tap() {
  var time = performance.now();
  if (tempo.tap.last) {
    tempo.tap.diff = time - tempo.tap.last;
    tempo.tap.times.push(tempo.tap.diff);
    refresh();
  }
  tempo.tap.last = time;
  beginTimeout();
}
function refresh() {
  if (tempo.tap.times.length > 2) {
    var average = tempo.tap.times.reduce((result, t2) => result += t2) / tempo.tap.times.length;
    var bpm = 1 / (average / 1e3) * 60;
    tempo.tap.bpm = bpm;
  }
}
let timer = null;
function beginTimeout() {
  clearTimeout(timer);
  timer = setTimeout(function() {
    tempo.tap.times = [tempo.tap.diff];
    tempo.tap.last = null;
  }, tempo.tap.timeout);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var Midi = {};
var midiFile = {};
function parseMidi(data) {
  var p2 = new Parser(data);
  var headerChunk = p2.readChunk();
  if (headerChunk.id != "MThd")
    throw "Bad MIDI file.  Expected 'MHdr', got: '" + headerChunk.id + "'";
  var header = parseHeader(headerChunk.data);
  var tracks2 = [];
  for (var i2 = 0; !p2.eof() && i2 < header.numTracks; i2++) {
    var trackChunk = p2.readChunk();
    if (trackChunk.id != "MTrk")
      throw "Bad MIDI file.  Expected 'MTrk', got: '" + trackChunk.id + "'";
    var track = parseTrack(trackChunk.data);
    tracks2.push(track);
  }
  return {
    header,
    tracks: tracks2
  };
}
function parseHeader(data) {
  var p2 = new Parser(data);
  var format = p2.readUInt16();
  var numTracks = p2.readUInt16();
  var result = {
    format,
    numTracks
  };
  var timeDivision = p2.readUInt16();
  if (timeDivision & 32768) {
    result.framesPerSecond = 256 - (timeDivision >> 8);
    result.ticksPerFrame = timeDivision & 255;
  } else {
    result.ticksPerBeat = timeDivision;
  }
  return result;
}
function parseTrack(data) {
  var p2 = new Parser(data);
  var events = [];
  while (!p2.eof()) {
    var event = readEvent();
    events.push(event);
  }
  return events;
  var lastEventTypeByte = null;
  function readEvent() {
    var event2 = {};
    event2.deltaTime = p2.readVarInt();
    var eventTypeByte = p2.readUInt8();
    if ((eventTypeByte & 240) === 240) {
      if (eventTypeByte === 255) {
        event2.meta = true;
        var metatypeByte = p2.readUInt8();
        var length = p2.readVarInt();
        switch (metatypeByte) {
          case 0:
            event2.type = "sequenceNumber";
            if (length !== 2)
              throw "Expected length for sequenceNumber event is 2, got " + length;
            event2.number = p2.readUInt16();
            return event2;
          case 1:
            event2.type = "text";
            event2.text = p2.readString(length);
            return event2;
          case 2:
            event2.type = "copyrightNotice";
            event2.text = p2.readString(length);
            return event2;
          case 3:
            event2.type = "trackName";
            event2.text = p2.readString(length);
            return event2;
          case 4:
            event2.type = "instrumentName";
            event2.text = p2.readString(length);
            return event2;
          case 5:
            event2.type = "lyrics";
            event2.text = p2.readString(length);
            return event2;
          case 6:
            event2.type = "marker";
            event2.text = p2.readString(length);
            return event2;
          case 7:
            event2.type = "cuePoint";
            event2.text = p2.readString(length);
            return event2;
          case 32:
            event2.type = "channelPrefix";
            if (length != 1)
              throw "Expected length for channelPrefix event is 1, got " + length;
            event2.channel = p2.readUInt8();
            return event2;
          case 33:
            event2.type = "portPrefix";
            if (length != 1)
              throw "Expected length for portPrefix event is 1, got " + length;
            event2.port = p2.readUInt8();
            return event2;
          case 47:
            event2.type = "endOfTrack";
            if (length != 0)
              throw "Expected length for endOfTrack event is 0, got " + length;
            return event2;
          case 81:
            event2.type = "setTempo";
            if (length != 3)
              throw "Expected length for setTempo event is 3, got " + length;
            event2.microsecondsPerBeat = p2.readUInt24();
            return event2;
          case 84:
            event2.type = "smpteOffset";
            if (length != 5)
              throw "Expected length for smpteOffset event is 5, got " + length;
            var hourByte = p2.readUInt8();
            var FRAME_RATES = { 0: 24, 32: 25, 64: 29, 96: 30 };
            event2.frameRate = FRAME_RATES[hourByte & 96];
            event2.hour = hourByte & 31;
            event2.min = p2.readUInt8();
            event2.sec = p2.readUInt8();
            event2.frame = p2.readUInt8();
            event2.subFrame = p2.readUInt8();
            return event2;
          case 88:
            event2.type = "timeSignature";
            if (length != 2 && length != 4)
              throw "Expected length for timeSignature event is 4 or 2, got " + length;
            event2.numerator = p2.readUInt8();
            event2.denominator = 1 << p2.readUInt8();
            if (length === 4) {
              event2.metronome = p2.readUInt8();
              event2.thirtyseconds = p2.readUInt8();
            } else {
              event2.metronome = 36;
              event2.thirtyseconds = 8;
            }
            return event2;
          case 89:
            event2.type = "keySignature";
            if (length != 2)
              throw "Expected length for keySignature event is 2, got " + length;
            event2.key = p2.readInt8();
            event2.scale = p2.readUInt8();
            return event2;
          case 127:
            event2.type = "sequencerSpecific";
            event2.data = p2.readBytes(length);
            return event2;
          default:
            event2.type = "unknownMeta";
            event2.data = p2.readBytes(length);
            event2.metatypeByte = metatypeByte;
            return event2;
        }
      } else if (eventTypeByte == 240) {
        event2.type = "sysEx";
        var length = p2.readVarInt();
        event2.data = p2.readBytes(length);
        return event2;
      } else if (eventTypeByte == 247) {
        event2.type = "endSysEx";
        var length = p2.readVarInt();
        event2.data = p2.readBytes(length);
        return event2;
      } else {
        throw "Unrecognised MIDI event type byte: " + eventTypeByte;
      }
    } else {
      var param1;
      if ((eventTypeByte & 128) === 0) {
        if (lastEventTypeByte === null)
          throw "Running status byte encountered before status byte";
        param1 = eventTypeByte;
        eventTypeByte = lastEventTypeByte;
        event2.running = true;
      } else {
        param1 = p2.readUInt8();
        lastEventTypeByte = eventTypeByte;
      }
      var eventType = eventTypeByte >> 4;
      event2.channel = eventTypeByte & 15;
      switch (eventType) {
        case 8:
          event2.type = "noteOff";
          event2.noteNumber = param1;
          event2.velocity = p2.readUInt8();
          return event2;
        case 9:
          var velocity = p2.readUInt8();
          event2.type = velocity === 0 ? "noteOff" : "noteOn";
          event2.noteNumber = param1;
          event2.velocity = velocity;
          if (velocity === 0)
            event2.byte9 = true;
          return event2;
        case 10:
          event2.type = "noteAftertouch";
          event2.noteNumber = param1;
          event2.amount = p2.readUInt8();
          return event2;
        case 11:
          event2.type = "controller";
          event2.controllerType = param1;
          event2.value = p2.readUInt8();
          return event2;
        case 12:
          event2.type = "programChange";
          event2.programNumber = param1;
          return event2;
        case 13:
          event2.type = "channelAftertouch";
          event2.amount = param1;
          return event2;
        case 14:
          event2.type = "pitchBend";
          event2.value = param1 + (p2.readUInt8() << 7) - 8192;
          return event2;
        default:
          throw "Unrecognised MIDI event type: " + eventType;
      }
    }
  }
}
function Parser(data) {
  this.buffer = data;
  this.bufferLen = this.buffer.length;
  this.pos = 0;
}
Parser.prototype.eof = function() {
  return this.pos >= this.bufferLen;
};
Parser.prototype.readUInt8 = function() {
  var result = this.buffer[this.pos];
  this.pos += 1;
  return result;
};
Parser.prototype.readInt8 = function() {
  var u2 = this.readUInt8();
  if (u2 & 128)
    return u2 - 256;
  else
    return u2;
};
Parser.prototype.readUInt16 = function() {
  var b0 = this.readUInt8(), b1 = this.readUInt8();
  return (b0 << 8) + b1;
};
Parser.prototype.readInt16 = function() {
  var u2 = this.readUInt16();
  if (u2 & 32768)
    return u2 - 65536;
  else
    return u2;
};
Parser.prototype.readUInt24 = function() {
  var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8();
  return (b0 << 16) + (b1 << 8) + b2;
};
Parser.prototype.readInt24 = function() {
  var u2 = this.readUInt24();
  if (u2 & 8388608)
    return u2 - 16777216;
  else
    return u2;
};
Parser.prototype.readUInt32 = function() {
  var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8(), b3 = this.readUInt8();
  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
};
Parser.prototype.readBytes = function(len) {
  var bytes = this.buffer.slice(this.pos, this.pos + len);
  this.pos += len;
  return bytes;
};
Parser.prototype.readString = function(len) {
  var bytes = this.readBytes(len);
  return String.fromCharCode.apply(null, bytes);
};
Parser.prototype.readVarInt = function() {
  var result = 0;
  while (!this.eof()) {
    var b2 = this.readUInt8();
    if (b2 & 128) {
      result += b2 & 127;
      result <<= 7;
    } else {
      return result + b2;
    }
  }
  return result;
};
Parser.prototype.readChunk = function() {
  var id = this.readString(4);
  var length = this.readUInt32();
  var data = this.readBytes(length);
  return {
    id,
    length,
    data
  };
};
var midiParser = parseMidi;
function writeMidi(data, opts) {
  if (typeof data !== "object")
    throw "Invalid MIDI data";
  opts = opts || {};
  var header = data.header || {};
  var tracks2 = data.tracks || [];
  var i2, len = tracks2.length;
  var w2 = new Writer();
  writeHeader(w2, header, len);
  for (i2 = 0; i2 < len; i2++) {
    writeTrack(w2, tracks2[i2], opts);
  }
  return w2.buffer;
}
function writeHeader(w2, header, numTracks) {
  var format = header.format == null ? 1 : header.format;
  var timeDivision = 128;
  if (header.timeDivision) {
    timeDivision = header.timeDivision;
  } else if (header.ticksPerFrame && header.framesPerSecond) {
    timeDivision = -(header.framesPerSecond & 255) << 8 | header.ticksPerFrame & 255;
  } else if (header.ticksPerBeat) {
    timeDivision = header.ticksPerBeat & 32767;
  }
  var h2 = new Writer();
  h2.writeUInt16(format);
  h2.writeUInt16(numTracks);
  h2.writeUInt16(timeDivision);
  w2.writeChunk("MThd", h2.buffer);
}
function writeTrack(w2, track, opts) {
  var t2 = new Writer();
  var i2, len = track.length;
  var eventTypeByte = null;
  for (i2 = 0; i2 < len; i2++) {
    if (opts.running === false || !opts.running && !track[i2].running)
      eventTypeByte = null;
    eventTypeByte = writeEvent(t2, track[i2], eventTypeByte, opts.useByte9ForNoteOff);
  }
  w2.writeChunk("MTrk", t2.buffer);
}
function writeEvent(w2, event, lastEventTypeByte, useByte9ForNoteOff) {
  var type = event.type;
  var deltaTime = event.deltaTime;
  var text = event.text || "";
  var data = event.data || [];
  var eventTypeByte = null;
  w2.writeVarInt(deltaTime);
  switch (type) {
    case "sequenceNumber":
      w2.writeUInt8(255);
      w2.writeUInt8(0);
      w2.writeVarInt(2);
      w2.writeUInt16(event.number);
      break;
    case "text":
      w2.writeUInt8(255);
      w2.writeUInt8(1);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "copyrightNotice":
      w2.writeUInt8(255);
      w2.writeUInt8(2);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "trackName":
      w2.writeUInt8(255);
      w2.writeUInt8(3);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "instrumentName":
      w2.writeUInt8(255);
      w2.writeUInt8(4);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "lyrics":
      w2.writeUInt8(255);
      w2.writeUInt8(5);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "marker":
      w2.writeUInt8(255);
      w2.writeUInt8(6);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "cuePoint":
      w2.writeUInt8(255);
      w2.writeUInt8(7);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "channelPrefix":
      w2.writeUInt8(255);
      w2.writeUInt8(32);
      w2.writeVarInt(1);
      w2.writeUInt8(event.channel);
      break;
    case "portPrefix":
      w2.writeUInt8(255);
      w2.writeUInt8(33);
      w2.writeVarInt(1);
      w2.writeUInt8(event.port);
      break;
    case "endOfTrack":
      w2.writeUInt8(255);
      w2.writeUInt8(47);
      w2.writeVarInt(0);
      break;
    case "setTempo":
      w2.writeUInt8(255);
      w2.writeUInt8(81);
      w2.writeVarInt(3);
      w2.writeUInt24(event.microsecondsPerBeat);
      break;
    case "smpteOffset":
      w2.writeUInt8(255);
      w2.writeUInt8(84);
      w2.writeVarInt(5);
      var FRAME_RATES = { 24: 0, 25: 32, 29: 64, 30: 96 };
      var hourByte = event.hour & 31 | FRAME_RATES[event.frameRate];
      w2.writeUInt8(hourByte);
      w2.writeUInt8(event.min);
      w2.writeUInt8(event.sec);
      w2.writeUInt8(event.frame);
      w2.writeUInt8(event.subFrame);
      break;
    case "timeSignature":
      w2.writeUInt8(255);
      w2.writeUInt8(88);
      w2.writeVarInt(4);
      w2.writeUInt8(event.numerator);
      var denominator = Math.floor(Math.log(event.denominator) / Math.LN2) & 255;
      w2.writeUInt8(denominator);
      w2.writeUInt8(event.metronome);
      w2.writeUInt8(event.thirtyseconds || 8);
      break;
    case "keySignature":
      w2.writeUInt8(255);
      w2.writeUInt8(89);
      w2.writeVarInt(2);
      w2.writeInt8(event.key);
      w2.writeUInt8(event.scale);
      break;
    case "sequencerSpecific":
      w2.writeUInt8(255);
      w2.writeUInt8(127);
      w2.writeVarInt(data.length);
      w2.writeBytes(data);
      break;
    case "unknownMeta":
      if (event.metatypeByte != null) {
        w2.writeUInt8(255);
        w2.writeUInt8(event.metatypeByte);
        w2.writeVarInt(data.length);
        w2.writeBytes(data);
      }
      break;
    case "sysEx":
      w2.writeUInt8(240);
      w2.writeVarInt(data.length);
      w2.writeBytes(data);
      break;
    case "endSysEx":
      w2.writeUInt8(247);
      w2.writeVarInt(data.length);
      w2.writeBytes(data);
      break;
    case "noteOff":
      var noteByte = useByte9ForNoteOff !== false && event.byte9 || useByte9ForNoteOff && event.velocity == 0 ? 144 : 128;
      eventTypeByte = noteByte | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.noteNumber);
      w2.writeUInt8(event.velocity);
      break;
    case "noteOn":
      eventTypeByte = 144 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.noteNumber);
      w2.writeUInt8(event.velocity);
      break;
    case "noteAftertouch":
      eventTypeByte = 160 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.noteNumber);
      w2.writeUInt8(event.amount);
      break;
    case "controller":
      eventTypeByte = 176 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.controllerType);
      w2.writeUInt8(event.value);
      break;
    case "programChange":
      eventTypeByte = 192 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.programNumber);
      break;
    case "channelAftertouch":
      eventTypeByte = 208 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.amount);
      break;
    case "pitchBend":
      eventTypeByte = 224 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      var value14 = 8192 + event.value;
      var lsb14 = value14 & 127;
      var msb14 = value14 >> 7 & 127;
      w2.writeUInt8(lsb14);
      w2.writeUInt8(msb14);
      break;
    default:
      throw "Unrecognized event type: " + type;
  }
  return eventTypeByte;
}
function Writer() {
  this.buffer = [];
}
Writer.prototype.writeUInt8 = function(v2) {
  this.buffer.push(v2 & 255);
};
Writer.prototype.writeInt8 = Writer.prototype.writeUInt8;
Writer.prototype.writeUInt16 = function(v2) {
  var b0 = v2 >> 8 & 255, b1 = v2 & 255;
  this.writeUInt8(b0);
  this.writeUInt8(b1);
};
Writer.prototype.writeInt16 = Writer.prototype.writeUInt16;
Writer.prototype.writeUInt24 = function(v2) {
  var b0 = v2 >> 16 & 255, b1 = v2 >> 8 & 255, b2 = v2 & 255;
  this.writeUInt8(b0);
  this.writeUInt8(b1);
  this.writeUInt8(b2);
};
Writer.prototype.writeInt24 = Writer.prototype.writeUInt24;
Writer.prototype.writeUInt32 = function(v2) {
  var b0 = v2 >> 24 & 255, b1 = v2 >> 16 & 255, b2 = v2 >> 8 & 255, b3 = v2 & 255;
  this.writeUInt8(b0);
  this.writeUInt8(b1);
  this.writeUInt8(b2);
  this.writeUInt8(b3);
};
Writer.prototype.writeInt32 = Writer.prototype.writeUInt32;
Writer.prototype.writeBytes = function(arr) {
  this.buffer = this.buffer.concat(Array.prototype.slice.call(arr, 0));
};
Writer.prototype.writeString = function(str) {
  var i2, len = str.length, arr = [];
  for (i2 = 0; i2 < len; i2++) {
    arr.push(str.codePointAt(i2));
  }
  this.writeBytes(arr);
};
Writer.prototype.writeVarInt = function(v2) {
  if (v2 < 0)
    throw "Cannot write negative variable-length integer";
  if (v2 <= 127) {
    this.writeUInt8(v2);
  } else {
    var i2 = v2;
    var bytes = [];
    bytes.push(i2 & 127);
    i2 >>= 7;
    while (i2) {
      var b2 = i2 & 127 | 128;
      bytes.push(b2);
      i2 >>= 7;
    }
    this.writeBytes(bytes.reverse());
  }
};
Writer.prototype.writeChunk = function(id, data) {
  this.writeString(id);
  this.writeUInt32(data.length);
  this.writeBytes(data);
};
var midiWriter = writeMidi;
midiFile.parseMidi = midiParser;
midiFile.writeMidi = midiWriter;
var Header = {};
var BinarySearch = {};
Object.defineProperty(BinarySearch, "__esModule", { value: true });
BinarySearch.insert = BinarySearch.search = void 0;
function search(array, value, prop) {
  if (prop === void 0) {
    prop = "ticks";
  }
  var beginning = 0;
  var len = array.length;
  var end = len;
  if (len > 0 && array[len - 1][prop] <= value) {
    return len - 1;
  }
  while (beginning < end) {
    var midPoint = Math.floor(beginning + (end - beginning) / 2);
    var event_1 = array[midPoint];
    var nextEvent = array[midPoint + 1];
    if (event_1[prop] === value) {
      for (var i2 = midPoint; i2 < array.length; i2++) {
        var testEvent = array[i2];
        if (testEvent[prop] === value) {
          midPoint = i2;
        }
      }
      return midPoint;
    } else if (event_1[prop] < value && nextEvent[prop] > value) {
      return midPoint;
    } else if (event_1[prop] > value) {
      end = midPoint;
    } else if (event_1[prop] < value) {
      beginning = midPoint + 1;
    }
  }
  return -1;
}
BinarySearch.search = search;
function insert(array, event, prop) {
  if (prop === void 0) {
    prop = "ticks";
  }
  if (array.length) {
    var index2 = search(array, event[prop], prop);
    array.splice(index2 + 1, 0, event);
  } else {
    array.push(event);
  }
}
BinarySearch.insert = insert;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Header = exports.keySignatureKeys = void 0;
  var BinarySearch_12 = BinarySearch;
  var privatePPQMap = /* @__PURE__ */ new WeakMap();
  exports.keySignatureKeys = [
    "Cb",
    "Gb",
    "Db",
    "Ab",
    "Eb",
    "Bb",
    "F",
    "C",
    "G",
    "D",
    "A",
    "E",
    "B",
    "F#",
    "C#"
  ];
  var Header2 = function() {
    function Header3(midiData) {
      var _this = this;
      this.tempos = [];
      this.timeSignatures = [];
      this.keySignatures = [];
      this.meta = [];
      this.name = "";
      privatePPQMap.set(this, 480);
      if (midiData) {
        privatePPQMap.set(this, midiData.header.ticksPerBeat);
        midiData.tracks.forEach(function(track) {
          track.forEach(function(event) {
            if (event.meta) {
              if (event.type === "timeSignature") {
                _this.timeSignatures.push({
                  ticks: event.absoluteTime,
                  timeSignature: [
                    event.numerator,
                    event.denominator
                  ]
                });
              } else if (event.type === "setTempo") {
                _this.tempos.push({
                  bpm: 6e7 / event.microsecondsPerBeat,
                  ticks: event.absoluteTime
                });
              } else if (event.type === "keySignature") {
                _this.keySignatures.push({
                  key: exports.keySignatureKeys[event.key + 7],
                  scale: event.scale === 0 ? "major" : "minor",
                  ticks: event.absoluteTime
                });
              }
            }
          });
        });
        var firstTrackCurrentTicks_1 = 0;
        midiData.tracks[0].forEach(function(event) {
          firstTrackCurrentTicks_1 += event.deltaTime;
          if (event.meta) {
            if (event.type === "trackName") {
              _this.name = event.text;
            } else if (event.type === "text" || event.type === "cuePoint" || event.type === "marker" || event.type === "lyrics") {
              _this.meta.push({
                text: event.text,
                ticks: firstTrackCurrentTicks_1,
                type: event.type
              });
            }
          }
        });
        this.update();
      }
    }
    Header3.prototype.update = function() {
      var _this = this;
      var currentTime = 0;
      var lastEventBeats = 0;
      this.tempos.sort(function(a2, b2) {
        return a2.ticks - b2.ticks;
      });
      this.tempos.forEach(function(event, index2) {
        var lastBPM = index2 > 0 ? _this.tempos[index2 - 1].bpm : _this.tempos[0].bpm;
        var beats = event.ticks / _this.ppq - lastEventBeats;
        var elapsedSeconds = 60 / lastBPM * beats;
        event.time = elapsedSeconds + currentTime;
        currentTime = event.time;
        lastEventBeats += beats;
      });
      this.timeSignatures.sort(function(a2, b2) {
        return a2.ticks - b2.ticks;
      });
      this.timeSignatures.forEach(function(event, index2) {
        var lastEvent = index2 > 0 ? _this.timeSignatures[index2 - 1] : _this.timeSignatures[0];
        var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;
        var elapsedMeasures = elapsedBeats / lastEvent.timeSignature[0] / (lastEvent.timeSignature[1] / 4);
        lastEvent.measures = lastEvent.measures || 0;
        event.measures = elapsedMeasures + lastEvent.measures;
      });
    };
    Header3.prototype.ticksToSeconds = function(ticks) {
      var index2 = (0, BinarySearch_12.search)(this.tempos, ticks);
      if (index2 !== -1) {
        var tempo2 = this.tempos[index2];
        var tempoTime = tempo2.time;
        var elapsedBeats = (ticks - tempo2.ticks) / this.ppq;
        return tempoTime + 60 / tempo2.bpm * elapsedBeats;
      } else {
        var beats = ticks / this.ppq;
        return 60 / 120 * beats;
      }
    };
    Header3.prototype.ticksToMeasures = function(ticks) {
      var index2 = (0, BinarySearch_12.search)(this.timeSignatures, ticks);
      if (index2 !== -1) {
        var timeSigEvent = this.timeSignatures[index2];
        var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;
        return timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;
      } else {
        return ticks / this.ppq / 4;
      }
    };
    Object.defineProperty(Header3.prototype, "ppq", {
      get: function() {
        return privatePPQMap.get(this);
      },
      enumerable: false,
      configurable: true
    });
    Header3.prototype.secondsToTicks = function(seconds) {
      var index2 = (0, BinarySearch_12.search)(this.tempos, seconds, "time");
      if (index2 !== -1) {
        var tempo2 = this.tempos[index2];
        var tempoTime = tempo2.time;
        var elapsedTime = seconds - tempoTime;
        var elapsedBeats = elapsedTime / (60 / tempo2.bpm);
        return Math.round(tempo2.ticks + elapsedBeats * this.ppq);
      } else {
        var beats = seconds / (60 / 120);
        return Math.round(beats * this.ppq);
      }
    };
    Header3.prototype.toJSON = function() {
      return {
        keySignatures: this.keySignatures,
        meta: this.meta,
        name: this.name,
        ppq: this.ppq,
        tempos: this.tempos.map(function(t2) {
          return {
            bpm: t2.bpm,
            ticks: t2.ticks
          };
        }),
        timeSignatures: this.timeSignatures
      };
    };
    Header3.prototype.fromJSON = function(json) {
      this.name = json.name;
      this.tempos = json.tempos.map(function(t2) {
        return Object.assign({}, t2);
      });
      this.timeSignatures = json.timeSignatures.map(function(t2) {
        return Object.assign({}, t2);
      });
      this.keySignatures = json.keySignatures.map(function(t2) {
        return Object.assign({}, t2);
      });
      this.meta = json.meta.map(function(t2) {
        return Object.assign({}, t2);
      });
      privatePPQMap.set(this, json.ppq);
      this.update();
    };
    Header3.prototype.setTempo = function(bpm) {
      this.tempos = [
        {
          bpm,
          ticks: 0
        }
      ];
      this.update();
    };
    return Header3;
  }();
  exports.Header = Header2;
})(Header);
var Track$1 = {};
var ControlChange = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ControlChange = exports.controlChangeIds = exports.controlChangeNames = void 0;
  exports.controlChangeNames = {
    1: "modulationWheel",
    2: "breath",
    4: "footController",
    5: "portamentoTime",
    7: "volume",
    8: "balance",
    10: "pan",
    64: "sustain",
    65: "portamentoTime",
    66: "sostenuto",
    67: "softPedal",
    68: "legatoFootswitch",
    84: "portamentoControl"
  };
  exports.controlChangeIds = Object.keys(exports.controlChangeNames).reduce(function(obj, key) {
    obj[exports.controlChangeNames[key]] = key;
    return obj;
  }, {});
  var privateHeaderMap2 = /* @__PURE__ */ new WeakMap();
  var privateCCNumberMap = /* @__PURE__ */ new WeakMap();
  var ControlChange2 = function() {
    function ControlChange3(event, header) {
      privateHeaderMap2.set(this, header);
      privateCCNumberMap.set(this, event.controllerType);
      this.ticks = event.absoluteTime;
      this.value = event.value;
    }
    Object.defineProperty(ControlChange3.prototype, "number", {
      get: function() {
        return privateCCNumberMap.get(this);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ControlChange3.prototype, "name", {
      get: function() {
        if (exports.controlChangeNames[this.number]) {
          return exports.controlChangeNames[this.number];
        } else {
          return null;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ControlChange3.prototype, "time", {
      get: function() {
        var header = privateHeaderMap2.get(this);
        return header.ticksToSeconds(this.ticks);
      },
      set: function(t2) {
        var header = privateHeaderMap2.get(this);
        this.ticks = header.secondsToTicks(t2);
      },
      enumerable: false,
      configurable: true
    });
    ControlChange3.prototype.toJSON = function() {
      return {
        number: this.number,
        ticks: this.ticks,
        time: this.time,
        value: this.value
      };
    };
    return ControlChange3;
  }();
  exports.ControlChange = ControlChange2;
})(ControlChange);
var ControlChanges = {};
Object.defineProperty(ControlChanges, "__esModule", { value: true });
ControlChanges.createControlChanges = void 0;
var ControlChange_1$1 = ControlChange;
function createControlChanges() {
  return new Proxy({}, {
    get: function(target, handler) {
      if (target[handler]) {
        return target[handler];
      } else if (ControlChange_1$1.controlChangeIds.hasOwnProperty(handler)) {
        return target[ControlChange_1$1.controlChangeIds[handler]];
      }
    },
    set: function(target, handler, value) {
      if (ControlChange_1$1.controlChangeIds.hasOwnProperty(handler)) {
        target[ControlChange_1$1.controlChangeIds[handler]] = value;
      } else {
        target[handler] = value;
      }
      return true;
    }
  });
}
ControlChanges.createControlChanges = createControlChanges;
var PitchBend$1 = {};
Object.defineProperty(PitchBend$1, "__esModule", { value: true });
PitchBend$1.PitchBend = void 0;
var privateHeaderMap$2 = /* @__PURE__ */ new WeakMap();
var PitchBend = function() {
  function PitchBend2(event, header) {
    privateHeaderMap$2.set(this, header);
    this.ticks = event.absoluteTime;
    this.value = event.value;
  }
  Object.defineProperty(PitchBend2.prototype, "time", {
    get: function() {
      var header = privateHeaderMap$2.get(this);
      return header.ticksToSeconds(this.ticks);
    },
    set: function(t2) {
      var header = privateHeaderMap$2.get(this);
      this.ticks = header.secondsToTicks(t2);
    },
    enumerable: false,
    configurable: true
  });
  PitchBend2.prototype.toJSON = function() {
    return {
      ticks: this.ticks,
      time: this.time,
      value: this.value
    };
  };
  return PitchBend2;
}();
PitchBend$1.PitchBend = PitchBend;
var Instrument$1 = {};
var InstrumentMaps = {};
Object.defineProperty(InstrumentMaps, "__esModule", { value: true });
InstrumentMaps.DrumKitByPatchID = InstrumentMaps.InstrumentFamilyByID = InstrumentMaps.instrumentByPatchID = void 0;
InstrumentMaps.instrumentByPatchID = [
  "acoustic grand piano",
  "bright acoustic piano",
  "electric grand piano",
  "honky-tonk piano",
  "electric piano 1",
  "electric piano 2",
  "harpsichord",
  "clavi",
  "celesta",
  "glockenspiel",
  "music box",
  "vibraphone",
  "marimba",
  "xylophone",
  "tubular bells",
  "dulcimer",
  "drawbar organ",
  "percussive organ",
  "rock organ",
  "church organ",
  "reed organ",
  "accordion",
  "harmonica",
  "tango accordion",
  "acoustic guitar (nylon)",
  "acoustic guitar (steel)",
  "electric guitar (jazz)",
  "electric guitar (clean)",
  "electric guitar (muted)",
  "overdriven guitar",
  "distortion guitar",
  "guitar harmonics",
  "acoustic bass",
  "electric bass (finger)",
  "electric bass (pick)",
  "fretless bass",
  "slap bass 1",
  "slap bass 2",
  "synth bass 1",
  "synth bass 2",
  "violin",
  "viola",
  "cello",
  "contrabass",
  "tremolo strings",
  "pizzicato strings",
  "orchestral harp",
  "timpani",
  "string ensemble 1",
  "string ensemble 2",
  "synthstrings 1",
  "synthstrings 2",
  "choir aahs",
  "voice oohs",
  "synth voice",
  "orchestra hit",
  "trumpet",
  "trombone",
  "tuba",
  "muted trumpet",
  "french horn",
  "brass section",
  "synthbrass 1",
  "synthbrass 2",
  "soprano sax",
  "alto sax",
  "tenor sax",
  "baritone sax",
  "oboe",
  "english horn",
  "bassoon",
  "clarinet",
  "piccolo",
  "flute",
  "recorder",
  "pan flute",
  "blown bottle",
  "shakuhachi",
  "whistle",
  "ocarina",
  "lead 1 (square)",
  "lead 2 (sawtooth)",
  "lead 3 (calliope)",
  "lead 4 (chiff)",
  "lead 5 (charang)",
  "lead 6 (voice)",
  "lead 7 (fifths)",
  "lead 8 (bass + lead)",
  "pad 1 (new age)",
  "pad 2 (warm)",
  "pad 3 (polysynth)",
  "pad 4 (choir)",
  "pad 5 (bowed)",
  "pad 6 (metallic)",
  "pad 7 (halo)",
  "pad 8 (sweep)",
  "fx 1 (rain)",
  "fx 2 (soundtrack)",
  "fx 3 (crystal)",
  "fx 4 (atmosphere)",
  "fx 5 (brightness)",
  "fx 6 (goblins)",
  "fx 7 (echoes)",
  "fx 8 (sci-fi)",
  "sitar",
  "banjo",
  "shamisen",
  "koto",
  "kalimba",
  "bag pipe",
  "fiddle",
  "shanai",
  "tinkle bell",
  "agogo",
  "steel drums",
  "woodblock",
  "taiko drum",
  "melodic tom",
  "synth drum",
  "reverse cymbal",
  "guitar fret noise",
  "breath noise",
  "seashore",
  "bird tweet",
  "telephone ring",
  "helicopter",
  "applause",
  "gunshot"
];
InstrumentMaps.InstrumentFamilyByID = [
  "piano",
  "chromatic percussion",
  "organ",
  "guitar",
  "bass",
  "strings",
  "ensemble",
  "brass",
  "reed",
  "pipe",
  "synth lead",
  "synth pad",
  "synth effects",
  "world",
  "percussive",
  "sound effects"
];
InstrumentMaps.DrumKitByPatchID = {
  0: "standard kit",
  8: "room kit",
  16: "power kit",
  24: "electronic kit",
  25: "tr-808 kit",
  32: "jazz kit",
  40: "brush kit",
  48: "orchestra kit",
  56: "sound fx kit"
};
Object.defineProperty(Instrument$1, "__esModule", { value: true });
Instrument$1.Instrument = void 0;
var InstrumentMaps_1 = InstrumentMaps;
var privateTrackMap = /* @__PURE__ */ new WeakMap();
var Instrument = function() {
  function Instrument2(trackData, track) {
    this.number = 0;
    privateTrackMap.set(this, track);
    this.number = 0;
    if (trackData) {
      var programChange = trackData.find(function(e2) {
        return e2.type === "programChange";
      });
      if (programChange) {
        this.number = programChange.programNumber;
      }
    }
  }
  Object.defineProperty(Instrument2.prototype, "name", {
    get: function() {
      if (this.percussion) {
        return InstrumentMaps_1.DrumKitByPatchID[this.number];
      } else {
        return InstrumentMaps_1.instrumentByPatchID[this.number];
      }
    },
    set: function(n2) {
      var patchNumber = InstrumentMaps_1.instrumentByPatchID.indexOf(n2);
      if (patchNumber !== -1) {
        this.number = patchNumber;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Instrument2.prototype, "family", {
    get: function() {
      if (this.percussion) {
        return "drums";
      } else {
        return InstrumentMaps_1.InstrumentFamilyByID[Math.floor(this.number / 8)];
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Instrument2.prototype, "percussion", {
    get: function() {
      var track = privateTrackMap.get(this);
      return track.channel === 9;
    },
    enumerable: false,
    configurable: true
  });
  Instrument2.prototype.toJSON = function() {
    return {
      family: this.family,
      number: this.number,
      name: this.name
    };
  };
  Instrument2.prototype.fromJSON = function(json) {
    this.number = json.number;
  };
  return Instrument2;
}();
Instrument$1.Instrument = Instrument;
var Note$1 = {};
Object.defineProperty(Note$1, "__esModule", { value: true });
Note$1.Note = void 0;
function midiToPitch(midi2) {
  var octave2 = Math.floor(midi2 / 12) - 1;
  return midiToPitchClass(midi2) + octave2.toString();
}
function midiToPitchClass(midi2) {
  var scaleIndexToNote = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  var note2 = midi2 % 12;
  return scaleIndexToNote[note2];
}
function pitchClassToMidi(pitch) {
  var scaleIndexToNote = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  return scaleIndexToNote.indexOf(pitch);
}
var pitchToMidi = function() {
  var regexp = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;
  var noteToScaleIndex = {
    cbb: -2,
    cb: -1,
    c: 0,
    "c#": 1,
    cx: 2,
    dbb: 0,
    db: 1,
    d: 2,
    "d#": 3,
    dx: 4,
    ebb: 2,
    eb: 3,
    e: 4,
    "e#": 5,
    ex: 6,
    fbb: 3,
    fb: 4,
    f: 5,
    "f#": 6,
    fx: 7,
    gbb: 5,
    gb: 6,
    g: 7,
    "g#": 8,
    gx: 9,
    abb: 7,
    ab: 8,
    a: 9,
    "a#": 10,
    ax: 11,
    bbb: 9,
    bb: 10,
    b: 11,
    "b#": 12,
    bx: 13
  };
  return function(note2) {
    var split = regexp.exec(note2);
    var pitch = split[1];
    var octave2 = split[2];
    var index2 = noteToScaleIndex[pitch.toLowerCase()];
    return index2 + (parseInt(octave2, 10) + 1) * 12;
  };
}();
var privateHeaderMap$1 = /* @__PURE__ */ new WeakMap();
var Note = function() {
  function Note2(noteOn, noteOff, header) {
    privateHeaderMap$1.set(this, header);
    this.midi = noteOn.midi;
    this.velocity = noteOn.velocity;
    this.noteOffVelocity = noteOff.velocity;
    this.ticks = noteOn.ticks;
    this.durationTicks = noteOff.ticks - noteOn.ticks;
  }
  Object.defineProperty(Note2.prototype, "name", {
    get: function() {
      return midiToPitch(this.midi);
    },
    set: function(n2) {
      this.midi = pitchToMidi(n2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "octave", {
    get: function() {
      return Math.floor(this.midi / 12) - 1;
    },
    set: function(o2) {
      var diff = o2 - this.octave;
      this.midi += diff * 12;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "pitch", {
    get: function() {
      return midiToPitchClass(this.midi);
    },
    set: function(p2) {
      this.midi = 12 * (this.octave + 1) + pitchClassToMidi(p2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "duration", {
    get: function() {
      var header = privateHeaderMap$1.get(this);
      return header.ticksToSeconds(this.ticks + this.durationTicks) - header.ticksToSeconds(this.ticks);
    },
    set: function(d2) {
      var header = privateHeaderMap$1.get(this);
      var noteEndTicks = header.secondsToTicks(this.time + d2);
      this.durationTicks = noteEndTicks - this.ticks;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "time", {
    get: function() {
      var header = privateHeaderMap$1.get(this);
      return header.ticksToSeconds(this.ticks);
    },
    set: function(t2) {
      var header = privateHeaderMap$1.get(this);
      this.ticks = header.secondsToTicks(t2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "bars", {
    get: function() {
      var header = privateHeaderMap$1.get(this);
      return header.ticksToMeasures(this.ticks);
    },
    enumerable: false,
    configurable: true
  });
  Note2.prototype.toJSON = function() {
    return {
      duration: this.duration,
      durationTicks: this.durationTicks,
      midi: this.midi,
      name: this.name,
      ticks: this.ticks,
      time: this.time,
      velocity: this.velocity
    };
  };
  return Note2;
}();
Note$1.Note = Note;
Object.defineProperty(Track$1, "__esModule", { value: true });
Track$1.Track = void 0;
var BinarySearch_1 = BinarySearch;
var ControlChange_1 = ControlChange;
var ControlChanges_1 = ControlChanges;
var PitchBend_1 = PitchBend$1;
var Instrument_1 = Instrument$1;
var Note_1 = Note$1;
var privateHeaderMap = /* @__PURE__ */ new WeakMap();
var Track = function() {
  function Track2(trackData, header) {
    var _this = this;
    this.name = "";
    this.notes = [];
    this.controlChanges = (0, ControlChanges_1.createControlChanges)();
    this.pitchBends = [];
    privateHeaderMap.set(this, header);
    if (trackData) {
      var nameEvent = trackData.find(function(e2) {
        return e2.type === "trackName";
      });
      this.name = nameEvent ? nameEvent.text : "";
    }
    this.instrument = new Instrument_1.Instrument(trackData, this);
    this.channel = 0;
    if (trackData) {
      var noteOns = trackData.filter(function(event) {
        return event.type === "noteOn";
      });
      var noteOffs = trackData.filter(function(event) {
        return event.type === "noteOff";
      });
      var _loop_1 = function() {
        var currentNote = noteOns.shift();
        this_1.channel = currentNote.channel;
        var offIndex = noteOffs.findIndex(function(note2) {
          return note2.noteNumber === currentNote.noteNumber && note2.absoluteTime >= currentNote.absoluteTime;
        });
        if (offIndex !== -1) {
          var noteOff = noteOffs.splice(offIndex, 1)[0];
          this_1.addNote({
            durationTicks: noteOff.absoluteTime - currentNote.absoluteTime,
            midi: currentNote.noteNumber,
            noteOffVelocity: noteOff.velocity / 127,
            ticks: currentNote.absoluteTime,
            velocity: currentNote.velocity / 127
          });
        }
      };
      var this_1 = this;
      while (noteOns.length) {
        _loop_1();
      }
      var controlChanges = trackData.filter(function(event) {
        return event.type === "controller";
      });
      controlChanges.forEach(function(event) {
        _this.addCC({
          number: event.controllerType,
          ticks: event.absoluteTime,
          value: event.value / 127
        });
      });
      var pitchBends = trackData.filter(function(event) {
        return event.type === "pitchBend";
      });
      pitchBends.forEach(function(event) {
        _this.addPitchBend({
          ticks: event.absoluteTime,
          value: event.value / Math.pow(2, 13)
        });
      });
      var endOfTrackEvent = trackData.find(function(event) {
        return event.type === "endOfTrack";
      });
      this.endOfTrackTicks = endOfTrackEvent !== void 0 ? endOfTrackEvent.absoluteTime : void 0;
    }
  }
  Track2.prototype.addNote = function(props) {
    var header = privateHeaderMap.get(this);
    var note2 = new Note_1.Note({
      midi: 0,
      ticks: 0,
      velocity: 1
    }, {
      ticks: 0,
      velocity: 0
    }, header);
    Object.assign(note2, props);
    (0, BinarySearch_1.insert)(this.notes, note2, "ticks");
    return this;
  };
  Track2.prototype.addCC = function(props) {
    var header = privateHeaderMap.get(this);
    var cc = new ControlChange_1.ControlChange({
      controllerType: props.number
    }, header);
    delete props.number;
    Object.assign(cc, props);
    if (!Array.isArray(this.controlChanges[cc.number])) {
      this.controlChanges[cc.number] = [];
    }
    (0, BinarySearch_1.insert)(this.controlChanges[cc.number], cc, "ticks");
    return this;
  };
  Track2.prototype.addPitchBend = function(props) {
    var header = privateHeaderMap.get(this);
    var pb = new PitchBend_1.PitchBend({}, header);
    Object.assign(pb, props);
    (0, BinarySearch_1.insert)(this.pitchBends, pb, "ticks");
    return this;
  };
  Object.defineProperty(Track2.prototype, "duration", {
    get: function() {
      if (!this.notes.length) {
        return 0;
      }
      var maxDuration = this.notes[this.notes.length - 1].time + this.notes[this.notes.length - 1].duration;
      for (var i2 = 0; i2 < this.notes.length - 1; i2++) {
        var duration2 = this.notes[i2].time + this.notes[i2].duration;
        if (maxDuration < duration2) {
          maxDuration = duration2;
        }
      }
      return maxDuration;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Track2.prototype, "durationTicks", {
    get: function() {
      if (!this.notes.length) {
        return 0;
      }
      var maxDuration = this.notes[this.notes.length - 1].ticks + this.notes[this.notes.length - 1].durationTicks;
      for (var i2 = 0; i2 < this.notes.length - 1; i2++) {
        var duration2 = this.notes[i2].ticks + this.notes[i2].durationTicks;
        if (maxDuration < duration2) {
          maxDuration = duration2;
        }
      }
      return maxDuration;
    },
    enumerable: false,
    configurable: true
  });
  Track2.prototype.fromJSON = function(json) {
    var _this = this;
    this.name = json.name;
    this.channel = json.channel;
    this.instrument = new Instrument_1.Instrument(void 0, this);
    this.instrument.fromJSON(json.instrument);
    if (json.endOfTrackTicks !== void 0) {
      this.endOfTrackTicks = json.endOfTrackTicks;
    }
    for (var number in json.controlChanges) {
      if (json.controlChanges[number]) {
        json.controlChanges[number].forEach(function(cc) {
          _this.addCC({
            number: cc.number,
            ticks: cc.ticks,
            value: cc.value
          });
        });
      }
    }
    json.notes.forEach(function(n2) {
      _this.addNote({
        durationTicks: n2.durationTicks,
        midi: n2.midi,
        ticks: n2.ticks,
        velocity: n2.velocity
      });
    });
  };
  Track2.prototype.toJSON = function() {
    var controlChanges = {};
    for (var i2 = 0; i2 < 127; i2++) {
      if (this.controlChanges.hasOwnProperty(i2)) {
        controlChanges[i2] = this.controlChanges[i2].map(function(c2) {
          return c2.toJSON();
        });
      }
    }
    var json = {
      channel: this.channel,
      controlChanges,
      pitchBends: this.pitchBends.map(function(pb) {
        return pb.toJSON();
      }),
      instrument: this.instrument.toJSON(),
      name: this.name,
      notes: this.notes.map(function(n2) {
        return n2.toJSON();
      })
    };
    if (this.endOfTrackTicks !== void 0) {
      json.endOfTrackTicks = this.endOfTrackTicks;
    }
    return json;
  };
  return Track2;
}();
Track$1.Track = Track;
var Encode = {};
function flatten(array) {
  var result = [];
  $flatten(array, result);
  return result;
}
function $flatten(array, result) {
  for (var i2 = 0; i2 < array.length; i2++) {
    var value = array[i2];
    if (Array.isArray(value)) {
      $flatten(value, result);
    } else {
      result.push(value);
    }
  }
}
var dist_es2015 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  flatten
}, Symbol.toStringTag, { value: "Module" }));
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015);
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(Encode, "__esModule", { value: true });
Encode.encode = void 0;
var midi_file_1 = midiFile;
var Header_1 = Header;
var array_flatten_1 = require$$2;
function encodeNote(note2, channel) {
  return [
    {
      absoluteTime: note2.ticks,
      channel,
      deltaTime: 0,
      noteNumber: note2.midi,
      type: "noteOn",
      velocity: Math.floor(note2.velocity * 127)
    },
    {
      absoluteTime: note2.ticks + note2.durationTicks,
      channel,
      deltaTime: 0,
      noteNumber: note2.midi,
      type: "noteOff",
      velocity: Math.floor(note2.noteOffVelocity * 127)
    }
  ];
}
function encodeNotes(track) {
  return (0, array_flatten_1.flatten)(track.notes.map(function(note2) {
    return encodeNote(note2, track.channel);
  }));
}
function encodeControlChange(cc, channel) {
  return {
    absoluteTime: cc.ticks,
    channel,
    controllerType: cc.number,
    deltaTime: 0,
    type: "controller",
    value: Math.floor(cc.value * 127)
  };
}
function encodeControlChanges(track) {
  var controlChanges = [];
  for (var i2 = 0; i2 < 127; i2++) {
    if (track.controlChanges.hasOwnProperty(i2)) {
      track.controlChanges[i2].forEach(function(cc) {
        controlChanges.push(encodeControlChange(cc, track.channel));
      });
    }
  }
  return controlChanges;
}
function encodePitchBend(pb, channel) {
  return {
    absoluteTime: pb.ticks,
    channel,
    deltaTime: 0,
    type: "pitchBend",
    value: pb.value
  };
}
function encodePitchBends(track) {
  var pitchBends = [];
  track.pitchBends.forEach(function(pb) {
    pitchBends.push(encodePitchBend(pb, track.channel));
  });
  return pitchBends;
}
function encodeInstrument(track) {
  return {
    absoluteTime: 0,
    channel: track.channel,
    deltaTime: 0,
    programNumber: track.instrument.number,
    type: "programChange"
  };
}
function encodeTrackName(name2) {
  return {
    absoluteTime: 0,
    deltaTime: 0,
    meta: true,
    text: name2,
    type: "trackName"
  };
}
function encodeTempo(tempo2) {
  return {
    absoluteTime: tempo2.ticks,
    deltaTime: 0,
    meta: true,
    microsecondsPerBeat: Math.floor(6e7 / tempo2.bpm),
    type: "setTempo"
  };
}
function encodeTimeSignature(timeSig) {
  return {
    absoluteTime: timeSig.ticks,
    deltaTime: 0,
    denominator: timeSig.timeSignature[1],
    meta: true,
    metronome: 24,
    numerator: timeSig.timeSignature[0],
    thirtyseconds: 8,
    type: "timeSignature"
  };
}
function encodeKeySignature(keySig) {
  var keyIndex = Header_1.keySignatureKeys.indexOf(keySig.key);
  return {
    absoluteTime: keySig.ticks,
    deltaTime: 0,
    key: keyIndex + 7,
    meta: true,
    scale: keySig.scale === "major" ? 0 : 1,
    type: "keySignature"
  };
}
function encodeText(textEvent) {
  return {
    absoluteTime: textEvent.ticks,
    deltaTime: 0,
    meta: true,
    text: textEvent.text,
    type: textEvent.type
  };
}
function encode(midi2) {
  var midiData = {
    header: {
      format: 1,
      numTracks: midi2.tracks.length + 1,
      ticksPerBeat: midi2.header.ppq
    },
    tracks: __spreadArray([
      __spreadArray(__spreadArray(__spreadArray(__spreadArray([
        {
          absoluteTime: 0,
          deltaTime: 0,
          meta: true,
          text: midi2.header.name,
          type: "trackName"
        }
      ], midi2.header.keySignatures.map(function(keySig) {
        return encodeKeySignature(keySig);
      }), true), midi2.header.meta.map(function(e2) {
        return encodeText(e2);
      }), true), midi2.header.tempos.map(function(tempo2) {
        return encodeTempo(tempo2);
      }), true), midi2.header.timeSignatures.map(function(timeSig) {
        return encodeTimeSignature(timeSig);
      }), true)
    ], midi2.tracks.map(function(track) {
      return __spreadArray(__spreadArray(__spreadArray([
        encodeTrackName(track.name),
        encodeInstrument(track)
      ], encodeNotes(track), true), encodeControlChanges(track), true), encodePitchBends(track), true);
    }), true)
  };
  midiData.tracks = midiData.tracks.map(function(track) {
    track = track.sort(function(a2, b2) {
      return a2.absoluteTime - b2.absoluteTime;
    });
    var lastTime = 0;
    track.forEach(function(note2) {
      note2.deltaTime = note2.absoluteTime - lastTime;
      lastTime = note2.absoluteTime;
      delete note2.absoluteTime;
    });
    track.push({
      deltaTime: 0,
      meta: true,
      type: "endOfTrack"
    });
    return track;
  });
  return new Uint8Array((0, midi_file_1.writeMidi)(midiData));
}
Encode.encode = encode;
(function(exports) {
  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n2) {
      return function(v2) {
        return step([n2, v2]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Header = exports.Track = exports.Midi = void 0;
  var midi_file_12 = midiFile;
  var Header_12 = Header;
  var Track_1 = Track$1;
  var Encode_1 = Encode;
  var Midi2 = function() {
    function Midi3(midiArray) {
      var _this = this;
      var midiData = null;
      if (midiArray) {
        var midiArrayLike = midiArray instanceof ArrayBuffer ? new Uint8Array(midiArray) : midiArray;
        midiData = (0, midi_file_12.parseMidi)(midiArrayLike);
        midiData.tracks.forEach(function(track) {
          var currentTicks = 0;
          track.forEach(function(event) {
            currentTicks += event.deltaTime;
            event.absoluteTime = currentTicks;
          });
        });
        midiData.tracks = splitTracks(midiData.tracks);
      }
      this.header = new Header_12.Header(midiData);
      this.tracks = [];
      if (midiArray) {
        this.tracks = midiData.tracks.map(function(trackData) {
          return new Track_1.Track(trackData, _this.header);
        });
        if (midiData.header.format === 1 && this.tracks[0].duration === 0) {
          this.tracks.shift();
        }
      }
    }
    Midi3.fromUrl = function(url) {
      return __awaiter(this, void 0, void 0, function() {
        var response, arrayBuffer;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, fetch(url)];
            case 1:
              response = _a2.sent();
              if (!response.ok)
                return [3, 3];
              return [4, response.arrayBuffer()];
            case 2:
              arrayBuffer = _a2.sent();
              return [2, new Midi3(arrayBuffer)];
            case 3:
              throw new Error("Could not load '".concat(url, "'"));
          }
        });
      });
    };
    Object.defineProperty(Midi3.prototype, "name", {
      get: function() {
        return this.header.name;
      },
      set: function(n2) {
        this.header.name = n2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Midi3.prototype, "duration", {
      get: function() {
        var durations = this.tracks.map(function(t2) {
          return t2.duration;
        });
        return Math.max.apply(Math, durations);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Midi3.prototype, "durationTicks", {
      get: function() {
        var durationTicks = this.tracks.map(function(t2) {
          return t2.durationTicks;
        });
        return Math.max.apply(Math, durationTicks);
      },
      enumerable: false,
      configurable: true
    });
    Midi3.prototype.addTrack = function() {
      var track = new Track_1.Track(void 0, this.header);
      this.tracks.push(track);
      return track;
    };
    Midi3.prototype.toArray = function() {
      return (0, Encode_1.encode)(this);
    };
    Midi3.prototype.toJSON = function() {
      return {
        header: this.header.toJSON(),
        tracks: this.tracks.map(function(track) {
          return track.toJSON();
        })
      };
    };
    Midi3.prototype.fromJSON = function(json) {
      var _this = this;
      this.header = new Header_12.Header();
      this.header.fromJSON(json.header);
      this.tracks = json.tracks.map(function(trackJSON) {
        var track = new Track_1.Track(void 0, _this.header);
        track.fromJSON(trackJSON);
        return track;
      });
    };
    Midi3.prototype.clone = function() {
      var midi2 = new Midi3();
      midi2.fromJSON(this.toJSON());
      return midi2;
    };
    return Midi3;
  }();
  exports.Midi = Midi2;
  var Track_2 = Track$1;
  Object.defineProperty(exports, "Track", { enumerable: true, get: function() {
    return Track_2.Track;
  } });
  var Header_2 = Header;
  Object.defineProperty(exports, "Header", { enumerable: true, get: function() {
    return Header_2.Header;
  } });
  function splitTracks(tracks2) {
    var newTracks = [];
    for (var i2 = 0; i2 < tracks2.length; i2++) {
      var defaultTrack = newTracks.length;
      var trackMap = /* @__PURE__ */ new Map();
      var currentProgram = Array(16).fill(0);
      for (var _i = 0, _a2 = tracks2[i2]; _i < _a2.length; _i++) {
        var event_1 = _a2[_i];
        var targetTrack = defaultTrack;
        var channel = event_1.channel;
        if (channel !== void 0) {
          if (event_1.type === "programChange") {
            currentProgram[channel] = event_1.programNumber;
          }
          var program = currentProgram[channel];
          var trackKey = "".concat(program, " ").concat(channel);
          if (trackMap.has(trackKey)) {
            targetTrack = trackMap.get(trackKey);
          } else {
            targetTrack = defaultTrack + trackMap.size;
            trackMap.set(trackKey, targetTrack);
          }
        }
        if (!newTracks[targetTrack]) {
          newTracks.push([]);
        }
        newTracks[targetTrack].push(event_1);
      }
    }
    return newTracks;
  }
})(Midi);
function createAndDownloadBlobFile(body, filename, extension = "mid") {
  const blob = new Blob([body]);
  const fileName = `${filename}.${extension}`;
  if (navigator.msSaveBlob) {
    navigator.msSaveBlob(blob, fileName);
  } else {
    const link = document.createElement("a");
    if (link.download !== void 0) {
      const url = URL.createObjectURL(blob);
      link.setAttribute("href", url);
      link.setAttribute("download", fileName);
      link.style.visibility = "hidden";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }
}
const loops = reactive([]);
function useLoop(order = 0) {
  const loop = reactive({
    pitch: computed(() => globalScale.tonic),
    chroma: computed(() => globalScale.set.chroma),
    metre: {
      over: useStorage(`grid-${order}-over`, 4),
      under: useStorage(`grid-${order}-under`, 4)
    },
    octave: useStorage(`grid-${order}-octave`, 3),
    volume: useStorage(`grid-${order}-vol`, 1),
    pan: useStorage(`grid-${order}-pan`, order % 2 == 1 ? -0.5 : 0.5),
    probability: useStorage(`grid-${order}-probability`, 1),
    tonic: computed(() => {
      return loop.pitch + 12 * loop.octave - 3;
    }),
    steps: useStorage(`grid-${order}-steps`, []),
    current: [],
    progress: computed(() => {
      if (tempo.ticks) {
        return sequence == null ? void 0 : sequence.progress;
      } else {
        return 0;
      }
    }),
    clear() {
      loop.steps.forEach((step, s2) => {
        loop.steps[s2] = [{}];
      });
    },
    rotate(way = 1) {
      loop.steps = rotateArray(loop.steps, way);
    }
  });
  loops[order] = loop;
  const { channel } = createChannel$1(`grid-loop-${order}`);
  const panner = new PanVol(loop.pan, 0).connect(channel);
  const synth2 = new PolySynth({
    envelope: {
      attack: 0.5,
      release: 0.2
    },
    filterEnvelope: {
      attack: 0.1,
      release: 0.2
    }
  }).connect(panner);
  synth2.maxPolyphony = 100;
  let sequence = new Sequence((time, step) => {
    beatClick(step, time);
  }, loop.steps, loop.metre.under + "n").start(0);
  watch(() => loop.metre.under, () => {
    sequence.stop().dispose();
    sequence = new Sequence((time, step) => {
      beatClick(step, time);
    }, loop.steps, loop.metre.under + "n").start(0);
    sequence.probability = loop.probability;
  });
  watch(() => loop.metre.over, () => {
    if (loop.steps.length > loop.metre.over) {
      loop.steps.length = loop.metre.over;
    } else {
      for (let i2 = loop.steps.length; i2 < loop.metre.over; i2++) {
        loop.steps.push([{}]);
      }
    }
    sequence.events = loop.steps;
  }, { immediate: true });
  watchEffect(() => {
    sequence.events = loop.steps;
  });
  watchEffect(() => {
    if (tempo.stopped) {
      loop.current = null;
    }
  });
  watchEffect(() => {
    sequence.probability = loop.probability;
    panner.volume.targetRampTo(gainToDb(loop.volume), 1);
    panner.pan.targetRampTo(loop.pan, 1);
  });
  function beatClick(step, time) {
    if (context.state == "suspended") {
      start$1();
    }
    let notes2 = Object.entries(step).map((entry) => {
      if (entry[0] == "sub")
        return;
      return entry[1] ? Midi$1(Number(entry[0]) + loop.tonic) : null;
    }).filter(Number);
    synth2.triggerAttackRelease(notes2, { [loop.metre.under + "n"]: 1 / (step.sub || 1) }, time);
    Draw.schedule(() => {
      let dur = Time({
        [loop.metre.under + "n"]: 1 / (step.sub || 1)
      }).toMilliseconds();
      let midiNotes = notes2.map((n2) => n2.toMidi());
      midiPlay(midiNotes, { duration: dur, attack: loop.volume });
    }, time);
  }
  onBeforeUnmount(() => {
    loops.splice(order, 1);
    sequence.stop().dispose();
    panner.dispose();
    synth2.dispose();
  });
  return loop;
}
const mic = reactive({
  initiated: false,
  open: false,
  opened: false,
  monitor: false,
  meter: 0,
  volume: useClamp(useStorage("mic-vol", 1), 0, 2),
  gate: useClamp(useStorage("mic-gate", -60), -100, -40)
});
let meter, input, gate, compressor;
function useMic() {
  if (!mic.initiated) {
    meter = new Meter();
    meter.normalRange = true;
    input = new UserMedia();
    compressor = new Compressor({ threshold: -20, ratio: 2 }).connect(meter);
    gate = new Gate({ threshold: -60, smoothing: 1 });
    input.connect(gate);
    gate.connect(compressor);
    const { channel } = createChannel$1("mic");
    watch(() => mic.open, (o2) => {
      if (o2) {
        input.open().then(() => {
          mic.opened = true;
          useRafFn(() => {
            mic.meter = meter.getValue();
          });
        });
      } else {
        input.close();
        mic.opened = false;
      }
    });
    watch(() => mic.monitor, (mon) => mon ? meter.connect(channel) : meter.disconnect(channel));
    watch(() => mic.volume, (vol) => input.volume.rampTo(gainToDb(vol)), { immediate: true });
    watch(() => mic.gate, (g2) => gate.threshold = g2, { immediate: true });
  }
  return { mic, input };
}
function useSvgMouse() {
  const svg = ref(null);
  const area = ref(null);
  const { pressed } = useMousePressed();
  const mouse = reactive({
    x: 0,
    y: 0,
    normX: 0,
    normY: 0,
    pressed,
    inside: false
  });
  onMounted(() => {
    svg.value.addEventListener("mousemove", getCursorPosition);
    const { isOutside } = useMouseInElement(area);
    watch(isOutside, (out) => {
      mouse.inside = !out;
    });
  });
  function getCursorPosition(event, svgElement = svg.value, rect = area.value) {
    if (!svgElement)
      return;
    var svgPoint = svgElement.createSVGPoint();
    svgPoint.x = event.clientX;
    svgPoint.y = event.clientY;
    let correct = svgPoint.matrixTransform(svgElement.getScreenCTM().inverse());
    if (rect) {
      let bounds = rect.getBBox();
      mouse.x = correct.x < bounds.width ? correct.x < 0 ? 0 : correct.x : bounds.width;
      mouse.y = correct.y < bounds.height ? correct.y < 0 ? 0 : correct.y : bounds.height;
      mouse.normY = 1 - mouse.y / bounds.height;
      mouse.normX = mouse.x / bounds.width;
    } else {
      mouse.x = correct.x;
      mouse.y = correct.y;
    }
  }
  return {
    svg,
    area,
    mouse
  };
}
const types = { brown: "brown", pink: "pink", white: "white" };
const filterTypes = { lowpass: "LP", highpass: "HP", bandpass: "BP" };
const filterLFOTypes = {
  sine: "SIN",
  triangle: "TRI",
  square: "SQR",
  sawtooth: "SAW"
};
const options = useStorage("noise-options", {
  noise: {
    type: "pink"
  },
  envelope: {
    attack: 0.1,
    decay: 0.1,
    sustain: 0.9,
    release: 1
  },
  volume: 1
});
const filterOptions = useStorage("filter-options", {
  on: false,
  play: false,
  volume: 0.5,
  baseFrequency: 50,
  depth: 0.1,
  frequency: 1,
  octaves: 2,
  wet: 1,
  type: "sine",
  filter: {
    Q: 1,
    type: "lowpass"
  }
});
const pannerOptions = useStorage("panner-options", {
  on: false,
  play: false,
  wet: 1,
  frequency: 1,
  depth: 1,
  volume: 1
});
const crusherOptions = useStorage("bit-options", {
  on: false,
  bits: 16,
  wet: 1,
  volume: 1
});
function useNoise() {
  const active = ref(false);
  const fftData = ref([]);
  const fftFreq = ref([]);
  const { channel } = createChannel$1("noise");
  const fft = new FFT({ size: 512, smoothing: 0.2 }).connect(channel);
  for (let j2 = 0; j2 < 32; j2++) {
    fftFreq.value[j2] = fft.getFrequencyOfIndex(j2);
  }
  const gain = new Gain(options.value.volume).connect(fft);
  const filterGain = new Gain(filterOptions.value.volume).connect(fft);
  const pannerGain = new Gain(pannerOptions.value.volume).connect(fft);
  const crusherGain = new Gain(crusherOptions.value.volume).connect(fft);
  const panner = new AutoPanner(pannerOptions.value).connect(pannerGain);
  const crusher = new BitCrusher(crusherOptions.value).connect(crusherGain).connect(panner);
  const filter2 = new AutoFilter(filterOptions.value).connect(filterGain).connect(crusher);
  const synth2 = new NoiseSynth(options.value).connect(gain).connect(filter2);
  useRafFn(() => {
    let arr = fft.getValue();
    for (let j2 = 0; j2 < 32; j2++) {
      fftData.value[j2] = dbToGain(arr[j2]) * 10;
    }
  });
  onKeyStroke(" ", (e2) => {
    e2.preventDefault();
    active.value = true;
  }, { eventName: "keydown" });
  onKeyStroke(" ", (e2) => {
    active.value = false;
  }, { eventName: "keyup" });
  watch(active, (act) => {
    if (act) {
      synth2.triggerAttack();
    } else {
      synth2.triggerRelease();
    }
  });
  watch(options.value, () => {
    synth2.set(options.value);
  });
  watch(() => options.value.volume, (vol) => {
    gain.gain.rampTo(vol, 1);
  });
  onBeforeUnmount(() => {
    synth2.triggerRelease();
  });
  watch(filterOptions.value, (opt) => {
    opt.play ? filter2.start() : filter2.stop();
    if (opt.on) {
      filterGain.gain.rampTo(filterOptions.value.volume, 0.2);
    } else {
      filterGain.gain.rampTo(0, 0.2);
    }
    filter2.set(opt);
  });
  watch(pannerOptions.value, (opt) => {
    opt.play ? panner.start() : panner.stop();
    opt.on ? pannerGain.gain.rampTo(pannerOptions.value.volume, 0.2) : pannerGain.gain.rampTo(0, 0.2);
    panner.set(opt);
  });
  watch(crusherOptions.value, (opt) => {
    opt.on ? crusherGain.gain.rampTo(crusherOptions.value.volume, 0.2) : crusherGain.gain.rampTo(0, 0.2);
    crusher.set(opt);
  });
  return {
    options,
    filterOptions,
    pannerOptions,
    crusherOptions,
    active,
    fftData,
    fftFreq,
    types,
    filterTypes,
    filterLFOTypes
  };
}
let piano;
function usePiano() {
  init$1();
  return { init: init$1, piano, pianoOnce, pianoAttack, pianoRelease, pianoReleaseAll };
}
function init$1() {
  start$1();
  if (piano)
    return;
  const { channel } = createChannel$1("piano");
  piano = new Sampler({
    urls: {
      A0: "A0.mp3",
      C1: "C1.mp3",
      "D#1": "Ds1.mp3",
      "F#1": "Fs1.mp3",
      A1: "A1.mp3",
      C2: "C2.mp3",
      "D#2": "Ds2.mp3",
      "F#2": "Fs2.mp3",
      A2: "A2.mp3",
      C3: "C3.mp3",
      "D#3": "Ds3.mp3",
      "F#3": "Fs3.mp3",
      A3: "A3.mp3",
      C4: "C4.mp3",
      "D#4": "Ds4.mp3",
      "F#4": "Fs4.mp3",
      A4: "A4.mp3",
      C5: "C5.mp3",
      "D#5": "Ds5.mp3",
      "F#5": "Fs5.mp3",
      A5: "A5.mp3",
      C6: "C6.mp3",
      "D#6": "Ds6.mp3",
      "F#6": "Fs6.mp3",
      A6: "A6.mp3",
      C7: "C7.mp3",
      "D#7": "Ds7.mp3",
      "F#7": "Fs7.mp3",
      A7: "A7.mp3",
      C8: "C8.mp3"
    },
    release: 1,
    volume: -10,
    baseUrl: "/audio/piano/"
  }).connect(channel);
}
function pianoOnce(note2 = "A4", duration2 = "8n", time) {
  if (!piano)
    return init$1();
  piano.triggerAttackRelease(note2, duration2, time);
}
function pianoAttack(note2, velocity) {
  if (!piano)
    return init$1();
  piano.triggerAttack(note2, now(), velocity);
}
function pianoRelease(note2) {
  if (!piano)
    return init$1();
  piano.triggerRelease(note2);
}
function pianoReleaseAll() {
  if (!piano)
    return init$1();
  piano.releaseAll();
}
const tracks = reactive([]);
function useSequence(metre = {
  over: 4,
  under: 4,
  sound: "A",
  volume: 1
}, order = 0, mode = "bar") {
  let pan = order % 2 == 1 ? -0.5 : 0.5;
  const audio2 = {
    meter: null,
    mic: null,
    recorder: null,
    panner: null,
    synth: null
  };
  const { channel } = createChannel$1(`sequence-${mode}-${order}`);
  audio2.panner = new PanVol(pan, 0).connect(channel);
  audio2.synth = new Sampler({
    urls: {
      A1: "tongue/high.wav",
      A2: "tongue/low.wav",
      B1: "synth/high.wav",
      B2: "synth/low.wav",
      C1: "seiko/high.wav",
      C2: "seiko/low.wav",
      D1: "/ping/high.wav",
      D2: "/ping/low.wav",
      E1: "/logic/high.wav",
      E2: "/logic/low.wav"
    },
    volume: 1,
    envelope: {
      attack: 1e-3,
      release: 2
    },
    baseUrl: "/audio/metronome/"
  }).connect(audio2.panner);
  audio2.recorder = new Recorder();
  const recorder2 = reactive({
    recording: false,
    main: false,
    accent: false,
    both: computed(() => recorder2.main && recorder2.accent),
    async load(pos = "main", blob) {
      let arr = await blob.arrayBuffer();
      let buff = await audio2.recorder.context.decodeAudioData(arr);
      audio2.synth.add(pos == "main" ? "F1" : "F2", buff);
      recorder2[pos] = true;
      recorder2.recording = false;
    },
    async rec(pos = "main") {
      if (!recorder2.recording) {
        audio2.meter = new Meter().connect(audio2.recorder);
        audio2.mic = new UserMedia(1).connect(audio2.meter);
        audio2.mic.open().then(() => {
          recorder2.recording = pos;
          audio2.recorder.start();
        }).catch((e2) => {
          console.log("mic not open");
        });
      } else {
        let blob = await audio2.recorder.stop();
        let arr = await blob.arrayBuffer();
        let buff = await audio2.recorder.context.decodeAudioData(arr);
        audio2.synth.add(pos == "main" ? "F1" : "F2", buff);
        recorder2[pos] = true;
        recorder2.recording = false;
      }
    }
  });
  watch(() => metre.sound, (sound) => {
    if (sound != "F") {
      recorder2.main = false;
      recorder2.accent = false;
    }
  });
  const current = ref("0-0");
  const steps = reactive([["0-1"], ["1-1"], ["2-1"], ["3-1"]]);
  const mutes = useStorage(`metro-${mode}-mutes-${order}`, []);
  const accents = useStorage(`metro-${mode}-accents-${order}`, [true]);
  const volume = useClamp(useStorage(`metro-${mode}-vol-${order}`, metre.volume || 1), 0, 1);
  const panning = useClamp(useStorage(`metro-${mode}-pan-${order}`, pan), -1, 1);
  const mutesCount = computed(() => mutes.value.reduce((acc, val) => {
    if (!val) {
      acc++;
    }
    return acc;
  }, 0));
  const euclidSeq = computed(() => mutesCount.value > 0 && mutesCount.value < steps.length ? getEuclideanRhythm(mutesCount.value, steps.length) : new Array(steps.length).fill("1").join(""));
  const currentSeq = computed(() => mutes.value.reduce((acc, val) => val ? acc + "0" : acc + "1", ""));
  const isEuclidean = computed(() => euclidSeq.value == currentSeq.value);
  function reset() {
    let arr = [];
    euclidSeq.value.split("").forEach((e2, i2) => {
      arr[i2] = e2 != false && e2 != null ? false : true;
    });
    mutes.value = arr;
  }
  let sequence = new Sequence((time, step) => {
    beatClick(step, time);
  }, steps, metre.under + "n").start(0);
  watch(() => metre.under, () => {
    sequence.stop().dispose();
    sequence = new Sequence((time, step) => {
      beatClick(step, time);
    }, steps, metre.under + "n").start(0);
  });
  watch(() => metre.over, () => {
    steps.length = 0;
    for (let i2 = 0; i2 < metre.over; i2++) {
      steps.push([`${i2}-1`]);
    }
    sequence.events = steps;
  }, { immediate: true });
  watchEffect(() => {
    sequence.events = steps;
    accents.value.length = steps.length;
    mutes.value.length = steps.length;
  });
  watchEffect(() => {
    if (tempo.stopped) {
      current.value = "1000-1";
    }
  });
  watch(volume, (vol) => {
    audio2.panner.volume.targetRampTo(gainToDb(vol), 1);
  }, { immediate: true });
  watch(panning, (p2) => {
    audio2.panner.pan.targetRampTo(p2, 1);
  }, { immediate: true });
  const progress = computed(() => {
    if (tempo.ticks) {
      return sequence.progress;
    } else {
      return 0;
    }
  });
  function beatClick(step, time) {
    if (context.state == "suspended") {
      start$1();
    }
    let mainStep = typeof step == "string" ? +step.split("-")[0] : step;
    Draw.schedule(() => {
      current.value = step;
    }, time);
    let accented = accents.value[mainStep] && step.split("-")[1] == "1";
    if (mutes.value[mainStep])
      return;
    if (mutes.value[step])
      return;
    if (metre.sound == "F" && !accented && !recorder2.main)
      return;
    if (metre.sound == "F" && accented && !recorder2.accent)
      return;
    let note2 = `${metre.sound}${accented ? 2 : 1}`;
    audio2.synth.triggerAttackRelease(note2, metre.under + "n", time);
  }
  const lastHit = ref(0);
  onKeyStroke("Shift", () => {
    lastHit.value = progress.value;
  });
  onBeforeUnmount(() => {
    sequence.stop().dispose();
    audio2.panner.dispose();
    audio2.synth.dispose();
  });
  tracks[order] = reactive({
    metre: computed(() => metre),
    steps,
    mutes,
    accents,
    mutesCount,
    isEuclidean,
    reset
  });
  return {
    progress,
    current,
    steps,
    mutes,
    accents,
    volume,
    panning,
    recorder: recorder2,
    lastHit,
    reset,
    isEuclidean
  };
}
function _getEuclideanRhythm(m2, k2, input2) {
  input2 = input2 || new Array(m2).fill("1").concat(new Array(k2).fill("0"));
  const output = [];
  for (let i2 = 0; i2 < Math.min(m2, k2); i2++) {
    output.push(input2.shift() + input2.pop());
  }
  if (input2.length > 1) {
    return _getEuclideanRhythm(output.length, input2.length, output.concat(input2));
  }
  return output.concat(input2);
}
function getEuclideanRhythm(x2, total) {
  return _getEuclideanRhythm(x2, total - x2).join("");
}
var meyda_min = { exports: {} };
(function(module, exports) {
  !function(r2, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    function r2(r3, t3, e3) {
      if (e3 || arguments.length === 2)
        for (var a3, n3 = 0, o3 = t3.length; n3 < o3; n3++)
          !a3 && n3 in t3 || (a3 || (a3 = Array.prototype.slice.call(t3, 0, n3)), a3[n3] = t3[n3]);
      return r3.concat(a3 || Array.prototype.slice.call(t3));
    }
    var t2 = Object.freeze({ __proto__: null, blackman: function(r3) {
      for (var t3 = new Float32Array(r3), e3 = 2 * Math.PI / (r3 - 1), a3 = 2 * e3, n3 = 0; n3 < r3 / 2; n3++)
        t3[n3] = 0.42 - 0.5 * Math.cos(n3 * e3) + 0.08 * Math.cos(n3 * a3);
      for (n3 = Math.ceil(r3 / 2); n3 > 0; n3--)
        t3[r3 - n3] = t3[n3 - 1];
      return t3;
    }, sine: function(r3) {
      for (var t3 = Math.PI / (r3 - 1), e3 = new Float32Array(r3), a3 = 0; a3 < r3; a3++)
        e3[a3] = Math.sin(t3 * a3);
      return e3;
    }, hanning: function(r3) {
      for (var t3 = new Float32Array(r3), e3 = 0; e3 < r3; e3++)
        t3[e3] = 0.5 - 0.5 * Math.cos(2 * Math.PI * e3 / (r3 - 1));
      return t3;
    }, hamming: function(r3) {
      for (var t3 = new Float32Array(r3), e3 = 0; e3 < r3; e3++)
        t3[e3] = 0.54 - 0.46 * Math.cos(2 * Math.PI * (e3 / r3 - 1));
      return t3;
    } }), e2 = {};
    function a2(r3) {
      for (; r3 % 2 == 0 && r3 > 1; )
        r3 /= 2;
      return r3 === 1;
    }
    function n2(r3, a3) {
      if (a3 !== "rect") {
        if (a3 !== "" && a3 || (a3 = "hanning"), e2[a3] || (e2[a3] = {}), !e2[a3][r3.length])
          try {
            e2[a3][r3.length] = t2[a3](r3.length);
          } catch (r4) {
            throw new Error("Invalid windowing function");
          }
        r3 = function(r4, t3) {
          for (var e3 = [], a4 = 0; a4 < Math.min(r4.length, t3.length); a4++)
            e3[a4] = r4[a4] * t3[a4];
          return e3;
        }(r3, e2[a3][r3.length]);
      }
      return r3;
    }
    function o2(r3, t3, e3) {
      for (var a3 = new Float32Array(r3), n3 = 0; n3 < a3.length; n3++)
        a3[n3] = n3 * t3 / e3, a3[n3] = 13 * Math.atan(a3[n3] / 1315.8) + 3.5 * Math.atan(Math.pow(a3[n3] / 7518, 2));
      return a3;
    }
    function i2(r3) {
      return Float32Array.from(r3);
    }
    function u2(r3) {
      return 1125 * Math.log(1 + r3 / 700);
    }
    function f2(r3, t3, e3) {
      for (var a3, n3 = new Float32Array(r3 + 2), o3 = new Float32Array(r3 + 2), i3 = t3 / 2, f3 = u2(0), c3 = (u2(i3) - f3) / (r3 + 1), l3 = new Array(r3 + 2), s3 = 0; s3 < n3.length; s3++)
        n3[s3] = s3 * c3, o3[s3] = (a3 = n3[s3], 700 * (Math.exp(a3 / 1125) - 1)), l3[s3] = Math.floor((e3 + 1) * o3[s3] / t3);
      for (var m3 = new Array(r3), p3 = 0; p3 < m3.length; p3++) {
        m3[p3] = new Array(e3 / 2 + 1).fill(0);
        for (s3 = l3[p3]; s3 < l3[p3 + 1]; s3++)
          m3[p3][s3] = (s3 - l3[p3]) / (l3[p3 + 1] - l3[p3]);
        for (s3 = l3[p3 + 1]; s3 < l3[p3 + 2]; s3++)
          m3[p3][s3] = (l3[p3 + 2] - s3) / (l3[p3 + 2] - l3[p3 + 1]);
      }
      return m3;
    }
    function c2(t3, e3, a3, n3, o3, i3, u3) {
      n3 === void 0 && (n3 = 5), o3 === void 0 && (o3 = 2), i3 === void 0 && (i3 = true), u3 === void 0 && (u3 = 440);
      var f3 = Math.floor(a3 / 2) + 1, c3 = new Array(a3).fill(0).map(function(r3, n4) {
        return t3 * function(r4, t4) {
          return Math.log2(16 * r4 / t4);
        }(e3 * n4 / a3, u3);
      });
      c3[0] = c3[1] - 1.5 * t3;
      var l3, s3, m3, p3 = c3.slice(1).map(function(r3, t4) {
        return Math.max(r3 - c3[t4]);
      }, 1).concat([1]), h3 = Math.round(t3 / 2), g3 = new Array(t3).fill(0).map(function(r3, e4) {
        return c3.map(function(r4) {
          return (10 * t3 + h3 + r4 - e4) % t3 - h3;
        });
      }), w3 = g3.map(function(r3, t4) {
        return r3.map(function(r4, e4) {
          return Math.exp(-0.5 * Math.pow(2 * g3[t4][e4] / p3[e4], 2));
        });
      });
      if (s3 = (l3 = w3)[0].map(function() {
        return 0;
      }), m3 = l3.reduce(function(r3, t4) {
        return t4.forEach(function(t5, e4) {
          r3[e4] += Math.pow(t5, 2);
        }), r3;
      }, s3).map(Math.sqrt), w3 = l3.map(function(r3, t4) {
        return r3.map(function(r4, t5) {
          return r4 / (m3[t5] || 1);
        });
      }), o3) {
        var v3 = c3.map(function(r3) {
          return Math.exp(-0.5 * Math.pow((r3 / t3 - n3) / o3, 2));
        });
        w3 = w3.map(function(r3) {
          return r3.map(function(r4, t4) {
            return r4 * v3[t4];
          });
        });
      }
      return i3 && (w3 = r2(r2([], w3.slice(3), true), w3.slice(0, 3), true)), w3.map(function(r3) {
        return r3.slice(0, f3);
      });
    }
    function l2(r3, t3) {
      for (var e3 = 0, a3 = 0, n3 = 0; n3 < t3.length; n3++)
        e3 += Math.pow(n3, r3) * Math.abs(t3[n3]), a3 += t3[n3];
      return e3 / a3;
    }
    function s2(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.barkScale, a3 = r3.numberOfBarkBands, n3 = a3 === void 0 ? 24 : a3;
      if (typeof t3 != "object" || typeof e3 != "object")
        throw new TypeError();
      var o3 = n3, i3 = new Float32Array(o3), u3 = 0, f3 = t3, c3 = new Int32Array(o3 + 1);
      c3[0] = 0;
      for (var l3 = e3[f3.length - 1] / o3, s3 = 1, m3 = 0; m3 < f3.length; m3++)
        for (; e3[m3] > l3; )
          c3[s3++] = m3, l3 = s3 * e3[f3.length - 1] / o3;
      c3[o3] = f3.length - 1;
      for (m3 = 0; m3 < o3; m3++) {
        for (var p3 = 0, h3 = c3[m3]; h3 < c3[m3 + 1]; h3++)
          p3 += f3[h3];
        i3[m3] = Math.pow(p3, 0.23);
      }
      for (m3 = 0; m3 < i3.length; m3++)
        u3 += i3[m3];
      return { specific: i3, total: u3 };
    }
    function m2(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = new Float32Array(t3.length), a3 = 0; a3 < e3.length; a3++)
        e3[a3] = Math.pow(t3[a3], 2);
      return e3;
    }
    function p2(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.melFilterBank, a3 = r3.bufferSize;
      if (typeof t3 != "object")
        throw new TypeError("Valid ampSpectrum is required to generate melBands");
      if (typeof e3 != "object")
        throw new TypeError("Valid melFilterBank is required to generate melBands");
      for (var n3 = m2({ ampSpectrum: t3 }), o3 = e3.length, i3 = Array(o3), u3 = new Float32Array(o3), f3 = 0; f3 < u3.length; f3++) {
        i3[f3] = new Float32Array(a3 / 2), u3[f3] = 0;
        for (var c3 = 0; c3 < a3 / 2; c3++)
          i3[f3][c3] = e3[f3][c3] * n3[c3], u3[f3] += i3[f3][c3];
        u3[f3] = Math.log(u3[f3] + 1);
      }
      return Array.prototype.slice.call(u3);
    }
    function h2(r3) {
      return r3 && r3.__esModule && Object.prototype.hasOwnProperty.call(r3, "default") ? r3.default : r3;
    }
    var g2 = { exports: {} }, w2 = null;
    var v2 = function(r3, t3) {
      var e3 = r3.length;
      return t3 = t3 || 2, w2 && w2[e3] || function(r4) {
        (w2 = w2 || {})[r4] = new Array(r4 * r4);
        for (var t4 = Math.PI / r4, e4 = 0; e4 < r4; e4++)
          for (var a3 = 0; a3 < r4; a3++)
            w2[r4][a3 + e4 * r4] = Math.cos(t4 * (a3 + 0.5) * e4);
      }(e3), r3.map(function() {
        return 0;
      }).map(function(a3, n3) {
        return t3 * r3.reduce(function(r4, t4, a4, o3) {
          return r4 + t4 * w2[e3][a4 + n3 * e3];
        }, 0);
      });
    };
    !function(r3) {
      r3.exports = v2;
    }(g2);
    var d2 = h2(g2.exports);
    var y2 = Object.freeze({ __proto__: null, buffer: function(r3) {
      return r3.signal;
    }, rms: function(r3) {
      var t3 = r3.signal;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = 0, a3 = 0; a3 < t3.length; a3++)
        e3 += Math.pow(t3[a3], 2);
      return e3 /= t3.length, e3 = Math.sqrt(e3);
    }, energy: function(r3) {
      var t3 = r3.signal;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = 0, a3 = 0; a3 < t3.length; a3++)
        e3 += Math.pow(Math.abs(t3[a3]), 2);
      return e3;
    }, complexSpectrum: function(r3) {
      return r3.complexSpectrum;
    }, spectralSlope: function(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.sampleRate, a3 = r3.bufferSize;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var n3 = 0, o3 = 0, i3 = new Float32Array(t3.length), u3 = 0, f3 = 0, c3 = 0; c3 < t3.length; c3++) {
        n3 += t3[c3];
        var l3 = c3 * e3 / a3;
        i3[c3] = l3, u3 += l3 * l3, o3 += l3, f3 += l3 * t3[c3];
      }
      return (t3.length * f3 - o3 * n3) / (n3 * (u3 - Math.pow(o3, 2)));
    }, spectralCentroid: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      return l2(1, t3);
    }, spectralRolloff: function(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.sampleRate;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var a3 = t3, n3 = e3 / (2 * (a3.length - 1)), o3 = 0, i3 = 0; i3 < a3.length; i3++)
        o3 += a3[i3];
      for (var u3 = 0.99 * o3, f3 = a3.length - 1; o3 > u3 && f3 >= 0; )
        o3 -= a3[f3], --f3;
      return (f3 + 1) * n3;
    }, spectralFlatness: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = 0, a3 = 0, n3 = 0; n3 < t3.length; n3++)
        e3 += Math.log(t3[n3]), a3 += t3[n3];
      return Math.exp(e3 / t3.length) * t3.length / a3;
    }, spectralSpread: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      return Math.sqrt(l2(2, t3) - Math.pow(l2(1, t3), 2));
    }, spectralSkewness: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      var e3 = l2(1, t3), a3 = l2(2, t3), n3 = l2(3, t3);
      return (2 * Math.pow(e3, 3) - 3 * e3 * a3 + n3) / Math.pow(Math.sqrt(a3 - Math.pow(e3, 2)), 3);
    }, spectralKurtosis: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      var e3 = t3, a3 = l2(1, e3), n3 = l2(2, e3), o3 = l2(3, e3), i3 = l2(4, e3);
      return (-3 * Math.pow(a3, 4) + 6 * a3 * n3 - 4 * a3 * o3 + i3) / Math.pow(Math.sqrt(n3 - Math.pow(a3, 2)), 4);
    }, amplitudeSpectrum: function(r3) {
      return r3.ampSpectrum;
    }, zcr: function(r3) {
      var t3 = r3.signal;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = 0, a3 = 1; a3 < t3.length; a3++)
        (t3[a3 - 1] >= 0 && t3[a3] < 0 || t3[a3 - 1] < 0 && t3[a3] >= 0) && e3++;
      return e3;
    }, loudness: s2, perceptualSpread: function(r3) {
      for (var t3 = s2({ ampSpectrum: r3.ampSpectrum, barkScale: r3.barkScale }), e3 = 0, a3 = 0; a3 < t3.specific.length; a3++)
        t3.specific[a3] > e3 && (e3 = t3.specific[a3]);
      return Math.pow((t3.total - e3) / t3.total, 2);
    }, perceptualSharpness: function(r3) {
      for (var t3 = s2({ ampSpectrum: r3.ampSpectrum, barkScale: r3.barkScale }), e3 = t3.specific, a3 = 0, n3 = 0; n3 < e3.length; n3++)
        a3 += n3 < 15 ? (n3 + 1) * e3[n3 + 1] : 0.066 * Math.exp(0.171 * (n3 + 1));
      return a3 *= 0.11 / t3.total;
    }, powerSpectrum: m2, mfcc: function(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.melFilterBank, a3 = r3.numberOfMFCCCoefficients, n3 = r3.bufferSize, o3 = Math.min(40, Math.max(1, a3 || 13));
      if (e3.length < o3)
        throw new Error("Insufficient filter bank for requested number of coefficients");
      var i3 = p2({ ampSpectrum: t3, melFilterBank: e3, bufferSize: n3 });
      return d2(i3).slice(0, o3);
    }, chroma: function(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.chromaFilterBank;
      if (typeof t3 != "object")
        throw new TypeError("Valid ampSpectrum is required to generate chroma");
      if (typeof e3 != "object")
        throw new TypeError("Valid chromaFilterBank is required to generate chroma");
      var a3 = e3.map(function(r4, e4) {
        return t3.reduce(function(t4, e5, a4) {
          return t4 + e5 * r4[a4];
        }, 0);
      }), n3 = Math.max.apply(Math, a3);
      return n3 ? a3.map(function(r4) {
        return r4 / n3;
      }) : a3;
    }, spectralFlux: function(r3) {
      var t3 = r3.signal, e3 = r3.previousSignal, a3 = r3.bufferSize;
      if (typeof t3 != "object" || typeof e3 != "object")
        throw new TypeError();
      for (var n3 = 0, o3 = -a3 / 2; o3 < t3.length / 2 - 1; o3++)
        x = Math.abs(t3[o3]) - Math.abs(e3[o3]), n3 += (x + Math.abs(x)) / 2;
      return n3;
    }, spectralCrest: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      var e3 = 0, a3 = -1 / 0;
      return t3.forEach(function(r4) {
        e3 += Math.pow(r4, 2), a3 = r4 > a3 ? r4 : a3;
      }), e3 /= t3.length, e3 = Math.sqrt(e3), a3 / e3;
    }, melBands: p2 });
    function S2(r3) {
      if (Array.isArray(r3)) {
        for (var t3 = 0, e3 = Array(r3.length); t3 < r3.length; t3++)
          e3[t3] = r3[t3];
        return e3;
      }
      return Array.from(r3);
    }
    var _ = {}, b2 = {}, M2 = { bitReverseArray: function(r3) {
      if (_[r3] === void 0) {
        for (var t3 = (r3 - 1).toString(2).length, e3 = "0".repeat(t3), a3 = {}, n3 = 0; n3 < r3; n3++) {
          var o3 = n3.toString(2);
          o3 = e3.substr(o3.length) + o3, o3 = [].concat(S2(o3)).reverse().join(""), a3[n3] = parseInt(o3, 2);
        }
        _[r3] = a3;
      }
      return _[r3];
    }, multiply: function(r3, t3) {
      return { real: r3.real * t3.real - r3.imag * t3.imag, imag: r3.real * t3.imag + r3.imag * t3.real };
    }, add: function(r3, t3) {
      return { real: r3.real + t3.real, imag: r3.imag + t3.imag };
    }, subtract: function(r3, t3) {
      return { real: r3.real - t3.real, imag: r3.imag - t3.imag };
    }, euler: function(r3, t3) {
      var e3 = -2 * Math.PI * r3 / t3;
      return { real: Math.cos(e3), imag: Math.sin(e3) };
    }, conj: function(r3) {
      return r3.imag *= -1, r3;
    }, constructComplexArray: function(r3) {
      var t3 = {};
      t3.real = r3.real === void 0 ? r3.slice() : r3.real.slice();
      var e3 = t3.real.length;
      return b2[e3] === void 0 && (b2[e3] = Array.apply(null, Array(e3)).map(Number.prototype.valueOf, 0)), t3.imag = b2[e3].slice(), t3;
    } }, F = function(r3) {
      var t3 = {};
      r3.real === void 0 || r3.imag === void 0 ? t3 = M2.constructComplexArray(r3) : (t3.real = r3.real.slice(), t3.imag = r3.imag.slice());
      var e3 = t3.real.length, a3 = Math.log2(e3);
      if (Math.round(a3) != a3)
        throw new Error("Input size must be a power of 2.");
      if (t3.real.length != t3.imag.length)
        throw new Error("Real and imaginary components must have the same length.");
      for (var n3 = M2.bitReverseArray(e3), o3 = { real: [], imag: [] }, i3 = 0; i3 < e3; i3++)
        o3.real[n3[i3]] = t3.real[i3], o3.imag[n3[i3]] = t3.imag[i3];
      for (var u3 = 0; u3 < e3; u3++)
        t3.real[u3] = o3.real[u3], t3.imag[u3] = o3.imag[u3];
      for (var f3 = 1; f3 <= a3; f3++)
        for (var c3 = Math.pow(2, f3), l3 = 0; l3 < c3 / 2; l3++)
          for (var s3 = M2.euler(l3, c3), m3 = 0; m3 < e3 / c3; m3++) {
            var p3 = c3 * m3 + l3, h3 = c3 * m3 + l3 + c3 / 2, g3 = { real: t3.real[p3], imag: t3.imag[p3] }, w3 = { real: t3.real[h3], imag: t3.imag[h3] }, v3 = M2.multiply(s3, w3), d3 = M2.subtract(g3, v3);
            t3.real[h3] = d3.real, t3.imag[h3] = d3.imag;
            var y3 = M2.add(v3, g3);
            t3.real[p3] = y3.real, t3.imag[p3] = y3.imag;
          }
      return t3;
    }, A = F, E = function() {
      function r3(r4, t3) {
        var e3 = this;
        if (this._m = t3, !r4.audioContext)
          throw this._m.errors.noAC;
        if (r4.bufferSize && !a2(r4.bufferSize))
          throw this._m._errors.notPow2;
        if (!r4.source)
          throw this._m._errors.noSource;
        this._m.audioContext = r4.audioContext, this._m.bufferSize = r4.bufferSize || this._m.bufferSize || 256, this._m.hopSize = r4.hopSize || this._m.hopSize || this._m.bufferSize, this._m.sampleRate = r4.sampleRate || this._m.audioContext.sampleRate || 44100, this._m.callback = r4.callback, this._m.windowingFunction = r4.windowingFunction || "hanning", this._m.featureExtractors = y2, this._m.EXTRACTION_STARTED = r4.startImmediately || false, this._m.channel = typeof r4.channel == "number" ? r4.channel : 0, this._m.inputs = r4.inputs || 1, this._m.outputs = r4.outputs || 1, this._m.numberOfMFCCCoefficients = r4.numberOfMFCCCoefficients || this._m.numberOfMFCCCoefficients || 13, this._m.numberOfBarkBands = r4.numberOfBarkBands || this._m.numberOfBarkBands || 24, this._m.spn = this._m.audioContext.createScriptProcessor(this._m.bufferSize, this._m.inputs, this._m.outputs), this._m.spn.connect(this._m.audioContext.destination), this._m._featuresToExtract = r4.featureExtractors || [], this._m.barkScale = o2(this._m.bufferSize, this._m.sampleRate, this._m.bufferSize), this._m.melFilterBank = f2(Math.max(this._m.melBands, this._m.numberOfMFCCCoefficients), this._m.sampleRate, this._m.bufferSize), this._m.inputData = null, this._m.previousInputData = null, this._m.frame = null, this._m.previousFrame = null, this.setSource(r4.source), this._m.spn.onaudioprocess = function(r5) {
          var t4;
          e3._m.inputData !== null && (e3._m.previousInputData = e3._m.inputData), e3._m.inputData = r5.inputBuffer.getChannelData(e3._m.channel), e3._m.previousInputData ? ((t4 = new Float32Array(e3._m.previousInputData.length + e3._m.inputData.length - e3._m.hopSize)).set(e3._m.previousInputData.slice(e3._m.hopSize)), t4.set(e3._m.inputData, e3._m.previousInputData.length - e3._m.hopSize)) : t4 = e3._m.inputData, function(r6, t5, e4) {
            if (r6.length < t5)
              throw new Error("Buffer is too short for frame length");
            if (e4 < 1)
              throw new Error("Hop length cannot be less that 1");
            if (t5 < 1)
              throw new Error("Frame length cannot be less that 1");
            var a3 = 1 + Math.floor((r6.length - t5) / e4);
            return new Array(a3).fill(0).map(function(a4, n3) {
              return r6.slice(n3 * e4, n3 * e4 + t5);
            });
          }(t4, e3._m.bufferSize, e3._m.hopSize).forEach(function(r6) {
            e3._m.frame = r6;
            var t5 = e3._m.extract(e3._m._featuresToExtract, e3._m.frame, e3._m.previousFrame);
            typeof e3._m.callback == "function" && e3._m.EXTRACTION_STARTED && e3._m.callback(t5), e3._m.previousFrame = e3._m.frame;
          });
        };
      }
      return r3.prototype.start = function(r4) {
        this._m._featuresToExtract = r4 || this._m._featuresToExtract, this._m.EXTRACTION_STARTED = true;
      }, r3.prototype.stop = function() {
        this._m.EXTRACTION_STARTED = false;
      }, r3.prototype.setSource = function(r4) {
        this._m.source && this._m.source.disconnect(this._m.spn), this._m.source = r4, this._m.source.connect(this._m.spn);
      }, r3.prototype.setChannel = function(r4) {
        r4 <= this._m.inputs ? this._m.channel = r4 : console.error("Channel ".concat(r4, " does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(r4, " when instantiating the MeydaAnalyzer"));
      }, r3.prototype.get = function(r4) {
        return this._m.inputData ? this._m.extract(r4 || this._m._featuresToExtract, this._m.inputData, this._m.previousInputData) : null;
      }, r3;
    }(), C = { audioContext: null, spn: null, bufferSize: 512, sampleRate: 44100, melBands: 26, chromaBands: 12, callback: null, windowingFunction: "hanning", featureExtractors: y2, EXTRACTION_STARTED: false, numberOfMFCCCoefficients: 13, numberOfBarkBands: 24, _featuresToExtract: [], windowing: n2, _errors: { notPow2: new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"), featureUndef: new Error("Meyda: No features defined."), invalidFeatureFmt: new Error("Meyda: Invalid feature format"), invalidInput: new Error("Meyda: Invalid input."), noAC: new Error("Meyda: No AudioContext specified."), noSource: new Error("Meyda: No source node specified.") }, createMeydaAnalyzer: function(r3) {
      return new E(r3, Object.assign({}, C));
    }, listAvailableFeatureExtractors: function() {
      return Object.keys(this.featureExtractors);
    }, extract: function(r3, t3, e3) {
      var n3 = this;
      if (!t3)
        throw this._errors.invalidInput;
      if (typeof t3 != "object")
        throw this._errors.invalidInput;
      if (!r3)
        throw this._errors.featureUndef;
      if (!a2(t3.length))
        throw this._errors.notPow2;
      this.barkScale !== void 0 && this.barkScale.length == this.bufferSize || (this.barkScale = o2(this.bufferSize, this.sampleRate, this.bufferSize)), this.melFilterBank !== void 0 && this.barkScale.length == this.bufferSize && this.melFilterBank.length == this.melBands || (this.melFilterBank = f2(Math.max(this.melBands, this.numberOfMFCCCoefficients), this.sampleRate, this.bufferSize)), this.chromaFilterBank !== void 0 && this.chromaFilterBank.length == this.chromaBands || (this.chromaFilterBank = c2(this.chromaBands, this.sampleRate, this.bufferSize)), "buffer" in t3 && t3.buffer === void 0 ? this.signal = i2(t3) : this.signal = t3;
      var u3 = k2(t3, this.windowingFunction, this.bufferSize);
      if (this.signal = u3.windowedSignal, this.complexSpectrum = u3.complexSpectrum, this.ampSpectrum = u3.ampSpectrum, e3) {
        var l3 = k2(e3, this.windowingFunction, this.bufferSize);
        this.previousSignal = l3.windowedSignal, this.previousComplexSpectrum = l3.complexSpectrum, this.previousAmpSpectrum = l3.ampSpectrum;
      }
      var s3 = function(r4) {
        return n3.featureExtractors[r4]({ ampSpectrum: n3.ampSpectrum, chromaFilterBank: n3.chromaFilterBank, complexSpectrum: n3.complexSpectrum, signal: n3.signal, bufferSize: n3.bufferSize, sampleRate: n3.sampleRate, barkScale: n3.barkScale, melFilterBank: n3.melFilterBank, previousSignal: n3.previousSignal, previousAmpSpectrum: n3.previousAmpSpectrum, previousComplexSpectrum: n3.previousComplexSpectrum, numberOfMFCCCoefficients: n3.numberOfMFCCCoefficients, numberOfBarkBands: n3.numberOfBarkBands });
      };
      if (typeof r3 == "object")
        return r3.reduce(function(r4, t4) {
          var e4;
          return Object.assign({}, r4, ((e4 = {})[t4] = s3(t4), e4));
        }, {});
      if (typeof r3 == "string")
        return s3(r3);
      throw this._errors.invalidFeatureFmt;
    } }, k2 = function(r3, t3, e3) {
      var a3 = {};
      r3.buffer === void 0 ? a3.signal = i2(r3) : a3.signal = r3, a3.windowedSignal = n2(a3.signal, t3), a3.complexSpectrum = A(a3.windowedSignal), a3.ampSpectrum = new Float32Array(e3 / 2);
      for (var o3 = 0; o3 < e3 / 2; o3++)
        a3.ampSpectrum[o3] = Math.sqrt(Math.pow(a3.complexSpectrum.real[o3], 2) + Math.pow(a3.complexSpectrum.imag[o3], 2));
      return a3;
    };
    return typeof window != "undefined" && (window.Meyda = C), C;
  });
})(meyda_min);
var Meyda = /* @__PURE__ */ getDefaultExportFromCjs(meyda_min.exports);
const noteStrings = [
  "C",
  "C\u266F",
  "D",
  "D\u266F",
  "E",
  "F",
  "F\u266F",
  "G",
  "G\u266F",
  "A",
  "A\u266F",
  "B"
];
const settings = {
  middleA: 440,
  semitone: 69
};
const tuner = reactive({
  initiated: false,
  stream: null,
  middleA: settings.middleA,
  semitone: settings.semitone,
  note: {
    name: "A",
    value: 69,
    cents: 0,
    octave: 4,
    frequency: 440,
    color: freqColor(440),
    silent: false
  },
  span: 64,
  bufferSize: 4096,
  tempoBufferSize: 512,
  frequencyData: null,
  running: false,
  frame: 0,
  beat: 0,
  bpm: 0,
  confidence: 0,
  listenBeat: false,
  prevBeat: 0,
  blink: false,
  chroma: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  spec: [],
  rms: 0
});
const chain = {};
function useTuner() {
  initGetUserMedia();
  return {
    init,
    tuner,
    chain
  };
}
function init() {
  tuner.initiated = true;
  chain.audioContext = new window.AudioContext();
  chain.analyser = chain.audioContext.createAnalyser();
  chain.scriptProcessor = chain.audioContext.createScriptProcessor(tuner.bufferSize, 1, 1);
  chain.beatProcessor = chain.audioContext.createScriptProcessor(tuner.tempoBufferSize, 1, 1);
  watch(() => tuner.frame, () => {
    if (!tuner.listen)
      return;
    if (tuner.beat > tuner.prevBeat) {
      tuner.prevBeat = tuner.beat;
      tuner.blink = true;
      setTimeout(() => {
        tuner.blink = false;
      }, 60);
    }
  });
  chain.meyda = Meyda.createMeydaAnalyzer({
    audioContext: chain.audioContext,
    source: chain.analyser,
    bufferSize: 4096,
    featureExtractors: ["chroma", "amplitudeSpectrum", "rms"],
    callback: (features) => {
      tuner.rms = features.rms;
      tuner.chroma = features.chroma;
      tuner.spec = features.amplitudeSpectrum;
    }
  });
  chain.meyda.start();
  tuner.frequencyData = new Uint8Array(chain.analyser.frequencyBinCount);
  Aubio$1().then(function(aubio) {
    chain.pitchDetector = new aubio.Pitch("default", tuner.bufferSize, 1, chain.audioContext.sampleRate);
    chain.tempoAnalyzer = new aubio.Tempo(tuner.tempoBufferSize * 4, tuner.tempoBufferSize, chain.audioContext.sampleRate);
    tuner.running = true;
    start();
  });
}
function start() {
  navigator.mediaDevices.getUserMedia({ audio: true }).then(function(stream) {
    tuner.stream = stream;
    chain.audioContext.createMediaStreamSource(stream).connect(chain.analyser);
    chain.analyser.connect(chain.scriptProcessor);
    chain.analyser.connect(chain.beatProcessor);
    chain.scriptProcessor.connect(chain.audioContext.destination);
    chain.beatProcessor.connect(chain.audioContext.destination);
    chain.beatProcessor.addEventListener("audioprocess", (e2) => {
      const tempo2 = chain.tempoAnalyzer.do(e2.inputBuffer.getChannelData(0));
      if (tempo2) {
        tuner.beat++;
        tuner.confidence = chain.tempoAnalyzer.getConfidence();
        tuner.bpm = chain.tempoAnalyzer.getBpm();
      }
    });
    chain.scriptProcessor.addEventListener("audioprocess", function(event) {
      const frequency = chain.pitchDetector.do(event.inputBuffer.getChannelData(0));
      tuner.frame++;
      if (frequency) {
        const note2 = getNote(frequency);
        tuner.note = {
          name: noteStrings[note2 % 12],
          value: note2,
          cents: getCents(frequency, note2),
          octave: parseInt(note2 / 12) - 1,
          frequency,
          color: freqColor(frequency),
          silent: false
        };
      } else {
        tuner.note.silent = true;
      }
    });
  }).catch(function(error) {
    console.log(error.name + ": " + error.message);
  });
}
function getNote(frequency) {
  const note2 = 12 * (Math.log(frequency / tuner.middleA) / Math.log(2));
  return Math.round(note2) + tuner.semitone;
}
function getStandardFrequency(note2) {
  return tuner.middleA * Math.pow(2, (note2 - tuner.semitone) / 12);
}
function getCents(frequency, note2) {
  return Math.floor(1200 * Math.log(frequency / getStandardFrequency(note2)) / Math.log(2));
}
function freqColor(frequency) {
  const note2 = getRawNote(frequency);
  if (!note2)
    return "#333";
  const octave2 = parseInt(note2 / 12) + 2;
  const color = pitchColor(note2, octave2);
  return color;
}
function getRawNote(frequency) {
  return 12 * (Math.log(frequency / settings.middleA) / Math.log(2)) % 12;
}
export { midiAttack as $, getSupportedMimeTypes as A, fileNames as B, devices as C, cameras as D, microphones as E, ensureDevicesListPermissions as F, download as G, useRecording as H, cast as I, globalScale as J, playChromaOnce as K, playChroma as L, stopChroma as M, playNote as N, stopNote as O, lchToHsl as P, getColorInfo as Q, levelColor as R, chromaColorMix as S, setupKeyboard as T, useLoop as U, mic as V, useMic as W, midi$1 as X, learnCC as Y, playKey as Z, useMidi as _, channels as a, midiPlay as a0, midiStop as a1, midiRelease as a2, midiOnce$1 as a3, setCC as a4, stopAll as a5, forwardMidi as a6, createAndDownloadBlobFile as a7, useSvgMouse as a8, useNoise as a9, intervals as aA, noteNames as aB, notes as aC, chords as aD, scales as aE, tuner as aF, useTuner as aG, usePiano as aa, pianoOnce as ab, pianoAttack as ac, pianoRelease as ad, pianoReleaseAll as ae, recorder as af, recording as ag, record as ah, useRecorder as ai, tracks as aj, useSequence as ak, getEuclideanRhythm as al, quantizeModes as am, synth as an, useSynth as ao, synthOnce as ap, synthAttack as aq, synthRelease as ar, synthReleaseAll as as, tempo as at, useTempo as au, tap as av, chordType as aw, scaleType as ax, chordList as ay, scaleList as az, createChannel$1 as b, commonjsGlobal as c, midiA as d, pitchFreq as e, pitchColor as f, freqColor$1 as g, freqPitch as h, initGetUserMedia as i, isInChroma as j, getCircleCoord as k, clampNum as l, master as m, getCents$1 as n, getStandardFrequency$1 as o, pitchNoteOctave as p, currentCamera as q, rotateArray as r, currentMic as s, showRecordingDialog as t, useAudio as u, recordingName as v, recordCamera as w, mimeType as x, mimeExtMap as y, getFilename as z };
