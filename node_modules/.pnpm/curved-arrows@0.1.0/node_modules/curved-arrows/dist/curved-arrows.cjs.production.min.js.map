{"version":3,"file":"curved-arrows.cjs.production.min.js","sources":["../src/utils.ts","../src/getBoxToBoxArrow.ts","../src/getArrow.ts"],"sourcesContent":["export type RectSide = 'top' | 'right' | 'bottom' | 'left'\nexport type Vec2 = { x: number; y: number }\nexport type Box = {\n  x: number\n  y: number\n  w: number\n  h: number\n}\n\n/** Calculate the distance of two points. */\nexport function distanceOf(p1: Vec2, p2: Vec2): number {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2))\n}\n\n/**\n * @param box\n * @param size Add `size` to all edges.\n */\nexport function growBox(box: Box, size: number): Box {\n  return {\n    x: box.x - size,\n    y: box.y - size,\n    w: box.w + 2 * size,\n    h: box.h + 2 * size,\n  }\n}\n\nexport function isPointInBox(point: Vec2, box: Box): boolean {\n  return (\n    point.x > box.x &&\n    point.x < box.x + box.w &&\n    point.y > box.y &&\n    point.y < box.y + box.h\n  )\n}\n\n/** Calculate the control point. */\nexport function controlPointOf(\n  target: Vec2,\n  another: Vec2,\n  sideOfTarget: RectSide\n) {\n  const margin = 30\n  switch (sideOfTarget) {\n    case 'top': {\n      return {\n        x: target.x,\n        y: Math.min(target.y - (target.y - another.y) / 2, target.y - margin),\n      }\n    }\n    case 'bottom': {\n      return {\n        x: target.x,\n        y: Math.max(target.y - (target.y - another.y) / 2, target.y + margin),\n      }\n    }\n    case 'left': {\n      return {\n        x: Math.min(target.x - (target.x - another.x) / 2, target.x - margin),\n        y: target.y,\n      }\n    }\n    case 'right': {\n      return {\n        x: Math.max(target.x - (target.x - another.x) / 2, target.x + margin),\n        y: target.y,\n      }\n    }\n  }\n}\n\n/** Return the entering angle of a rectangle side. */\nexport function angleOf(enteringSide: RectSide): number {\n  switch (enteringSide) {\n    case 'left':\n      return 0\n    case 'top':\n      return 90\n    case 'right':\n      return 180\n    case 'bottom':\n      return 270\n  }\n}\n","import {\n  angleOf,\n  controlPointOf,\n  distanceOf,\n  growBox,\n  isPointInBox,\n  RectSide,\n} from './utils'\n\n/** Parameters that describe an arrow. */\nexport type ArrowDescriptor = [\n  /** start point */\n  /* sx: */ number,\n  /* sy: */ number,\n  /** control point for start point */\n  /* c1x: */ number,\n  /* c1y: */ number,\n  /** control point for end point */\n  /* c2x: */ number,\n  /* c2y: */ number,\n  /** end point */\n  /* ex: */ number,\n  /* ey: */ number,\n  /** angle of end point */\n  /* ae: */ number,\n  /** angle of start point */\n  /* as: */ number\n]\n\nexport type ArrowOptions = Partial<{\n  padStart: number\n  padEnd: number\n}>\n\n/**\n * Get parameters to draw an S-curved line between two boxes.\n * \n * @returns [sx, sy, c1x, c1y, c2x, c2y, ex, ey, ae, as]\n * @example\n * const arrowHeadSize = 9\n * const [\n *  startX, startY,\n *  controlStartX, controlStartY,\n *  controlEndX, controlEndY,\n *  endX, endY, \n *  endAngle,\n *  startAngle\n * ] = getBoxToBoxArrow(0, 0, 100, 100, 200, 200, 200, 100, {\n *   padStart: 0,\n *   padEnd: arrowHeadSize, // make room for drawing arrow head\n * })\n */\nexport default function getBoxToBoxArrow(\n  /** start box */\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  /** end box */\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  userOptions?: ArrowOptions\n): ArrowDescriptor {\n  const options = { padStart: 0, padEnd: 0, ...userOptions }\n\n  /** Points of start box. */\n  const startBox = { x: x0, y: y0, w: w0, h: h0 }\n  // const centerOfStartBox = centerPointOf(startBox)\n  const startAtTop = {\n    x: x0 + w0 / 2,\n    y: y0 - 2 * options.padStart,\n  }\n  const startAtBottom = {\n    x: x0 + w0 / 2,\n    y: y0 + h0 + 2 * options.padStart,\n  }\n  const startAtLeft = {\n    x: x0 - 2 * options.padStart,\n    y: y0 + h0 / 2,\n  }\n  const startAtRight = {\n    x: x0 + w0 + 2 * options.padStart,\n    y: y0 + h0 / 2,\n  }\n\n  /** Points of end box. */\n  const endBox = { x: x1, y: y1, w: w1, h: h1 }\n  // const centerOfEndBox = centerPointOf(endBox)\n  const endAtTop = { x: x1 + w1 / 2, y: y1 - 2 * options.padEnd }\n  const endAtBottom = {\n    x: x1 + w1 / 2,\n    y: y1 + h1 + 2 * options.padEnd,\n  }\n  const endAtLeft = { x: x1 - 2 * options.padEnd, y: y1 + h1 / 2 }\n  const endAtRight = {\n    x: x1 + w1 + 2 * options.padEnd,\n    y: y1 + h1 / 2,\n  }\n\n  const sides: RectSide[] = ['top', 'right', 'bottom', 'left']\n  const startPoints = [startAtTop, startAtRight, startAtBottom, startAtLeft]\n  const endPoints = [endAtTop, endAtRight, endAtBottom, endAtLeft]\n\n  let shortestDistance = 1 / 0\n  let bestStartPoint = startAtTop\n  let bestEndPoint = endAtTop\n  let bestStartSide: RectSide = 'top'\n  let bestEndSide: RectSide = 'top'\n\n  const keepOutZone = 15\n  for (let startSideId = 0; startSideId < sides.length; startSideId++) {\n    const startPoint = startPoints[startSideId]\n    if (isPointInBox(startPoint, growBox(endBox, keepOutZone))) continue\n\n    for (let endSideId = 0; endSideId < sides.length; endSideId++) {\n      const endPoint = endPoints[endSideId]\n\n      /**\n       * If the start point is in the rectangle of end, or the end point\n       * is in the rectangle of start, this combination is abandoned.\n       */\n      if (isPointInBox(endPoint, growBox(startBox, keepOutZone))) continue\n\n      const d = distanceOf(startPoint, endPoint)\n      if (d < shortestDistance) {\n        shortestDistance = d\n        bestStartPoint = startPoint\n        bestEndPoint = endPoint\n        bestStartSide = sides[startSideId]\n        bestEndSide = sides[endSideId]\n      }\n    }\n  }\n\n  const controlPointForStartPoint = controlPointOf(\n    bestStartPoint,\n    bestEndPoint,\n    bestStartSide\n  )\n  const controlPointForEndPoint = controlPointOf(\n    bestEndPoint,\n    bestStartPoint,\n    bestEndSide\n  )\n\n  return [\n    bestStartPoint.x,\n    bestStartPoint.y,\n    controlPointForStartPoint.x,\n    controlPointForStartPoint.y,\n    controlPointForEndPoint.x,\n    controlPointForEndPoint.y,\n    bestEndPoint.x,\n    bestEndPoint.y,\n    angleOf(bestEndSide),\n    angleOf(bestStartSide),\n  ]\n}\n","import getBoxToBoxArrow, {\n  ArrowDescriptor,\n  ArrowOptions,\n} from './getBoxToBoxArrow'\n\n/**\n * Get parameters to draw an S-curved line between two points.\n * \n * @param x0 \n * @param y0 \n * @param x1 \n * @param y1 \n * @param userOptions \n * @returns [sx, sy, c1x, c1y, c2x, c2y, ex, ey, ae, as]\n * @example\n * const arrowHeadSize = 9\n * const arrow = getArrow(0, 0, 100, 200, {\n *   padStart: 0,\n *   padEnd: arrowHeadSize,\n * })\n * const [sx, sy, c1x, c1y, c2x, c2y ex, ey, ae, as] = arrow\n */\nexport default function getArrow(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  userOptions?: ArrowOptions\n): ArrowDescriptor {\n  return getBoxToBoxArrow(x0, y0, 0, 0, x1, y1, 0, 0, userOptions)\n}\n"],"names":["growBox","box","size","x","y","w","h","isPointInBox","point","controlPointOf","target","another","sideOfTarget","Math","min","max","angleOf","enteringSide","getBoxToBoxArrow","x0","y0","w0","h0","x1","y1","w1","h1","userOptions","p1","p2","options","padStart","padEnd","startBox","startAtTop","endBox","endAtTop","sides","startPoints","endPoints","shortestDistance","bestStartPoint","bestEndPoint","bestStartSide","bestEndSide","startSideId","length","startPoint","endSideId","endPoint","d","sqrt","pow","controlPointForStartPoint","controlPointForEndPoint"],"mappings":"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"}