function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/** Calculate the distance of two points. */
function distanceOf(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
/**
 * @param box
 * @param size Add `size` to all edges.
 */

function growBox(box, size) {
  return {
    x: box.x - size,
    y: box.y - size,
    w: box.w + 2 * size,
    h: box.h + 2 * size
  };
}
function isPointInBox(point, box) {
  return point.x > box.x && point.x < box.x + box.w && point.y > box.y && point.y < box.y + box.h;
}
/** Calculate the control point. */

function controlPointOf(target, another, sideOfTarget) {
  var margin = 30;

  switch (sideOfTarget) {
    case 'top':
      {
        return {
          x: target.x,
          y: Math.min(target.y - (target.y - another.y) / 2, target.y - margin)
        };
      }

    case 'bottom':
      {
        return {
          x: target.x,
          y: Math.max(target.y - (target.y - another.y) / 2, target.y + margin)
        };
      }

    case 'left':
      {
        return {
          x: Math.min(target.x - (target.x - another.x) / 2, target.x - margin),
          y: target.y
        };
      }

    case 'right':
      {
        return {
          x: Math.max(target.x - (target.x - another.x) / 2, target.x + margin),
          y: target.y
        };
      }
  }
}
/** Return the entering angle of a rectangle side. */

function angleOf(enteringSide) {
  switch (enteringSide) {
    case 'left':
      return 0;

    case 'top':
      return 90;

    case 'right':
      return 180;

    case 'bottom':
      return 270;
  }
}

/**
 * Get parameters to draw an S-curved line between two boxes.
 *
 * @returns [sx, sy, c1x, c1y, c2x, c2y, ex, ey, ae, as]
 * @example
 * const arrowHeadSize = 9
 * const [
 *  startX, startY,
 *  controlStartX, controlStartY,
 *  controlEndX, controlEndY,
 *  endX, endY,
 *  endAngle,
 *  startAngle
 * ] = getBoxToBoxArrow(0, 0, 100, 100, 200, 200, 200, 100, {
 *   padStart: 0,
 *   padEnd: arrowHeadSize, // make room for drawing arrow head
 * })
 */

function getBoxToBoxArrow(
/** start box */
x0, y0, w0, h0,
/** end box */
x1, y1, w1, h1, userOptions) {
  var options = _extends({
    padStart: 0,
    padEnd: 0
  }, userOptions);
  /** Points of start box. */


  var startBox = {
    x: x0,
    y: y0,
    w: w0,
    h: h0
  }; // const centerOfStartBox = centerPointOf(startBox)

  var startAtTop = {
    x: x0 + w0 / 2,
    y: y0 - 2 * options.padStart
  };
  var startAtBottom = {
    x: x0 + w0 / 2,
    y: y0 + h0 + 2 * options.padStart
  };
  var startAtLeft = {
    x: x0 - 2 * options.padStart,
    y: y0 + h0 / 2
  };
  var startAtRight = {
    x: x0 + w0 + 2 * options.padStart,
    y: y0 + h0 / 2
  };
  /** Points of end box. */

  var endBox = {
    x: x1,
    y: y1,
    w: w1,
    h: h1
  }; // const centerOfEndBox = centerPointOf(endBox)

  var endAtTop = {
    x: x1 + w1 / 2,
    y: y1 - 2 * options.padEnd
  };
  var endAtBottom = {
    x: x1 + w1 / 2,
    y: y1 + h1 + 2 * options.padEnd
  };
  var endAtLeft = {
    x: x1 - 2 * options.padEnd,
    y: y1 + h1 / 2
  };
  var endAtRight = {
    x: x1 + w1 + 2 * options.padEnd,
    y: y1 + h1 / 2
  };
  var sides = ['top', 'right', 'bottom', 'left'];
  var startPoints = [startAtTop, startAtRight, startAtBottom, startAtLeft];
  var endPoints = [endAtTop, endAtRight, endAtBottom, endAtLeft];
  var shortestDistance = 1 / 0;
  var bestStartPoint = startAtTop;
  var bestEndPoint = endAtTop;
  var bestStartSide = 'top';
  var bestEndSide = 'top';
  var keepOutZone = 15;

  for (var startSideId = 0; startSideId < sides.length; startSideId++) {
    var startPoint = startPoints[startSideId];
    if (isPointInBox(startPoint, growBox(endBox, keepOutZone))) continue;

    for (var endSideId = 0; endSideId < sides.length; endSideId++) {
      var endPoint = endPoints[endSideId];
      /**
       * If the start point is in the rectangle of end, or the end point
       * is in the rectangle of start, this combination is abandoned.
       */

      if (isPointInBox(endPoint, growBox(startBox, keepOutZone))) continue;
      var d = distanceOf(startPoint, endPoint);

      if (d < shortestDistance) {
        shortestDistance = d;
        bestStartPoint = startPoint;
        bestEndPoint = endPoint;
        bestStartSide = sides[startSideId];
        bestEndSide = sides[endSideId];
      }
    }
  }

  var controlPointForStartPoint = controlPointOf(bestStartPoint, bestEndPoint, bestStartSide);
  var controlPointForEndPoint = controlPointOf(bestEndPoint, bestStartPoint, bestEndSide);
  return [bestStartPoint.x, bestStartPoint.y, controlPointForStartPoint.x, controlPointForStartPoint.y, controlPointForEndPoint.x, controlPointForEndPoint.y, bestEndPoint.x, bestEndPoint.y, angleOf(bestEndSide), angleOf(bestStartSide)];
}

/**
 * Get parameters to draw an S-curved line between two points.
 *
 * @param x0
 * @param y0
 * @param x1
 * @param y1
 * @param userOptions
 * @returns [sx, sy, c1x, c1y, c2x, c2y, ex, ey, ae, as]
 * @example
 * const arrowHeadSize = 9
 * const arrow = getArrow(0, 0, 100, 200, {
 *   padStart: 0,
 *   padEnd: arrowHeadSize,
 * })
 * const [sx, sy, c1x, c1y, c2x, c2y ex, ey, ae, as] = arrow
 */

function getArrow(x0, y0, x1, y1, userOptions) {
  return getBoxToBoxArrow(x0, y0, 0, 0, x1, y1, 0, 0, userOptions);
}

export { getArrow, getBoxToBoxArrow };
//# sourceMappingURL=curved-arrows.esm.js.map
