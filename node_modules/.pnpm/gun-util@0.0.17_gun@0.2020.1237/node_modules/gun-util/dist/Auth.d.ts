import { IGunChainReference } from "./gun/types/chain";
import { IGunCryptoKeyPair } from "./gun/types/types";
export interface UserCredentials {
    alias: string;
    pass: string;
}
export interface AuthBasicOptions {
    /** Timeout interval in milliseconds. */
    timeout?: number;
    /**
     * Time in milliseconds to spend looking
     * for a user with an alias (where applicable).
     *
     * Note that Gun will only be able to find an
     * existing alias if it has a connection to
     * a peer which has it.
     *
     * It is recommended to set a reasonable timeout
     * for this to be effective.
     */
    existsTimeout?: number;
}
export interface AuthDelegate {
    /** The delegate should securely store the pair. */
    storePair?: (pair: IGunCryptoKeyPair, auth: Auth) => Promise<void> | void;
    /**
     * The delegate should recover the store pair if available.
     * If a timeout option is specified, it's up to the delegate to
     * enforce this.
     **/
    recallPair?: (auth: Auth, opts: AuthBasicOptions) => Promise<IGunCryptoKeyPair | undefined> | IGunCryptoKeyPair | undefined;
}
/**
 * Convenience methods for creating an authenticating a Gun user.
 */
export default class Auth {
    readonly gun: IGunChainReference;
    delegate?: AuthDelegate;
    static defaultGun: IGunChainReference | undefined;
    /**
     * Default timeout in milliseconds for user operations.
     * Set to zero to disable (not recommended).
     */
    static defaultTimeout: number;
    /**
     * Default time in milliseconds to spend looking
     * for a user with an alias (where applicable).
     */
    static defaultExistsTimeout: number;
    constructor(gun: IGunChainReference);
    static default(gun?: IGunChainReference): Auth;
    static resetDefault(): void;
    logout(): void;
    user(): IGunChainReference | undefined;
    /**
     * The current user's public key.
     * @param gun
     */
    pub(): string | undefined;
    /**
     * The current user's key pair.
     * @param gun
     */
    pair(): IGunCryptoKeyPair | undefined;
    /**
     * Login an existing user.
     * @param creds
     */
    login(creds: UserCredentials | IGunCryptoKeyPair, options?: AuthBasicOptions): Promise<string>;
    /**
     * Create a user and automatically login.
     * @param creds
     */
    create(creds: UserCredentials, options?: AuthBasicOptions): Promise<string>;
    /**
     * Resolves with a user's public key using the
     * specified alias, if the user exists.
     *
     * Note that Gun will only be able to find an
     * existing alias if it has a connection to
     * a peer which has it.
     *
     * It is recommended to set a reasonable timeout
     * for this to be effective.
     */
    getPub(creds: {
        alias: string;
    }, options?: Pick<AuthBasicOptions, 'timeout'>): Promise<string | undefined>;
    /**
     * Resolves true if a user with the specified `alias`
     * exists.
     *
     * Note that Gun will only be able to find an
     * existing alias if it has a connection to
     * a peer which has it.
     *
     * It is recommended to set a reasonable timeout
     * for this to be effective.
     */
    exists(creds: {
        alias: string;
    }, options?: AuthBasicOptions): Promise<boolean>;
    /**
     * Login a previously saved user.
     *
     * Set the receiver's delegate to be able to customise behaviour.
     */
    recall(options?: AuthBasicOptions): Promise<string | undefined>;
    /**
     * Subscribe to authentication events with
     * a callback. If a user is already authenticated,
     * it is called immediately.
     *
     * Also returns a promise which
     * Resolves when a user has been authenticated.
     * If a user is already authenticated, resolves
     * immediately.
     */
    on(cb?: () => void): Promise<string>;
    /**
     * If you use your own `gun.on('auth', cb)` listener,
     * call this method inside it.
     *
     * Why? It's been observed that multiple `gun.on('auth', cb)`
     * listeners don't work.
     *
     * @deprecated Use Gun's callback chaining instead.
     *
     * For example:
     *
     * ```
     * let gun = new Gun();
     * gun.on('auth', function (..args) {
     *     // Do work
     *     // ...
     *     // Allow other on('auth') listeners to receive a callback:
     *     // @ts-ignore: Ignore TypeScript scope shadowing error
     *     this.to.next(...args);
     * });
     * ```
     */
    did(): void;
    /**
     * Changes a user's password.
     *
     * **Does not work with Gun v0.2020.520**
    */
    changePass(creds: UserCredentials & {
        newPass: string;
    }, options?: AuthBasicOptions): Promise<string>;
    /**
     * Deletes a user.
     *
     * **Does not work with Gun v0.2020.520**
    */
    delete(creds: UserCredentials, options?: AuthBasicOptions): Promise<void>;
    /**
     * Wait for all user operations to finish.
     */
    join(options?: AuthBasicOptions): Promise<void>;
    /** Internal gun user work. */
    private _gunUserAction;
    /**
     * Auth user work wrapper. This can finish
     * faster than `_gunUserAction`.
     */
    private _authBlock;
    private _onAuth$;
    private _onAuthResolver;
    private _subscribedToAuth;
    private _onAuthCallbacks;
    private static _default;
    private _login;
    private _recallSessionStorage;
    private _create;
    private _delete;
    private _joinInternal;
    private _onAuth;
    private _subscribeToAuth;
    private _addOnAuthCallback;
    private _beginOnAuth;
    private _endOnAuth;
    private _beginAuthBlock;
    private static _parseGunError;
}
