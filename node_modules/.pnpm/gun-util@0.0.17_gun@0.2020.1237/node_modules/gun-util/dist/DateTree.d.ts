import { IGunChainReference } from "./gun/types/chain";
import { Moment } from 'moment';
import { IterateOptions } from "./iterate";
import { Filter, ValueRange } from "./filter";
import { IGunSubscription } from "./types";
export declare type DateUnit = 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond';
export declare const ALL_DATE_UNITS: DateUnit[];
export declare const DATE_UNIT_SET: Set<DateUnit>;
export declare type DateParsable = Moment | Date | string | number;
export declare type DateEventOptions = Filter<DateParsable>;
export declare type DateEventCallback<T> = (data: T, date: Moment, at: any, sub: IGunSubscription) => void;
/**
 * All date components are natural.
 * For the avoidance of doubt, month 1 is
 * January.
 */
export declare type DateComponents = {
    [K in DateUnit]?: number;
};
export interface DateIterateOptions extends IterateOptions<DateParsable> {
}
/**
 * Efficiently distributes and stores data in a tree with nodes using date
 * components as keys up to a specified resolution.
 * The root of the tree is specified as a Gun node reference.
 *
 * **Why not just use a hash table?**
 *
 * Having large nodes is discouraged in a graph database like Gun.
 * If you need to store large lists or tables of data, you need to break
 * them up into smaller nodes to ease synchronization between peers.
 */
export default class DateTree<T = any> {
    root: IGunChainReference;
    resolution: DateUnit;
    constructor(root: IGunChainReference<any>, resolution: DateUnit);
    nextDate(date: DateParsable): Moment;
    previousDate(date: DateParsable): Moment;
    /**
     * Subscribes to data in a date range.
     * It is recommended to limit the date range
     * as much as possible to avoid creating too
     * many internal data subscriptions, which slows
     * down program execution.
     *
     * The data is not ordered.
     *
     * If no date range is given, subscribes to changes
     * on any date (not recommended on larger trees).
     *
     * @param cb
     * @param opts
     * @returns A {@link IGunSubscription} object.
     */
    on(cb: DateEventCallback<T>, opts?: DateEventOptions): IGunSubscription;
    private _onAny;
    /**
     * Listens to changes about the specified date.
     *
     * Let's say we want to listen to changes to a blog described
     * by a date tree.
     * How would we handle a case where we are close to the end
     * of the nodes for the current time period?
     *
     * For example, we are at 2019-12-31 23:54, which is the end
     * of the hour, day, month and year. We may get a message this
     * next minute, hour, day, month or year.
     * Subscribing to all nodes would be impractical.
     * Listen to a single path of the tree instead with `changesAbout()`.
     *
     * **Proposed strategy:**
     *
     * At each date in the future, we can call `latest()`
     * and `iterate()` to get the latest data.
     *
     * When the date gets too far away, we can call `unsub()`
     * and resubscribe to a later date.
     *
     * @param date
     * @param callback
     *
     * Whenever a node changes next to the direct path between the root and the
     * tree's maximum resolution, the callback is called with the date components
     * identifying the node. Note that the date components are partial unless the
     * change occured at the maximum resolution.
     *
     * @returns An unsubscribe function
     */
    changesAbout(date: DateParsable, callback: (comps: DateComponents, sub: IGunSubscription) => void): IGunSubscription;
    /**
     * Returns the date for the specified Gun node reference.
     * @param ref Gun node reference
     * @returns Date
     */
    getDate(ref: IGunChainReference<T>): Moment;
    /**
     * Returns the Gun node reference for a particular date
     * up to the receiver's maximum resolution. If none
     * exists, it is created.
     * @param date Date
     * @returns Gun node reference
     */
    get(date: DateParsable): IGunChainReference<T>;
    /**
     * Assumes the date components are clean (with no other properties).
     * @param comps
     */
    private _getRefChain;
    /**
     * Assumes the date components are clean (with no other properties).
     * @param comps
     */
    private _getRef;
    /**
     * Gets the latest Gun node reference if one exists.
     * @param date
     * @returns A Gun node reference and its date
     */
    latest(): Promise<[IGunChainReference<T> | undefined, Moment | undefined]>;
    /**
     * Gets the earliest Gun node reference if one exists.
     * @param date
     * @returns A Gun node reference and its date
     */
    earliest(): Promise<[IGunChainReference<T> | undefined, Moment | undefined]>;
    /**
     * Gets the next Gun node reference for a particular date
     * if one exists. If no date is specified, returns the
     * first node reference.
     * @param date
     * @returns A Gun node reference and its date
     */
    next(date?: DateParsable): Promise<[IGunChainReference<T> | undefined, Moment | undefined]>;
    /**
     * Gets the previous Gun node reference for a particular date
     * if one exists. If no date is specified, returns the
     * last node reference.
     * @param date
     * @returns A Gun node reference and its date
     */
    previous(date?: Moment): Promise<[IGunChainReference<T> | undefined, Moment | undefined]>;
    /**
     * Iterates over all node references after and
     * inclusing `start` date and before and excluding
     * `end` date.
     * @param param0
     */
    iterate(opts?: DateIterateOptions): AsyncGenerator<[IGunChainReference<T>, Moment]>;
    /**
     * Iterates over all refs children.
     * @param ref
     * @param start inclusive
     * @param end exclusive
     */
    private _iterateRef;
    private _allUnits;
    static lowerUnit(unit: DateUnit): DateUnit | undefined;
    static getDateWithComponents(comps: DateComponents, resolution?: DateUnit): Moment;
    static getDateComponents(date: DateParsable, resolution: DateUnit): DateComponents;
    static getDateComponent(date: DateParsable, unit: DateUnit): number;
    /**
     * Returns the largest common unit between two date components.
     * If none is found, returns undefined
     * @param comp1
     * @param comp2
     */
    static largestCommonUnit(comp1: DateComponents, comp2: DateComponents): DateUnit | undefined;
    static encodeDateComponent(value: number | undefined, unit: DateUnit): string | undefined;
    static decodeDateComponent(key: string): number;
    static downsampleDateComponents(components: DateComponents, resolution: DateUnit): DateComponents;
    static getDateComponentKeyRange(comps: DateComponents, compRange: Pick<Required<ValueRange<DateComponents>>, 'start' | 'end'>, unit: DateUnit): ValueRange<string>;
    static getDateComponentRange(comps: DateComponents, startComps: DateComponents, endComps: DateComponents, unit: DateUnit): [number | undefined, number | undefined];
    static getBiggerUnit(unit: DateUnit): DateUnit | undefined;
    static getSmallerUnit(unit: DateUnit): DateUnit | undefined;
    static dateComponentsToString(comp: DateComponents, resolution?: DateUnit): string;
    static isResolution(resolution: any): resolution is DateUnit;
    /**
     * Parses a date into a `Moment`, using the
     * current time zone and converts it into UTC time.
     * @param date
     */
    static parseDate(date: DateParsable, resolution?: DateUnit): Moment;
}
