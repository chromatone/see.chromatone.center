'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Gun$1 = require('gun');
var _ = require('lodash');
var moment = require('moment');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Gun__default = /*#__PURE__*/_interopDefaultLegacy(Gun$1);
var ___default = /*#__PURE__*/_interopDefaultLegacy(_);
var moment__default = /*#__PURE__*/_interopDefaultLegacy(moment);

/**
 * Gun constructor.
 *
 * Use this type instead of the Gun's default import
 * if you run into type issues with the Gun constructor.
 */
const Gun = Gun__default['default'];

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

/** Base Gun wrapper error. */
class GunError extends Error {
}
/** Base error related to the network. */
class NetworkError extends GunError {
}
/** Timeout error. */
class TimeoutError extends NetworkError {
    constructor(...args) {
        super(...withDefaultMessage(args, 'The operation timed out'));
    }
}
/** Base error related to authentication. */
class AuthError extends GunError {
}
/** Attempting to start another login while another is in progress. */
class MultipleAuthError extends AuthError {
}
/** Login error. */
class InvalidCredentials extends AuthError {
}
/** User creation error. */
class UserExists extends AuthError {
}
const withDefaultMessage = (args, defaultMessage) => {
    if (args.length === 0 || args.length === 1 && !args[0]) {
        args = [defaultMessage];
    }
    return args;
};

const isPlatformWeb = () => {
    return typeof window !== 'undefined';
};
const isGunInstance = (gun) => {
    var _a;
    return !!(gun === null || gun === void 0 ? void 0 : gun.user) && !!((_a = gun === null || gun === void 0 ? void 0 : gun.constructor) === null || _a === void 0 ? void 0 : _a.SEA);
};

/**
 * Subscribes to a Gun node reference and return
 * that value when the filter returns a truthy value.
 *
 * If no `filter` is specified, returns on the
 * first non-undefined value.
 *
 * If a `timeout` (in milliseconds) is given, and no
 * matching data arrives in that time, `timeoutError`
 * is thrown (or a `TimeoutError` if none given).
 *
 * @param ref
 * @param filter
 */
function waitForData(ref, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!ref) {
            throw new Error('Invalid Gun node reference');
        }
        let { filter, timeout, timeoutError, } = options;
        if (typeof filter !== 'undefined' && (typeof filter !== 'function' || filter.length === 0)) {
            throw new Error('Invalid filter');
        }
        let sub;
        let listener = new Promise((resolve, reject) => {
            if (!filter) {
                filter = (data) => typeof data !== 'undefined';
            }
            sub = ref.on((data, key, at, ev) => {
                var _a;
                sub = ev;
                if (filter(data)) {
                    (_a = sub === null || sub === void 0 ? void 0 : sub.off) === null || _a === void 0 ? void 0 : _a.call(sub);
                    sub = undefined;
                    resolve(data);
                }
            });
        }).finally(() => {
            var _a;
            (_a = sub === null || sub === void 0 ? void 0 : sub.off) === null || _a === void 0 ? void 0 : _a.call(sub);
        });
        if (timeout && timeout > 0) {
            return yield timeoutAfter(listener, timeout, timeoutError);
        }
        else {
            return yield listener;
        }
    });
}
/**
 * Resolve after `ms` interval.
 * @param ms
 * @param passthrough
 */
function delay(ms, passthrough) {
    let timer;
    return new Promise((resolve, reject) => {
        timer = setTimeout(() => resolve(passthrough), ms);
    }).finally(() => {
        timer && clearTimeout(timer);
    });
}
/**
 * Throw error after `ms` interval.
 * @param ms
 * @param error
 */
function errorAfter(ms, error) {
    return __awaiter(this, void 0, void 0, function* () {
        yield delay(ms);
        throw error;
    });
}
/**
 * If the promise does not resolve (or error) within `ms` interval,
 * throws a the specified `error`. If no error is specified, uses
 * a `TimeoutError` instead.
 * @param ms
 * @param error
 */
function timeoutAfter(promise, ms, error) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.race([
            promise,
            errorAfter(ms, error || new TimeoutError()),
        ]);
    });
}

const LOGIN_CHECK_DELAY = 500;
/**
 * Convenience methods for creating an authenticating a Gun user.
 */
class Auth {
    constructor(gun) {
        this._subscribedToAuth = false;
        this._onAuthCallbacks = [];
        if (!isGunInstance(gun)) {
            throw new GunError('Must specify a valid gun instance');
        }
        this.gun = gun;
        if (!Auth._default) {
            if (!Auth.defaultGun || gun === Auth.defaultGun) {
                Auth.defaultGun = gun;
                Auth._default = this;
            }
        }
    }
    static default(gun) {
        if (!this._default) {
            if (!this.defaultGun) {
                this.defaultGun = gun;
            }
            gun = gun || this.defaultGun;
            if (!isGunInstance(gun)) {
                throw new GunError('Must specify a valid gun instance or set a default');
            }
            this._default = new Auth(gun);
        }
        return this._default;
    }
    static resetDefault() {
        this.defaultGun = undefined;
        this._default = undefined;
    }
    logout() {
        if (!this.pub()) {
            return;
        }
        let userRef = this.gun.user();
        userRef.leave();
        if (!this.pub()) ;
        else {
            throw new AuthError('Failed to log out');
        }
    }
    user() {
        let pub = this.pub();
        return !!pub ? this.gun.user(pub) : undefined;
    }
    /**
     * The current user's public key.
     * @param gun
     */
    pub() {
        var _a;
        return (_a = this.pair()) === null || _a === void 0 ? void 0 : _a.pub;
    }
    /**
     * The current user's key pair.
     * @param gun
     */
    pair() {
        let userRef = this.gun.user();
        return userRef._.sea;
    }
    /**
     * Login an existing user.
     * @param creds
     */
    login(creds, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logout();
            return this._beginAuthBlock(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this._login(creds, options);
                }
                catch (error) {
                    if (error instanceof MultipleAuthError) {
                        // Wait for internal work and try again
                        yield this._joinInternal();
                        return yield this._login(creds, options);
                    }
                    throw error;
                }
            }));
        });
    }
    /**
     * Create a user and automatically login.
     * @param creds
     */
    create(creds, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logout();
            return this._beginAuthBlock(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this._create(creds, options);
                }
                catch (error) {
                    if (error instanceof MultipleAuthError) {
                        // Wait for internal work and try again
                        yield this._joinInternal();
                        return yield this._create(creds, options);
                    }
                    throw error;
                }
            }));
        });
    }
    /**
     * Resolves with a user's public key using the
     * specified alias, if the user exists.
     *
     * Note that Gun will only be able to find an
     * existing alias if it has a connection to
     * a peer which has it.
     *
     * It is recommended to set a reasonable timeout
     * for this to be effective.
     */
    getPub(creds, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let { timeout = Auth.defaultExistsTimeout, } = options;
            timeout = Math.max(0, timeout);
            const key = '~@' + creds.alias;
            let data;
            try {
                data = yield waitForData(this.gun.get(key), { timeout });
            }
            catch (error) {
                if (error instanceof TimeoutError) {
                    return undefined;
                }
                throw error;
            }
            if (!data) {
                return undefined;
            }
            if ('_' in data) {
                delete data._;
            }
            // Make sure the internal representation hasn't changed
            let keys = Object.keys(data);
            if (keys.length !== 1) {
                throw new GunError('Unsupported Gun version');
            }
            let pub = keys[0];
            if (!pub.startsWith('~')) {
                throw new GunError('Unsupported Gun version');
            }
            return pub.substring(1);
        });
    }
    /**
     * Resolves true if a user with the specified `alias`
     * exists.
     *
     * Note that Gun will only be able to find an
     * existing alias if it has a connection to
     * a peer which has it.
     *
     * It is recommended to set a reasonable timeout
     * for this to be effective.
     */
    exists(creds, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let pub = yield this.getPub(creds, options);
            return !!pub;
        });
    }
    /**
     * Login a previously saved user.
     *
     * Set the receiver's delegate to be able to customise behaviour.
     */
    recall(options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.recallPair) {
                let pair = yield this.delegate.recallPair(this, options);
                if (pair) {
                    // Auth with pair
                    return yield this.login(pair, options);
                }
            }
            else if (isPlatformWeb()) {
                return this._beginAuthBlock(() => __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield this._recallSessionStorage(options);
                    }
                    catch (error) {
                        if (error instanceof MultipleAuthError) {
                            // Wait for internal work and try again
                            yield this._joinInternal();
                            return yield this._recallSessionStorage(options);
                        }
                        throw error;
                    }
                }));
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * Subscribe to authentication events with
     * a callback. If a user is already authenticated,
     * it is called immediately.
     *
     * Also returns a promise which
     * Resolves when a user has been authenticated.
     * If a user is already authenticated, resolves
     * immediately.
     */
    on(cb) {
        return __awaiter(this, void 0, void 0, function* () {
            if (cb) {
                this._addOnAuthCallback(cb);
            }
            let pub = this.pub();
            if (pub) {
                cb === null || cb === void 0 ? void 0 : cb();
                return Promise.resolve(pub);
            }
            // Allow multiple subscriptions to on,
            // so share the promise.
            if (!this._onAuth$) {
                this._onAuth$ = this._onAuth();
            }
            return this._onAuth$;
        });
    }
    /**
     * If you use your own `gun.on('auth', cb)` listener,
     * call this method inside it.
     *
     * Why? It's been observed that multiple `gun.on('auth', cb)`
     * listeners don't work.
     *
     * @deprecated Use Gun's callback chaining instead.
     *
     * For example:
     *
     * ```
     * let gun = new Gun();
     * gun.on('auth', function (..args) {
     *     // Do work
     *     // ...
     *     // Allow other on('auth') listeners to receive a callback:
     *     // @ts-ignore: Ignore TypeScript scope shadowing error
     *     this.to.next(...args);
     * });
     * ```
     */
    did() {
        this._endOnAuth();
    }
    /**
     * Changes a user's password.
     *
     * **Does not work with Gun v0.2020.520**
    */
    changePass(creds, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logout();
            return this.create(creds, options);
        });
    }
    /**
     * Deletes a user.
     *
     * **Does not work with Gun v0.2020.520**
    */
    delete(creds, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._beginAuthBlock(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this._delete(creds, options);
                }
                catch (error) {
                    if (error instanceof MultipleAuthError) {
                        // Wait for internal work and try again
                        yield this._joinInternal();
                        return yield this._delete(creds, options);
                    }
                    throw error;
                }
            }));
        });
    }
    /**
     * Wait for all user operations to finish.
     */
    join(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let { timeout = 0 } = options;
            let stop = false;
            let joins = (() => __awaiter(this, void 0, void 0, function* () {
                yield this._joinInternal();
                while (!stop && this._authBlock) {
                    try {
                        yield this._authBlock;
                    }
                    catch (error) { }
                }
                yield this._joinInternal();
            }))();
            if (timeout) {
                yield timeoutAfter(joins, timeout)
                    .catch(err => {
                    stop = true;
                    throw err;
                });
            }
            else {
                yield joins;
            }
        });
    }
    _login(creds, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { timeout = Auth.defaultTimeout, existsTimeout = Auth.defaultExistsTimeout, } = options;
            // It's been observed that when existance of a
            // user is checked using `gun.get('~@' + alias)`,
            // gun.user().auth() fails immediately with an invalid
            // credentials error.
            // Use `existsTimeout` with `gun.user().auth()` instead.
            const loginCheckDelay = timeout && timeout > 1000
                ? Math.min(LOGIN_CHECK_DELAY, timeout - 100)
                : 0;
            let loginAction = new Promise((resolve, reject) => {
                let resolveOnce = resolve;
                let rejectOnce = reject;
                // Check for login ahead of time
                let timer = loginCheckDelay && setTimeout(() => {
                    if (!resolveOnce)
                        return;
                    let pub = this.pub();
                    if (pub) {
                        // Instant login
                        resolveOnce(pub);
                        resolveOnce = undefined;
                        rejectOnce = undefined;
                    }
                }, loginCheckDelay);
                // Begin login
                let cb = (ack) => {
                    if (!resolveOnce || !rejectOnce)
                        return;
                    if ('err' in ack) {
                        // Check for login anyway
                        let pub = this.pub();
                        if (pub) {
                            // Actually logged in.
                            // (This is Gun v0.2020.520 behaviour only)
                            console.warn('Logged in without login acknowledgement. Your data may not be synced to peers.');
                            resolveOnce(pub);
                        }
                        else if (ack.lack) {
                            // Timed out
                            rejectOnce(new TimeoutError(ack.err));
                        }
                        else {
                            rejectOnce(Auth._parseGunError(ack.err, InvalidCredentials));
                        }
                    }
                    else {
                        resolveOnce(ack.sea.pub);
                    }
                    resolveOnce = undefined;
                    rejectOnce = undefined;
                    timer && clearTimeout(timer);
                };
                let user = this.gun.user();
                let { alias = '', pass = '' } = creds;
                let gunOpts = existsTimeout && existsTimeout > 0 ? {
                    wait: existsTimeout
                } : undefined;
                if (alias && pass) {
                    user.auth(alias, pass, cb, gunOpts);
                }
                else {
                    user.auth(creds, '', cb, gunOpts);
                }
            });
            this._gunUserAction = loginAction;
            let promises = [
                loginAction,
                this.on(),
            ];
            if (timeout && timeout > 0) {
                promises.push(errorAfter(timeout, new TimeoutError()));
            }
            return Promise.race(promises);
        });
    }
    _recallSessionStorage(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { timeout = Auth.defaultTimeout, } = options;
            let recallAction = new Promise((resolve, reject) => {
                let resolveOnce = resolve;
                let rejectOnce = reject;
                let timer;
                if (timeout && timeout > 0) {
                    timer = setTimeout(() => {
                        if (!resolveOnce)
                            return;
                        let pub = this.pub();
                        // Login or bail
                        resolveOnce(pub);
                        resolveOnce = undefined;
                        rejectOnce = undefined;
                    }, timeout);
                }
                // Begin login
                let gunOpts = {
                    sessionStorage: true,
                };
                this.gun.user().recall(gunOpts, (ack) => {
                    if (!resolveOnce || !rejectOnce)
                        return;
                    if ('err' in ack) {
                        // Check for login anyway
                        let pub = this.pub();
                        if (pub) {
                            // Actually logged in.
                            // (This is Gun v0.2020.520 behaviour only)
                            resolveOnce(pub);
                        }
                        else if (ack.lack) {
                            // Timed out
                            rejectOnce(new TimeoutError(ack.err));
                        }
                        else {
                            rejectOnce(Auth._parseGunError(ack.err, InvalidCredentials));
                        }
                    }
                    else {
                        resolveOnce(ack.sea.pub);
                    }
                    resolveOnce = undefined;
                    rejectOnce = undefined;
                    timer && clearTimeout(timer);
                });
            });
            this._gunUserAction = recallAction;
            return Promise.race([
                recallAction,
                this.on()
            ]);
        });
    }
    _create({ alias, pass, newPass }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { timeout = Auth.defaultTimeout, existsTimeout = Auth.defaultExistsTimeout, } = options;
            if (alias) {
                // Check if user with alias already exists
                let exists = yield this.exists({ alias }, { timeout: existsTimeout });
                if (exists) {
                    throw new UserExists('User already created!');
                }
            }
            let createAction = new Promise((resolve, reject) => {
                let options = {};
                if (newPass) {
                    options.change = newPass;
                }
                if (this.pub()) {
                    throw new MultipleAuthError('Should not be logged in when creating a user');
                }
                this.gun.user().create(alias, pass, (ack) => {
                    if ('err' in ack) {
                        // Check for login anyway
                        let pub = this.pub();
                        if (pub) {
                            // Actually created user
                            resolve(pub);
                        }
                        else {
                            reject(Auth._parseGunError(ack.err, UserExists));
                        }
                    }
                    else {
                        resolve(ack.pub);
                    }
                }, options);
            });
            this._gunUserAction = createAction;
            let promises = [
                createAction,
                this.on(),
            ];
            if (timeout && timeout > 0) {
                promises.push(errorAfter(timeout, new TimeoutError()));
            }
            return Promise.race(promises);
        });
    }
    _delete({ alias, pass }, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { timeout = Auth.defaultTimeout, } = options;
            let deleteAction = new Promise((resolve, reject) => {
                this.gun.user().delete(alias, pass, () => {
                    if (!this.pub()) {
                        resolve();
                    }
                    else {
                        reject(new GunError('Failed to delete user'));
                    }
                });
            });
            this._gunUserAction = deleteAction;
            let promises = [deleteAction];
            if (timeout && timeout > 0) {
                promises.push(errorAfter(timeout, new TimeoutError()));
            }
            return Promise.race(promises);
        });
    }
    _joinInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._gunUserAction) {
                return;
            }
            try {
                yield this._gunUserAction;
            }
            catch (error) { }
        });
    }
    _onAuth() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                // Allow resolving immediately in other methods
                this._beginOnAuth(resolve);
                this._subscribeToAuth();
            }).then(pub => {
                this._endOnAuth();
                return pub;
            });
        });
    }
    _subscribeToAuth() {
        // Note that only one listener can be
        // registered to gun.on('auth')
        if (this._subscribedToAuth)
            return;
        this._subscribedToAuth = true;
        let innerCallback = () => this._endOnAuth();
        this.gun.on('auth', function (...args) {
            innerCallback();
            // Allow other on('auth') listeners to receive a callback:
            // @ts-ignore: Ignore TypeScript scope shadowing error
            this.to.next(...args);
        });
    }
    _addOnAuthCallback(cb) {
        this._onAuthCallbacks.push(cb);
    }
    _beginOnAuth(resolver) {
        this._onAuthResolver = resolver;
    }
    _endOnAuth(pub) {
        var _a;
        pub = pub || this.pub();
        if (pub) {
            // Inform delegate
            if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.storePair) {
                let pair = this.pair();
                if (pair) {
                    this.delegate.storePair(pair, this);
                }
            }
            // on callbacks
            for (let cb of this._onAuthCallbacks) {
                cb();
            }
            // Resolve on promise.
            // We resolve this last to sync all different
            // types of listeners.
            let resolve = this._onAuthResolver;
            this._onAuthResolver = undefined;
            this._onAuth$ = undefined;
            resolve === null || resolve === void 0 ? void 0 : resolve(pub);
        }
        return pub;
    }
    _beginAuthBlock(blockFactory) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._authBlock) {
                throw new MultipleAuthError('Already performing a user operation');
            }
            try {
                let block = blockFactory();
                this._authBlock = block;
                return yield block;
            }
            finally {
                this._authBlock = undefined;
                this._endOnAuth();
            }
        });
    }
    static _parseGunError(error, defaultClass = GunError) {
        switch (error) {
            case 'User already created!':
                return new UserExists(error);
            case 'Wrong user or password.':
                return new InvalidCredentials(error);
            case 'User is already being created or authenticated!':
                return new MultipleAuthError(error);
            default:
                return new defaultClass(error);
        }
    }
}
/**
 * Default timeout in milliseconds for user operations.
 * Set to zero to disable (not recommended).
 */
Auth.defaultTimeout = 10000;
/**
 * Default time in milliseconds to spend looking
 * for a user with an alias (where applicable).
 */
Auth.defaultExistsTimeout = 3000;

const TEST_GUN_PEERS = isPlatformWeb()
    ? []
    : (process.env.TEST_GUN_PEERS || '')
        .split(',')
        .map(peer => peer.trim())
        .filter(peer => !!peer);
const TEST_GUN_OPTIONS = {
    peers: TEST_GUN_PEERS,
    radisk: false,
    localStorage: false,
    axe: false,
    multicast: false,
};

function isInRange(key, range) {
    if (isValueRangeEmpty(range)) {
        return false;
    }
    let { start, end, startClosed, endClosed, } = range;
    let keyValue = key.valueOf();
    if (typeof start !== 'undefined') {
        let startValue = start.valueOf();
        if (keyValue < startValue)
            return false;
        if (!startClosed && keyValue === startValue)
            return false;
    }
    if (typeof end !== 'undefined') {
        let endValue = end.valueOf();
        if (keyValue > endValue)
            return false;
        if (!endClosed && keyValue === endValue)
            return false;
    }
    return true;
}
/**
 * Returns the index range of keys which are inside
 * the given range.
 *
 * @param keys Unique keys sorted in ascending lexical order
 * @param range
 * @returns
 *  The start (inclusive) and end (exclusive) indexes of
 *  the keys matching the filter.
 */
function filteredIndexRange(keys, range) {
    if (isValueRangeEmpty(range)) {
        return [0, 0];
    }
    let len = keys.length;
    if (len === 0) {
        return [0, 0];
    }
    if (len === 1) {
        if (isInRange(keys[0], range)) {
            return [0, 1];
        }
        else {
            return [0, 0];
        }
    }
    let { start, end, startClosed = true, endClosed = false, } = range;
    let iStart = 0;
    if (typeof start !== 'undefined') {
        iStart = ___default['default'].sortedIndex(keys, start);
        let key = keys[iStart];
        if (key <= start && !startClosed) {
            iStart += 1;
        }
    }
    // iEnd is inclusive here
    let iEnd = len - 1;
    if (typeof end !== 'undefined') {
        iEnd = ___default['default'].sortedIndex(keys, end);
        let key = keys[iEnd];
        if (key >= end && !endClosed) {
            iEnd -= 1;
        }
        iEnd = Math.min(iEnd, len - 1);
    }
    if (iStart > iEnd) {
        return [0, 0];
    }
    return [iStart, iEnd + 1];
}
const isValueRangeEmpty = (range) => {
    let { start, end, startClosed, endClosed, } = range;
    if (typeof start !== 'undefined' && typeof end !== 'undefined') {
        if (start == end && !(startClosed && endClosed)) {
            return true;
        }
        else if (start > end) {
            return true;
        }
    }
    return false;
};
function rangeWithFilter(filter) {
    let { gt, gte, lt, lte } = filter || {};
    let range = {
        start: undefined,
        end: undefined,
        startClosed: false,
        endClosed: false,
    };
    if (typeof gte !== 'undefined') {
        range.start = gte;
        range.startClosed = true;
    }
    else if (typeof gt !== 'undefined') {
        range.start = gt;
    }
    if (typeof lte !== 'undefined') {
        range.end = lte;
        range.endClosed = true;
    }
    else if (typeof lt !== 'undefined') {
        range.end = lt;
    }
    return range;
}
function filterWithRange(range) {
    let { start, end, startClosed, endClosed, } = range;
    let filter = {};
    if (startClosed) {
        filter.gte = start;
    }
    else {
        filter.gt = start;
    }
    if (endClosed) {
        filter.lte = end;
    }
    else {
        filter.lt = end;
    }
    return filter;
}
function mapValueRange(range, map) {
    return {
        start: typeof range.start !== 'undefined' ? map(range.start) : undefined,
        end: typeof range.end !== 'undefined' ? map(range.end) : undefined,
        startClosed: range.startClosed,
        endClosed: range.endClosed,
    };
}
/**
 * Create a closed filter from an open filter,
 * preserving any other properties on the object.
 **/
function closedFilter(filter) {
    // Extract filter
    let { gt, gte, lt, lte } = filter, otherOptions = __rest(filter, ["gt", "gte", "lt", "lte"]);
    let start = gt || gte;
    let end = lt || lte;
    // Reapply filter
    let closedFilter = otherOptions;
    if (typeof start !== 'undefined') {
        closedFilter.gte = start;
    }
    if (typeof end !== 'undefined') {
        closedFilter.lte = end;
    }
    return closedFilter;
}

/**
 * Subscribe to a Gun node `ref` and return
 * a subscription.
 *
 * Unsubscribes automatically on uncaught errors
 * inside the callback and rethrows.
 *
 * **Why not just use `ref.on()`?**
 *
 * Calling `ref.off()` unsubscribes all listeners,
 * not just the last one. This method provides a
 * way to unsubscribe only a single listener inline.
 *
 * *It is only possible to unsubscribe once the internal `on()` callback
 * has been fired once. See [issue](https://github.com/amark/gun/issues/713).*
 * @param ref
 */
function subscribe(ref, callback, opt) {
    let internalSub;
    let didUnsub = false;
    let externalSub = {
        off: () => {
            if (didUnsub) {
                return;
            }
            didUnsub = true;
            internalSub === null || internalSub === void 0 ? void 0 : internalSub.off();
            internalSub = undefined;
        },
    };
    ref.on((data, key, at, sub) => {
        if (didUnsub) {
            sub.off();
            return;
        }
        // Only use off() inside callback.
        // External off() will remove all listeners.
        // See https://github.com/amark/gun/issues/713
        internalSub = sub;
        try {
            callback(data, key, at, Object.assign(Object.assign({}, sub), externalSub));
        }
        catch (error) {
            externalSub.off();
            throw error;
        }
    }, opt);
    return externalSub;
}

const ASC_ORDER = 1;
/**
 * Iterate over async iterator to the end and return
 * the collected values.
 * @param it An async iterable
 */
function iterateAll(it) {
    var it_1, it_1_1;
    var e_1, _a;
    return __awaiter(this, void 0, void 0, function* () {
        let values = [];
        try {
            for (it_1 = __asyncValues(it); it_1_1 = yield it_1.next(), !it_1_1.done;) {
                let value = it_1_1.value;
                values.push(value);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (it_1_1 && !it_1_1.done && (_a = it_1.return)) yield _a.call(it_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return values;
    });
}
/**
 * Iterates over the inner keys of a record at a Gun node reference.
 * ~~Specify a `opt.wait` value over 1000 on slow networks and CPUs.~~
 * ~~Behaviour is different if ordering is required, which is specified by
 * setting `opt.order` to a non zero value.~~
 *
 * **1. If order is specified:**
 *
 * Iterates over the inner keys of a record at a Gun node reference,
 * by loading the whole record.
 *
 * Note that keys are guaranteed to be in order, but if a peer
 * fails to reply within the `wait` period, the item [value, key] will
 * skipped. A second pass is necessary to get these skipped items.
 *
 * Filtering using [Gun's lexical wire spec](https://gun.eco/docs/RAD#lex)
 * is **not** supported (as at Gun v0.2020.520).
 *
 * **2. If order is not specified:**
 *
 * ~~This is more efficient than without ordering, but it sacrifices guaranteed
 * ascending order of data by key. This is the case if there is more
 * than one connected peer.~~
 *
 * ~~Filtering using [Gun's lexical wire spec](https://gun.eco/docs/RAD#lex)
 * is supported.~~
 *
 * @param ref Gun node reference
 **/
function iterateRecord(ref, opts = {}) {
    if (!ref) {
        throw new Error('Invalid Gun node reference');
    }
    // TODO: _fastIterateRecord has unintended side-effects, disable for now
    // Turn on when iterate using map().once() works
    return _iterateSortedRecord(ref, opts);
    // if (!!opts.order) {
    //     return _iterateSortedRecord(ref, opts);
    // } else {
    //     return _fastIterateRecord(ref, opts);
    // }
}
/**
 * Iterates over the inner keys of a record at a Gun node reference,
 * by loading the whole record.
 *
 * Note that keys are guaranteed to be in order, but if a peer
 * fails to reply within the `wait` period, the item [value, key] will
 * skipped. A second pass is necessary to get these skipped items.
 *
 * Filtering using [Gun's lexical wire spec](https://gun.eco/docs/RAD#lex)
 * is **not** supported (as at Gun v0.2020.520). Use {@link scanRecord}
 * instead, if you need to filter in this way.
 *
 * @param ref Gun node reference
 **/
function _iterateSortedRecord(ref, opts) {
    var _a;
    return __asyncGenerator(this, arguments, function* _iterateSortedRecord_1() {
        let order = opts.order || ASC_ORDER;
        let range = rangeWithFilter(opts);
        if (isValueRangeEmpty(range)) {
            return yield __await(void 0);
        }
        // Get list of keys:
        // ~~Prefer using `once` instead of `then` to allow customizing `wait`.~~
        let obj = yield __await(ref.then());
        // The following implementation is somehow buggy.
        // Produces errors during unit testing in unrelated code.
        // let obj: any = await new Promise((resolve, reject) => {
        //     ref.once((data, key) => {
        //         resolve(data);
        //     }, { wait });
        // });
        if (typeof obj === 'undefined' || obj === null) {
            return yield __await(void 0);
        }
        if (typeof obj !== 'object') {
            throw new Error(`Cannot iterate keys of non-object record "${obj}" at key "${(_a = ref._) === null || _a === void 0 ? void 0 : _a.get}"`);
        }
        // Remove meta
        obj = ___default['default'].omit(obj, '_');
        let keys = Object.keys(obj).sort();
        // Find iteration bounds
        let [iStart, iEnd] = filteredIndexRange(keys, range);
        if (iStart >= iEnd) {
            return yield __await(void 0);
        }
        // Iterate
        let key;
        if (order >= 0) {
            // Natural direction
            for (let i = iStart; i < iEnd; i++) {
                key = keys[i];
                yield yield __await([obj[key], key]);
            }
        }
        else {
            // Reverse direction
            for (let i = iEnd - 1; i >= iStart; i--) {
                key = keys[i];
                yield yield __await([obj[key], key]);
            }
        }
    });
}
/**
 * Iterate over inner references at a Gun node reference, yielding
 * the inner reference and its key.
 *
 * Note that keys are not guaranteed to be in order if there
 * is more than one connected peer.
 *
 * @param ref Gun node reference
 **/
function iterateRefs(ref, opts) {
    return __asyncGenerator(this, arguments, function* iterateRefs_1() {
        var e_2, _a;
        let innerRef;
        try {
            for (var _b = __asyncValues(iterateRecord(ref, opts)), _c; _c = yield __await(_b.next()), !_c.done;) {
                let [val, key] = _c.value;
                innerRef = ref.get(key);
                yield yield __await([innerRef, key]);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
            }
            finally { if (e_2) throw e_2.error; }
        }
    });
}
/**
 * Iterate over inner records at a Gun node reference, yielding
 * the inner record and its key.
 *
 * Note that keys are not guaranteed to be in order if there
 * is more than one connected peer.
 *
 * @param ref Gun node reference
 **/
function iterateItems(ref, opts) {
    return __asyncGenerator(this, arguments, function* iterateItems_1() {
        var e_3, _a;
        try {
            // TODO: batch and resolve in parallel
            for (var _b = __asyncValues(iterateRecord(ref, opts)), _c; _c = yield __await(_b.next()), !_c.done;) {
                let [val, key] = _c.value;
                if (typeof val === 'object') {
                    val = yield __await(ref.get(key).then());
                }
                yield yield __await([val, key]);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
            }
            finally { if (e_3) throw e_3.error; }
        }
    });
}
/**
 * Iterate over inner records at a Gun node reference, yielding
 * the inner record.
 *
 * Note that keys are not guaranteed to be in order if there
 * is more than one connected peer.
 *
 * @param ref Gun node reference
 **/
function iterateValues(ref, opts) {
    return __asyncGenerator(this, arguments, function* iterateValues_1() {
        var e_4, _a;
        try {
            for (var _b = __asyncValues(iterateItems(ref, opts)), _c; _c = yield __await(_b.next()), !_c.done;) {
                let [v] = _c.value;
                yield yield __await(v);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
            }
            finally { if (e_4) throw e_4.error; }
        }
    });
}
/**
 * Iterate over inner records at a Gun node reference, yielding
 * the inner record.
 *
 * Note that keys are not guaranteed to be in order if there
 * is more than one connected peer.
 *
 * @param ref Gun node reference
 **/
function iterateKeys(ref, opts) {
    return __asyncGenerator(this, arguments, function* iterateKeys_1() {
        var e_5, _a;
        try {
            for (var _b = __asyncValues(iterateRecord(ref, opts)), _c; _c = yield __await(_b.next()), !_c.done;) {
                let [v, k] = _c.value;
                yield yield __await(k);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
            }
            finally { if (e_5) throw e_5.error; }
        }
    });
}

const ALL_DATE_UNITS = [
    'year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond',
];
const DATE_UNIT_SET = new Set(ALL_DATE_UNITS);
const ZERO_DATE = moment__default['default'].utc().startOf('year').set('year', 1);
/**
 * Efficiently distributes and stores data in a tree with nodes using date
 * components as keys up to a specified resolution.
 * The root of the tree is specified as a Gun node reference.
 *
 * **Why not just use a hash table?**
 *
 * Having large nodes is discouraged in a graph database like Gun.
 * If you need to store large lists or tables of data, you need to break
 * them up into smaller nodes to ease synchronization between peers.
 */
class DateTree {
    constructor(root, resolution) {
        if (!DateTree.isResolution(resolution)) {
            throw new Error('Invalid graph date resolution: ' + resolution);
        }
        this.root = root;
        this.resolution = resolution;
    }
    nextDate(date) {
        let m = DateTree.parseDate(date);
        let floor = m.startOf(this.resolution);
        let next = floor.add(1, this.resolution);
        return next;
    }
    previousDate(date) {
        let m = DateTree.parseDate(date);
        let floor = m.startOf(this.resolution);
        if (floor.isSame(m)) {
            floor = floor.subtract(1, this.resolution);
        }
        return floor;
    }
    /**
     * Subscribes to data in a date range.
     * It is recommended to limit the date range
     * as much as possible to avoid creating too
     * many internal data subscriptions, which slows
     * down program execution.
     *
     * The data is not ordered.
     *
     * If no date range is given, subscribes to changes
     * on any date (not recommended on larger trees).
     *
     * @param cb
     * @param opts
     * @returns A {@link IGunSubscription} object.
     */
    on(cb, opts = {}) {
        // TODO: add updates support
        let range = mapValueRange(rangeWithFilter(opts), x => DateTree.parseDate(x, this.resolution));
        let { start, end } = range;
        if (!start && !end) {
            return this._onAny(cb);
        }
        let startComps = (start && DateTree.getDateComponents(start, this.resolution) || {});
        let endComps = (end && DateTree.getDateComponents(end, this.resolution) || {});
        let commonUnit = DateTree.largestCommonUnit(startComps, endComps);
        let commonComps = commonUnit
            ? DateTree.downsampleDateComponents(startComps, commonUnit)
            : {};
        let mapTable = {};
        let subTable = {};
        let didUnsub = false;
        let commonSub = {
            off: () => {
                if (didUnsub) {
                    return;
                }
                didUnsub = true;
                for (let sub of Object.values(subTable)) {
                    sub.off();
                }
                subTable = {};
            }
        };
        const beginSub = (comps, unit) => {
            if (didUnsub) {
                return;
            }
            let compKey = DateTree.dateComponentsToString(comps, unit);
            if (compKey in mapTable) {
                // Already subscribed
                return;
            }
            let innerRef = this._getRef(comps);
            let innerUnit = unit ? DateTree.getSmallerUnit(unit) : 'year';
            // Filter inner keys if needed
            let innerRange = DateTree.getDateComponentKeyRange(comps, {
                start: startComps,
                end: endComps,
            }, innerUnit);
            let { start: innerStart, end: innerEnd } = innerRange;
            if (typeof innerStart !== 'undefined' || typeof innerEnd !== 'undefined') {
                // Filter inner keys
                let lexRange = {};
                if (typeof innerStart !== 'undefined') {
                    // Start filter is inclusive
                    lexRange['>'] = innerStart;
                }
                if (typeof innerEnd !== 'undefined') {
                    // End filter is inclusive
                    lexRange['<'] = innerEnd;
                }
                innerRef = innerRef.get({ '.': lexRange });
            }
            let map = innerRef.map();
            mapTable[compKey] = map;
            subTable[compKey] = subscribe(map, (data, key, at, innerSub) => {
                let value = DateTree.decodeDateComponent(key);
                let innerComps = Object.assign(Object.assign({}, comps), { [innerUnit]: value });
                if (innerUnit === this.resolution) {
                    // Got data
                    let date = DateTree.getDateWithComponents(innerComps);
                    // Filter boundaries
                    if (isInRange(date, range)) {
                        cb(data, date, at, commonSub);
                    }
                }
                else {
                    // Map deeper
                    beginSub(innerComps, innerUnit);
                }
            });
        };
        // Begin subscribing
        beginSub(commonComps, commonUnit);
        return commonSub;
    }
    _onAny(cb) {
        // TODO: opts.updates = true not working as expected
        let units = this._allUnits();
        let ref = this.root.map();
        for (let i = 0; i < units.length - 1; i++) {
            ref = ref.map();
        }
        return ref.on((data, key, at, event) => {
            let date = this.getDate(at);
            cb(data, date, at, event);
        });
    }
    /**
     * Listens to changes about the specified date.
     *
     * Let's say we want to listen to changes to a blog described
     * by a date tree.
     * How would we handle a case where we are close to the end
     * of the nodes for the current time period?
     *
     * For example, we are at 2019-12-31 23:54, which is the end
     * of the hour, day, month and year. We may get a message this
     * next minute, hour, day, month or year.
     * Subscribing to all nodes would be impractical.
     * Listen to a single path of the tree instead with `changesAbout()`.
     *
     * **Proposed strategy:**
     *
     * At each date in the future, we can call `latest()`
     * and `iterate()` to get the latest data.
     *
     * When the date gets too far away, we can call `unsub()`
     * and resubscribe to a later date.
     *
     * @param date
     * @param callback
     *
     * Whenever a node changes next to the direct path between the root and the
     * tree's maximum resolution, the callback is called with the date components
     * identifying the node. Note that the date components are partial unless the
     * change occured at the maximum resolution.
     *
     * @returns An unsubscribe function
     */
    changesAbout(date, callback) {
        let m = DateTree.parseDate(date);
        let comps = DateTree.getDateComponents(m, this.resolution);
        let units = Object.keys(comps);
        let refs = this._getRefChain(comps);
        let refTable = ___default['default'].zipObject(units, refs);
        let subTable = {};
        let didUnsub = false;
        let commonSub = {
            off: () => {
                if (didUnsub) {
                    return;
                }
                didUnsub = true;
                for (let sub of Object.values(subTable)) {
                    sub.off();
                }
                subTable = {};
            }
        };
        ___default['default'].forIn(refTable, (ref, unit) => {
            subTable[unit] = subscribe(ref, (changes, outerKey, at, sub) => {
                // Get data
                ___default['default'].forIn(changes, (val, key) => {
                    if (key === '_') {
                        // Meta
                        return;
                    }
                    let changedUnit = unit;
                    let changeComps = DateTree.downsampleDateComponents(comps, changedUnit);
                    let compVal = DateTree.decodeDateComponent(key);
                    if (compVal !== changeComps[changedUnit]) {
                        changeComps[changedUnit] = compVal;
                    }
                    else {
                        // Filter changes to the current ref chain
                        return;
                    }
                    try {
                        callback(changeComps, commonSub);
                    }
                    catch (error) {
                        console.error(`Uncaught error in DateTree: ${error}`);
                    }
                });
            }, { change: true });
        });
        return commonSub;
    }
    /**
     * Returns the date for the specified Gun node reference.
     * @param ref Gun node reference
     * @returns Date
     */
    getDate(ref) {
        var _a, _b, _c, _d, _e, _f;
        let currentRef = ref;
        let units = this._allUnits();
        let keys = [];
        let ok = true;
        const getKey = (ref) => {
            var _a, _b, _c, _d;
            return ((_a = ref._) === null || _a === void 0 ? void 0 : _a.get) || ref.get || ((_b = ref.$) === null || _b === void 0 ? void 0 : _b.get) || ((_d = (_c = ref.$) === null || _c === void 0 ? void 0 : _c._) === null || _d === void 0 ? void 0 : _d.get);
        };
        const rootKey = getKey(this.root);
        while (currentRef && keys.length < units.length) {
            let key = getKey(currentRef);
            if (!key || key === rootKey) {
                ok = false;
                break;
            }
            keys.unshift(key);
            if (typeof currentRef.back === 'function') {
                // Using concrete reference
                currentRef = currentRef.back();
            }
            else if (typeof ((_b = (_a = currentRef.$) === null || _a === void 0 ? void 0 : _a._) === null || _b === void 0 ? void 0 : _b.back) === 'object') {
                // Using reference from callback
                currentRef = (_d = (_c = currentRef.$) === null || _c === void 0 ? void 0 : _c._) === null || _d === void 0 ? void 0 : _d.back;
            }
            else if (typeof ((_e = currentRef.$) === null || _e === void 0 ? void 0 : _e.back) === 'function') {
                // Using reference from callback
                currentRef = (_f = currentRef.$) === null || _f === void 0 ? void 0 : _f.back();
            }
            else {
                ok = false;
                break;
            }
        }
        if (getKey(currentRef) !== rootKey) {
            ok = false;
        }
        if (!ok) {
            throw new Error('Invalid Gun node reference. Expected a leaf on the date tree.');
        }
        let values = keys.map(k => DateTree.decodeDateComponent(k));
        let comps = ___default['default'].zipObject(units, values);
        return DateTree.getDateWithComponents(comps);
    }
    /**
     * Returns the Gun node reference for a particular date
     * up to the receiver's maximum resolution. If none
     * exists, it is created.
     * @param date Date
     * @returns Gun node reference
     */
    get(date) {
        let comps = DateTree.getDateComponents(DateTree.parseDate(date), this.resolution);
        let chain = this._getRefChain(comps);
        return chain[chain.length - 1];
    }
    /**
     * Assumes the date components are clean (with no other properties).
     * @param comps
     */
    _getRefChain(comps) {
        let ref = this.root;
        let refs = [ref];
        ___default['default'].forIn(comps, (val, unit) => {
            let key = DateTree.encodeDateComponent(val, unit);
            ref = ref.get(key);
            refs.push(ref);
        });
        return refs;
    }
    /**
     * Assumes the date components are clean (with no other properties).
     * @param comps
     */
    _getRef(comps) {
        let chain = this._getRefChain(comps);
        return chain[chain.length - 1];
    }
    /**
     * Gets the latest Gun node reference if one exists.
     * @param date
     * @returns A Gun node reference and its date
     */
    latest() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.previous();
        });
    }
    /**
     * Gets the earliest Gun node reference if one exists.
     * @param date
     * @returns A Gun node reference and its date
     */
    earliest() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.next();
        });
    }
    /**
     * Gets the next Gun node reference for a particular date
     * if one exists. If no date is specified, returns the
     * first node reference.
     * @param date
     * @returns A Gun node reference and its date
     */
    next(date) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            let it = this.iterate({
                gt: date && DateTree.parseDate(date, this.resolution) || undefined,
                order: 1,
            });
            try {
                for (var it_1 = __asyncValues(it), it_1_1; it_1_1 = yield it_1.next(), !it_1_1.done;) {
                    let [ref, refDate] = it_1_1.value;
                    if (date) {
                        if (refDate.isSame(date)) {
                            continue;
                        }
                        else if (refDate.isBefore(date)) {
                            throw new Error(`Unexpected date ${refDate} after ${date}`);
                        }
                    }
                    return [ref, refDate];
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (it_1_1 && !it_1_1.done && (_a = it_1.return)) yield _a.call(it_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return [undefined, undefined];
        });
    }
    /**
     * Gets the previous Gun node reference for a particular date
     * if one exists. If no date is specified, returns the
     * last node reference.
     * @param date
     * @returns A Gun node reference and its date
     */
    previous(date) {
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function* () {
            let it = this.iterate({
                lt: date && DateTree.parseDate(date, this.resolution) || undefined,
                order: -1,
            });
            try {
                for (var it_2 = __asyncValues(it), it_2_1; it_2_1 = yield it_2.next(), !it_2_1.done;) {
                    let [ref, refDate] = it_2_1.value;
                    if (date) {
                        if (refDate.isSame(date)) {
                            continue;
                        }
                        else if (refDate.isAfter(date)) {
                            throw new Error(`Unexpected date ${refDate} before ${date}`);
                        }
                    }
                    return [ref, refDate];
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (it_2_1 && !it_2_1.done && (_a = it_2.return)) yield _a.call(it_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return [undefined, undefined];
        });
    }
    /**
     * Iterates over all node references after and
     * inclusing `start` date and before and excluding
     * `end` date.
     * @param param0
     */
    iterate(opts = {}) {
        return __asyncGenerator(this, arguments, function* iterate_1() {
            var e_3, _a;
            let range = mapValueRange(rangeWithFilter(opts), x => DateTree.parseDate(x, this.resolution));
            let { start, end } = range;
            let { order } = opts;
            let ref = this.root;
            let startComps = (start && DateTree.getDateComponents(start, this.resolution) || {});
            let endComps = (end && DateTree.getDateComponents(end, this.resolution) || {});
            let comps = {};
            let units = this._allUnits();
            let unitIndex = 0;
            let unitsLen = units.length;
            let it;
            let itStack = [];
            while (unitIndex >= 0) {
                let goUp = false;
                let unit = units[unitIndex];
                let atLeaf = unitIndex === unitsLen - 1;
                if (ref) {
                    // Queue another node for iteration
                    let range = DateTree.getDateComponentKeyRange(comps, {
                        start: startComps,
                        end: endComps,
                    }, unit);
                    let filter = filterWithRange(range);
                    it = this._iterateRef(ref, Object.assign(Object.assign({}, filter), { order }));
                    itStack.unshift(it);
                    ref = undefined;
                }
                if (it && atLeaf) {
                    try {
                        // Found data
                        for (var it_3 = (e_3 = void 0, __asyncValues(it)), it_3_1; it_3_1 = yield __await(it_3.next()), !it_3_1.done;) {
                            let [innerRef, compVal] = it_3_1.value;
                            comps[unit] = compVal;
                            let date = DateTree.getDateWithComponents(comps, this.resolution);
                            // Filter boundaries
                            if (isInRange(date, range)) {
                                yield yield __await([innerRef, date]);
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (it_3_1 && !it_3_1.done && (_a = it_3.return)) yield __await(_a.call(it_3));
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    // Go up a level
                    goUp = true;
                }
                if (!goUp) {
                    // Go to sibling
                    let next = yield __await(itStack[0].next());
                    if (next.done) {
                        // Go up a level
                        goUp = true;
                    }
                    else {
                        // Go down a level
                        ref = next.value[0];
                        comps[unit] = next.value[1];
                        unitIndex += 1;
                    }
                }
                if (goUp) {
                    itStack.shift();
                    unitIndex -= 1;
                    if (unit in comps) {
                        delete comps[unit];
                    }
                    continue;
                }
            }
        });
    }
    /**
     * Iterates over all refs children.
     * @param ref
     * @param start inclusive
     * @param end exclusive
     */
    _iterateRef(ref, opts) {
        return __asyncGenerator(this, arguments, function* _iterateRef_1() {
            var e_4, _a;
            try {
                for (var _b = __asyncValues(iterateRefs(ref, opts)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    let [innerRef, key] = _c.value;
                    let val = DateTree.decodeDateComponent(key);
                    yield yield __await([innerRef, val]);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    _allUnits() {
        let units = [];
        for (let res of ALL_DATE_UNITS) {
            units.push(res);
            if (res === this.resolution) {
                break;
            }
        }
        return units;
    }
    static lowerUnit(unit) {
        let i = ALL_DATE_UNITS.indexOf(unit);
        if (i < 0) {
            return undefined;
        }
        return ALL_DATE_UNITS[i - 1];
    }
    static getDateWithComponents(comps, resolution) {
        let c = comps;
        let m = ZERO_DATE.clone();
        for (let res of ALL_DATE_UNITS) {
            if (res in comps) {
                let val = nativeDateValue(c[res], res);
                m.set(nativeDateUnit(res), val);
            }
            else {
                break;
            }
            if (res === resolution) {
                break;
            }
        }
        return m;
    }
    static getDateComponents(date, resolution) {
        let m = this.parseDate(date);
        if (!this.isResolution(resolution)) {
            throw new Error('Invalid graph date resolution: ' + resolution);
        }
        let comps = {};
        for (let res of ALL_DATE_UNITS) {
            comps[res] = this.getDateComponent(m, res);
            if (res === resolution) {
                break;
            }
        }
        return comps;
    }
    static getDateComponent(date, unit) {
        let m = this.parseDate(date);
        let val = m.get(nativeDateUnit(unit));
        return graphDateValue(val, unit);
    }
    /**
     * Returns the largest common unit between two date components.
     * If none is found, returns undefined
     * @param comp1
     * @param comp2
     */
    static largestCommonUnit(comp1, comp2) {
        let commonUnit;
        for (let unit of ALL_DATE_UNITS) {
            if (comp1[unit] === comp2[unit]) {
                commonUnit = unit;
            }
            else {
                break;
            }
        }
        return commonUnit;
    }
    static encodeDateComponent(value, unit) {
        if (typeof value === 'undefined') {
            return undefined;
        }
        // Pad number with zeroes for lexicographical ordering
        let key = value.toString();
        let padLen = DATE_COMP_PADS[unit];
        return key.padStart(padLen, '0');
    }
    static decodeDateComponent(key) {
        // TODO: validate key in case there is unexpected data in the tree
        return Math.round(parseFloat(key));
    }
    static downsampleDateComponents(components, resolution) {
        let newComponents = {};
        for (let res of ALL_DATE_UNITS) {
            newComponents[res] = components[res];
            if (res === resolution) {
                break;
            }
        }
        return newComponents;
    }
    static getDateComponentKeyRange(comps, compRange, unit) {
        let [startVal, endVal] = DateTree.getDateComponentRange(comps, compRange.start, compRange.end, unit);
        return {
            start: DateTree.encodeDateComponent(startVal, unit),
            end: DateTree.encodeDateComponent(endVal, unit),
            startClosed: true,
            endClosed: true,
        };
    }
    static getDateComponentRange(comps, startComps, endComps, unit) {
        let startVal = startComps[unit];
        let endVal = endComps[unit];
        if (typeof startVal === 'undefined' && typeof endVal === 'undefined') {
            return [startVal, endVal];
        }
        let upUnit = this.getBiggerUnit(unit);
        if (!upUnit) {
            return [startVal, endVal];
        }
        let upComps = this.downsampleDateComponents(comps, upUnit);
        if (typeof startVal !== 'undefined') {
            let upStartComps = this.downsampleDateComponents(startComps, upUnit);
            if (!___default['default'].isEqual(upStartComps, upComps)) {
                // Expand start
                startVal = undefined;
            }
        }
        if (typeof endVal !== 'undefined') {
            let upEndComps = DateTree.downsampleDateComponents(endComps, upUnit);
            if (!___default['default'].isEqual(upEndComps, upComps)) {
                // Expand end
                endVal = undefined;
            }
        }
        return [startVal, endVal];
    }
    static getBiggerUnit(unit) {
        let i = ALL_DATE_UNITS.indexOf(unit);
        if (i < 0)
            return undefined;
        return ALL_DATE_UNITS[i - 1];
    }
    static getSmallerUnit(unit) {
        let i = ALL_DATE_UNITS.indexOf(unit);
        if (i === ALL_DATE_UNITS.length - 1)
            return undefined;
        return ALL_DATE_UNITS[i + 1];
    }
    static dateComponentsToString(comp, resolution) {
        let str = '';
        for (let unit of ALL_DATE_UNITS) {
            if (!(resolution || unit in comp)) {
                break;
            }
            let val = this.encodeDateComponent(comp[unit], unit);
            switch (unit) {
                case 'year':
                    break;
                case 'month':
                case 'day':
                    str += '-';
                    break;
                case 'hour':
                    str += 'T';
                    break;
                case 'minute':
                case 'second':
                    str += ':';
                    break;
                case 'millisecond':
                    str += '.';
                    break;
            }
            str += val;
            if (unit === 'millisecond') {
                str += 'Z';
            }
            if (unit === resolution) {
                break;
            }
        }
        return str;
    }
    static isResolution(resolution) {
        if (typeof resolution !== 'string')
            return false;
        return DATE_UNIT_SET.has(resolution);
    }
    /**
     * Parses a date into a `Moment`, using the
     * current time zone and converts it into UTC time.
     * @param date
     */
    static parseDate(date, resolution) {
        if (!date || (typeof date === 'number' && (isNaN(date) || !isFinite(date)))) {
            throw new Error('Invalid date');
        }
        let m = moment__default['default'](date).utc();
        if (resolution) {
            m = m.startOf(resolution);
        }
        return m;
    }
}
const nativeDateUnit = (res) => {
    if (res === 'day') {
        return 'date';
    }
    return res;
};
const graphDateValue = (value, res) => {
    if (res === 'month') {
        value += 1;
    }
    return value;
};
const nativeDateValue = (value, res) => {
    if (res === 'month') {
        value -= 1;
    }
    return value;
};
/** The minimum (inclusive) date component values. */
(() => {
    let maxDate = moment__default['default'].utc().startOf('year');
    let units = ALL_DATE_UNITS.slice(1);
    return ___default['default'].zipObject(units, units.map(r => graphDateValue(maxDate.get(nativeDateUnit(r)), r)));
})();
/** The maximum (exclusive) date component values. */
const MAX_DATE_COMPONENTS = (() => {
    let maxDate = moment__default['default'].utc().endOf('year');
    let units = ALL_DATE_UNITS.slice(1);
    return ___default['default'].zipObject(units, units.map(r => graphDateValue(maxDate.get(nativeDateUnit(r)), r) + 1));
})();
const DATE_COMP_PADS = (() => {
    let pads = {
        year: 4
    };
    for (let unit of ALL_DATE_UNITS) {
        if (unit !== 'year') {
            let max = MAX_DATE_COMPONENTS[unit] - 1;
            pads[unit] = max.toString().length;
        }
    }
    return pads;
})();
// /** The set of all possible keys of a date component. */
// const DATE_COMPONENT_KEY_SETS: Omit<{ readonly [K in DateUnit]: Set<string> }, 'year'> = (() => {
//     let sets: Partial<Omit<{ [K in DateUnit]: Set<string> }, 'year'>> = {};
//     for (let unit of ALL_DATE_UNITS) {
//         if (unit === 'year') continue;
//         let min = MIN_DATE_COMPONENTS[unit];
//         let max = MIN_DATE_COMPONENTS[unit];
//         let set = new Set<string>();
//         for (let i = min; i < max; i++) {
//             set.add(DateTree.encodeDateComponent(i, unit)!);
//         }
//         sets[unit] = set;
//     }
//     return sets as Omit<{ readonly [K in DateUnit]: Set<string> }, 'year'>;
// })();

/**
 * Encrypt (and optionally sign) a value, array or object. The encrypted data
 * retains topology and can only be decrypted by the current user.
 *
 * Keys are not encrypted.
 *
 * If the value or nested value is already encrypted, does not re-encrypt
 * that value.
 *
 * Specifying a recipient's epub key will only allow that user to decrypt the value,
 * with Elliptic-curve DiffieHellman based encryption.
 *
 * @param value
 * @param opts
 */
function encrypt(data, opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let epub = (_a = opts.recipient) === null || _a === void 0 ? void 0 : _a.epub;
        return yield _crypt(data, _encryptValue, Object.assign(Object.assign({}, opts), { epub }));
    });
}
/**
 * Decrypt (and optionally verify) a value, array or object. The decrypted data
 * retains topology and can only be decrypted by the current user.
 *
 * Keys are not encrypted.
 *
 * If the value or nested value is already encrypted, does not re-encrypt
 * that value.
 *
 * Specifying a sender's epub key will decrypt the value which was encrypted
 * by the sender.
 *
 * @param value
 * @param opts
 */
function decrypt(data, opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let epub = (_a = opts.sender) === null || _a === void 0 ? void 0 : _a.epub;
        return yield _crypt(data, _decryptValue, Object.assign(Object.assign({}, opts), { epub }));
    });
}
function _crypt(data, map, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        let { pair, secret = '', epub = '' } = opts;
        if (!pair && !secret) {
            throw new Error('Either pair or secret is required');
        }
        if (!secret && epub) {
            secret = yield Gun__default['default'].SEA.secret(epub, pair || secret);
            if (typeof secret === 'undefined') {
                throw _getSEAError('Could not create secret');
            }
        }
        if (!secret) {
            secret = pair;
        }
        return yield _mapDeep(data, map, { secret, signed: !epub });
    });
}
/**
 * Traverse data and map.
 * @param data
 * @param map
 * @param opts
 */
function _mapDeep(data, map, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (typeof data) {
            case 'undefined':
                return undefined;
            case 'object':
                if (___default['default'].isArrayLike(data)) {
                    // Array
                    return Promise.all(___default['default'].map(data, x => _mapDeep(x, map, opts)));
                }
                // Object
                let meta = data._;
                if (meta) {
                    // Remove meta
                    data = ___default['default'].omit(data, '_');
                }
                let keys = Object.keys(data);
                let rawValues = Object.values(data);
                let values = yield Promise.all(rawValues.map(x => _mapDeep(x, map, opts)));
                let result = ___default['default'].zipObject(keys, values);
                if (meta) {
                    result = Object.assign({ _: meta }, result);
                }
                return result;
            default:
                return map(data, opts);
        }
    });
}
const _encryptValue = (value, { secret, signed }) => __awaiter(void 0, void 0, void 0, function* () {
    if (value.startsWith('SEA{')) {
        // Already encrypted
        return value;
    }
    let data = yield Gun__default['default'].SEA.encrypt(value, secret);
    if (typeof data === 'undefined') {
        throw _getSEAError('Could not encrypt');
    }
    if (signed) {
        data = yield Gun__default['default'].SEA.sign(data, secret);
        if (typeof data === 'undefined') {
            throw _getSEAError('Could not sign');
        }
    }
    return data;
});
const _decryptValue = (data, { secret, signed }) => __awaiter(void 0, void 0, void 0, function* () {
    if (!data.startsWith('SEA{')) {
        // No decryption necessary
        return data;
    }
    let msg = data;
    if (signed) {
        msg = yield Gun__default['default'].SEA.verify(data, secret);
        if (typeof msg === 'undefined') {
            throw _getSEAError('Could not verify');
        }
    }
    let value = yield Gun__default['default'].SEA.decrypt(msg, secret);
    if (typeof value === 'undefined') {
        throw _getSEAError('Could not decrypt');
    }
    return value;
});
const _getSEAError = (_default) => {
    let err = Gun__default['default'].SEA.err || _default;
    if (!err) {
        return undefined;
    }
    if (typeof err === 'object' && err instanceof Error) {
        return err;
    }
    return new Error(String(err));
};

// Temporary GUN fixes
// PR: Fixed missing Gun.log.once function #961
// https://github.com/amark/gun/pull/961
const gunLogOnceFix = (Gun) => {
    if (typeof Gun !== 'function') {
        throw new Error('Must specify a Gun constructor');
    }
    if (!Gun.log.once) {
        Gun.log.once = function (w, s, o) { return (o = Gun.log.once)[w] = o[w] || 0, o[w]++ || Gun.log(s); };
    }
};
/** Call in case of user is not defined errors. */
const fixSea = (Gun) => {
    if (typeof Gun !== 'function') {
        throw new Error('Must specify a Gun constructor');
    }
    if (!Gun.SEA && !!require) {
        Gun.SEA = require('gun/sea');
    }
};

exports.ALL_DATE_UNITS = ALL_DATE_UNITS;
exports.Auth = Auth;
exports.AuthError = AuthError;
exports.DATE_UNIT_SET = DATE_UNIT_SET;
exports.DateTree = DateTree;
exports.Gun = Gun;
exports.GunError = GunError;
exports.InvalidCredentials = InvalidCredentials;
exports.MultipleAuthError = MultipleAuthError;
exports.NetworkError = NetworkError;
exports.TEST_GUN_OPTIONS = TEST_GUN_OPTIONS;
exports.TEST_GUN_PEERS = TEST_GUN_PEERS;
exports.TimeoutError = TimeoutError;
exports.UserExists = UserExists;
exports._crypt = _crypt;
exports.closedFilter = closedFilter;
exports.decrypt = decrypt;
exports.delay = delay;
exports.encrypt = encrypt;
exports.errorAfter = errorAfter;
exports.filterWithRange = filterWithRange;
exports.filteredIndexRange = filteredIndexRange;
exports.fixSea = fixSea;
exports.gunLogOnceFix = gunLogOnceFix;
exports.isGunInstance = isGunInstance;
exports.isInRange = isInRange;
exports.isPlatformWeb = isPlatformWeb;
exports.isValueRangeEmpty = isValueRangeEmpty;
exports.iterateAll = iterateAll;
exports.iterateItems = iterateItems;
exports.iterateKeys = iterateKeys;
exports.iterateRecord = iterateRecord;
exports.iterateRefs = iterateRefs;
exports.iterateValues = iterateValues;
exports.mapValueRange = mapValueRange;
exports.rangeWithFilter = rangeWithFilter;
exports.subscribe = subscribe;
exports.timeoutAfter = timeoutAfter;
exports.waitForData = waitForData;
