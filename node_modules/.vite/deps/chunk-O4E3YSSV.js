import {
  __commonJS,
  __require,
  computed,
  getCurrentInstance,
  getCurrentScope,
  isRef,
  nextTick,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  reactive,
  ref,
  shallowReactive,
  shallowRef,
  unref,
  watch,
  watchEffect
} from "./chunk-UDYEDF36.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          throw new Error(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          throw new Error(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/chromatone.center@1.9.0/node_modules/chromatone.center/lib/tone.js
var version = "14.8.40";
var createExtendedExponentialRampToValueAutomationEvent = (value, endTime, insertTime) => {
  return { endTime, insertTime, type: "exponentialRampToValue", value };
};
var createExtendedLinearRampToValueAutomationEvent = (value, endTime, insertTime) => {
  return { endTime, insertTime, type: "linearRampToValue", value };
};
var createSetValueAutomationEvent = (value, startTime) => {
  return { startTime, type: "setValue", value };
};
var createSetValueCurveAutomationEvent = (values, startTime, duration2) => {
  return { duration: duration2, startTime, type: "setValueCurve", values };
};
var getTargetValueAtTime = (time, valueAtStartTime, { startTime, target, timeConstant }) => {
  return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);
};
var isExponentialRampToValueAutomationEvent = (automationEvent) => {
  return automationEvent.type === "exponentialRampToValue";
};
var isLinearRampToValueAutomationEvent = (automationEvent) => {
  return automationEvent.type === "linearRampToValue";
};
var isAnyRampToValueAutomationEvent = (automationEvent) => {
  return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);
};
var isSetValueAutomationEvent = (automationEvent) => {
  return automationEvent.type === "setValue";
};
var isSetValueCurveAutomationEvent = (automationEvent) => {
  return automationEvent.type === "setValueCurve";
};
var getValueOfAutomationEventAtIndexAtTime = (automationEvents, index2, time, defaultValue) => {
  const automationEvent = automationEvents[index2];
  return automationEvent === void 0 ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index2 - 1, automationEvent.startTime, defaultValue), automationEvent);
};
var getEndTimeAndValueOfPreviousAutomationEvent = (automationEvents, index2, currentAutomationEvent, nextAutomationEvent, defaultValue) => {
  return currentAutomationEvent === void 0 ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [
    currentAutomationEvent.startTime + currentAutomationEvent.duration,
    currentAutomationEvent.values[currentAutomationEvent.values.length - 1]
  ] : [
    currentAutomationEvent.startTime,
    getValueOfAutomationEventAtIndexAtTime(automationEvents, index2 - 1, currentAutomationEvent.startTime, defaultValue)
  ];
};
var isCancelAndHoldAutomationEvent = (automationEvent) => {
  return automationEvent.type === "cancelAndHold";
};
var isCancelScheduledValuesAutomationEvent = (automationEvent) => {
  return automationEvent.type === "cancelScheduledValues";
};
var getEventTime = (automationEvent) => {
  if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
    return automationEvent.cancelTime;
  }
  if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {
    return automationEvent.endTime;
  }
  return automationEvent.startTime;
};
var getExponentialRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {
  if (valueAtStartTime === value) {
    return value;
  }
  if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {
    return valueAtStartTime * (value / valueAtStartTime) ** ((time - startTime) / (endTime - startTime));
  }
  return 0;
};
var getLinearRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {
  return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);
};
var interpolateValue = (values, theoreticIndex) => {
  const lowerIndex = Math.floor(theoreticIndex);
  const upperIndex = Math.ceil(theoreticIndex);
  if (lowerIndex === upperIndex) {
    return values[lowerIndex];
  }
  return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];
};
var getValueCurveValueAtTime = (time, { duration: duration2, startTime, values }) => {
  const theoreticIndex = (time - startTime) / duration2 * (values.length - 1);
  return interpolateValue(values, theoreticIndex);
};
var isSetTargetAutomationEvent = (automationEvent) => {
  return automationEvent.type === "setTarget";
};
var AutomationEventList = class {
  constructor(defaultValue) {
    this._automationEvents = [];
    this._currenTime = 0;
    this._defaultValue = defaultValue;
  }
  [Symbol.iterator]() {
    return this._automationEvents[Symbol.iterator]();
  }
  add(automationEvent) {
    const eventTime = getEventTime(automationEvent);
    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
      const index2 = this._automationEvents.findIndex((currentAutomationEvent) => {
        if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {
          return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;
        }
        return getEventTime(currentAutomationEvent) >= eventTime;
      });
      const removedAutomationEvent = this._automationEvents[index2];
      if (index2 !== -1) {
        this._automationEvents = this._automationEvents.slice(0, index2);
      }
      if (isCancelAndHoldAutomationEvent(automationEvent)) {
        const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];
        if (removedAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {
          if (isSetTargetAutomationEvent(lastAutomationEvent)) {
            throw new Error("The internal list is malformed.");
          }
          const startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);
          const startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;
          const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);
          const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);
          this._automationEvents.push(truncatedAutomationEvent);
        }
        if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {
          this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));
        }
        if (lastAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {
          this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);
        }
      }
    } else {
      const index2 = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > eventTime);
      const previousAutomationEvent = index2 === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index2 - 1];
      if (previousAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {
        return false;
      }
      const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;
      if (index2 === -1) {
        this._automationEvents.push(persistentAutomationEvent);
      } else {
        if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[index2])) {
          return false;
        }
        this._automationEvents.splice(index2, 0, persistentAutomationEvent);
      }
    }
    return true;
  }
  flush(time) {
    const index2 = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > time);
    if (index2 > 1) {
      const remainingAutomationEvents = this._automationEvents.slice(index2 - 1);
      const firstRemainingAutomationEvent = remainingAutomationEvents[0];
      if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {
        remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index2 - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));
      }
      this._automationEvents = remainingAutomationEvents;
    }
  }
  getValue(time) {
    if (this._automationEvents.length === 0) {
      return this._defaultValue;
    }
    const indexOfNextEvent = this._automationEvents.findIndex((automationEvent) => getEventTime(automationEvent) > time);
    const nextAutomationEvent = this._automationEvents[indexOfNextEvent];
    const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;
    const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];
    if (currentAutomationEvent !== void 0 && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {
      return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);
    }
    if (currentAutomationEvent !== void 0 && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
      return currentAutomationEvent.value;
    }
    if (currentAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {
      if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {
        return getValueCurveValueAtTime(time, currentAutomationEvent);
      }
      return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];
    }
    if (currentAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
      return currentAutomationEvent.value;
    }
    if (nextAutomationEvent !== void 0 && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {
      const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);
      return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);
    }
    if (nextAutomationEvent !== void 0 && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {
      const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);
      return getLinearRampValueAtTime(time, startTime, value, nextAutomationEvent);
    }
    return this._defaultValue;
  }
};
var createCancelAndHoldAutomationEvent = (cancelTime) => {
  return { cancelTime, type: "cancelAndHold" };
};
var createCancelScheduledValuesAutomationEvent = (cancelTime) => {
  return { cancelTime, type: "cancelScheduledValues" };
};
var createExponentialRampToValueAutomationEvent = (value, endTime) => {
  return { endTime, type: "exponentialRampToValue", value };
};
var createLinearRampToValueAutomationEvent = (value, endTime) => {
  return { endTime, type: "linearRampToValue", value };
};
var createSetTargetAutomationEvent = (target, startTime, timeConstant) => {
  return { startTime, target, timeConstant, type: "setTarget" };
};
var createAbortError = () => new DOMException("", "AbortError");
var createAddActiveInputConnectionToAudioNode = (insertElementInSet2) => {
  return (activeInputs, source, [output, input2, eventListener], ignoreDuplicates) => {
    insertElementInSet2(activeInputs[input2], [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
  };
};
var createAddAudioNodeConnections = (audioNodeConnectionsStore) => {
  return (audioNode, audioNodeRenderer, nativeAudioNode) => {
    const activeInputs = [];
    for (let i2 = 0; i2 < nativeAudioNode.numberOfInputs; i2 += 1) {
      activeInputs.push(/* @__PURE__ */ new Set());
    }
    audioNodeConnectionsStore.set(audioNode, {
      activeInputs,
      outputs: /* @__PURE__ */ new Set(),
      passiveInputs: /* @__PURE__ */ new WeakMap(),
      renderer: audioNodeRenderer
    });
  };
};
var createAddAudioParamConnections = (audioParamConnectionsStore) => {
  return (audioParam, audioParamRenderer) => {
    audioParamConnectionsStore.set(audioParam, { activeInputs: /* @__PURE__ */ new Set(), passiveInputs: /* @__PURE__ */ new WeakMap(), renderer: audioParamRenderer });
  };
};
var ACTIVE_AUDIO_NODE_STORE = /* @__PURE__ */ new WeakSet();
var AUDIO_NODE_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();
var AUDIO_NODE_STORE = /* @__PURE__ */ new WeakMap();
var AUDIO_PARAM_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();
var AUDIO_PARAM_STORE = /* @__PURE__ */ new WeakMap();
var CONTEXT_STORE = /* @__PURE__ */ new WeakMap();
var EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();
var CYCLE_COUNTERS = /* @__PURE__ */ new WeakMap();
var NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = /* @__PURE__ */ new WeakMap();
var NODE_TO_PROCESSOR_MAPS = /* @__PURE__ */ new WeakMap();
var handler = {
  construct() {
    return handler;
  }
};
var isConstructible = (constructible) => {
  try {
    const proxy = new Proxy(constructible, handler);
    new proxy();
  } catch {
    return false;
  }
  return true;
};
var IMPORT_STATEMENT_REGEX = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/;
var splitImportStatements = (source, url) => {
  const importStatements = [];
  let sourceWithoutImportStatements = source.replace(/^[\s]+/, "");
  let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
  while (result !== null) {
    const unresolvedUrl = result[1].slice(1, -1);
    const importStatementWithResolvedUrl = result[0].replace(/([\s]+)?;?$/, "").replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());
    importStatements.push(importStatementWithResolvedUrl);
    sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\s]+/, "");
    result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
  }
  return [importStatements.join(";"), sourceWithoutImportStatements];
};
var verifyParameterDescriptors = (parameterDescriptors) => {
  if (parameterDescriptors !== void 0 && !Array.isArray(parameterDescriptors)) {
    throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.");
  }
};
var verifyProcessorCtor = (processorCtor) => {
  if (!isConstructible(processorCtor)) {
    throw new TypeError("The given value for processorCtor should be a constructor.");
  }
  if (processorCtor.prototype === null || typeof processorCtor.prototype !== "object") {
    throw new TypeError("The given value for processorCtor should have a prototype.");
  }
};
var createAddAudioWorkletModule = (cacheTestResult2, createNotSupportedError2, evaluateSource, exposeCurrentFrameAndCurrentTime2, fetchSource, getNativeContext2, getOrCreateBackupOfflineAudioContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window2) => {
  let index2 = 0;
  return (context2, moduleURL, options2 = { credentials: "omit" }) => {
    const resolvedRequestsOfContext = resolvedRequests.get(context2);
    if (resolvedRequestsOfContext !== void 0 && resolvedRequestsOfContext.has(moduleURL)) {
      return Promise.resolve();
    }
    const ongoingRequestsOfContext = ongoingRequests.get(context2);
    if (ongoingRequestsOfContext !== void 0) {
      const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);
      if (promiseOfOngoingRequest !== void 0) {
        return promiseOfOngoingRequest;
      }
    }
    const nativeContext = getNativeContext2(context2);
    const promise = nativeContext.audioWorklet === void 0 ? fetchSource(moduleURL).then(([source, absoluteUrl]) => {
      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
      const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}
})})(window,'_AWGS')`;
      return evaluateSource(wrappedSource);
    }).then(() => {
      const evaluateAudioWorkletGlobalScope = window2._AWGS.pop();
      if (evaluateAudioWorkletGlobalScope === void 0) {
        throw new SyntaxError();
      }
      exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {
      }, void 0, (name2, processorCtor) => {
        if (name2.trim() === "") {
          throw createNotSupportedError2();
        }
        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
        if (nodeNameToProcessorConstructorMap !== void 0) {
          if (nodeNameToProcessorConstructorMap.has(name2)) {
            throw createNotSupportedError2();
          }
          verifyProcessorCtor(processorCtor);
          verifyParameterDescriptors(processorCtor.parameterDescriptors);
          nodeNameToProcessorConstructorMap.set(name2, processorCtor);
        } else {
          verifyProcessorCtor(processorCtor);
          verifyParameterDescriptors(processorCtor.parameterDescriptors);
          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, /* @__PURE__ */ new Map([[name2, processorCtor]]));
        }
      }, nativeContext.sampleRate, void 0, void 0));
    }) : Promise.all([
      fetchSource(moduleURL),
      Promise.resolve(cacheTestResult2(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))
    ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {
      const currentIndex = index2 + 1;
      index2 = currentIndex;
      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
      const patchedAudioWorkletProcessor = isSupportingPostMessage ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}";
      const memberDefinition = isSupportingPostMessage ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));";
      const bufferRegistration = isSupportingPostMessage ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));";
      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}
})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;
      const blob = new Blob([wrappedSource], { type: "application/javascript; charset=utf-8" });
      const url = URL.createObjectURL(blob);
      return nativeContext.audioWorklet.addModule(url, options2).then(() => {
        if (isNativeOfflineAudioContext2(nativeContext)) {
          return nativeContext;
        }
        const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext2(nativeContext);
        return backupOfflineAudioContext.audioWorklet.addModule(url, options2).then(() => backupOfflineAudioContext);
      }).then((nativeContextOrBackupOfflineAudioContext) => {
        if (nativeAudioWorkletNodeConstructor2 === null) {
          throw new SyntaxError();
        }
        try {
          new nativeAudioWorkletNodeConstructor2(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`);
        } catch {
          throw new SyntaxError();
        }
      }).finally(() => URL.revokeObjectURL(url));
    });
    if (ongoingRequestsOfContext === void 0) {
      ongoingRequests.set(context2, /* @__PURE__ */ new Map([[moduleURL, promise]]));
    } else {
      ongoingRequestsOfContext.set(moduleURL, promise);
    }
    promise.then(() => {
      const updatedResolvedRequestsOfContext = resolvedRequests.get(context2);
      if (updatedResolvedRequestsOfContext === void 0) {
        resolvedRequests.set(context2, /* @__PURE__ */ new Set([moduleURL]));
      } else {
        updatedResolvedRequestsOfContext.add(moduleURL);
      }
    }).finally(() => {
      const updatedOngoingRequestsOfContext = ongoingRequests.get(context2);
      if (updatedOngoingRequestsOfContext !== void 0) {
        updatedOngoingRequestsOfContext.delete(moduleURL);
      }
    });
    return promise;
  };
};
var getValueForKey = (map, key) => {
  const value = map.get(key);
  if (value === void 0) {
    throw new Error("A value with the given key could not be found.");
  }
  return value;
};
var pickElementFromSet = (set, predicate) => {
  const matchingElements = Array.from(set).filter(predicate);
  if (matchingElements.length > 1) {
    throw Error("More than one element was found.");
  }
  if (matchingElements.length === 0) {
    throw Error("No element was found.");
  }
  const [matchingElement] = matchingElements;
  set.delete(matchingElement);
  return matchingElement;
};
var deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input2) => {
  const passiveInputConnections = getValueForKey(passiveInputs, source);
  const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input2);
  if (passiveInputConnections.size === 0) {
    passiveInputs.delete(source);
  }
  return matchingConnection;
};
var getEventListenersOfAudioNode = (audioNode) => {
  return getValueForKey(EVENT_LISTENERS, audioNode);
};
var setInternalStateToActive = (audioNode) => {
  if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
    throw new Error("The AudioNode is already stored.");
  }
  ACTIVE_AUDIO_NODE_STORE.add(audioNode);
  getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));
};
var isAudioWorkletNode = (audioNode) => {
  return "port" in audioNode;
};
var setInternalStateToPassive = (audioNode) => {
  if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
    throw new Error("The AudioNode is not stored.");
  }
  ACTIVE_AUDIO_NODE_STORE.delete(audioNode);
  getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));
};
var setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {
  if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {
    setInternalStateToPassive(audioNode);
  }
};
var createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode2, addPassiveInputConnectionToAudioNode2, connectNativeAudioNodeToNativeAudioNode2, deleteActiveInputConnectionToAudioNode2, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getAudioNodeTailTime2, getEventListenersOfAudioNode2, getNativeAudioNode2, insertElementInSet2, isActiveAudioNode2, isPartOfACycle2, isPassiveAudioNode2) => {
  const tailTimeTimeoutIds = /* @__PURE__ */ new WeakMap();
  return (source, destination, output, input2, isOffline) => {
    const { activeInputs, passiveInputs } = getAudioNodeConnections2(destination);
    const { outputs } = getAudioNodeConnections2(source);
    const eventListeners = getEventListenersOfAudioNode2(source);
    const eventListener = (isActive) => {
      const nativeDestinationAudioNode = getNativeAudioNode2(destination);
      const nativeSourceAudioNode = getNativeAudioNode2(source);
      if (isActive) {
        const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input2);
        addActiveInputConnectionToAudioNode2(activeInputs, source, partialConnection, false);
        if (!isOffline && !isPartOfACycle2(source)) {
          connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input2);
        }
        if (isPassiveAudioNode2(destination)) {
          setInternalStateToActive(destination);
        }
      } else {
        const partialConnection = deleteActiveInputConnectionToAudioNode2(activeInputs, source, output, input2);
        addPassiveInputConnectionToAudioNode2(passiveInputs, input2, partialConnection, false);
        if (!isOffline && !isPartOfACycle2(source)) {
          disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input2);
        }
        const tailTime = getAudioNodeTailTime2(destination);
        if (tailTime === 0) {
          if (isActiveAudioNode2(destination)) {
            setInternalStateToPassiveWhenNecessary(destination, activeInputs);
          }
        } else {
          const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);
          if (tailTimeTimeoutId !== void 0) {
            clearTimeout(tailTimeTimeoutId);
          }
          tailTimeTimeoutIds.set(destination, setTimeout(() => {
            if (isActiveAudioNode2(destination)) {
              setInternalStateToPassiveWhenNecessary(destination, activeInputs);
            }
          }, tailTime * 1e3));
        }
      }
    };
    if (insertElementInSet2(outputs, [destination, output, input2], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input2, true)) {
      eventListeners.add(eventListener);
      if (isActiveAudioNode2(source)) {
        addActiveInputConnectionToAudioNode2(activeInputs, source, [output, input2, eventListener], true);
      } else {
        addPassiveInputConnectionToAudioNode2(passiveInputs, input2, [source, output, eventListener], true);
      }
      return true;
    }
    return false;
  };
};
var createAddPassiveInputConnectionToAudioNode = (insertElementInSet2) => {
  return (passiveInputs, input2, [source, output, eventListener], ignoreDuplicates) => {
    const passiveInputConnections = passiveInputs.get(source);
    if (passiveInputConnections === void 0) {
      passiveInputs.set(source, /* @__PURE__ */ new Set([[output, input2, eventListener]]));
    } else {
      insertElementInSet2(passiveInputConnections, [output, input2, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input2, ignoreDuplicates);
    }
  };
};
var createAddSilentConnection = (createNativeGainNode2) => {
  return (nativeContext, nativeAudioScheduledSourceNode) => {
    const nativeGainNode = createNativeGainNode2(nativeContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: 0
    });
    nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);
    const disconnect2 = () => {
      nativeAudioScheduledSourceNode.removeEventListener("ended", disconnect2);
      nativeAudioScheduledSourceNode.disconnect(nativeGainNode);
      nativeGainNode.disconnect();
    };
    nativeAudioScheduledSourceNode.addEventListener("ended", disconnect2);
  };
};
var createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
  return (nativeContext, audioWorkletNode) => {
    getUnrenderedAudioWorkletNodes2(nativeContext).add(audioWorkletNode);
  };
};
var DEFAULT_OPTIONS$j = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  fftSize: 2048,
  maxDecibels: -30,
  minDecibels: -100,
  smoothingTimeConstant: 0.8
};
var createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer2, createIndexSizeError2, createNativeAnalyserNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class AnalyserNode extends audionNodeConstructor {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$j, ...options2 };
      const nativeAnalyserNode = createNativeAnalyserNode2(nativeContext, mergedOptions);
      const analyserNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createAnalyserNodeRenderer2() : null;
      super(context2, false, nativeAnalyserNode, analyserNodeRenderer);
      this._nativeAnalyserNode = nativeAnalyserNode;
    }
    get fftSize() {
      return this._nativeAnalyserNode.fftSize;
    }
    set fftSize(value) {
      this._nativeAnalyserNode.fftSize = value;
    }
    get frequencyBinCount() {
      return this._nativeAnalyserNode.frequencyBinCount;
    }
    get maxDecibels() {
      return this._nativeAnalyserNode.maxDecibels;
    }
    set maxDecibels(value) {
      const maxDecibels = this._nativeAnalyserNode.maxDecibels;
      this._nativeAnalyserNode.maxDecibels = value;
      if (!(value > this._nativeAnalyserNode.minDecibels)) {
        this._nativeAnalyserNode.maxDecibels = maxDecibels;
        throw createIndexSizeError2();
      }
    }
    get minDecibels() {
      return this._nativeAnalyserNode.minDecibels;
    }
    set minDecibels(value) {
      const minDecibels = this._nativeAnalyserNode.minDecibels;
      this._nativeAnalyserNode.minDecibels = value;
      if (!(this._nativeAnalyserNode.maxDecibels > value)) {
        this._nativeAnalyserNode.minDecibels = minDecibels;
        throw createIndexSizeError2();
      }
    }
    get smoothingTimeConstant() {
      return this._nativeAnalyserNode.smoothingTimeConstant;
    }
    set smoothingTimeConstant(value) {
      this._nativeAnalyserNode.smoothingTimeConstant = value;
    }
    getByteFrequencyData(array) {
      this._nativeAnalyserNode.getByteFrequencyData(array);
    }
    getByteTimeDomainData(array) {
      this._nativeAnalyserNode.getByteTimeDomainData(array);
    }
    getFloatFrequencyData(array) {
      this._nativeAnalyserNode.getFloatFrequencyData(array);
    }
    getFloatTimeDomainData(array) {
      this._nativeAnalyserNode.getFloatTimeDomainData(array);
    }
  };
};
var isOwnedByContext = (nativeAudioNode, nativeContext) => {
  return nativeAudioNode.context === nativeContext;
};
var createAnalyserNodeRendererFactory = (createNativeAnalyserNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeAnalyserNodes = /* @__PURE__ */ new WeakMap();
    const createAnalyserNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAnalyserNode = getNativeAudioNode2(proxy);
      const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);
      if (!nativeAnalyserNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeAnalyserNode.channelCount,
          channelCountMode: nativeAnalyserNode.channelCountMode,
          channelInterpretation: nativeAnalyserNode.channelInterpretation,
          fftSize: nativeAnalyserNode.fftSize,
          maxDecibels: nativeAnalyserNode.maxDecibels,
          minDecibels: nativeAnalyserNode.minDecibels,
          smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant
        };
        nativeAnalyserNode = createNativeAnalyserNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAnalyserNode);
      return nativeAnalyserNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAnalyserNode !== void 0) {
          return Promise.resolve(renderedNativeAnalyserNode);
        }
        return createAnalyserNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {
  try {
    nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);
  } catch {
    return false;
  }
  return true;
};
var createIndexSizeError = () => new DOMException("", "IndexSizeError");
var wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {
  audioBuffer.getChannelData = ((getChannelData) => {
    return (channel) => {
      try {
        return getChannelData.call(audioBuffer, channel);
      } catch (err) {
        if (err.code === 12) {
          throw createIndexSizeError();
        }
        throw err;
      }
    };
  })(audioBuffer.getChannelData);
};
var DEFAULT_OPTIONS$i = {
  numberOfChannels: 1
};
var createAudioBufferConstructor = (audioBufferStore2, cacheTestResult2, createNotSupportedError2, nativeAudioBufferConstructor2, nativeOfflineAudioContextConstructor2, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
  let nativeOfflineAudioContext = null;
  return class AudioBuffer {
    constructor(options2) {
      if (nativeOfflineAudioContextConstructor2 === null) {
        throw new Error("Missing the native OfflineAudioContext constructor.");
      }
      const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS$i, ...options2 };
      if (nativeOfflineAudioContext === null) {
        nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
      }
      const audioBuffer = nativeAudioBufferConstructor2 !== null && cacheTestResult2(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor2({ length, numberOfChannels, sampleRate }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);
      if (audioBuffer.numberOfChannels === 0) {
        throw createNotSupportedError2();
      }
      if (typeof audioBuffer.copyFromChannel !== "function") {
        wrapAudioBufferCopyChannelMethods2(audioBuffer);
        wrapAudioBufferGetChannelDataMethod(audioBuffer);
      } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {
        wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
      }
      audioBufferStore2.add(audioBuffer);
      return audioBuffer;
    }
    static [Symbol.hasInstance](instance) {
      return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore2.has(instance);
    }
  };
};
var MOST_NEGATIVE_SINGLE_FLOAT = -34028234663852886e22;
var MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;
var isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);
var DEFAULT_OPTIONS$h = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  loop: false,
  loopEnd: 0,
  loopStart: 0,
  playbackRate: 1
};
var createAudioBufferSourceNodeConstructor = (audioNodeConstructor2, createAudioBufferSourceNodeRenderer2, createAudioParam2, createInvalidStateError2, createNativeAudioBufferSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
  return class AudioBufferSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$h, ...options2 };
      const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer2() : null;
      super(context2, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);
      this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;
      this._isBufferNullified = false;
      this._isBufferSet = mergedOptions.buffer !== null;
      this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;
      this._onended = null;
      this._playbackRate = createAudioParam2(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
    }
    get buffer() {
      if (this._isBufferNullified) {
        return null;
      }
      return this._nativeAudioBufferSourceNode.buffer;
    }
    set buffer(value) {
      this._nativeAudioBufferSourceNode.buffer = value;
      if (value !== null) {
        if (this._isBufferSet) {
          throw createInvalidStateError2();
        }
        this._isBufferSet = true;
      }
    }
    get loop() {
      return this._nativeAudioBufferSourceNode.loop;
    }
    set loop(value) {
      this._nativeAudioBufferSourceNode.loop = value;
    }
    get loopEnd() {
      return this._nativeAudioBufferSourceNode.loopEnd;
    }
    set loopEnd(value) {
      this._nativeAudioBufferSourceNode.loopEnd = value;
    }
    get loopStart() {
      return this._nativeAudioBufferSourceNode.loopStart;
    }
    set loopStart(value) {
      this._nativeAudioBufferSourceNode.loopStart = value;
    }
    get onended() {
      return this._onended;
    }
    set onended(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeAudioBufferSourceNode.onended = wrappedListener;
      const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;
      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
    }
    get playbackRate() {
      return this._playbackRate;
    }
    start(when = 0, offset = 0, duration2) {
      this._nativeAudioBufferSourceNode.start(when, offset, duration2);
      if (this._audioBufferSourceNodeRenderer !== null) {
        this._audioBufferSourceNodeRenderer.start = duration2 === void 0 ? [when, offset] : [when, offset, duration2];
      }
      if (this.context.state !== "closed") {
        setInternalStateToActive(this);
        const resetInternalStateToPassive = () => {
          this._nativeAudioBufferSourceNode.removeEventListener("ended", resetInternalStateToPassive);
          if (isActiveAudioNode(this)) {
            setInternalStateToPassive(this);
          }
        };
        this._nativeAudioBufferSourceNode.addEventListener("ended", resetInternalStateToPassive);
      }
    }
    stop(when = 0) {
      this._nativeAudioBufferSourceNode.stop(when);
      if (this._audioBufferSourceNodeRenderer !== null) {
        this._audioBufferSourceNodeRenderer.stop = when;
      }
    }
  };
};
var createAudioBufferSourceNodeRendererFactory = (connectAudioParam2, createNativeAudioBufferSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeAudioBufferSourceNodes = /* @__PURE__ */ new WeakMap();
    let start22 = null;
    let stop = null;
    const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioBufferSourceNode = getNativeAudioNode2(proxy);
      const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);
      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
        const options2 = {
          buffer: nativeAudioBufferSourceNode.buffer,
          channelCount: nativeAudioBufferSourceNode.channelCount,
          channelCountMode: nativeAudioBufferSourceNode.channelCountMode,
          channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,
          loop: nativeAudioBufferSourceNode.loop,
          loopEnd: nativeAudioBufferSourceNode.loopEnd,
          loopStart: nativeAudioBufferSourceNode.loopStart,
          playbackRate: nativeAudioBufferSourceNode.playbackRate.value
        };
        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, options2);
        if (start22 !== null) {
          nativeAudioBufferSourceNode.start(...start22);
        }
        if (stop !== null) {
          nativeAudioBufferSourceNode.stop(stop);
        }
      }
      renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);
      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);
      return nativeAudioBufferSourceNode;
    };
    return {
      set start(value) {
        start22 = value;
      },
      set stop(value) {
        stop = value;
      },
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioBufferSourceNode !== void 0) {
          return Promise.resolve(renderedNativeAudioBufferSourceNode);
        }
        return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var isAudioBufferSourceNode = (audioNode) => {
  return "playbackRate" in audioNode;
};
var isBiquadFilterNode = (audioNode) => {
  return "frequency" in audioNode && "gain" in audioNode;
};
var isConstantSourceNode = (audioNode) => {
  return "offset" in audioNode;
};
var isGainNode = (audioNode) => {
  return !("frequency" in audioNode) && "gain" in audioNode;
};
var isOscillatorNode = (audioNode) => {
  return "detune" in audioNode && "frequency" in audioNode;
};
var isStereoPannerNode = (audioNode) => {
  return "pan" in audioNode;
};
var getAudioNodeConnections = (audioNode) => {
  return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);
};
var getAudioParamConnections = (audioParam) => {
  return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);
};
var deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {
  const { activeInputs } = getAudioNodeConnections(audioNode);
  activeInputs.forEach((connections) => connections.forEach(([source]) => {
    if (!trace.includes(audioNode)) {
      deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);
    }
  }));
  const audioParams = isAudioBufferSourceNode(audioNode) ? [
    audioNode.playbackRate
  ] : isAudioWorkletNode(audioNode) ? Array.from(audioNode.parameters.values()) : isBiquadFilterNode(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : isConstantSourceNode(audioNode) ? [audioNode.offset] : isGainNode(audioNode) ? [audioNode.gain] : isOscillatorNode(audioNode) ? [audioNode.detune, audioNode.frequency] : isStereoPannerNode(audioNode) ? [audioNode.pan] : [];
  for (const audioParam of audioParams) {
    const audioParamConnections = getAudioParamConnections(audioParam);
    if (audioParamConnections !== void 0) {
      audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));
    }
  }
  if (isActiveAudioNode(audioNode)) {
    setInternalStateToPassive(audioNode);
  }
};
var deactivateAudioGraph = (context2) => {
  deactivateActiveAudioNodeInputConnections(context2.destination, []);
};
var isValidLatencyHint = (latencyHint) => {
  return latencyHint === void 0 || typeof latencyHint === "number" || typeof latencyHint === "string" && (latencyHint === "balanced" || latencyHint === "interactive" || latencyHint === "playback");
};
var createAudioContextConstructor = (baseAudioContextConstructor2, createInvalidStateError2, createNotSupportedError2, createUnknownError2, mediaElementAudioSourceNodeConstructor2, mediaStreamAudioDestinationNodeConstructor2, mediaStreamAudioSourceNodeConstructor2, mediaStreamTrackAudioSourceNodeConstructor2, nativeAudioContextConstructor2) => {
  return class AudioContext extends baseAudioContextConstructor2 {
    constructor(options2 = {}) {
      if (nativeAudioContextConstructor2 === null) {
        throw new Error("Missing the native AudioContext constructor.");
      }
      let nativeAudioContext;
      try {
        nativeAudioContext = new nativeAudioContextConstructor2(options2);
      } catch (err) {
        if (err.code === 12 && err.message === "sampleRate is not in range") {
          throw createNotSupportedError2();
        }
        throw err;
      }
      if (nativeAudioContext === null) {
        throw createUnknownError2();
      }
      if (!isValidLatencyHint(options2.latencyHint)) {
        throw new TypeError(`The provided value '${options2.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
      }
      if (options2.sampleRate !== void 0 && nativeAudioContext.sampleRate !== options2.sampleRate) {
        throw createNotSupportedError2();
      }
      super(nativeAudioContext, 2);
      const { latencyHint } = options2;
      const { sampleRate } = nativeAudioContext;
      this._baseLatency = typeof nativeAudioContext.baseLatency === "number" ? nativeAudioContext.baseLatency : latencyHint === "balanced" ? 512 / sampleRate : latencyHint === "interactive" || latencyHint === void 0 ? 256 / sampleRate : latencyHint === "playback" ? 1024 / sampleRate : Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;
      this._nativeAudioContext = nativeAudioContext;
      if (nativeAudioContextConstructor2.name === "webkitAudioContext") {
        this._nativeGainNode = nativeAudioContext.createGain();
        this._nativeOscillatorNode = nativeAudioContext.createOscillator();
        this._nativeGainNode.gain.value = 1e-37;
        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);
        this._nativeOscillatorNode.start();
      } else {
        this._nativeGainNode = null;
        this._nativeOscillatorNode = null;
      }
      this._state = null;
      if (nativeAudioContext.state === "running") {
        this._state = "suspended";
        const revokeState = () => {
          if (this._state === "suspended") {
            this._state = null;
          }
          nativeAudioContext.removeEventListener("statechange", revokeState);
        };
        nativeAudioContext.addEventListener("statechange", revokeState);
      }
    }
    get baseLatency() {
      return this._baseLatency;
    }
    get state() {
      return this._state !== null ? this._state : this._nativeAudioContext.state;
    }
    close() {
      if (this.state === "closed") {
        return this._nativeAudioContext.close().then(() => {
          throw createInvalidStateError2();
        });
      }
      if (this._state === "suspended") {
        this._state = null;
      }
      return this._nativeAudioContext.close().then(() => {
        if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
          this._nativeOscillatorNode.stop();
          this._nativeGainNode.disconnect();
          this._nativeOscillatorNode.disconnect();
        }
        deactivateAudioGraph(this);
      });
    }
    createMediaElementSource(mediaElement) {
      return new mediaElementAudioSourceNodeConstructor2(this, { mediaElement });
    }
    createMediaStreamDestination() {
      return new mediaStreamAudioDestinationNodeConstructor2(this);
    }
    createMediaStreamSource(mediaStream) {
      return new mediaStreamAudioSourceNodeConstructor2(this, { mediaStream });
    }
    createMediaStreamTrackSource(mediaStreamTrack) {
      return new mediaStreamTrackAudioSourceNodeConstructor2(this, { mediaStreamTrack });
    }
    resume() {
      if (this._state === "suspended") {
        return new Promise((resolve, reject) => {
          const resolvePromise = () => {
            this._nativeAudioContext.removeEventListener("statechange", resolvePromise);
            if (this._nativeAudioContext.state === "running") {
              resolve();
            } else {
              this.resume().then(resolve, reject);
            }
          };
          this._nativeAudioContext.addEventListener("statechange", resolvePromise);
        });
      }
      return this._nativeAudioContext.resume().catch((err) => {
        if (err === void 0 || err.code === 15) {
          throw createInvalidStateError2();
        }
        throw err;
      });
    }
    suspend() {
      return this._nativeAudioContext.suspend().catch((err) => {
        if (err === void 0) {
          throw createInvalidStateError2();
        }
        throw err;
      });
    }
  };
};
var createAudioDestinationNodeConstructor = (audioNodeConstructor2, createAudioDestinationNodeRenderer2, createIndexSizeError2, createInvalidStateError2, createNativeAudioDestinationNode, getNativeContext2, isNativeOfflineAudioContext2, renderInputsOfAudioNode2) => {
  return class AudioDestinationNode extends audioNodeConstructor2 {
    constructor(context2, channelCount) {
      const nativeContext = getNativeContext2(context2);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);
      const audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer2(renderInputsOfAudioNode2) : null;
      super(context2, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);
      this._isNodeOfNativeOfflineAudioContext = isOffline;
      this._nativeAudioDestinationNode = nativeAudioDestinationNode;
    }
    get channelCount() {
      return this._nativeAudioDestinationNode.channelCount;
    }
    set channelCount(value) {
      if (this._isNodeOfNativeOfflineAudioContext) {
        throw createInvalidStateError2();
      }
      if (value > this._nativeAudioDestinationNode.maxChannelCount) {
        throw createIndexSizeError2();
      }
      this._nativeAudioDestinationNode.channelCount = value;
    }
    get channelCountMode() {
      return this._nativeAudioDestinationNode.channelCountMode;
    }
    set channelCountMode(value) {
      if (this._isNodeOfNativeOfflineAudioContext) {
        throw createInvalidStateError2();
      }
      this._nativeAudioDestinationNode.channelCountMode = value;
    }
    get maxChannelCount() {
      return this._nativeAudioDestinationNode.maxChannelCount;
    }
  };
};
var createAudioDestinationNodeRenderer = (renderInputsOfAudioNode2) => {
  const renderedNativeAudioDestinationNodes = /* @__PURE__ */ new WeakMap();
  const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {
    const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;
    renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);
    await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);
    return nativeAudioDestinationNode;
  };
  return {
    render(proxy, nativeOfflineAudioContext) {
      const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);
      if (renderedNativeAudioDestinationNode !== void 0) {
        return Promise.resolve(renderedNativeAudioDestinationNode);
      }
      return createAudioDestinationNode(proxy, nativeOfflineAudioContext);
    }
  };
};
var createAudioListenerFactory = (createAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeScriptProcessorNode2, createNotSupportedError2, getFirstSample2, isNativeOfflineAudioContext2, overwriteAccessors2) => {
  return (context2, nativeContext) => {
    const nativeListener = nativeContext.listener;
    const createFakeAudioParams = () => {
      const buffer = new Float32Array(1);
      const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "speakers",
        numberOfInputs: 9
      });
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      let isScriptProcessorNodeCreated = false;
      let lastOrientation = [0, 0, -1, 0, 1, 0];
      let lastPosition = [0, 0, 0];
      const createScriptProcessorNode = () => {
        if (isScriptProcessorNodeCreated) {
          return;
        }
        isScriptProcessorNodeCreated = true;
        const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 9, 0);
        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
          const orientation = [
            getFirstSample2(inputBuffer, buffer, 0),
            getFirstSample2(inputBuffer, buffer, 1),
            getFirstSample2(inputBuffer, buffer, 2),
            getFirstSample2(inputBuffer, buffer, 3),
            getFirstSample2(inputBuffer, buffer, 4),
            getFirstSample2(inputBuffer, buffer, 5)
          ];
          if (orientation.some((value, index2) => value !== lastOrientation[index2])) {
            nativeListener.setOrientation(...orientation);
            lastOrientation = orientation;
          }
          const positon = [
            getFirstSample2(inputBuffer, buffer, 6),
            getFirstSample2(inputBuffer, buffer, 7),
            getFirstSample2(inputBuffer, buffer, 8)
          ];
          if (positon.some((value, index2) => value !== lastPosition[index2])) {
            nativeListener.setPosition(...positon);
            lastPosition = positon;
          }
        };
        channelMergerNode.connect(scriptProcessorNode);
      };
      const createSetOrientation = (index2) => (value) => {
        if (value !== lastOrientation[index2]) {
          lastOrientation[index2] = value;
          nativeListener.setOrientation(...lastOrientation);
        }
      };
      const createSetPosition = (index2) => (value) => {
        if (value !== lastPosition[index2]) {
          lastPosition[index2] = value;
          nativeListener.setPosition(...lastPosition);
        }
      };
      const createFakeAudioParam = (input2, initialValue, setValue) => {
        const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          offset: initialValue
        });
        constantSourceNode.connect(channelMergerNode, 0, input2);
        constantSourceNode.start();
        Object.defineProperty(constantSourceNode.offset, "defaultValue", {
          get() {
            return initialValue;
          }
        });
        const audioParam = createAudioParam2({ context: context2 }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        overwriteAccessors2(audioParam, "value", (get2) => () => get2.call(audioParam), (set) => (value) => {
          try {
            set.call(audioParam, value);
          } catch (err) {
            if (err.code !== 9) {
              throw err;
            }
          }
          createScriptProcessorNode();
          if (isOffline) {
            setValue(value);
          }
        });
        audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = cancelAndHoldAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.cancelAndHoldAtTime);
        audioParam.cancelScheduledValues = ((cancelScheduledValues) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = cancelScheduledValues.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.cancelScheduledValues);
        audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = exponentialRampToValueAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.exponentialRampToValueAtTime);
        audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = linearRampToValueAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.linearRampToValueAtTime);
        audioParam.setTargetAtTime = ((setTargetAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = setTargetAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.setTargetAtTime);
        audioParam.setValueAtTime = ((setValueAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = setValueAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.setValueAtTime);
        audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = setValueCurveAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.setValueCurveAtTime);
        return audioParam;
      };
      return {
        forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),
        forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),
        forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),
        positionX: createFakeAudioParam(6, 0, createSetPosition(0)),
        positionY: createFakeAudioParam(7, 0, createSetPosition(1)),
        positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),
        upX: createFakeAudioParam(3, 0, createSetOrientation(3)),
        upY: createFakeAudioParam(4, 1, createSetOrientation(4)),
        upZ: createFakeAudioParam(5, 0, createSetOrientation(5))
      };
    };
    const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === void 0 ? createFakeAudioParams() : nativeListener;
    return {
      get forwardX() {
        return forwardX;
      },
      get forwardY() {
        return forwardY;
      },
      get forwardZ() {
        return forwardZ;
      },
      get positionX() {
        return positionX;
      },
      get positionY() {
        return positionY;
      },
      get positionZ() {
        return positionZ;
      },
      get upX() {
        return upX;
      },
      get upY() {
        return upY;
      },
      get upZ() {
        return upZ;
      }
    };
  };
};
var isAudioNode$1 = (audioNodeOrAudioParam) => {
  return "context" in audioNodeOrAudioParam;
};
var isAudioNodeOutputConnection = (outputConnection) => {
  return isAudioNode$1(outputConnection[0]);
};
var insertElementInSet = (set, element, predicate, ignoreDuplicates) => {
  for (const lmnt of set) {
    if (predicate(lmnt)) {
      if (ignoreDuplicates) {
        return false;
      }
      throw Error("The set contains at least one similar element.");
    }
  }
  set.add(element);
  return true;
};
var addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {
  insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
};
var addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {
  const passiveInputConnections = passiveInputs.get(source);
  if (passiveInputConnections === void 0) {
    passiveInputs.set(source, /* @__PURE__ */ new Set([[output, eventListener]]));
  } else {
    insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output, ignoreDuplicates);
  }
};
var isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {
  return "inputs" in nativeAudioNodeOrNativeAudioNodeFaker;
};
var connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input2) => {
  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
    const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input2];
    nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);
    return [fakeNativeDestinationAudioNode, output, 0];
  }
  nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input2);
  return [nativeDestinationAudioNode, output, input2];
};
var deleteActiveInputConnection = (activeInputConnections, source, output) => {
  for (const activeInputConnection of activeInputConnections) {
    if (activeInputConnection[0] === source && activeInputConnection[1] === output) {
      activeInputConnections.delete(activeInputConnection);
      return activeInputConnection;
    }
  }
  return null;
};
var deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {
  return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);
};
var deleteEventListenerOfAudioNode = (audioNode, eventListener) => {
  const eventListeners = getEventListenersOfAudioNode(audioNode);
  if (!eventListeners.delete(eventListener)) {
    throw new Error("Missing the expected event listener.");
  }
};
var deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {
  const passiveInputConnections = getValueForKey(passiveInputs, source);
  const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output);
  if (passiveInputConnections.size === 0) {
    passiveInputs.delete(source);
  }
  return matchingConnection;
};
var disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input2) => {
  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input2], output, 0);
  } else {
    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input2);
  }
};
var getNativeAudioNode = (audioNode) => {
  return getValueForKey(AUDIO_NODE_STORE, audioNode);
};
var getNativeAudioParam = (audioParam) => {
  return getValueForKey(AUDIO_PARAM_STORE, audioParam);
};
var isPartOfACycle = (audioNode) => {
  return CYCLE_COUNTERS.has(audioNode);
};
var isPassiveAudioNode = (audioNode) => {
  return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);
};
var testAudioNodeDisconnectMethodSupport = (nativeAudioContext, nativeAudioWorkletNodeConstructor2) => {
  return new Promise((resolve) => {
    if (nativeAudioWorkletNodeConstructor2 !== null) {
      resolve(true);
    } else {
      const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);
      const dummy = nativeAudioContext.createGain();
      const ones = nativeAudioContext.createBuffer(1, 2, 44100);
      const channelData = ones.getChannelData(0);
      channelData[0] = 1;
      channelData[1] = 1;
      const source = nativeAudioContext.createBufferSource();
      source.buffer = ones;
      source.loop = true;
      source.connect(analyzer).connect(nativeAudioContext.destination);
      source.connect(dummy);
      source.disconnect(dummy);
      analyzer.onaudioprocess = (event) => {
        const chnnlDt = event.inputBuffer.getChannelData(0);
        if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {
          resolve(true);
        } else {
          resolve(false);
        }
        source.stop();
        analyzer.onaudioprocess = null;
        source.disconnect(analyzer);
        analyzer.disconnect(nativeAudioContext.destination);
      };
      source.start();
    }
  });
};
var visitEachAudioNodeOnce = (cycles, visitor) => {
  const counts = /* @__PURE__ */ new Map();
  for (const cycle of cycles) {
    for (const audioNode of cycle) {
      const count = counts.get(audioNode);
      counts.set(audioNode, count === void 0 ? 1 : count + 1);
    }
  }
  counts.forEach((count, audioNode) => visitor(audioNode, count));
};
var isNativeAudioNode$1 = (nativeAudioNodeOrAudioParam) => {
  return "context" in nativeAudioNodeOrAudioParam;
};
var wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {
  const connections = /* @__PURE__ */ new Map();
  nativeAudioNode.connect = ((connect2) => {
    return (destination, output = 0, input2 = 0) => {
      const returnValue = isNativeAudioNode$1(destination) ? connect2(destination, output, input2) : connect2(destination, output);
      const connectionsToDestination = connections.get(destination);
      if (connectionsToDestination === void 0) {
        connections.set(destination, [{ input: input2, output }]);
      } else {
        if (connectionsToDestination.every((connection) => connection.input !== input2 || connection.output !== output)) {
          connectionsToDestination.push({ input: input2, output });
        }
      }
      return returnValue;
    };
  })(nativeAudioNode.connect.bind(nativeAudioNode));
  nativeAudioNode.disconnect = ((disconnect2) => {
    return (destinationOrOutput, output, input2) => {
      disconnect2.apply(nativeAudioNode);
      if (destinationOrOutput === void 0) {
        connections.clear();
      } else if (typeof destinationOrOutput === "number") {
        for (const [destination, connectionsToDestination] of connections) {
          const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);
          if (filteredConnections.length === 0) {
            connections.delete(destination);
          } else {
            connections.set(destination, filteredConnections);
          }
        }
      } else if (connections.has(destinationOrOutput)) {
        if (output === void 0) {
          connections.delete(destinationOrOutput);
        } else {
          const connectionsToDestination = connections.get(destinationOrOutput);
          if (connectionsToDestination !== void 0) {
            const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input2 || input2 === void 0));
            if (filteredConnections.length === 0) {
              connections.delete(destinationOrOutput);
            } else {
              connections.set(destinationOrOutput, filteredConnections);
            }
          }
        }
      }
      for (const [destination, connectionsToDestination] of connections) {
        connectionsToDestination.forEach((connection) => {
          if (isNativeAudioNode$1(destination)) {
            nativeAudioNode.connect(destination, connection.output, connection.input);
          } else {
            nativeAudioNode.connect(destination, connection.output);
          }
        });
      }
    };
  })(nativeAudioNode.disconnect);
};
var addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {
  const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
  const { outputs } = getAudioNodeConnections(source);
  const eventListeners = getEventListenersOfAudioNode(source);
  const eventListener = (isActive) => {
    const nativeAudioNode = getNativeAudioNode(source);
    const nativeAudioParam = getNativeAudioParam(destination);
    if (isActive) {
      const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);
      if (!isOffline && !isPartOfACycle(source)) {
        nativeAudioNode.connect(nativeAudioParam, output);
      }
    } else {
      const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);
      addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);
      if (!isOffline && !isPartOfACycle(source)) {
        nativeAudioNode.disconnect(nativeAudioParam, output);
      }
    }
  };
  if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {
    eventListeners.add(eventListener);
    if (isActiveAudioNode(source)) {
      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);
    } else {
      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);
    }
    return true;
  }
  return false;
};
var deleteInputConnectionOfAudioNode = (source, destination, output, input2) => {
  const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);
  const activeInputConnection = deleteActiveInputConnection(activeInputs[input2], source, output);
  if (activeInputConnection === null) {
    const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input2);
    return [passiveInputConnection[2], false];
  }
  return [activeInputConnection[2], true];
};
var deleteInputConnectionOfAudioParam = (source, destination, output) => {
  const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
  const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);
  if (activeInputConnection === null) {
    const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
    return [passiveInputConnection[1], false];
  }
  return [activeInputConnection[2], true];
};
var deleteInputsOfAudioNode = (source, isOffline, destination, output, input2) => {
  const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input2);
  if (listener !== null) {
    deleteEventListenerOfAudioNode(source, listener);
    if (isActive && !isOffline && !isPartOfACycle(source)) {
      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input2);
    }
  }
  if (isActiveAudioNode(destination)) {
    const { activeInputs } = getAudioNodeConnections(destination);
    setInternalStateToPassiveWhenNecessary(destination, activeInputs);
  }
};
var deleteInputsOfAudioParam = (source, isOffline, destination, output) => {
  const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);
  if (listener !== null) {
    deleteEventListenerOfAudioNode(source, listener);
    if (isActive && !isOffline && !isPartOfACycle(source)) {
      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);
    }
  }
};
var deleteAnyConnection = (source, isOffline) => {
  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
  const destinations = [];
  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
    if (isAudioNodeOutputConnection(outputConnection)) {
      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
    } else {
      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
    }
    destinations.push(outputConnection[0]);
  }
  audioNodeConnectionsOfSource.outputs.clear();
  return destinations;
};
var deleteConnectionAtOutput = (source, isOffline, output) => {
  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
  const destinations = [];
  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
    if (outputConnection[1] === output) {
      if (isAudioNodeOutputConnection(outputConnection)) {
        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
      } else {
        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
      }
      destinations.push(outputConnection[0]);
      audioNodeConnectionsOfSource.outputs.delete(outputConnection);
    }
  }
  return destinations;
};
var deleteConnectionToDestination = (source, isOffline, destination, output, input2) => {
  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
  return Array.from(audioNodeConnectionsOfSource.outputs).filter((outputConnection) => outputConnection[0] === destination && (output === void 0 || outputConnection[1] === output) && (input2 === void 0 || outputConnection[2] === input2)).map((outputConnection) => {
    if (isAudioNodeOutputConnection(outputConnection)) {
      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
    } else {
      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
    }
    audioNodeConnectionsOfSource.outputs.delete(outputConnection);
    return outputConnection[0];
  });
};
var createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult2, createIncrementCycleCounter, createIndexSizeError2, createInvalidAccessError2, createNotSupportedError2, decrementCycleCounter, detectCycles, eventTargetConstructor2, getNativeContext2, isNativeAudioContext2, isNativeAudioNode2, isNativeAudioParam2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2) => {
  return class AudioNode extends eventTargetConstructor2 {
    constructor(context2, isActive, nativeAudioNode, audioNodeRenderer) {
      super(nativeAudioNode);
      this._context = context2;
      this._nativeAudioNode = nativeAudioNode;
      const nativeContext = getNativeContext2(context2);
      if (isNativeAudioContext2(nativeContext) && cacheTestResult2(testAudioNodeDisconnectMethodSupport, () => {
        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor2);
      }) !== true) {
        wrapAudioNodeDisconnectMethod(nativeAudioNode);
      }
      AUDIO_NODE_STORE.set(this, nativeAudioNode);
      EVENT_LISTENERS.set(this, /* @__PURE__ */ new Set());
      if (context2.state !== "closed" && isActive) {
        setInternalStateToActive(this);
      }
      addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);
    }
    get channelCount() {
      return this._nativeAudioNode.channelCount;
    }
    set channelCount(value) {
      this._nativeAudioNode.channelCount = value;
    }
    get channelCountMode() {
      return this._nativeAudioNode.channelCountMode;
    }
    set channelCountMode(value) {
      this._nativeAudioNode.channelCountMode = value;
    }
    get channelInterpretation() {
      return this._nativeAudioNode.channelInterpretation;
    }
    set channelInterpretation(value) {
      this._nativeAudioNode.channelInterpretation = value;
    }
    get context() {
      return this._context;
    }
    get numberOfInputs() {
      return this._nativeAudioNode.numberOfInputs;
    }
    get numberOfOutputs() {
      return this._nativeAudioNode.numberOfOutputs;
    }
    connect(destination, output = 0, input2 = 0) {
      if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {
        throw createIndexSizeError2();
      }
      const nativeContext = getNativeContext2(this._context);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      if (isNativeAudioNode2(destination) || isNativeAudioParam2(destination)) {
        throw createInvalidAccessError2();
      }
      if (isAudioNode$1(destination)) {
        const nativeDestinationAudioNode = getNativeAudioNode(destination);
        try {
          const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input2);
          const isPassive = isPassiveAudioNode(this);
          if (isOffline || isPassive) {
            this._nativeAudioNode.disconnect(...connection);
          }
          if (this.context.state !== "closed" && !isPassive && isPassiveAudioNode(destination)) {
            setInternalStateToActive(destination);
          }
        } catch (err) {
          if (err.code === 12) {
            throw createInvalidAccessError2();
          }
          throw err;
        }
        const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input2, isOffline);
        if (isNewConnectionToAudioNode) {
          const cycles = detectCycles([this], destination);
          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
        }
        return destination;
      }
      const nativeAudioParam = getNativeAudioParam(destination);
      if (nativeAudioParam.name === "playbackRate" && nativeAudioParam.maxValue === 1024) {
        throw createNotSupportedError2();
      }
      try {
        this._nativeAudioNode.connect(nativeAudioParam, output);
        if (isOffline || isPassiveAudioNode(this)) {
          this._nativeAudioNode.disconnect(nativeAudioParam, output);
        }
      } catch (err) {
        if (err.code === 12) {
          throw createInvalidAccessError2();
        }
        throw err;
      }
      const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);
      if (isNewConnectionToAudioParam) {
        const cycles = detectCycles([this], destination);
        visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
      }
    }
    disconnect(destinationOrOutput, output, input2) {
      let destinations;
      const nativeContext = getNativeContext2(this._context);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      if (destinationOrOutput === void 0) {
        destinations = deleteAnyConnection(this, isOffline);
      } else if (typeof destinationOrOutput === "number") {
        if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {
          throw createIndexSizeError2();
        }
        destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);
      } else {
        if (output !== void 0 && (output < 0 || output >= this.numberOfOutputs)) {
          throw createIndexSizeError2();
        }
        if (isAudioNode$1(destinationOrOutput) && input2 !== void 0 && (input2 < 0 || input2 >= destinationOrOutput.numberOfInputs)) {
          throw createIndexSizeError2();
        }
        destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input2);
        if (destinations.length === 0) {
          throw createInvalidAccessError2();
        }
      }
      for (const destination of destinations) {
        const cycles = detectCycles([this], destination);
        visitEachAudioNodeOnce(cycles, decrementCycleCounter);
      }
    }
  };
};
var createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore2, audioParamStore, createAudioParamRenderer2, createCancelAndHoldAutomationEvent2, createCancelScheduledValuesAutomationEvent2, createExponentialRampToValueAutomationEvent2, createLinearRampToValueAutomationEvent2, createSetTargetAutomationEvent2, createSetValueAutomationEvent2, createSetValueCurveAutomationEvent2, nativeAudioContextConstructor2, setValueAtTimeUntilPossible2) => {
  return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {
    const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);
    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer2(automationEventList) : null;
    const audioParam = {
      get defaultValue() {
        return nativeAudioParam.defaultValue;
      },
      get maxValue() {
        return maxValue === null ? nativeAudioParam.maxValue : maxValue;
      },
      get minValue() {
        return minValue === null ? nativeAudioParam.minValue : minValue;
      },
      get value() {
        return nativeAudioParam.value;
      },
      set value(value) {
        nativeAudioParam.value = value;
        audioParam.setValueAtTime(value, audioNode.context.currentTime);
      },
      cancelAndHoldAtTime(cancelTime) {
        if (typeof nativeAudioParam.cancelAndHoldAtTime === "function") {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
          nativeAudioParam.cancelAndHoldAtTime(cancelTime);
        } else {
          const previousLastEvent = Array.from(automationEventList).pop();
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
          const currentLastEvent = Array.from(automationEventList).pop();
          nativeAudioParam.cancelScheduledValues(cancelTime);
          if (previousLastEvent !== currentLastEvent && currentLastEvent !== void 0) {
            if (currentLastEvent.type === "exponentialRampToValue") {
              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
            } else if (currentLastEvent.type === "linearRampToValue") {
              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
            } else if (currentLastEvent.type === "setValue") {
              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);
            } else if (currentLastEvent.type === "setValueCurve") {
              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);
            }
          }
        }
        return audioParam;
      },
      cancelScheduledValues(cancelTime) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }
        automationEventList.add(createCancelScheduledValuesAutomationEvent2(cancelTime));
        nativeAudioParam.cancelScheduledValues(cancelTime);
        return audioParam;
      },
      exponentialRampToValueAtTime(value, endTime) {
        if (value === 0) {
          throw new RangeError();
        }
        if (!Number.isFinite(endTime) || endTime < 0) {
          throw new RangeError();
        }
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }
        automationEventList.add(createExponentialRampToValueAutomationEvent2(value, endTime));
        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);
        return audioParam;
      },
      linearRampToValueAtTime(value, endTime) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }
        automationEventList.add(createLinearRampToValueAutomationEvent2(value, endTime));
        nativeAudioParam.linearRampToValueAtTime(value, endTime);
        return audioParam;
      },
      setTargetAtTime(target, startTime, timeConstant) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }
        automationEventList.add(createSetTargetAutomationEvent2(target, startTime, timeConstant));
        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);
        return audioParam;
      },
      setValueAtTime(value, startTime) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }
        automationEventList.add(createSetValueAutomationEvent2(value, startTime));
        nativeAudioParam.setValueAtTime(value, startTime);
        return audioParam;
      },
      setValueCurveAtTime(values, startTime, duration2) {
        const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);
        if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
          const endTime = startTime + duration2;
          const sampleRate = audioNode.context.sampleRate;
          const firstSample = Math.ceil(startTime * sampleRate);
          const lastSample = Math.floor(endTime * sampleRate);
          const numberOfInterpolatedValues = lastSample - firstSample;
          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);
          for (let i2 = 0; i2 < numberOfInterpolatedValues; i2 += 1) {
            const theoreticIndex = (convertedValues.length - 1) / duration2 * ((firstSample + i2) / sampleRate - startTime);
            const lowerIndex = Math.floor(theoreticIndex);
            const upperIndex = Math.ceil(theoreticIndex);
            interpolatedValues[i2] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];
          }
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createSetValueCurveAutomationEvent2(interpolatedValues, startTime, duration2));
          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration2);
          const timeOfLastSample = lastSample / sampleRate;
          if (timeOfLastSample < endTime) {
            setValueAtTimeUntilPossible2(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);
          }
          setValueAtTimeUntilPossible2(audioParam, convertedValues[convertedValues.length - 1], endTime);
        } else {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createSetValueCurveAutomationEvent2(convertedValues, startTime, duration2));
          nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration2);
        }
        return audioParam;
      }
    };
    audioParamStore.set(audioParam, nativeAudioParam);
    audioParamAudioNodeStore2.set(audioParam, audioNode);
    addAudioParamConnections(audioParam, audioParamRenderer);
    return audioParam;
  };
};
var createAudioParamRenderer = (automationEventList) => {
  return {
    replay(audioParam) {
      for (const automationEvent of automationEventList) {
        if (automationEvent.type === "exponentialRampToValue") {
          const { endTime, value } = automationEvent;
          audioParam.exponentialRampToValueAtTime(value, endTime);
        } else if (automationEvent.type === "linearRampToValue") {
          const { endTime, value } = automationEvent;
          audioParam.linearRampToValueAtTime(value, endTime);
        } else if (automationEvent.type === "setTarget") {
          const { startTime, target, timeConstant } = automationEvent;
          audioParam.setTargetAtTime(target, startTime, timeConstant);
        } else if (automationEvent.type === "setValue") {
          const { startTime, value } = automationEvent;
          audioParam.setValueAtTime(value, startTime);
        } else if (automationEvent.type === "setValueCurve") {
          const { duration: duration2, startTime, values } = automationEvent;
          audioParam.setValueCurveAtTime(values, startTime, duration2);
        } else {
          throw new Error("Can't apply an unknown automation.");
        }
      }
    }
  };
};
var ReadOnlyMap = class {
  constructor(parameters) {
    this._map = new Map(parameters);
  }
  get size() {
    return this._map.size;
  }
  entries() {
    return this._map.entries();
  }
  forEach(callback, thisArg = null) {
    return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));
  }
  get(name2) {
    return this._map.get(name2);
  }
  has(name2) {
    return this._map.has(name2);
  }
  keys() {
    return this._map.keys();
  }
  values() {
    return this._map.values();
  }
};
var DEFAULT_OPTIONS$g = {
  channelCount: 2,
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 1,
  numberOfOutputs: 1,
  parameterData: {},
  processorOptions: {}
};
var createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode2, audioNodeConstructor2, createAudioParam2, createAudioWorkletNodeRenderer2, createNativeAudioWorkletNode2, getAudioNodeConnections2, getBackupOfflineAudioContext2, getNativeContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, sanitizeAudioWorkletNodeOptions2, setActiveAudioWorkletNodeInputs2, testAudioWorkletNodeOptionsClonability2, wrapEventListener2) => {
  return class AudioWorkletNode extends audioNodeConstructor2 {
    constructor(context2, name2, options2) {
      var _a2;
      const nativeContext = getNativeContext2(context2);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const mergedOptions = sanitizeAudioWorkletNodeOptions2({ ...DEFAULT_OPTIONS$g, ...options2 });
      testAudioWorkletNodeOptionsClonability2(mergedOptions);
      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
      const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name2);
      const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== "closed" ? nativeContext : (_a2 = getBackupOfflineAudioContext2(nativeContext)) !== null && _a2 !== void 0 ? _a2 : nativeContext;
      const nativeAudioWorkletNode = createNativeAudioWorkletNode2(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context2.baseLatency, nativeAudioWorkletNodeConstructor2, name2, processorConstructor, mergedOptions);
      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer2(name2, mergedOptions, processorConstructor) : null;
      super(context2, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);
      const parameters = [];
      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {
        const audioParam = createAudioParam2(this, isOffline, nativeAudioParam);
        parameters.push([nm, audioParam]);
      });
      this._nativeAudioWorkletNode = nativeAudioWorkletNode;
      this._onprocessorerror = null;
      this._parameters = new ReadOnlyMap(parameters);
      if (isOffline) {
        addUnrenderedAudioWorkletNode2(nativeContext, this);
      }
      const { activeInputs } = getAudioNodeConnections2(this);
      setActiveAudioWorkletNodeInputs2(nativeAudioWorkletNode, activeInputs);
    }
    get onprocessorerror() {
      return this._onprocessorerror;
    }
    set onprocessorerror(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;
      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;
      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;
    }
    get parameters() {
      if (this._parameters === null) {
        return this._nativeAudioWorkletNode.parameters;
      }
      return this._parameters;
    }
    get port() {
      return this._nativeAudioWorkletNode.port;
    }
  };
};
function copyFromChannel(audioBuffer, parent, key, channelNumber, bufferOffset) {
  if (typeof audioBuffer.copyFromChannel === "function") {
    if (parent[key].byteLength === 0) {
      parent[key] = new Float32Array(128);
    }
    audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);
  } else {
    const channelData = audioBuffer.getChannelData(channelNumber);
    if (parent[key].byteLength === 0) {
      parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);
    } else {
      const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);
      parent[key].set(slicedInput);
    }
  }
}
var copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {
  if (typeof audioBuffer.copyToChannel === "function") {
    if (parent[key].byteLength !== 0) {
      audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);
    }
  } else {
    if (parent[key].byteLength !== 0) {
      audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);
    }
  }
};
var createNestedArrays = (x2, y2) => {
  const arrays = [];
  for (let i2 = 0; i2 < x2; i2 += 1) {
    const array = [];
    const length = typeof y2 === "number" ? y2 : y2[i2];
    for (let j2 = 0; j2 < length; j2 += 1) {
      array.push(new Float32Array(128));
    }
    arrays.push(array);
  }
  return arrays;
};
var getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {
  const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);
  const nativeAudioWorkletNode = getNativeAudioNode(proxy);
  return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);
};
var processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options2, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2) => {
  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;
  const numberOfInputChannels = options2.channelCount * options2.numberOfInputs;
  const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);
  if (processorConstructor === void 0) {
    throw new Error("Missing the processor constructor.");
  }
  const audioNodeConnections = getAudioNodeConnections(proxy);
  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);
  const inputs = createNestedArrays(options2.numberOfInputs, options2.channelCount);
  const outputs = createNestedArrays(options2.numberOfOutputs, outputChannelCount);
  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name2) => ({ ...prmtrs, [name2]: new Float32Array(128) }), {});
  for (let i2 = 0; i2 < length; i2 += 128) {
    if (options2.numberOfInputs > 0 && renderedBuffer !== null) {
      for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
        for (let k2 = 0; k2 < options2.channelCount; k2 += 1) {
          copyFromChannel(renderedBuffer, inputs[j2], k2, k2, i2);
        }
      }
    }
    if (processorConstructor.parameterDescriptors !== void 0 && renderedBuffer !== null) {
      processorConstructor.parameterDescriptors.forEach(({ name: name2 }, index2) => {
        copyFromChannel(renderedBuffer, parameters, name2, numberOfInputChannels + index2, i2);
      });
    }
    for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
      for (let k2 = 0; k2 < outputChannelCount[j2]; k2 += 1) {
        if (outputs[j2][k2].byteLength === 0) {
          outputs[j2][k2] = new Float32Array(128);
        }
      }
    }
    try {
      const potentiallyEmptyInputs = inputs.map((input2, index2) => {
        if (audioNodeConnections.activeInputs[index2].size === 0) {
          return [];
        }
        return input2;
      });
      const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(i2 / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));
      if (processedBuffer !== null) {
        for (let j2 = 0, outputChannelSplitterNodeOutput = 0; j2 < options2.numberOfOutputs; j2 += 1) {
          for (let k2 = 0; k2 < outputChannelCount[j2]; k2 += 1) {
            copyToChannel(processedBuffer, outputs[j2], k2, outputChannelSplitterNodeOutput + k2, i2);
          }
          outputChannelSplitterNodeOutput += outputChannelCount[j2];
        }
      }
      if (!activeSourceFlag) {
        break;
      }
    } catch (error) {
      proxy.dispatchEvent(new ErrorEvent("processorerror", {
        colno: error.colno,
        filename: error.filename,
        lineno: error.lineno,
        message: error.message
      }));
      break;
    }
  }
  return processedBuffer;
};
var createAudioWorkletNodeRendererFactory = (connectAudioParam2, connectMultipleOutputs2, createNativeAudioBufferSourceNode2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, deleteUnrenderedAudioWorkletNode2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getNativeAudioNode2, nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
  return (name2, options2, processorConstructor) => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    let processedBufferPromise = null;
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioWorkletNode = getNativeAudioNode2(proxy);
      let nativeOutputNodes = null;
      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);
      const outputChannelCount = Array.isArray(options2.outputChannelCount) ? options2.outputChannelCount : Array.from(options2.outputChannelCount);
      if (nativeAudioWorkletNodeConstructor2 === null) {
        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
        const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, {
          channelCount: Math.max(1, numberOfOutputChannels),
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          numberOfOutputs: Math.max(1, numberOfOutputChannels)
        });
        const outputChannelMergerNodes = [];
        for (let i2 = 0; i2 < proxy.numberOfOutputs; i2 += 1) {
          outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeOfflineAudioContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: outputChannelCount[i2]
          }));
        }
        const outputGainNode = createNativeGainNode2(nativeOfflineAudioContext, {
          channelCount: options2.channelCount,
          channelCountMode: options2.channelCountMode,
          channelInterpretation: options2.channelInterpretation,
          gain: 1
        });
        outputGainNode.connect = connectMultipleOutputs2.bind(null, outputChannelMergerNodes);
        outputGainNode.disconnect = disconnectMultipleOutputs2.bind(null, outputChannelMergerNodes);
        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];
      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {
        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeOfflineAudioContext, name2);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);
      if (nativeOutputNodes !== null) {
        if (processedBufferPromise === null) {
          if (processorConstructor === void 0) {
            throw new Error("Missing the processor constructor.");
          }
          if (nativeOfflineAudioContextConstructor2 === null) {
            throw new Error("Missing the native OfflineAudioContext constructor.");
          }
          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;
          const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
          const numberOfChannels = numberOfInputChannels + numberOfParameters;
          const renderBuffer = async () => {
            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(numberOfChannels, Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);
            const gainNodes = [];
            const inputChannelSplitterNodes = [];
            for (let i2 = 0; i2 < options2.numberOfInputs; i2 += 1) {
              gainNodes.push(createNativeGainNode2(partialOfflineAudioContext, {
                channelCount: options2.channelCount,
                channelCountMode: options2.channelCountMode,
                channelInterpretation: options2.channelInterpretation,
                gain: 1
              }));
              inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(partialOfflineAudioContext, {
                channelCount: options2.channelCount,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                numberOfOutputs: options2.channelCount
              }));
            }
            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {
              const constantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                offset: audioParam.value
              });
              await renderAutomation2(partialOfflineAudioContext, audioParam, constantSourceNode.offset);
              return constantSourceNode;
            }));
            const inputChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "speakers",
              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
            });
            for (let i2 = 0; i2 < options2.numberOfInputs; i2 += 1) {
              gainNodes[i2].connect(inputChannelSplitterNodes[i2]);
              for (let j2 = 0; j2 < options2.channelCount; j2 += 1) {
                inputChannelSplitterNodes[i2].connect(inputChannelMergerNode, j2, i2 * options2.channelCount + j2);
              }
            }
            for (const [index2, constantSourceNode] of constantSourceNodes.entries()) {
              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index2);
              constantSourceNode.start(0);
            }
            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);
            await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, gainNode)));
            return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
          };
          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options2, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2);
        }
        const processedBuffer = await processedBufferPromise;
        const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
          buffer: null,
          channelCount: 2,
          channelCountMode: "max",
          channelInterpretation: "speakers",
          loop: false,
          loopEnd: 0,
          loopStart: 0,
          playbackRate: 1
        });
        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;
        if (processedBuffer !== null) {
          audioBufferSourceNode.buffer = processedBuffer;
          audioBufferSourceNode.start(0);
        }
        audioBufferSourceNode.connect(outputChannelSplitterNode);
        for (let i2 = 0, outputChannelSplitterNodeOutput = 0; i2 < proxy.numberOfOutputs; i2 += 1) {
          const outputChannelMergerNode = outputChannelMergerNodes[i2];
          for (let j2 = 0; j2 < outputChannelCount[i2]; j2 += 1) {
            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
          }
          outputChannelSplitterNodeOutput += outputChannelCount[i2];
        }
        return outputGainNode;
      }
      if (!nativeAudioWorkletNodeIsOwnedByContext) {
        for (const [nm, audioParam] of proxy.parameters.entries()) {
          await renderAutomation2(nativeOfflineAudioContext, audioParam, nativeAudioWorkletNode.parameters.get(nm));
        }
      } else {
        for (const [nm, audioParam] of proxy.parameters.entries()) {
          await connectAudioParam2(nativeOfflineAudioContext, audioParam, nativeAudioWorkletNode.parameters.get(nm));
        }
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);
      return nativeAudioWorkletNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        deleteUnrenderedAudioWorkletNode2(nativeOfflineAudioContext, proxy);
        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioWorkletNodeOrGainNode !== void 0) {
          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createBaseAudioContextConstructor = (addAudioWorkletModule2, analyserNodeConstructor2, audioBufferConstructor2, audioBufferSourceNodeConstructor2, biquadFilterNodeConstructor2, channelMergerNodeConstructor2, channelSplitterNodeConstructor2, constantSourceNodeConstructor2, convolverNodeConstructor2, decodeAudioData2, delayNodeConstructor2, dynamicsCompressorNodeConstructor2, gainNodeConstructor2, iIRFilterNodeConstructor2, minimalBaseAudioContextConstructor2, oscillatorNodeConstructor2, pannerNodeConstructor2, periodicWaveConstructor2, stereoPannerNodeConstructor2, waveShaperNodeConstructor2) => {
  return class BaseAudioContext extends minimalBaseAudioContextConstructor2 {
    constructor(_nativeContext, numberOfChannels) {
      super(_nativeContext, numberOfChannels);
      this._nativeContext = _nativeContext;
      this._audioWorklet = addAudioWorkletModule2 === void 0 ? void 0 : {
        addModule: (moduleURL, options2) => {
          return addAudioWorkletModule2(this, moduleURL, options2);
        }
      };
    }
    get audioWorklet() {
      return this._audioWorklet;
    }
    createAnalyser() {
      return new analyserNodeConstructor2(this);
    }
    createBiquadFilter() {
      return new biquadFilterNodeConstructor2(this);
    }
    createBuffer(numberOfChannels, length, sampleRate) {
      return new audioBufferConstructor2({ length, numberOfChannels, sampleRate });
    }
    createBufferSource() {
      return new audioBufferSourceNodeConstructor2(this);
    }
    createChannelMerger(numberOfInputs = 6) {
      return new channelMergerNodeConstructor2(this, { numberOfInputs });
    }
    createChannelSplitter(numberOfOutputs = 6) {
      return new channelSplitterNodeConstructor2(this, { numberOfOutputs });
    }
    createConstantSource() {
      return new constantSourceNodeConstructor2(this);
    }
    createConvolver() {
      return new convolverNodeConstructor2(this);
    }
    createDelay(maxDelayTime = 1) {
      return new delayNodeConstructor2(this, { maxDelayTime });
    }
    createDynamicsCompressor() {
      return new dynamicsCompressorNodeConstructor2(this);
    }
    createGain() {
      return new gainNodeConstructor2(this);
    }
    createIIRFilter(feedforward, feedback) {
      return new iIRFilterNodeConstructor2(this, { feedback, feedforward });
    }
    createOscillator() {
      return new oscillatorNodeConstructor2(this);
    }
    createPanner() {
      return new pannerNodeConstructor2(this);
    }
    createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {
      return new periodicWaveConstructor2(this, { ...constraints, imag, real });
    }
    createStereoPanner() {
      return new stereoPannerNodeConstructor2(this);
    }
    createWaveShaper() {
      return new waveShaperNodeConstructor2(this);
    }
    decodeAudioData(audioData, successCallback, errorCallback) {
      return decodeAudioData2(this._nativeContext, audioData).then((audioBuffer) => {
        if (typeof successCallback === "function") {
          successCallback(audioBuffer);
        }
        return audioBuffer;
      }, (err) => {
        if (typeof errorCallback === "function") {
          errorCallback(err);
        }
        throw err;
      });
    }
  };
};
var DEFAULT_OPTIONS$f = {
  Q: 1,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  detune: 0,
  frequency: 350,
  gain: 0,
  type: "lowpass"
};
var createBiquadFilterNodeConstructor = (audioNodeConstructor2, createAudioParam2, createBiquadFilterNodeRenderer2, createInvalidAccessError2, createNativeBiquadFilterNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class BiquadFilterNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$f, ...options2 };
      const nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer2() : null;
      super(context2, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);
      this._Q = createAudioParam2(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._detune = createAudioParam2(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));
      this._frequency = createAudioParam2(this, isOffline, nativeBiquadFilterNode.frequency, context2.sampleRate / 2, 0);
      this._gain = createAudioParam2(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);
      this._nativeBiquadFilterNode = nativeBiquadFilterNode;
      setAudioNodeTailTime2(this, 1);
    }
    get detune() {
      return this._detune;
    }
    get frequency() {
      return this._frequency;
    }
    get gain() {
      return this._gain;
    }
    get Q() {
      return this._Q;
    }
    get type() {
      return this._nativeBiquadFilterNode.type;
    }
    set type(value) {
      this._nativeBiquadFilterNode.type = value;
    }
    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
      try {
        this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
      } catch (err) {
        if (err.code === 11) {
          throw createInvalidAccessError2();
        }
        throw err;
      }
      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
        throw createInvalidAccessError2();
      }
    }
  };
};
var createBiquadFilterNodeRendererFactory = (connectAudioParam2, createNativeBiquadFilterNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeBiquadFilterNodes = /* @__PURE__ */ new WeakMap();
    const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeBiquadFilterNode = getNativeAudioNode2(proxy);
      const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);
      if (!nativeBiquadFilterNodeIsOwnedByContext) {
        const options2 = {
          Q: nativeBiquadFilterNode.Q.value,
          channelCount: nativeBiquadFilterNode.channelCount,
          channelCountMode: nativeBiquadFilterNode.channelCountMode,
          channelInterpretation: nativeBiquadFilterNode.channelInterpretation,
          detune: nativeBiquadFilterNode.detune.value,
          frequency: nativeBiquadFilterNode.frequency.value,
          gain: nativeBiquadFilterNode.gain.value,
          type: nativeBiquadFilterNode.type
        };
        nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);
      if (!nativeBiquadFilterNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
        await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
        await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
        await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);
      return nativeBiquadFilterNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);
        if (renderedNativeBiquadFilterNode !== void 0) {
          return Promise.resolve(renderedNativeBiquadFilterNode);
        }
        return createBiquadFilterNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createCacheTestResult = (ongoingTests, testResults) => {
  return (tester, test) => {
    const cachedTestResult = testResults.get(tester);
    if (cachedTestResult !== void 0) {
      return cachedTestResult;
    }
    const ongoingTest = ongoingTests.get(tester);
    if (ongoingTest !== void 0) {
      return ongoingTest;
    }
    try {
      const synchronousTestResult = test();
      if (synchronousTestResult instanceof Promise) {
        ongoingTests.set(tester, synchronousTestResult);
        return synchronousTestResult.catch(() => false).then((finalTestResult) => {
          ongoingTests.delete(tester);
          testResults.set(tester, finalTestResult);
          return finalTestResult;
        });
      }
      testResults.set(tester, synchronousTestResult);
      return synchronousTestResult;
    } catch {
      testResults.set(tester, false);
      return false;
    }
  };
};
var DEFAULT_OPTIONS$e = {
  channelCount: 1,
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 6
};
var createChannelMergerNodeConstructor = (audioNodeConstructor2, createChannelMergerNodeRenderer2, createNativeChannelMergerNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class ChannelMergerNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$e, ...options2 };
      const nativeChannelMergerNode = createNativeChannelMergerNode2(nativeContext, mergedOptions);
      const channelMergerNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelMergerNodeRenderer2() : null;
      super(context2, false, nativeChannelMergerNode, channelMergerNodeRenderer);
    }
  };
};
var createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioNode = getNativeAudioNode2(proxy);
      const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
      if (!nativeAudioNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeAudioNode.channelCount,
          channelCountMode: nativeAudioNode.channelCountMode,
          channelInterpretation: nativeAudioNode.channelInterpretation,
          numberOfInputs: nativeAudioNode.numberOfInputs
        };
        nativeAudioNode = createNativeChannelMergerNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
      return nativeAudioNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioNode !== void 0) {
          return Promise.resolve(renderedNativeAudioNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var DEFAULT_OPTIONS$d = {
  channelCount: 6,
  channelCountMode: "explicit",
  channelInterpretation: "discrete",
  numberOfOutputs: 6
};
var createChannelSplitterNodeConstructor = (audioNodeConstructor2, createChannelSplitterNodeRenderer2, createNativeChannelSplitterNode2, getNativeContext2, isNativeOfflineAudioContext2, sanitizeChannelSplitterOptions2) => {
  return class ChannelSplitterNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = sanitizeChannelSplitterOptions2({ ...DEFAULT_OPTIONS$d, ...options2 });
      const nativeChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, mergedOptions);
      const channelSplitterNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelSplitterNodeRenderer2() : null;
      super(context2, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);
    }
  };
};
var createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioNode = getNativeAudioNode2(proxy);
      const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
      if (!nativeAudioNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeAudioNode.channelCount,
          channelCountMode: nativeAudioNode.channelCountMode,
          channelInterpretation: nativeAudioNode.channelInterpretation,
          numberOfOutputs: nativeAudioNode.numberOfOutputs
        };
        nativeAudioNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
      return nativeAudioNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioNode !== void 0) {
          return Promise.resolve(renderedNativeAudioNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createConnectAudioParam = (renderInputsOfAudioParam2) => {
  return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
    return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
  };
};
var createConnectMultipleOutputs = (createIndexSizeError2) => {
  return (outputAudioNodes, destination, output = 0, input2 = 0) => {
    const outputAudioNode = outputAudioNodes[output];
    if (outputAudioNode === void 0) {
      throw createIndexSizeError2();
    }
    if (isNativeAudioNode$1(destination)) {
      return outputAudioNode.connect(destination, 0, input2);
    }
    return outputAudioNode.connect(destination, 0);
  };
};
var createConnectedNativeAudioBufferSourceNodeFactory = (createNativeAudioBufferSourceNode2) => {
  return (nativeContext, nativeAudioNode) => {
    const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
      buffer: null,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    });
    const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);
    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
    nativeAudioBufferSourceNode.loop = true;
    nativeAudioBufferSourceNode.connect(nativeAudioNode);
    nativeAudioBufferSourceNode.start();
    return () => {
      nativeAudioBufferSourceNode.stop();
      nativeAudioBufferSourceNode.disconnect(nativeAudioNode);
    };
  };
};
var DEFAULT_OPTIONS$c = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  offset: 1
};
var createConstantSourceNodeConstructor = (audioNodeConstructor2, createAudioParam2, createConstantSourceNodeRendererFactory2, createNativeConstantSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
  return class ConstantSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$c, ...options2 };
      const nativeConstantSourceNode = createNativeConstantSourceNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory2() : null;
      super(context2, false, nativeConstantSourceNode, constantSourceNodeRenderer);
      this._constantSourceNodeRenderer = constantSourceNodeRenderer;
      this._nativeConstantSourceNode = nativeConstantSourceNode;
      this._offset = createAudioParam2(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._onended = null;
    }
    get offset() {
      return this._offset;
    }
    get onended() {
      return this._onended;
    }
    set onended(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeConstantSourceNode.onended = wrappedListener;
      const nativeOnEnded = this._nativeConstantSourceNode.onended;
      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
    }
    start(when = 0) {
      this._nativeConstantSourceNode.start(when);
      if (this._constantSourceNodeRenderer !== null) {
        this._constantSourceNodeRenderer.start = when;
      }
      if (this.context.state !== "closed") {
        setInternalStateToActive(this);
        const resetInternalStateToPassive = () => {
          this._nativeConstantSourceNode.removeEventListener("ended", resetInternalStateToPassive);
          if (isActiveAudioNode(this)) {
            setInternalStateToPassive(this);
          }
        };
        this._nativeConstantSourceNode.addEventListener("ended", resetInternalStateToPassive);
      }
    }
    stop(when = 0) {
      this._nativeConstantSourceNode.stop(when);
      if (this._constantSourceNodeRenderer !== null) {
        this._constantSourceNodeRenderer.stop = when;
      }
    }
  };
};
var createConstantSourceNodeRendererFactory = (connectAudioParam2, createNativeConstantSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeConstantSourceNodes = /* @__PURE__ */ new WeakMap();
    let start22 = null;
    let stop = null;
    const createConstantSourceNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeConstantSourceNode = getNativeAudioNode2(proxy);
      const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);
      if (!nativeConstantSourceNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeConstantSourceNode.channelCount,
          channelCountMode: nativeConstantSourceNode.channelCountMode,
          channelInterpretation: nativeConstantSourceNode.channelInterpretation,
          offset: nativeConstantSourceNode.offset.value
        };
        nativeConstantSourceNode = createNativeConstantSourceNode2(nativeOfflineAudioContext, options2);
        if (start22 !== null) {
          nativeConstantSourceNode.start(start22);
        }
        if (stop !== null) {
          nativeConstantSourceNode.stop(stop);
        }
      }
      renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);
      if (!nativeConstantSourceNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);
      return nativeConstantSourceNode;
    };
    return {
      set start(value) {
        start22 = value;
      },
      set stop(value) {
        stop = value;
      },
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);
        if (renderedNativeConstantSourceNode !== void 0) {
          return Promise.resolve(renderedNativeConstantSourceNode);
        }
        return createConstantSourceNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createConvertNumberToUnsignedLong = (unit32Array) => {
  return (value) => {
    unit32Array[0] = value;
    return unit32Array[0];
  };
};
var DEFAULT_OPTIONS$b = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  disableNormalization: false
};
var createConvolverNodeConstructor = (audioNodeConstructor2, createConvolverNodeRenderer2, createNativeConvolverNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class ConvolverNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$b, ...options2 };
      const nativeConvolverNode = createNativeConvolverNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const convolverNodeRenderer = isOffline ? createConvolverNodeRenderer2() : null;
      super(context2, false, nativeConvolverNode, convolverNodeRenderer);
      this._isBufferNullified = false;
      this._nativeConvolverNode = nativeConvolverNode;
      if (mergedOptions.buffer !== null) {
        setAudioNodeTailTime2(this, mergedOptions.buffer.duration);
      }
    }
    get buffer() {
      if (this._isBufferNullified) {
        return null;
      }
      return this._nativeConvolverNode.buffer;
    }
    set buffer(value) {
      this._nativeConvolverNode.buffer = value;
      if (value === null && this._nativeConvolverNode.buffer !== null) {
        const nativeContext = this._nativeConvolverNode.context;
        this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, 44100);
        this._isBufferNullified = true;
        setAudioNodeTailTime2(this, 0);
      } else {
        this._isBufferNullified = false;
        setAudioNodeTailTime2(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
      }
    }
    get normalize() {
      return this._nativeConvolverNode.normalize;
    }
    set normalize(value) {
      this._nativeConvolverNode.normalize = value;
    }
  };
};
var createConvolverNodeRendererFactory = (createNativeConvolverNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeConvolverNodes = /* @__PURE__ */ new WeakMap();
    const createConvolverNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeConvolverNode = getNativeAudioNode2(proxy);
      const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);
      if (!nativeConvolverNodeIsOwnedByContext) {
        const options2 = {
          buffer: nativeConvolverNode.buffer,
          channelCount: nativeConvolverNode.channelCount,
          channelCountMode: nativeConvolverNode.channelCountMode,
          channelInterpretation: nativeConvolverNode.channelInterpretation,
          disableNormalization: !nativeConvolverNode.normalize
        };
        nativeConvolverNode = createNativeConvolverNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);
      if (isNativeAudioNodeFaker(nativeConvolverNode)) {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode);
      }
      return nativeConvolverNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);
        if (renderedNativeConvolverNode !== void 0) {
          return Promise.resolve(renderedNativeConvolverNode);
        }
        return createConvolverNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createCreateNativeOfflineAudioContext = (createNotSupportedError2, nativeOfflineAudioContextConstructor2) => {
  return (numberOfChannels, length, sampleRate) => {
    if (nativeOfflineAudioContextConstructor2 === null) {
      throw new Error("Missing the native OfflineAudioContext constructor.");
    }
    try {
      return new nativeOfflineAudioContextConstructor2(numberOfChannels, length, sampleRate);
    } catch (err) {
      if (err.name === "SyntaxError") {
        throw createNotSupportedError2();
      }
      throw err;
    }
  };
};
var createDataCloneError = () => new DOMException("", "DataCloneError");
var detachArrayBuffer = (arrayBuffer) => {
  const { port1, port2 } = new MessageChannel();
  return new Promise((resolve) => {
    const closeAndResolve = () => {
      port2.onmessage = null;
      port1.close();
      port2.close();
      resolve();
    };
    port2.onmessage = () => closeAndResolve();
    try {
      port1.postMessage(arrayBuffer, [arrayBuffer]);
    } finally {
      closeAndResolve();
    }
  });
};
var createDecodeAudioData = (audioBufferStore2, cacheTestResult2, createDataCloneError2, createEncodingError2, detachedArrayBuffers, getNativeContext2, isNativeContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, testPromiseSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
  return (anyContext, audioData) => {
    const nativeContext = isNativeContext2(anyContext) ? anyContext : getNativeContext2(anyContext);
    if (detachedArrayBuffers.has(audioData)) {
      const err = createDataCloneError2();
      return Promise.reject(err);
    }
    try {
      detachedArrayBuffers.add(audioData);
    } catch {
    }
    if (cacheTestResult2(testPromiseSupport2, () => testPromiseSupport2(nativeContext))) {
      return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {
        detachArrayBuffer(audioData).catch(() => {
        });
        if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
          wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
        }
        audioBufferStore2.add(audioBuffer);
        return audioBuffer;
      });
    }
    return new Promise((resolve, reject) => {
      const complete = async () => {
        try {
          await detachArrayBuffer(audioData);
        } catch {
        }
      };
      const fail = (err) => {
        reject(err);
        complete();
      };
      try {
        nativeContext.decodeAudioData(audioData, (audioBuffer) => {
          if (typeof audioBuffer.copyFromChannel !== "function") {
            wrapAudioBufferCopyChannelMethods2(audioBuffer);
            wrapAudioBufferGetChannelDataMethod(audioBuffer);
          }
          audioBufferStore2.add(audioBuffer);
          complete().then(() => resolve(audioBuffer));
        }, (err) => {
          if (err === null) {
            fail(createEncodingError2());
          } else {
            fail(err);
          }
        });
      } catch (err) {
        fail(err);
      }
    });
  };
};
var createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode2, cycleCounters, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, getNativeContext2, isActiveAudioNode2, isNativeOfflineAudioContext2) => {
  return (audioNode, count) => {
    const cycleCounter = cycleCounters.get(audioNode);
    if (cycleCounter === void 0) {
      throw new Error("Missing the expected cycle count.");
    }
    const nativeContext = getNativeContext2(audioNode.context);
    const isOffline = isNativeOfflineAudioContext2(nativeContext);
    if (cycleCounter === count) {
      cycleCounters.delete(audioNode);
      if (!isOffline && isActiveAudioNode2(audioNode)) {
        const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
        const { outputs } = getAudioNodeConnections2(audioNode);
        for (const output of outputs) {
          if (isAudioNodeOutputConnection(output)) {
            const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);
            connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
          } else {
            const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);
            nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);
          }
        }
      }
    } else {
      cycleCounters.set(audioNode, cycleCounter - count);
    }
  };
};
var DEFAULT_OPTIONS$a = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  delayTime: 0,
  maxDelayTime: 1
};
var createDelayNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDelayNodeRenderer2, createNativeDelayNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class DelayNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$a, ...options2 };
      const nativeDelayNode = createNativeDelayNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const delayNodeRenderer = isOffline ? createDelayNodeRenderer2(mergedOptions.maxDelayTime) : null;
      super(context2, false, nativeDelayNode, delayNodeRenderer);
      this._delayTime = createAudioParam2(this, isOffline, nativeDelayNode.delayTime);
      setAudioNodeTailTime2(this, mergedOptions.maxDelayTime);
    }
    get delayTime() {
      return this._delayTime;
    }
  };
};
var createDelayNodeRendererFactory = (connectAudioParam2, createNativeDelayNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return (maxDelayTime) => {
    const renderedNativeDelayNodes = /* @__PURE__ */ new WeakMap();
    const createDelayNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeDelayNode = getNativeAudioNode2(proxy);
      const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);
      if (!nativeDelayNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeDelayNode.channelCount,
          channelCountMode: nativeDelayNode.channelCountMode,
          channelInterpretation: nativeDelayNode.channelInterpretation,
          delayTime: nativeDelayNode.delayTime.value,
          maxDelayTime
        };
        nativeDelayNode = createNativeDelayNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);
      if (!nativeDelayNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDelayNode);
      return nativeDelayNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);
        if (renderedNativeDelayNode !== void 0) {
          return Promise.resolve(renderedNativeDelayNode);
        }
        return createDelayNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createDeleteActiveInputConnectionToAudioNode = (pickElementFromSet2) => {
  return (activeInputs, source, output, input2) => {
    return pickElementFromSet2(activeInputs[input2], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);
  };
};
var createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
  return (nativeContext, audioWorkletNode) => {
    getUnrenderedAudioWorkletNodes2(nativeContext).delete(audioWorkletNode);
  };
};
var isDelayNode = (audioNode) => {
  return "delayTime" in audioNode;
};
var createDetectCycles = (audioParamAudioNodeStore2, getAudioNodeConnections2, getValueForKey2) => {
  return function detectCycles(chain2, nextLink) {
    const audioNode = isAudioNode$1(nextLink) ? nextLink : getValueForKey2(audioParamAudioNodeStore2, nextLink);
    if (isDelayNode(audioNode)) {
      return [];
    }
    if (chain2[0] === audioNode) {
      return [chain2];
    }
    if (chain2.includes(audioNode)) {
      return [];
    }
    const { outputs } = getAudioNodeConnections2(audioNode);
    return Array.from(outputs).map((outputConnection) => detectCycles([...chain2, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);
  };
};
var getOutputAudioNodeAtIndex = (createIndexSizeError2, outputAudioNodes, output) => {
  const outputAudioNode = outputAudioNodes[output];
  if (outputAudioNode === void 0) {
    throw createIndexSizeError2();
  }
  return outputAudioNode;
};
var createDisconnectMultipleOutputs = (createIndexSizeError2) => {
  return (outputAudioNodes, destinationOrOutput = void 0, output = void 0, input2 = 0) => {
    if (destinationOrOutput === void 0) {
      return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());
    }
    if (typeof destinationOrOutput === "number") {
      return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, destinationOrOutput).disconnect();
    }
    if (isNativeAudioNode$1(destinationOrOutput)) {
      if (output === void 0) {
        return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
      }
      if (input2 === void 0) {
        return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
      }
      return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input2);
    }
    if (output === void 0) {
      return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
    }
    return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
  };
};
var DEFAULT_OPTIONS$9 = {
  attack: 3e-3,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  knee: 30,
  ratio: 12,
  release: 0.25,
  threshold: -24
};
var createDynamicsCompressorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDynamicsCompressorNodeRenderer2, createNativeDynamicsCompressorNode2, createNotSupportedError2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class DynamicsCompressorNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$9, ...options2 };
      const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer2() : null;
      super(context2, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);
      this._attack = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.attack);
      this._knee = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.knee);
      this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;
      this._ratio = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.ratio);
      this._release = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.release);
      this._threshold = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.threshold);
      setAudioNodeTailTime2(this, 6e-3);
    }
    get attack() {
      return this._attack;
    }
    get channelCount() {
      return this._nativeDynamicsCompressorNode.channelCount;
    }
    set channelCount(value) {
      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;
      this._nativeDynamicsCompressorNode.channelCount = value;
      if (value > 2) {
        this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;
        throw createNotSupportedError2();
      }
    }
    get channelCountMode() {
      return this._nativeDynamicsCompressorNode.channelCountMode;
    }
    set channelCountMode(value) {
      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;
      this._nativeDynamicsCompressorNode.channelCountMode = value;
      if (value === "max") {
        this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;
        throw createNotSupportedError2();
      }
    }
    get knee() {
      return this._knee;
    }
    get ratio() {
      return this._ratio;
    }
    get reduction() {
      if (typeof this._nativeDynamicsCompressorNode.reduction.value === "number") {
        return this._nativeDynamicsCompressorNode.reduction.value;
      }
      return this._nativeDynamicsCompressorNode.reduction;
    }
    get release() {
      return this._release;
    }
    get threshold() {
      return this._threshold;
    }
  };
};
var createDynamicsCompressorNodeRendererFactory = (connectAudioParam2, createNativeDynamicsCompressorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeDynamicsCompressorNodes = /* @__PURE__ */ new WeakMap();
    const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeDynamicsCompressorNode = getNativeAudioNode2(proxy);
      const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);
      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
        const options2 = {
          attack: nativeDynamicsCompressorNode.attack.value,
          channelCount: nativeDynamicsCompressorNode.channelCount,
          channelCountMode: nativeDynamicsCompressorNode.channelCountMode,
          channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,
          knee: nativeDynamicsCompressorNode.knee.value,
          ratio: nativeDynamicsCompressorNode.ratio.value,
          release: nativeDynamicsCompressorNode.release.value,
          threshold: nativeDynamicsCompressorNode.threshold.value
        };
        nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);
      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
        await renderAutomation2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
        await renderAutomation2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
        await renderAutomation2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
        await renderAutomation2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);
      return nativeDynamicsCompressorNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);
        if (renderedNativeDynamicsCompressorNode !== void 0) {
          return Promise.resolve(renderedNativeDynamicsCompressorNode);
        }
        return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createEncodingError = () => new DOMException("", "EncodingError");
var createEvaluateSource = (window2) => {
  return (source) => new Promise((resolve, reject) => {
    if (window2 === null) {
      reject(new SyntaxError());
      return;
    }
    const head = window2.document.head;
    if (head === null) {
      reject(new SyntaxError());
    } else {
      const script = window2.document.createElement("script");
      const blob = new Blob([source], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      const originalOnErrorHandler = window2.onerror;
      const removeErrorEventListenerAndRevokeUrl = () => {
        window2.onerror = originalOnErrorHandler;
        URL.revokeObjectURL(url);
      };
      window2.onerror = (message, src, lineno, colno, error) => {
        if (src === url || src === window2.location.href && lineno === 1 && colno === 1) {
          removeErrorEventListenerAndRevokeUrl();
          reject(error);
          return false;
        }
        if (originalOnErrorHandler !== null) {
          return originalOnErrorHandler(message, src, lineno, colno, error);
        }
      };
      script.onerror = () => {
        removeErrorEventListenerAndRevokeUrl();
        reject(new SyntaxError());
      };
      script.onload = () => {
        removeErrorEventListenerAndRevokeUrl();
        resolve();
      };
      script.src = url;
      script.type = "module";
      head.appendChild(script);
    }
  });
};
var createEventTargetConstructor = (wrapEventListener2) => {
  return class EventTarget {
    constructor(_nativeEventTarget) {
      this._nativeEventTarget = _nativeEventTarget;
      this._listeners = /* @__PURE__ */ new WeakMap();
    }
    addEventListener(type, listener, options2) {
      if (listener !== null) {
        let wrappedEventListener = this._listeners.get(listener);
        if (wrappedEventListener === void 0) {
          wrappedEventListener = wrapEventListener2(this, listener);
          if (typeof listener === "function") {
            this._listeners.set(listener, wrappedEventListener);
          }
        }
        this._nativeEventTarget.addEventListener(type, wrappedEventListener, options2);
      }
    }
    dispatchEvent(event) {
      return this._nativeEventTarget.dispatchEvent(event);
    }
    removeEventListener(type, listener, options2) {
      const wrappedEventListener = listener === null ? void 0 : this._listeners.get(listener);
      this._nativeEventTarget.removeEventListener(type, wrappedEventListener === void 0 ? null : wrappedEventListener, options2);
    }
  };
};
var createExposeCurrentFrameAndCurrentTime = (window2) => {
  return (currentTime, sampleRate, fn) => {
    Object.defineProperties(window2, {
      currentFrame: {
        configurable: true,
        get() {
          return Math.round(currentTime * sampleRate);
        }
      },
      currentTime: {
        configurable: true,
        get() {
          return currentTime;
        }
      }
    });
    try {
      return fn();
    } finally {
      if (window2 !== null) {
        delete window2.currentFrame;
        delete window2.currentTime;
      }
    }
  };
};
var createFetchSource = (createAbortError2) => {
  return async (url) => {
    try {
      const response = await fetch(url);
      if (response.ok) {
        return [await response.text(), response.url];
      }
    } catch {
    }
    throw createAbortError2();
  };
};
var DEFAULT_OPTIONS$8 = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  gain: 1
};
var createGainNodeConstructor = (audioNodeConstructor2, createAudioParam2, createGainNodeRenderer2, createNativeGainNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class GainNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$8, ...options2 };
      const nativeGainNode = createNativeGainNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const gainNodeRenderer = isOffline ? createGainNodeRenderer2() : null;
      super(context2, false, nativeGainNode, gainNodeRenderer);
      this._gain = createAudioParam2(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
    }
    get gain() {
      return this._gain;
    }
  };
};
var createGainNodeRendererFactory = (connectAudioParam2, createNativeGainNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeGainNodes = /* @__PURE__ */ new WeakMap();
    const createGainNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeGainNode = getNativeAudioNode2(proxy);
      const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);
      if (!nativeGainNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeGainNode.channelCount,
          channelCountMode: nativeGainNode.channelCountMode,
          channelInterpretation: nativeGainNode.channelInterpretation,
          gain: nativeGainNode.gain.value
        };
        nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);
      if (!nativeGainNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeGainNode);
      return nativeGainNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);
        if (renderedNativeGainNode !== void 0) {
          return Promise.resolve(renderedNativeGainNode);
        }
        return createGainNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2, getValueForKey2) => {
  return (nativeAudioWorkletNode) => getValueForKey2(activeAudioWorkletNodeInputsStore2, nativeAudioWorkletNode);
};
var createGetAudioNodeRenderer = (getAudioNodeConnections2) => {
  return (audioNode) => {
    const audioNodeConnections = getAudioNodeConnections2(audioNode);
    if (audioNodeConnections.renderer === null) {
      throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
    }
    return audioNodeConnections.renderer;
  };
};
var createGetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
  return (audioNode) => {
    var _a2;
    return (_a2 = audioNodeTailTimeStore2.get(audioNode)) !== null && _a2 !== void 0 ? _a2 : 0;
  };
};
var createGetAudioParamRenderer = (getAudioParamConnections2) => {
  return (audioParam) => {
    const audioParamConnections = getAudioParamConnections2(audioParam);
    if (audioParamConnections.renderer === null) {
      throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
    }
    return audioParamConnections.renderer;
  };
};
var createGetBackupOfflineAudioContext = (backupOfflineAudioContextStore2) => {
  return (nativeContext) => {
    return backupOfflineAudioContextStore2.get(nativeContext);
  };
};
var createInvalidStateError = () => new DOMException("", "InvalidStateError");
var createGetNativeContext = (contextStore) => {
  return (context2) => {
    const nativeContext = contextStore.get(context2);
    if (nativeContext === void 0) {
      throw createInvalidStateError();
    }
    return nativeContext;
  };
};
var createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore2, nativeOfflineAudioContextConstructor2) => {
  return (nativeContext) => {
    let backupOfflineAudioContext = backupOfflineAudioContextStore2.get(nativeContext);
    if (backupOfflineAudioContext !== void 0) {
      return backupOfflineAudioContext;
    }
    if (nativeOfflineAudioContextConstructor2 === null) {
      throw new Error("Missing the native OfflineAudioContext constructor.");
    }
    backupOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
    backupOfflineAudioContextStore2.set(nativeContext, backupOfflineAudioContext);
    return backupOfflineAudioContext;
  };
};
var createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore2) => {
  return (nativeContext) => {
    const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore2.get(nativeContext);
    if (unrenderedAudioWorkletNodes === void 0) {
      throw new Error("The context has no set of AudioWorkletNodes.");
    }
    return unrenderedAudioWorkletNodes;
  };
};
var createInvalidAccessError = () => new DOMException("", "InvalidAccessError");
var wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {
  nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {
    return (frequencyHz, magResponse, phaseResponse) => {
      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
        throw createInvalidAccessError();
      }
      return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);
    };
  })(nativeIIRFilterNode.getFrequencyResponse);
};
var DEFAULT_OPTIONS$7 = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers"
};
var createIIRFilterNodeConstructor = (audioNodeConstructor2, createNativeIIRFilterNode2, createIIRFilterNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class IIRFilterNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const mergedOptions = { ...DEFAULT_OPTIONS$7, ...options2 };
      const nativeIIRFilterNode = createNativeIIRFilterNode2(nativeContext, isOffline ? null : context2.baseLatency, mergedOptions);
      const iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer2(mergedOptions.feedback, mergedOptions.feedforward) : null;
      super(context2, false, nativeIIRFilterNode, iirFilterNodeRenderer);
      wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);
      this._nativeIIRFilterNode = nativeIIRFilterNode;
      setAudioNodeTailTime2(this, 1);
    }
    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
      return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
    }
  };
};
var filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input2, output) => {
  const inputLength = input2.length;
  let i2 = bufferIndex;
  for (let j2 = 0; j2 < inputLength; j2 += 1) {
    let y2 = feedforward[0] * input2[j2];
    for (let k2 = 1; k2 < minLength; k2 += 1) {
      const x2 = i2 - k2 & bufferLength - 1;
      y2 += feedforward[k2] * xBuffer[x2];
      y2 -= feedback[k2] * yBuffer[x2];
    }
    for (let k2 = minLength; k2 < feedforwardLength; k2 += 1) {
      y2 += feedforward[k2] * xBuffer[i2 - k2 & bufferLength - 1];
    }
    for (let k2 = minLength; k2 < feedbackLength; k2 += 1) {
      y2 -= feedback[k2] * yBuffer[i2 - k2 & bufferLength - 1];
    }
    xBuffer[i2] = input2[j2];
    yBuffer[i2] = y2;
    i2 = i2 + 1 & bufferLength - 1;
    output[j2] = y2;
  }
  return i2;
};
var filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {
  const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
  const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
  const feedbackLength = convertedFeedback.length;
  const feedforwardLength = convertedFeedforward.length;
  const minLength = Math.min(feedbackLength, feedforwardLength);
  if (convertedFeedback[0] !== 1) {
    for (let i2 = 0; i2 < feedbackLength; i2 += 1) {
      convertedFeedforward[i2] /= convertedFeedback[0];
    }
    for (let i2 = 1; i2 < feedforwardLength; i2 += 1) {
      convertedFeedback[i2] /= convertedFeedback[0];
    }
  }
  const bufferLength = 32;
  const xBuffer = new Float32Array(bufferLength);
  const yBuffer = new Float32Array(bufferLength);
  const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
  const numberOfChannels = renderedBuffer.numberOfChannels;
  for (let i2 = 0; i2 < numberOfChannels; i2 += 1) {
    const input2 = renderedBuffer.getChannelData(i2);
    const output = filteredBuffer.getChannelData(i2);
    xBuffer.fill(0);
    yBuffer.fill(0);
    filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input2, output);
  }
  return filteredBuffer;
};
var createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
  return (feedback, feedforward) => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    let filteredBufferPromise = null;
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioBufferSourceNode = null;
      let nativeIIRFilterNode = getNativeAudioNode2(proxy);
      const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);
      if (nativeOfflineAudioContext.createIIRFilter === void 0) {
        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
          buffer: null,
          channelCount: 2,
          channelCountMode: "max",
          channelInterpretation: "speakers",
          loop: false,
          loopEnd: 0,
          loopStart: 0,
          playbackRate: 1
        });
      } else if (!nativeIIRFilterNodeIsOwnedByContext) {
        nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);
      if (nativeAudioBufferSourceNode !== null) {
        if (filteredBufferPromise === null) {
          if (nativeOfflineAudioContextConstructor2 === null) {
            throw new Error("Missing the native OfflineAudioContext constructor.");
          }
          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(proxy.context.destination.channelCount, proxy.context.length, nativeOfflineAudioContext.sampleRate);
          filteredBufferPromise = (async () => {
            await renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);
            const renderedBuffer = await renderNativeOfflineAudioContext2(partialOfflineAudioContext);
            return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);
          })();
        }
        const filteredBuffer = await filteredBufferPromise;
        nativeAudioBufferSourceNode.buffer = filteredBuffer;
        nativeAudioBufferSourceNode.start(0);
        return nativeAudioBufferSourceNode;
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);
      return nativeIIRFilterNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioNode !== void 0) {
          return Promise.resolve(renderedNativeAudioNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, isActiveAudioNode2) => {
  return (isOffline) => {
    return (audioNode, count) => {
      const cycleCounter = cycleCounters.get(audioNode);
      if (cycleCounter === void 0) {
        if (!isOffline && isActiveAudioNode2(audioNode)) {
          const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
          const { outputs } = getAudioNodeConnections2(audioNode);
          for (const output of outputs) {
            if (isAudioNodeOutputConnection(output)) {
              const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);
              disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
            } else {
              const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);
              nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);
            }
          }
        }
        cycleCounters.set(audioNode, count);
      } else {
        cycleCounters.set(audioNode, cycleCounter + count);
      }
    };
  };
};
var createIsAnyAudioContext = (contextStore, isNativeAudioContext2) => {
  return (anything) => {
    const nativeContext = contextStore.get(anything);
    return isNativeAudioContext2(nativeContext) || isNativeAudioContext2(anything);
  };
};
var createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode2) => {
  return (anything) => audioNodeStore.has(anything) || isNativeAudioNode2(anything);
};
var createIsAnyAudioParam = (audioParamStore, isNativeAudioParam2) => {
  return (anything) => audioParamStore.has(anything) || isNativeAudioParam2(anything);
};
var createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext2) => {
  return (anything) => {
    const nativeContext = contextStore.get(anything);
    return isNativeOfflineAudioContext2(nativeContext) || isNativeOfflineAudioContext2(anything);
  };
};
var createIsNativeAudioContext = (nativeAudioContextConstructor2) => {
  return (anything) => {
    return nativeAudioContextConstructor2 !== null && anything instanceof nativeAudioContextConstructor2;
  };
};
var createIsNativeAudioNode = (window2) => {
  return (anything) => {
    return window2 !== null && typeof window2.AudioNode === "function" && anything instanceof window2.AudioNode;
  };
};
var createIsNativeAudioParam = (window2) => {
  return (anything) => {
    return window2 !== null && typeof window2.AudioParam === "function" && anything instanceof window2.AudioParam;
  };
};
var createIsNativeContext = (isNativeAudioContext2, isNativeOfflineAudioContext2) => {
  return (anything) => {
    return isNativeAudioContext2(anything) || isNativeOfflineAudioContext2(anything);
  };
};
var createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor2) => {
  return (anything) => {
    return nativeOfflineAudioContextConstructor2 !== null && anything instanceof nativeOfflineAudioContextConstructor2;
  };
};
var createIsSecureContext = (window2) => window2 !== null && window2.isSecureContext;
var createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaElementAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class MediaElementAudioSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode2(nativeContext, options2);
      if (isNativeOfflineAudioContext2(nativeContext)) {
        throw TypeError();
      }
      super(context2, true, nativeMediaElementAudioSourceNode, null);
      this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;
    }
    get mediaElement() {
      return this._nativeMediaElementAudioSourceNode.mediaElement;
    }
  };
};
var DEFAULT_OPTIONS$6 = {
  channelCount: 2,
  channelCountMode: "explicit",
  channelInterpretation: "speakers"
};
var createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioDestinationNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class MediaStreamAudioDestinationNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      if (isNativeOfflineAudioContext2(nativeContext)) {
        throw new TypeError();
      }
      const mergedOptions = { ...DEFAULT_OPTIONS$6, ...options2 };
      const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode2(nativeContext, mergedOptions);
      super(context2, false, nativeMediaStreamAudioDestinationNode, null);
      this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;
    }
    get stream() {
      return this._nativeMediaStreamAudioDestinationNode.stream;
    }
  };
};
var createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class MediaStreamAudioSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode2(nativeContext, options2);
      if (isNativeOfflineAudioContext2(nativeContext)) {
        throw new TypeError();
      }
      super(context2, true, nativeMediaStreamAudioSourceNode, null);
      this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;
    }
    get mediaStream() {
      return this._nativeMediaStreamAudioSourceNode.mediaStream;
    }
  };
};
var createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamTrackAudioSourceNode2, getNativeContext2) => {
  return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode2(nativeContext, options2);
      super(context2, true, nativeMediaStreamTrackAudioSourceNode, null);
    }
  };
};
var createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor2, createAudioListener2, eventTargetConstructor2, isNativeOfflineAudioContext2, unrenderedAudioWorkletNodeStore2, wrapEventListener2) => {
  return class MinimalBaseAudioContext extends eventTargetConstructor2 {
    constructor(_nativeContext, numberOfChannels) {
      super(_nativeContext);
      this._nativeContext = _nativeContext;
      CONTEXT_STORE.set(this, _nativeContext);
      if (isNativeOfflineAudioContext2(_nativeContext)) {
        unrenderedAudioWorkletNodeStore2.set(_nativeContext, /* @__PURE__ */ new Set());
      }
      this._destination = new audioDestinationNodeConstructor2(this, numberOfChannels);
      this._listener = createAudioListener2(this, _nativeContext);
      this._onstatechange = null;
    }
    get currentTime() {
      return this._nativeContext.currentTime;
    }
    get destination() {
      return this._destination;
    }
    get listener() {
      return this._listener;
    }
    get onstatechange() {
      return this._onstatechange;
    }
    set onstatechange(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeContext.onstatechange = wrappedListener;
      const nativeOnStateChange = this._nativeContext.onstatechange;
      this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;
    }
    get sampleRate() {
      return this._nativeContext.sampleRate;
    }
    get state() {
      return this._nativeContext.state;
    }
  };
};
var testPromiseSupport = (nativeContext) => {
  const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
  try {
    const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {
    });
    if (promise === void 0) {
      return false;
    }
    promise.catch(() => {
    });
    return true;
  } catch {
  }
  return false;
};
var createMonitorConnections = (insertElementInSet2, isNativeAudioNode2) => {
  return (nativeAudioNode, whenConnected, whenDisconnected) => {
    const connections = /* @__PURE__ */ new Set();
    nativeAudioNode.connect = ((connect2) => {
      return (destination, output = 0, input2 = 0) => {
        const wasDisconnected = connections.size === 0;
        if (isNativeAudioNode2(destination)) {
          connect2.call(nativeAudioNode, destination, output, input2);
          insertElementInSet2(connections, [destination, output, input2], (connection) => connection[0] === destination && connection[1] === output && connection[2] === input2, true);
          if (wasDisconnected) {
            whenConnected();
          }
          return destination;
        }
        connect2.call(nativeAudioNode, destination, output);
        insertElementInSet2(connections, [destination, output], (connection) => connection[0] === destination && connection[1] === output, true);
        if (wasDisconnected) {
          whenConnected();
        }
        return;
      };
    })(nativeAudioNode.connect);
    nativeAudioNode.disconnect = ((disconnect2) => {
      return (destinationOrOutput, output, input2) => {
        const wasConnected = connections.size > 0;
        if (destinationOrOutput === void 0) {
          disconnect2.apply(nativeAudioNode);
          connections.clear();
        } else if (typeof destinationOrOutput === "number") {
          disconnect2.call(nativeAudioNode, destinationOrOutput);
          for (const connection of connections) {
            if (connection[1] === destinationOrOutput) {
              connections.delete(connection);
            }
          }
        } else {
          if (isNativeAudioNode2(destinationOrOutput)) {
            disconnect2.call(nativeAudioNode, destinationOrOutput, output, input2);
          } else {
            disconnect2.call(nativeAudioNode, destinationOrOutput, output);
          }
          for (const connection of connections) {
            if (connection[0] === destinationOrOutput && (output === void 0 || connection[1] === output) && (input2 === void 0 || connection[2] === input2)) {
              connections.delete(connection);
            }
          }
        }
        const isDisconnected = connections.size === 0;
        if (wasConnected && isDisconnected) {
          whenDisconnected();
        }
      };
    })(nativeAudioNode.disconnect);
    return nativeAudioNode;
  };
};
var assignNativeAudioNodeOption = (nativeAudioNode, options2, option) => {
  const value = options2[option];
  if (value !== void 0 && value !== nativeAudioNode[option]) {
    nativeAudioNode[option] = value;
  }
};
var assignNativeAudioNodeOptions = (nativeAudioNode, options2) => {
  assignNativeAudioNodeOption(nativeAudioNode, options2, "channelCount");
  assignNativeAudioNodeOption(nativeAudioNode, options2, "channelCountMode");
  assignNativeAudioNodeOption(nativeAudioNode, options2, "channelInterpretation");
};
var testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {
  return typeof nativeAnalyserNode.getFloatTimeDomainData === "function";
};
var wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {
  nativeAnalyserNode.getFloatTimeDomainData = (array) => {
    const byteTimeDomainData = new Uint8Array(array.length);
    nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);
    const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);
    for (let i2 = 0; i2 < length; i2 += 1) {
      array[i2] = (byteTimeDomainData[i2] - 128) * 78125e-7;
    }
    return array;
  };
};
var createNativeAnalyserNodeFactory = (cacheTestResult2, createIndexSizeError2) => {
  return (nativeContext, options2) => {
    const nativeAnalyserNode = nativeContext.createAnalyser();
    assignNativeAudioNodeOptions(nativeAnalyserNode, options2);
    if (!(options2.maxDecibels > options2.minDecibels)) {
      throw createIndexSizeError2();
    }
    assignNativeAudioNodeOption(nativeAnalyserNode, options2, "fftSize");
    assignNativeAudioNodeOption(nativeAnalyserNode, options2, "maxDecibels");
    assignNativeAudioNodeOption(nativeAnalyserNode, options2, "minDecibels");
    assignNativeAudioNodeOption(nativeAnalyserNode, options2, "smoothingTimeConstant");
    if (!cacheTestResult2(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {
      wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);
    }
    return nativeAnalyserNode;
  };
};
var createNativeAudioBufferConstructor = (window2) => {
  if (window2 === null) {
    return null;
  }
  if (window2.hasOwnProperty("AudioBuffer")) {
    return window2.AudioBuffer;
  }
  return null;
};
var assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options2, audioParam) => {
  const value = options2[audioParam];
  if (value !== void 0 && value !== nativeAudioNode[audioParam].value) {
    nativeAudioNode[audioParam].value = value;
  }
};
var wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {
  nativeAudioBufferSourceNode.start = ((start22) => {
    let isScheduled = false;
    return (when = 0, offset = 0, duration2) => {
      if (isScheduled) {
        throw createInvalidStateError();
      }
      start22.call(nativeAudioBufferSourceNode, when, offset, duration2);
      isScheduled = true;
    };
  })(nativeAudioBufferSourceNode.start);
};
var wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
  nativeAudioScheduledSourceNode.start = ((start22) => {
    return (when = 0, offset = 0, duration2) => {
      if (typeof duration2 === "number" && duration2 < 0 || offset < 0 || when < 0) {
        throw new RangeError("The parameters can't be negative.");
      }
      start22.call(nativeAudioScheduledSourceNode, when, offset, duration2);
    };
  })(nativeAudioScheduledSourceNode.start);
};
var wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
  nativeAudioScheduledSourceNode.stop = ((stop) => {
    return (when = 0) => {
      if (when < 0) {
        throw new RangeError("The parameter can't be negative.");
      }
      stop.call(nativeAudioScheduledSourceNode, when);
    };
  })(nativeAudioScheduledSourceNode.stop);
};
var createNativeAudioBufferSourceNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
  return (nativeContext, options2) => {
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options2, "playbackRate");
    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "buffer");
    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "loop");
    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "loopEnd");
    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "loopStart");
    if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2(nativeContext))) {
      wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);
    }
    if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport2(nativeContext))) {
      wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);
    }
    if (!cacheTestResult2(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2(nativeContext))) {
      wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeAudioBufferSourceNode, nativeContext);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);
    }
    addSilentConnection2(nativeContext, nativeAudioBufferSourceNode);
    return nativeAudioBufferSourceNode;
  };
};
var createNativeAudioContextConstructor = (window2) => {
  if (window2 === null) {
    return null;
  }
  if (window2.hasOwnProperty("AudioContext")) {
    return window2.AudioContext;
  }
  return window2.hasOwnProperty("webkitAudioContext") ? window2.webkitAudioContext : null;
};
var createNativeAudioDestinationNodeFactory = (createNativeGainNode2, overwriteAccessors2) => {
  return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {
    const nativeAudioDestinationNode = nativeContext.destination;
    if (nativeAudioDestinationNode.channelCount !== channelCount) {
      try {
        nativeAudioDestinationNode.channelCount = channelCount;
      } catch {
      }
    }
    if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== "explicit") {
      nativeAudioDestinationNode.channelCountMode = "explicit";
    }
    if (nativeAudioDestinationNode.maxChannelCount === 0) {
      Object.defineProperty(nativeAudioDestinationNode, "maxChannelCount", {
        value: channelCount
      });
    }
    const gainNode = createNativeGainNode2(nativeContext, {
      channelCount,
      channelCountMode: nativeAudioDestinationNode.channelCountMode,
      channelInterpretation: nativeAudioDestinationNode.channelInterpretation,
      gain: 1
    });
    overwriteAccessors2(gainNode, "channelCount", (get2) => () => get2.call(gainNode), (set) => (value) => {
      set.call(gainNode, value);
      try {
        nativeAudioDestinationNode.channelCount = value;
      } catch (err) {
        if (value > nativeAudioDestinationNode.maxChannelCount) {
          throw err;
        }
      }
    });
    overwriteAccessors2(gainNode, "channelCountMode", (get2) => () => get2.call(gainNode), (set) => (value) => {
      set.call(gainNode, value);
      nativeAudioDestinationNode.channelCountMode = value;
    });
    overwriteAccessors2(gainNode, "channelInterpretation", (get2) => () => get2.call(gainNode), (set) => (value) => {
      set.call(gainNode, value);
      nativeAudioDestinationNode.channelInterpretation = value;
    });
    Object.defineProperty(gainNode, "maxChannelCount", {
      get: () => nativeAudioDestinationNode.maxChannelCount
    });
    gainNode.connect(nativeAudioDestinationNode);
    return gainNode;
  };
};
var createNativeAudioWorkletNodeConstructor = (window2) => {
  if (window2 === null) {
    return null;
  }
  return window2.hasOwnProperty("AudioWorkletNode") ? window2.AudioWorkletNode : null;
};
var testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
  const { port1 } = new MessageChannel();
  try {
    port1.postMessage(audioWorkletNodeOptions);
  } finally {
    port1.close();
  }
};
var createNativeAudioWorkletNodeFactory = (createInvalidStateError2, createNativeAudioWorkletNodeFaker2, createNativeGainNode2, createNotSupportedError2, monitorConnections2) => {
  return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor2, name2, processorConstructor, options2) => {
    if (nativeAudioWorkletNodeConstructor2 !== null) {
      try {
        const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeContext, name2, options2);
        const patchedEventListeners = /* @__PURE__ */ new Map();
        let onprocessorerror = null;
        Object.defineProperties(nativeAudioWorkletNode, {
          channelCount: {
            get: () => options2.channelCount,
            set: () => {
              throw createInvalidStateError2();
            }
          },
          channelCountMode: {
            get: () => "explicit",
            set: () => {
              throw createInvalidStateError2();
            }
          },
          onprocessorerror: {
            get: () => onprocessorerror,
            set: (value) => {
              if (typeof onprocessorerror === "function") {
                nativeAudioWorkletNode.removeEventListener("processorerror", onprocessorerror);
              }
              onprocessorerror = typeof value === "function" ? value : null;
              if (typeof onprocessorerror === "function") {
                nativeAudioWorkletNode.addEventListener("processorerror", onprocessorerror);
              }
            }
          }
        });
        nativeAudioWorkletNode.addEventListener = ((addEventListener) => {
          return (...args) => {
            if (args[0] === "processorerror") {
              const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
              if (unpatchedEventListener !== null) {
                const patchedEventListener = patchedEventListeners.get(args[1]);
                if (patchedEventListener !== void 0) {
                  args[1] = patchedEventListener;
                } else {
                  args[1] = (event) => {
                    if (event.type === "error") {
                      Object.defineProperties(event, {
                        type: { value: "processorerror" }
                      });
                      unpatchedEventListener(event);
                    } else {
                      unpatchedEventListener(new ErrorEvent(args[0], { ...event }));
                    }
                  };
                  patchedEventListeners.set(unpatchedEventListener, args[1]);
                }
              }
            }
            addEventListener.call(nativeAudioWorkletNode, "error", args[1], args[2]);
            return addEventListener.call(nativeAudioWorkletNode, ...args);
          };
        })(nativeAudioWorkletNode.addEventListener);
        nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {
          return (...args) => {
            if (args[0] === "processorerror") {
              const patchedEventListener = patchedEventListeners.get(args[1]);
              if (patchedEventListener !== void 0) {
                patchedEventListeners.delete(args[1]);
                args[1] = patchedEventListener;
              }
            }
            removeEventListener.call(nativeAudioWorkletNode, "error", args[1], args[2]);
            return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);
          };
        })(nativeAudioWorkletNode.removeEventListener);
        if (options2.numberOfOutputs !== 0) {
          const nativeGainNode = createNativeGainNode2(nativeContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            gain: 0
          });
          nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);
          const whenConnected = () => nativeGainNode.disconnect();
          const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);
          return monitorConnections2(nativeAudioWorkletNode, whenConnected, whenDisconnected);
        }
        return nativeAudioWorkletNode;
      } catch (err) {
        if (err.code === 11) {
          throw createNotSupportedError2();
        }
        throw err;
      }
    }
    if (processorConstructor === void 0) {
      throw createNotSupportedError2();
    }
    testClonabilityOfAudioWorkletNodeOptions(options2);
    return createNativeAudioWorkletNodeFaker2(nativeContext, baseLatency, processorConstructor, options2);
  };
};
var computeBufferSize = (baseLatency, sampleRate) => {
  if (baseLatency === null) {
    return 512;
  }
  return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));
};
var cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
  return new Promise((resolve, reject) => {
    const { port1, port2 } = new MessageChannel();
    port1.onmessage = ({ data }) => {
      port1.close();
      port2.close();
      resolve(data);
    };
    port1.onmessageerror = ({ data }) => {
      port1.close();
      port2.close();
      reject(data);
    };
    port2.postMessage(audioWorkletNodeOptions);
  });
};
var createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {
  const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);
  return new processorConstructor(clonedAudioWorkletNodeOptions);
};
var createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {
  let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);
  if (nodeToProcessorMap === void 0) {
    nodeToProcessorMap = /* @__PURE__ */ new WeakMap();
    NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);
  }
  const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);
  nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);
  return audioWorkletProcessorPromise;
};
var createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs2, createIndexSizeError2, createInvalidStateError2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNotSupportedError2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getActiveAudioWorkletNodeInputs2, monitorConnections2) => {
  return (nativeContext, baseLatency, processorConstructor, options2) => {
    if (options2.numberOfInputs === 0 && options2.numberOfOutputs === 0) {
      throw createNotSupportedError2();
    }
    const outputChannelCount = Array.isArray(options2.outputChannelCount) ? options2.outputChannelCount : Array.from(options2.outputChannelCount);
    if (outputChannelCount.some((channelCount) => channelCount < 1)) {
      throw createNotSupportedError2();
    }
    if (outputChannelCount.length !== options2.numberOfOutputs) {
      throw createIndexSizeError2();
    }
    if (options2.channelCountMode !== "explicit") {
      throw createNotSupportedError2();
    }
    const numberOfInputChannels = options2.channelCount * options2.numberOfInputs;
    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
    const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {
      throw createNotSupportedError2();
    }
    const messageChannel = new MessageChannel();
    const gainNodes = [];
    const inputChannelSplitterNodes = [];
    for (let i2 = 0; i2 < options2.numberOfInputs; i2 += 1) {
      gainNodes.push(createNativeGainNode2(nativeContext, {
        channelCount: options2.channelCount,
        channelCountMode: options2.channelCountMode,
        channelInterpretation: options2.channelInterpretation,
        gain: 1
      }));
      inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(nativeContext, {
        channelCount: options2.channelCount,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: options2.channelCount
      }));
    }
    const constantSourceNodes = [];
    if (processorConstructor.parameterDescriptors !== void 0) {
      for (const { defaultValue, maxValue, minValue, name: name2 } of processorConstructor.parameterDescriptors) {
        const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          offset: options2.parameterData[name2] !== void 0 ? options2.parameterData[name2] : defaultValue === void 0 ? 0 : defaultValue
        });
        Object.defineProperties(constantSourceNode.offset, {
          defaultValue: {
            get: () => defaultValue === void 0 ? 0 : defaultValue
          },
          maxValue: {
            get: () => maxValue === void 0 ? MOST_POSITIVE_SINGLE_FLOAT : maxValue
          },
          minValue: {
            get: () => minValue === void 0 ? MOST_NEGATIVE_SINGLE_FLOAT : minValue
          }
        });
        constantSourceNodes.push(constantSourceNode);
      }
    }
    const inputChannelMergerNode = createNativeChannelMergerNode2(nativeContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
    });
    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
    const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, Math.max(1, numberOfOutputChannels));
    const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
      channelCount: Math.max(1, numberOfOutputChannels),
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: Math.max(1, numberOfOutputChannels)
    });
    const outputChannelMergerNodes = [];
    for (let i2 = 0; i2 < options2.numberOfOutputs; i2 += 1) {
      outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "speakers",
        numberOfInputs: outputChannelCount[i2]
      }));
    }
    for (let i2 = 0; i2 < options2.numberOfInputs; i2 += 1) {
      gainNodes[i2].connect(inputChannelSplitterNodes[i2]);
      for (let j2 = 0; j2 < options2.channelCount; j2 += 1) {
        inputChannelSplitterNodes[i2].connect(inputChannelMergerNode, j2, i2 * options2.channelCount + j2);
      }
    }
    const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.map(({ name: name2 }, index2) => {
      const constantSourceNode = constantSourceNodes[index2];
      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index2);
      constantSourceNode.start(0);
      return [name2, constantSourceNode.offset];
    }));
    inputChannelMergerNode.connect(scriptProcessorNode);
    let channelInterpretation = options2.channelInterpretation;
    let onprocessorerror = null;
    const outputAudioNodes = options2.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;
    const nativeAudioWorkletNodeFaker = {
      get bufferSize() {
        return bufferSize;
      },
      get channelCount() {
        return options2.channelCount;
      },
      set channelCount(_) {
        throw createInvalidStateError2();
      },
      get channelCountMode() {
        return options2.channelCountMode;
      },
      set channelCountMode(_) {
        throw createInvalidStateError2();
      },
      get channelInterpretation() {
        return channelInterpretation;
      },
      set channelInterpretation(value) {
        for (const gainNode of gainNodes) {
          gainNode.channelInterpretation = value;
        }
        channelInterpretation = value;
      },
      get context() {
        return scriptProcessorNode.context;
      },
      get inputs() {
        return gainNodes;
      },
      get numberOfInputs() {
        return options2.numberOfInputs;
      },
      get numberOfOutputs() {
        return options2.numberOfOutputs;
      },
      get onprocessorerror() {
        return onprocessorerror;
      },
      set onprocessorerror(value) {
        if (typeof onprocessorerror === "function") {
          nativeAudioWorkletNodeFaker.removeEventListener("processorerror", onprocessorerror);
        }
        onprocessorerror = typeof value === "function" ? value : null;
        if (typeof onprocessorerror === "function") {
          nativeAudioWorkletNodeFaker.addEventListener("processorerror", onprocessorerror);
        }
      },
      get parameters() {
        return parameterMap;
      },
      get port() {
        return messageChannel.port2;
      },
      addEventListener(...args) {
        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
      },
      connect: connectMultipleOutputs2.bind(null, outputAudioNodes),
      disconnect: disconnectMultipleOutputs2.bind(null, outputAudioNodes),
      dispatchEvent(...args) {
        return scriptProcessorNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    const patchedEventListeners = /* @__PURE__ */ new Map();
    messageChannel.port1.addEventListener = ((addEventListener) => {
      return (...args) => {
        if (args[0] === "message") {
          const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
          if (unpatchedEventListener !== null) {
            const patchedEventListener = patchedEventListeners.get(args[1]);
            if (patchedEventListener !== void 0) {
              args[1] = patchedEventListener;
            } else {
              args[1] = (event) => {
                exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));
              };
              patchedEventListeners.set(unpatchedEventListener, args[1]);
            }
          }
        }
        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
      };
    })(messageChannel.port1.addEventListener);
    messageChannel.port1.removeEventListener = ((removeEventListener) => {
      return (...args) => {
        if (args[0] === "message") {
          const patchedEventListener = patchedEventListeners.get(args[1]);
          if (patchedEventListener !== void 0) {
            patchedEventListeners.delete(args[1]);
            args[1] = patchedEventListener;
          }
        }
        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
      };
    })(messageChannel.port1.removeEventListener);
    let onmessage = null;
    Object.defineProperty(messageChannel.port1, "onmessage", {
      get: () => onmessage,
      set: (value) => {
        if (typeof onmessage === "function") {
          messageChannel.port1.removeEventListener("message", onmessage);
        }
        onmessage = typeof value === "function" ? value : null;
        if (typeof onmessage === "function") {
          messageChannel.port1.addEventListener("message", onmessage);
          messageChannel.port1.start();
        }
      }
    });
    processorConstructor.prototype.port = messageChannel.port1;
    let audioWorkletProcessor = null;
    const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options2);
    audioWorkletProcessorPromise.then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);
    const inputs = createNestedArrays(options2.numberOfInputs, options2.channelCount);
    const outputs = createNestedArrays(options2.numberOfOutputs, outputChannelCount);
    const parameters = processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, { name: name2 }) => ({ ...prmtrs, [name2]: new Float32Array(128) }), {});
    let isActive = true;
    const disconnectOutputsGraph = () => {
      if (options2.numberOfOutputs > 0) {
        scriptProcessorNode.disconnect(outputChannelSplitterNode);
      }
      for (let i2 = 0, outputChannelSplitterNodeOutput = 0; i2 < options2.numberOfOutputs; i2 += 1) {
        const outputChannelMergerNode = outputChannelMergerNodes[i2];
        for (let j2 = 0; j2 < outputChannelCount[i2]; j2 += 1) {
          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
        }
        outputChannelSplitterNodeOutput += outputChannelCount[i2];
      }
    };
    const activeInputIndexes = /* @__PURE__ */ new Map();
    scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {
      if (audioWorkletProcessor !== null) {
        const activeInputs = getActiveAudioWorkletNodeInputs2(nativeAudioWorkletNodeFaker);
        for (let i2 = 0; i2 < bufferSize; i2 += 128) {
          for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
            for (let k2 = 0; k2 < options2.channelCount; k2 += 1) {
              copyFromChannel(inputBuffer, inputs[j2], k2, k2, i2);
            }
          }
          if (processorConstructor.parameterDescriptors !== void 0) {
            processorConstructor.parameterDescriptors.forEach(({ name: name2 }, index2) => {
              copyFromChannel(inputBuffer, parameters, name2, numberOfInputChannels + index2, i2);
            });
          }
          for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
            for (let k2 = 0; k2 < outputChannelCount[j2]; k2 += 1) {
              if (outputs[j2][k2].byteLength === 0) {
                outputs[j2][k2] = new Float32Array(128);
              }
            }
          }
          try {
            const potentiallyEmptyInputs = inputs.map((input2, index2) => {
              const activeInput = activeInputs[index2];
              if (activeInput.size > 0) {
                activeInputIndexes.set(index2, bufferSize / 128);
                return input2;
              }
              const count = activeInputIndexes.get(index2);
              if (count === void 0) {
                return [];
              }
              if (input2.every((channelData) => channelData.every((sample) => sample === 0))) {
                if (count === 1) {
                  activeInputIndexes.delete(index2);
                } else {
                  activeInputIndexes.set(index2, count - 1);
                }
              }
              return input2;
            });
            const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime + i2 / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));
            isActive = activeSourceFlag;
            for (let j2 = 0, outputChannelSplitterNodeOutput = 0; j2 < options2.numberOfOutputs; j2 += 1) {
              for (let k2 = 0; k2 < outputChannelCount[j2]; k2 += 1) {
                copyToChannel(outputBuffer, outputs[j2], k2, outputChannelSplitterNodeOutput + k2, i2);
              }
              outputChannelSplitterNodeOutput += outputChannelCount[j2];
            }
          } catch (error) {
            isActive = false;
            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent("processorerror", {
              colno: error.colno,
              filename: error.filename,
              lineno: error.lineno,
              message: error.message
            }));
          }
          if (!isActive) {
            for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
              gainNodes[j2].disconnect(inputChannelSplitterNodes[j2]);
              for (let k2 = 0; k2 < options2.channelCount; k2 += 1) {
                inputChannelSplitterNodes[i2].disconnect(inputChannelMergerNode, k2, j2 * options2.channelCount + k2);
              }
            }
            if (processorConstructor.parameterDescriptors !== void 0) {
              const length = processorConstructor.parameterDescriptors.length;
              for (let j2 = 0; j2 < length; j2 += 1) {
                const constantSourceNode = constantSourceNodes[j2];
                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j2);
                constantSourceNode.stop();
              }
            }
            inputChannelMergerNode.disconnect(scriptProcessorNode);
            scriptProcessorNode.onaudioprocess = null;
            if (isConnected) {
              disconnectOutputsGraph();
            } else {
              disconnectFakeGraph();
            }
            break;
          }
        }
      }
    };
    let isConnected = false;
    const nativeGainNode = createNativeGainNode2(nativeContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: 0
    });
    const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);
    const disconnectFakeGraph = () => {
      scriptProcessorNode.disconnect(nativeGainNode);
      nativeGainNode.disconnect();
    };
    const whenConnected = () => {
      if (isActive) {
        disconnectFakeGraph();
        if (options2.numberOfOutputs > 0) {
          scriptProcessorNode.connect(outputChannelSplitterNode);
        }
        for (let i2 = 0, outputChannelSplitterNodeOutput = 0; i2 < options2.numberOfOutputs; i2 += 1) {
          const outputChannelMergerNode = outputChannelMergerNodes[i2];
          for (let j2 = 0; j2 < outputChannelCount[i2]; j2 += 1) {
            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
          }
          outputChannelSplitterNodeOutput += outputChannelCount[i2];
        }
      }
      isConnected = true;
    };
    const whenDisconnected = () => {
      if (isActive) {
        connectFakeGraph();
        disconnectOutputsGraph();
      }
      isConnected = false;
    };
    connectFakeGraph();
    return monitorConnections2(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);
  };
};
var createNativeBiquadFilterNode = (nativeContext, options2) => {
  const nativeBiquadFilterNode = nativeContext.createBiquadFilter();
  assignNativeAudioNodeOptions(nativeBiquadFilterNode, options2);
  assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "Q");
  assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "detune");
  assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "frequency");
  assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "gain");
  assignNativeAudioNodeOption(nativeBiquadFilterNode, options2, "type");
  return nativeBiquadFilterNode;
};
var createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor2, wrapChannelMergerNode2) => {
  return (nativeContext, options2) => {
    const nativeChannelMergerNode = nativeContext.createChannelMerger(options2.numberOfInputs);
    if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
      wrapChannelMergerNode2(nativeContext, nativeChannelMergerNode);
    }
    assignNativeAudioNodeOptions(nativeChannelMergerNode, options2);
    return nativeChannelMergerNode;
  };
};
var wrapChannelSplitterNode = (channelSplitterNode) => {
  const channelCount = channelSplitterNode.numberOfOutputs;
  Object.defineProperty(channelSplitterNode, "channelCount", {
    get: () => channelCount,
    set: (value) => {
      if (value !== channelCount) {
        throw createInvalidStateError();
      }
    }
  });
  Object.defineProperty(channelSplitterNode, "channelCountMode", {
    get: () => "explicit",
    set: (value) => {
      if (value !== "explicit") {
        throw createInvalidStateError();
      }
    }
  });
  Object.defineProperty(channelSplitterNode, "channelInterpretation", {
    get: () => "discrete",
    set: (value) => {
      if (value !== "discrete") {
        throw createInvalidStateError();
      }
    }
  });
};
var createNativeChannelSplitterNode = (nativeContext, options2) => {
  const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options2.numberOfOutputs);
  assignNativeAudioNodeOptions(nativeChannelSplitterNode, options2);
  wrapChannelSplitterNode(nativeChannelSplitterNode);
  return nativeChannelSplitterNode;
};
var createNativeConstantSourceNodeFactory = (addSilentConnection2, cacheTestResult2, createNativeConstantSourceNodeFaker2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2) => {
  return (nativeContext, options2) => {
    if (nativeContext.createConstantSource === void 0) {
      return createNativeConstantSourceNodeFaker2(nativeContext, options2);
    }
    const nativeConstantSourceNode = nativeContext.createConstantSource();
    assignNativeAudioNodeOptions(nativeConstantSourceNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options2, "offset");
    if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);
    }
    addSilentConnection2(nativeContext, nativeConstantSourceNode);
    return nativeConstantSourceNode;
  };
};
var interceptConnections = (original, interceptor) => {
  original.connect = interceptor.connect.bind(interceptor);
  original.disconnect = interceptor.disconnect.bind(interceptor);
  return original;
};
var createNativeConstantSourceNodeFakerFactory = (addSilentConnection2, createNativeAudioBufferSourceNode2, createNativeGainNode2, monitorConnections2) => {
  return (nativeContext, { offset, ...audioNodeOptions }) => {
    const audioBuffer = nativeContext.createBuffer(1, 2, 44100);
    const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
      buffer: null,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    });
    const gainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: offset });
    const channelData = audioBuffer.getChannelData(0);
    channelData[0] = 1;
    channelData[1] = 1;
    audioBufferSourceNode.buffer = audioBuffer;
    audioBufferSourceNode.loop = true;
    const nativeConstantSourceNodeFaker = {
      get bufferSize() {
        return void 0;
      },
      get channelCount() {
        return gainNode.channelCount;
      },
      set channelCount(value) {
        gainNode.channelCount = value;
      },
      get channelCountMode() {
        return gainNode.channelCountMode;
      },
      set channelCountMode(value) {
        gainNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return gainNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        gainNode.channelInterpretation = value;
      },
      get context() {
        return gainNode.context;
      },
      get inputs() {
        return [];
      },
      get numberOfInputs() {
        return audioBufferSourceNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return gainNode.numberOfOutputs;
      },
      get offset() {
        return gainNode.gain;
      },
      get onended() {
        return audioBufferSourceNode.onended;
      },
      set onended(value) {
        audioBufferSourceNode.onended = value;
      },
      addEventListener(...args) {
        return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return audioBufferSourceNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);
      },
      start(when = 0) {
        audioBufferSourceNode.start.call(audioBufferSourceNode, when);
      },
      stop(when = 0) {
        audioBufferSourceNode.stop.call(audioBufferSourceNode, when);
      }
    };
    const whenConnected = () => audioBufferSourceNode.connect(gainNode);
    const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);
    addSilentConnection2(nativeContext, audioBufferSourceNode);
    return monitorConnections2(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);
  };
};
var createNativeConvolverNodeFactory = (createNotSupportedError2, overwriteAccessors2) => {
  return (nativeContext, options2) => {
    const nativeConvolverNode = nativeContext.createConvolver();
    assignNativeAudioNodeOptions(nativeConvolverNode, options2);
    if (options2.disableNormalization === nativeConvolverNode.normalize) {
      nativeConvolverNode.normalize = !options2.disableNormalization;
    }
    assignNativeAudioNodeOption(nativeConvolverNode, options2, "buffer");
    if (options2.channelCount > 2) {
      throw createNotSupportedError2();
    }
    overwriteAccessors2(nativeConvolverNode, "channelCount", (get2) => () => get2.call(nativeConvolverNode), (set) => (value) => {
      if (value > 2) {
        throw createNotSupportedError2();
      }
      return set.call(nativeConvolverNode, value);
    });
    if (options2.channelCountMode === "max") {
      throw createNotSupportedError2();
    }
    overwriteAccessors2(nativeConvolverNode, "channelCountMode", (get2) => () => get2.call(nativeConvolverNode), (set) => (value) => {
      if (value === "max") {
        throw createNotSupportedError2();
      }
      return set.call(nativeConvolverNode, value);
    });
    return nativeConvolverNode;
  };
};
var createNativeDelayNode = (nativeContext, options2) => {
  const nativeDelayNode = nativeContext.createDelay(options2.maxDelayTime);
  assignNativeAudioNodeOptions(nativeDelayNode, options2);
  assignNativeAudioNodeAudioParamValue(nativeDelayNode, options2, "delayTime");
  return nativeDelayNode;
};
var createNativeDynamicsCompressorNodeFactory = (createNotSupportedError2) => {
  return (nativeContext, options2) => {
    const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();
    assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options2);
    if (options2.channelCount > 2) {
      throw createNotSupportedError2();
    }
    if (options2.channelCountMode === "max") {
      throw createNotSupportedError2();
    }
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "attack");
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "knee");
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "ratio");
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "release");
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "threshold");
    return nativeDynamicsCompressorNode;
  };
};
var createNativeGainNode = (nativeContext, options2) => {
  const nativeGainNode = nativeContext.createGain();
  assignNativeAudioNodeOptions(nativeGainNode, options2);
  assignNativeAudioNodeAudioParamValue(nativeGainNode, options2, "gain");
  return nativeGainNode;
};
var createNativeIIRFilterNodeFactory = (createNativeIIRFilterNodeFaker2) => {
  return (nativeContext, baseLatency, options2) => {
    if (nativeContext.createIIRFilter === void 0) {
      return createNativeIIRFilterNodeFaker2(nativeContext, baseLatency, options2);
    }
    const nativeIIRFilterNode = nativeContext.createIIRFilter(options2.feedforward, options2.feedback);
    assignNativeAudioNodeOptions(nativeIIRFilterNode, options2);
    return nativeIIRFilterNode;
  };
};
function divide(a2, b2) {
  const denominator = b2[0] * b2[0] + b2[1] * b2[1];
  return [(a2[0] * b2[0] + a2[1] * b2[1]) / denominator, (a2[1] * b2[0] - a2[0] * b2[1]) / denominator];
}
function multiply(a2, b2) {
  return [a2[0] * b2[0] - a2[1] * b2[1], a2[0] * b2[1] + a2[1] * b2[0]];
}
function evaluatePolynomial(coefficient, z) {
  let result = [0, 0];
  for (let i2 = coefficient.length - 1; i2 >= 0; i2 -= 1) {
    result = multiply(result, z);
    result[0] += coefficient[i2];
  }
  return result;
}
var createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError2, createInvalidStateError2, createNativeScriptProcessorNode2, createNotSupportedError2) => {
  return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {
    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
    const feedbackLength = convertedFeedback.length;
    const feedforwardLength = convertedFeedforward.length;
    const minLength = Math.min(feedbackLength, feedforwardLength);
    if (feedbackLength === 0 || feedbackLength > 20) {
      throw createNotSupportedError2();
    }
    if (convertedFeedback[0] === 0) {
      throw createInvalidStateError2();
    }
    if (feedforwardLength === 0 || feedforwardLength > 20) {
      throw createNotSupportedError2();
    }
    if (convertedFeedforward[0] === 0) {
      throw createInvalidStateError2();
    }
    if (convertedFeedback[0] !== 1) {
      for (let i2 = 0; i2 < feedforwardLength; i2 += 1) {
        convertedFeedforward[i2] /= convertedFeedback[0];
      }
      for (let i2 = 1; i2 < feedbackLength; i2 += 1) {
        convertedFeedback[i2] /= convertedFeedback[0];
      }
    }
    const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, bufferSize, channelCount, channelCount);
    scriptProcessorNode.channelCount = channelCount;
    scriptProcessorNode.channelCountMode = channelCountMode;
    scriptProcessorNode.channelInterpretation = channelInterpretation;
    const bufferLength = 32;
    const bufferIndexes = [];
    const xBuffers = [];
    const yBuffers = [];
    for (let i2 = 0; i2 < channelCount; i2 += 1) {
      bufferIndexes.push(0);
      const xBuffer = new Float32Array(bufferLength);
      const yBuffer = new Float32Array(bufferLength);
      xBuffer.fill(0);
      yBuffer.fill(0);
      xBuffers.push(xBuffer);
      yBuffers.push(yBuffer);
    }
    scriptProcessorNode.onaudioprocess = (event) => {
      const inputBuffer = event.inputBuffer;
      const outputBuffer = event.outputBuffer;
      const numberOfChannels = inputBuffer.numberOfChannels;
      for (let i2 = 0; i2 < numberOfChannels; i2 += 1) {
        const input2 = inputBuffer.getChannelData(i2);
        const output = outputBuffer.getChannelData(i2);
        bufferIndexes[i2] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[i2], yBuffers[i2], bufferIndexes[i2], bufferLength, input2, output);
      }
    };
    const nyquist = nativeContext.sampleRate / 2;
    const nativeIIRFilterNodeFaker = {
      get bufferSize() {
        return bufferSize;
      },
      get channelCount() {
        return scriptProcessorNode.channelCount;
      },
      set channelCount(value) {
        scriptProcessorNode.channelCount = value;
      },
      get channelCountMode() {
        return scriptProcessorNode.channelCountMode;
      },
      set channelCountMode(value) {
        scriptProcessorNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return scriptProcessorNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        scriptProcessorNode.channelInterpretation = value;
      },
      get context() {
        return scriptProcessorNode.context;
      },
      get inputs() {
        return [scriptProcessorNode];
      },
      get numberOfInputs() {
        return scriptProcessorNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return scriptProcessorNode.numberOfOutputs;
      },
      addEventListener(...args) {
        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return scriptProcessorNode.dispatchEvent(args[0]);
      },
      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
          throw createInvalidAccessError2();
        }
        const length = frequencyHz.length;
        for (let i2 = 0; i2 < length; i2 += 1) {
          const omega = -Math.PI * (frequencyHz[i2] / nyquist);
          const z = [Math.cos(omega), Math.sin(omega)];
          const numerator = evaluatePolynomial(convertedFeedforward, z);
          const denominator = evaluatePolynomial(convertedFeedback, z);
          const response = divide(numerator, denominator);
          magResponse[i2] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
          phaseResponse[i2] = Math.atan2(response[1], response[0]);
        }
      },
      removeEventListener(...args) {
        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);
  };
};
var createNativeMediaElementAudioSourceNode = (nativeAudioContext, options2) => {
  return nativeAudioContext.createMediaElementSource(options2.mediaElement);
};
var createNativeMediaStreamAudioDestinationNode = (nativeAudioContext, options2) => {
  const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();
  assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options2);
  if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {
    Object.defineProperty(nativeMediaStreamAudioDestinationNode, "numberOfOutputs", { get: () => 0 });
  }
  return nativeMediaStreamAudioDestinationNode;
};
var createNativeMediaStreamAudioSourceNode = (nativeAudioContext, { mediaStream }) => {
  const audioStreamTracks = mediaStream.getAudioTracks();
  audioStreamTracks.sort((a2, b2) => a2.id < b2.id ? -1 : a2.id > b2.id ? 1 : 0);
  const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);
  const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));
  Object.defineProperty(nativeMediaStreamAudioSourceNode, "mediaStream", { value: mediaStream });
  return nativeMediaStreamAudioSourceNode;
};
var createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError2, isNativeOfflineAudioContext2) => {
  return (nativeAudioContext, { mediaStreamTrack }) => {
    if (typeof nativeAudioContext.createMediaStreamTrackSource === "function") {
      return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);
    }
    const mediaStream = new MediaStream([mediaStreamTrack]);
    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);
    if (mediaStreamTrack.kind !== "audio") {
      throw createInvalidStateError2();
    }
    if (isNativeOfflineAudioContext2(nativeAudioContext)) {
      throw new TypeError();
    }
    return nativeMediaStreamAudioSourceNode;
  };
};
var createNativeOfflineAudioContextConstructor = (window2) => {
  if (window2 === null) {
    return null;
  }
  if (window2.hasOwnProperty("OfflineAudioContext")) {
    return window2.OfflineAudioContext;
  }
  return window2.hasOwnProperty("webkitOfflineAudioContext") ? window2.webkitOfflineAudioContext : null;
};
var createNativeOscillatorNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
  return (nativeContext, options2) => {
    const nativeOscillatorNode = nativeContext.createOscillator();
    assignNativeAudioNodeOptions(nativeOscillatorNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options2, "detune");
    assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options2, "frequency");
    if (options2.periodicWave !== void 0) {
      nativeOscillatorNode.setPeriodicWave(options2.periodicWave);
    } else {
      assignNativeAudioNodeOption(nativeOscillatorNode, options2, "type");
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeOscillatorNode, nativeContext);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);
    }
    addSilentConnection2(nativeContext, nativeOscillatorNode);
    return nativeOscillatorNode;
  };
};
var createNativePannerNodeFactory = (createNativePannerNodeFaker2) => {
  return (nativeContext, options2) => {
    const nativePannerNode = nativeContext.createPanner();
    if (nativePannerNode.orientationX === void 0) {
      return createNativePannerNodeFaker2(nativeContext, options2);
    }
    assignNativeAudioNodeOptions(nativePannerNode, options2);
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "orientationX");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "orientationY");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "orientationZ");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "positionX");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "positionY");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "positionZ");
    assignNativeAudioNodeOption(nativePannerNode, options2, "coneInnerAngle");
    assignNativeAudioNodeOption(nativePannerNode, options2, "coneOuterAngle");
    assignNativeAudioNodeOption(nativePannerNode, options2, "coneOuterGain");
    assignNativeAudioNodeOption(nativePannerNode, options2, "distanceModel");
    assignNativeAudioNodeOption(nativePannerNode, options2, "maxDistance");
    assignNativeAudioNodeOption(nativePannerNode, options2, "panningModel");
    assignNativeAudioNodeOption(nativePannerNode, options2, "refDistance");
    assignNativeAudioNodeOption(nativePannerNode, options2, "rolloffFactor");
    return nativePannerNode;
  };
};
var createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode2, createInvalidStateError2, createNativeChannelMergerNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNativeWaveShaperNode2, createNotSupportedError2, disconnectNativeAudioNodeFromNativeAudioNode2, getFirstSample2, monitorConnections2) => {
  return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {
    const pannerNode = nativeContext.createPanner();
    if (audioNodeOptions.channelCount > 2) {
      throw createNotSupportedError2();
    }
    if (audioNodeOptions.channelCountMode === "max") {
      throw createNotSupportedError2();
    }
    assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);
    const SINGLE_CHANNEL_OPTIONS = {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete"
    };
    const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
      ...SINGLE_CHANNEL_OPTIONS,
      channelInterpretation: "speakers",
      numberOfInputs: 6
    });
    const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
    const orientationXGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });
    const orientationYGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const orientationZGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const positionXGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const positionYGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const positionZGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 6, 1);
    const waveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_OPTIONS,
      curve: new Float32Array([1, 1]),
      oversample: "none"
    });
    let lastOrientation = [orientationX, orientationY, orientationZ];
    let lastPosition = [positionX, positionY, positionZ];
    const buffer = new Float32Array(1);
    scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
      const orientation = [
        getFirstSample2(inputBuffer, buffer, 0),
        getFirstSample2(inputBuffer, buffer, 1),
        getFirstSample2(inputBuffer, buffer, 2)
      ];
      if (orientation.some((value, index2) => value !== lastOrientation[index2])) {
        pannerNode.setOrientation(...orientation);
        lastOrientation = orientation;
      }
      const positon = [
        getFirstSample2(inputBuffer, buffer, 3),
        getFirstSample2(inputBuffer, buffer, 4),
        getFirstSample2(inputBuffer, buffer, 5)
      ];
      if (positon.some((value, index2) => value !== lastPosition[index2])) {
        pannerNode.setPosition(...positon);
        lastPosition = positon;
      }
    };
    Object.defineProperty(orientationYGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(orientationZGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(positionXGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(positionYGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(positionZGainNode.gain, "defaultValue", { get: () => 0 });
    const nativePannerNodeFaker = {
      get bufferSize() {
        return void 0;
      },
      get channelCount() {
        return pannerNode.channelCount;
      },
      set channelCount(value) {
        if (value > 2) {
          throw createNotSupportedError2();
        }
        inputGainNode.channelCount = value;
        pannerNode.channelCount = value;
      },
      get channelCountMode() {
        return pannerNode.channelCountMode;
      },
      set channelCountMode(value) {
        if (value === "max") {
          throw createNotSupportedError2();
        }
        inputGainNode.channelCountMode = value;
        pannerNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return pannerNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        inputGainNode.channelInterpretation = value;
        pannerNode.channelInterpretation = value;
      },
      get coneInnerAngle() {
        return pannerNode.coneInnerAngle;
      },
      set coneInnerAngle(value) {
        pannerNode.coneInnerAngle = value;
      },
      get coneOuterAngle() {
        return pannerNode.coneOuterAngle;
      },
      set coneOuterAngle(value) {
        pannerNode.coneOuterAngle = value;
      },
      get coneOuterGain() {
        return pannerNode.coneOuterGain;
      },
      set coneOuterGain(value) {
        if (value < 0 || value > 1) {
          throw createInvalidStateError2();
        }
        pannerNode.coneOuterGain = value;
      },
      get context() {
        return pannerNode.context;
      },
      get distanceModel() {
        return pannerNode.distanceModel;
      },
      set distanceModel(value) {
        pannerNode.distanceModel = value;
      },
      get inputs() {
        return [inputGainNode];
      },
      get maxDistance() {
        return pannerNode.maxDistance;
      },
      set maxDistance(value) {
        if (value < 0) {
          throw new RangeError();
        }
        pannerNode.maxDistance = value;
      },
      get numberOfInputs() {
        return pannerNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return pannerNode.numberOfOutputs;
      },
      get orientationX() {
        return orientationXGainNode.gain;
      },
      get orientationY() {
        return orientationYGainNode.gain;
      },
      get orientationZ() {
        return orientationZGainNode.gain;
      },
      get panningModel() {
        return pannerNode.panningModel;
      },
      set panningModel(value) {
        pannerNode.panningModel = value;
      },
      get positionX() {
        return positionXGainNode.gain;
      },
      get positionY() {
        return positionYGainNode.gain;
      },
      get positionZ() {
        return positionZGainNode.gain;
      },
      get refDistance() {
        return pannerNode.refDistance;
      },
      set refDistance(value) {
        if (value < 0) {
          throw new RangeError();
        }
        pannerNode.refDistance = value;
      },
      get rolloffFactor() {
        return pannerNode.rolloffFactor;
      },
      set rolloffFactor(value) {
        if (value < 0) {
          throw new RangeError();
        }
        pannerNode.rolloffFactor = value;
      },
      addEventListener(...args) {
        return inputGainNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return inputGainNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return inputGainNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {
      nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;
    }
    if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {
      nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;
    }
    if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {
      nativePannerNodeFaker.coneOuterGain = coneOuterGain;
    }
    if (distanceModel !== nativePannerNodeFaker.distanceModel) {
      nativePannerNodeFaker.distanceModel = distanceModel;
    }
    if (maxDistance !== nativePannerNodeFaker.maxDistance) {
      nativePannerNodeFaker.maxDistance = maxDistance;
    }
    if (orientationX !== nativePannerNodeFaker.orientationX.value) {
      nativePannerNodeFaker.orientationX.value = orientationX;
    }
    if (orientationY !== nativePannerNodeFaker.orientationY.value) {
      nativePannerNodeFaker.orientationY.value = orientationY;
    }
    if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {
      nativePannerNodeFaker.orientationZ.value = orientationZ;
    }
    if (panningModel !== nativePannerNodeFaker.panningModel) {
      nativePannerNodeFaker.panningModel = panningModel;
    }
    if (positionX !== nativePannerNodeFaker.positionX.value) {
      nativePannerNodeFaker.positionX.value = positionX;
    }
    if (positionY !== nativePannerNodeFaker.positionY.value) {
      nativePannerNodeFaker.positionY.value = positionY;
    }
    if (positionZ !== nativePannerNodeFaker.positionZ.value) {
      nativePannerNodeFaker.positionZ.value = positionZ;
    }
    if (refDistance !== nativePannerNodeFaker.refDistance) {
      nativePannerNodeFaker.refDistance = refDistance;
    }
    if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {
      nativePannerNodeFaker.rolloffFactor = rolloffFactor;
    }
    if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {
      pannerNode.setOrientation(...lastOrientation);
    }
    if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {
      pannerNode.setPosition(...lastPosition);
    }
    const whenConnected = () => {
      inputGainNode.connect(pannerNode);
      connectNativeAudioNodeToNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
      waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);
      waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);
      waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);
      waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);
      waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);
      waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);
      channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);
    };
    const whenDisconnected = () => {
      inputGainNode.disconnect(pannerNode);
      disconnectNativeAudioNodeFromNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
      waveShaperNode.disconnect(orientationXGainNode);
      orientationXGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(orientationYGainNode);
      orientationYGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(orientationZGainNode);
      orientationZGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(positionXGainNode);
      positionXGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(positionYGainNode);
      positionYGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(positionZGainNode);
      positionZGainNode.disconnect(channelMergerNode);
      channelMergerNode.disconnect(scriptProcessorNode);
      scriptProcessorNode.disconnect(nativeContext.destination);
    };
    return monitorConnections2(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);
  };
};
var createNativePeriodicWaveFactory = (createIndexSizeError2) => {
  return (nativeContext, { disableNormalization, imag, real }) => {
    const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);
    const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);
    const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });
    if (Array.from(imag).length < 2) {
      throw createIndexSizeError2();
    }
    return nativePeriodicWave;
  };
};
var createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {
  return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);
};
var createNativeStereoPannerNodeFactory = (createNativeStereoPannerNodeFaker, createNotSupportedError2) => {
  return (nativeContext, options2) => {
    const channelCountMode = options2.channelCountMode;
    if (channelCountMode === "clamped-max") {
      throw createNotSupportedError2();
    }
    if (nativeContext.createStereoPanner === void 0) {
      return createNativeStereoPannerNodeFaker(nativeContext, options2);
    }
    const nativeStereoPannerNode = nativeContext.createStereoPanner();
    assignNativeAudioNodeOptions(nativeStereoPannerNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options2, "pan");
    Object.defineProperty(nativeStereoPannerNode, "channelCountMode", {
      get: () => channelCountMode,
      set: (value) => {
        if (value !== channelCountMode) {
          throw createNotSupportedError2();
        }
      }
    });
    return nativeStereoPannerNode;
  };
};
var createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeGainNode2, createNativeWaveShaperNode2, createNotSupportedError2, monitorConnections2) => {
  const CURVE_SIZE = 16385;
  const DC_CURVE = new Float32Array([1, 1]);
  const HALF_PI = Math.PI / 2;
  const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" };
  const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: "none" };
  const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
    const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);
    for (let i2 = 0; i2 < CURVE_SIZE; i2 += 1) {
      const x2 = i2 / (CURVE_SIZE - 1) * HALF_PI;
      leftWaveShaperCurve[i2] = Math.cos(x2);
      rightWaveShaperCurve[i2] = Math.sin(x2);
    }
    const leftGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const leftWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve });
    const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });
    const rightGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const rightWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve });
    return {
      connectGraph() {
        inputGainNode.connect(leftGainNode);
        inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        inputGainNode.connect(rightGainNode);
        panWaveShaperNode.connect(panGainNode);
        panGainNode.connect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
        panGainNode.connect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
        leftWaveShaperNode.connect(leftGainNode.gain);
        rightWaveShaperNode.connect(rightGainNode.gain);
        leftGainNode.connect(channelMergerNode, 0, 0);
        rightGainNode.connect(channelMergerNode, 0, 1);
      },
      disconnectGraph() {
        inputGainNode.disconnect(leftGainNode);
        inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        inputGainNode.disconnect(rightGainNode);
        panWaveShaperNode.disconnect(panGainNode);
        panGainNode.disconnect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
        panGainNode.disconnect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
        leftWaveShaperNode.disconnect(leftGainNode.gain);
        rightWaveShaperNode.disconnect(rightGainNode.gain);
        leftGainNode.disconnect(channelMergerNode, 0, 0);
        rightGainNode.disconnect(channelMergerNode, 0, 1);
      }
    };
  };
  const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
    const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const centerIndex = Math.floor(CURVE_SIZE / 2);
    for (let i2 = 0; i2 < CURVE_SIZE; i2 += 1) {
      if (i2 > centerIndex) {
        const x2 = (i2 - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;
        leftInputForLeftOutputWaveShaperCurve[i2] = Math.cos(x2);
        leftInputForRightOutputWaveShaperCurve[i2] = Math.sin(x2);
        rightInputForLeftOutputWaveShaperCurve[i2] = 0;
        rightInputForRightOutputWaveShaperCurve[i2] = 1;
      } else {
        const x2 = i2 / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;
        leftInputForLeftOutputWaveShaperCurve[i2] = 1;
        leftInputForRightOutputWaveShaperCurve[i2] = 0;
        rightInputForLeftOutputWaveShaperCurve[i2] = Math.cos(x2);
        rightInputForRightOutputWaveShaperCurve[i2] = Math.sin(x2);
      }
    }
    const channelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
      channelCount: 2,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: 2
    });
    const leftInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: leftInputForLeftOutputWaveShaperCurve
    });
    const leftInputForRightOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: leftInputForRightOutputWaveShaperCurve
    });
    const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });
    const rightInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: rightInputForLeftOutputWaveShaperCurve
    });
    const rightInputForRightOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: rightInputForRightOutputWaveShaperCurve
    });
    return {
      connectGraph() {
        inputGainNode.connect(channelSplitterNode);
        inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);
        channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);
        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);
        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);
        panWaveShaperNode.connect(panGainNode);
        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);
        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);
        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);
        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);
        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
      },
      disconnectGraph() {
        inputGainNode.disconnect(channelSplitterNode);
        inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);
        channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);
        channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);
        channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);
        panWaveShaperNode.disconnect(panGainNode);
        panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
        panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
        leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);
        leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);
        rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);
        rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);
        leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
        rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
        leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
        rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
      }
    };
  };
  const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {
    if (channelCount === 1) {
      return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);
    }
    if (channelCount === 2) {
      return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);
    }
    throw createNotSupportedError2();
  };
  return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {
    if (channelCountMode === "max") {
      throw createNotSupportedError2();
    }
    const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
      ...audioNodeOptions,
      channelCount: 1,
      channelCountMode,
      numberOfInputs: 2
    });
    const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });
    const panGainNode = createNativeGainNode2(nativeContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: pan
    });
    let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);
    Object.defineProperty(panGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(panGainNode.gain, "maxValue", { get: () => 1 });
    Object.defineProperty(panGainNode.gain, "minValue", { get: () => -1 });
    const nativeStereoPannerNodeFakerFactory2 = {
      get bufferSize() {
        return void 0;
      },
      get channelCount() {
        return inputGainNode.channelCount;
      },
      set channelCount(value) {
        if (inputGainNode.channelCount !== value) {
          if (isConnected) {
            disconnectGraph();
          }
          ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));
          if (isConnected) {
            connectGraph();
          }
        }
        inputGainNode.channelCount = value;
      },
      get channelCountMode() {
        return inputGainNode.channelCountMode;
      },
      set channelCountMode(value) {
        if (value === "clamped-max" || value === "max") {
          throw createNotSupportedError2();
        }
        inputGainNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return inputGainNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        inputGainNode.channelInterpretation = value;
      },
      get context() {
        return inputGainNode.context;
      },
      get inputs() {
        return [inputGainNode];
      },
      get numberOfInputs() {
        return inputGainNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return inputGainNode.numberOfOutputs;
      },
      get pan() {
        return panGainNode.gain;
      },
      addEventListener(...args) {
        return inputGainNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return inputGainNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return inputGainNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    let isConnected = false;
    const whenConnected = () => {
      connectGraph();
      isConnected = true;
    };
    const whenDisconnected = () => {
      disconnectGraph();
      isConnected = false;
    };
    return monitorConnections2(interceptConnections(nativeStereoPannerNodeFakerFactory2, channelMergerNode), whenConnected, whenDisconnected);
  };
};
var createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError2, createNativeWaveShaperNodeFaker2, isDCCurve2, monitorConnections2, nativeAudioContextConstructor2, overwriteAccessors2) => {
  return (nativeContext, options2) => {
    const nativeWaveShaperNode = nativeContext.createWaveShaper();
    if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext" && nativeContext.createGain().gain.automationRate === void 0) {
      return createNativeWaveShaperNodeFaker2(nativeContext, options2);
    }
    assignNativeAudioNodeOptions(nativeWaveShaperNode, options2);
    const curve = options2.curve === null || options2.curve instanceof Float32Array ? options2.curve : new Float32Array(options2.curve);
    if (curve !== null && curve.length < 2) {
      throw createInvalidStateError2();
    }
    assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, "curve");
    assignNativeAudioNodeOption(nativeWaveShaperNode, options2, "oversample");
    let disconnectNativeAudioBufferSourceNode = null;
    let isConnected = false;
    overwriteAccessors2(nativeWaveShaperNode, "curve", (get2) => () => get2.call(nativeWaveShaperNode), (set) => (value) => {
      set.call(nativeWaveShaperNode, value);
      if (isConnected) {
        if (isDCCurve2(value) && disconnectNativeAudioBufferSourceNode === null) {
          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
        } else if (!isDCCurve2(value) && disconnectNativeAudioBufferSourceNode !== null) {
          disconnectNativeAudioBufferSourceNode();
          disconnectNativeAudioBufferSourceNode = null;
        }
      }
      return value;
    });
    const whenConnected = () => {
      isConnected = true;
      if (isDCCurve2(nativeWaveShaperNode.curve)) {
        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
      }
    };
    const whenDisconnected = () => {
      isConnected = false;
      if (disconnectNativeAudioBufferSourceNode !== null) {
        disconnectNativeAudioBufferSourceNode();
        disconnectNativeAudioBufferSourceNode = null;
      }
    };
    return monitorConnections2(nativeWaveShaperNode, whenConnected, whenDisconnected);
  };
};
var createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError2, createNativeGainNode2, isDCCurve2, monitorConnections2) => {
  return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {
    const negativeWaveShaperNode = nativeContext.createWaveShaper();
    const positiveWaveShaperNode = nativeContext.createWaveShaper();
    assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);
    assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);
    const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
    const invertGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: -1 });
    const outputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
    const revertGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: -1 });
    let disconnectNativeAudioBufferSourceNode = null;
    let isConnected = false;
    let unmodifiedCurve = null;
    const nativeWaveShaperNodeFaker = {
      get bufferSize() {
        return void 0;
      },
      get channelCount() {
        return negativeWaveShaperNode.channelCount;
      },
      set channelCount(value) {
        inputGainNode.channelCount = value;
        invertGainNode.channelCount = value;
        negativeWaveShaperNode.channelCount = value;
        outputGainNode.channelCount = value;
        positiveWaveShaperNode.channelCount = value;
        revertGainNode.channelCount = value;
      },
      get channelCountMode() {
        return negativeWaveShaperNode.channelCountMode;
      },
      set channelCountMode(value) {
        inputGainNode.channelCountMode = value;
        invertGainNode.channelCountMode = value;
        negativeWaveShaperNode.channelCountMode = value;
        outputGainNode.channelCountMode = value;
        positiveWaveShaperNode.channelCountMode = value;
        revertGainNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return negativeWaveShaperNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        inputGainNode.channelInterpretation = value;
        invertGainNode.channelInterpretation = value;
        negativeWaveShaperNode.channelInterpretation = value;
        outputGainNode.channelInterpretation = value;
        positiveWaveShaperNode.channelInterpretation = value;
        revertGainNode.channelInterpretation = value;
      },
      get context() {
        return negativeWaveShaperNode.context;
      },
      get curve() {
        return unmodifiedCurve;
      },
      set curve(value) {
        if (value !== null && value.length < 2) {
          throw createInvalidStateError2();
        }
        if (value === null) {
          negativeWaveShaperNode.curve = value;
          positiveWaveShaperNode.curve = value;
        } else {
          const curveLength = value.length;
          const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);
          const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);
          negativeCurve[0] = value[0];
          positiveCurve[0] = -value[curveLength - 1];
          const length = Math.ceil((curveLength + 1) / 2);
          const centerIndex = (curveLength + 1) / 2 - 1;
          for (let i2 = 1; i2 < length; i2 += 1) {
            const theoreticIndex = i2 / length * centerIndex;
            const lowerIndex = Math.floor(theoreticIndex);
            const upperIndex = Math.ceil(theoreticIndex);
            negativeCurve[i2] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];
            positiveCurve[i2] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];
          }
          negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;
          negativeWaveShaperNode.curve = negativeCurve;
          positiveWaveShaperNode.curve = positiveCurve;
        }
        unmodifiedCurve = value;
        if (isConnected) {
          if (isDCCurve2(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {
            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
          } else if (disconnectNativeAudioBufferSourceNode !== null) {
            disconnectNativeAudioBufferSourceNode();
            disconnectNativeAudioBufferSourceNode = null;
          }
        }
      },
      get inputs() {
        return [inputGainNode];
      },
      get numberOfInputs() {
        return negativeWaveShaperNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return negativeWaveShaperNode.numberOfOutputs;
      },
      get oversample() {
        return negativeWaveShaperNode.oversample;
      },
      set oversample(value) {
        negativeWaveShaperNode.oversample = value;
        positiveWaveShaperNode.oversample = value;
      },
      addEventListener(...args) {
        return inputGainNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return inputGainNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return inputGainNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    if (curve !== null) {
      nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);
    }
    if (oversample !== nativeWaveShaperNodeFaker.oversample) {
      nativeWaveShaperNodeFaker.oversample = oversample;
    }
    const whenConnected = () => {
      inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);
      inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);
      isConnected = true;
      if (isDCCurve2(unmodifiedCurve)) {
        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
      }
    };
    const whenDisconnected = () => {
      inputGainNode.disconnect(negativeWaveShaperNode);
      negativeWaveShaperNode.disconnect(outputGainNode);
      inputGainNode.disconnect(invertGainNode);
      invertGainNode.disconnect(positiveWaveShaperNode);
      positiveWaveShaperNode.disconnect(revertGainNode);
      revertGainNode.disconnect(outputGainNode);
      isConnected = false;
      if (disconnectNativeAudioBufferSourceNode !== null) {
        disconnectNativeAudioBufferSourceNode();
        disconnectNativeAudioBufferSourceNode = null;
      }
    };
    return monitorConnections2(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);
  };
};
var createNotSupportedError = () => new DOMException("", "NotSupportedError");
var DEFAULT_OPTIONS$5 = {
  numberOfChannels: 1
};
var createOfflineAudioContextConstructor = (baseAudioContextConstructor2, cacheTestResult2, createInvalidStateError2, createNativeOfflineAudioContext2, startRendering2) => {
  return class OfflineAudioContext extends baseAudioContextConstructor2 {
    constructor(a2, b2, c2) {
      let options2;
      if (typeof a2 === "number" && b2 !== void 0 && c2 !== void 0) {
        options2 = { length: b2, numberOfChannels: a2, sampleRate: c2 };
      } else if (typeof a2 === "object") {
        options2 = a2;
      } else {
        throw new Error("The given parameters are not valid.");
      }
      const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS$5, ...options2 };
      const nativeOfflineAudioContext = createNativeOfflineAudioContext2(numberOfChannels, length, sampleRate);
      if (!cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
        nativeOfflineAudioContext.addEventListener("statechange", (() => {
          let i2 = 0;
          const delayStateChangeEvent = (event) => {
            if (this._state === "running") {
              if (i2 > 0) {
                nativeOfflineAudioContext.removeEventListener("statechange", delayStateChangeEvent);
                event.stopImmediatePropagation();
                this._waitForThePromiseToSettle(event);
              } else {
                i2 += 1;
              }
            }
          };
          return delayStateChangeEvent;
        })());
      }
      super(nativeOfflineAudioContext, numberOfChannels);
      this._length = length;
      this._nativeOfflineAudioContext = nativeOfflineAudioContext;
      this._state = null;
    }
    get length() {
      if (this._nativeOfflineAudioContext.length === void 0) {
        return this._length;
      }
      return this._nativeOfflineAudioContext.length;
    }
    get state() {
      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
    }
    startRendering() {
      if (this._state === "running") {
        return Promise.reject(createInvalidStateError2());
      }
      this._state = "running";
      return startRendering2(this.destination, this._nativeOfflineAudioContext).finally(() => {
        this._state = null;
        deactivateAudioGraph(this);
      });
    }
    _waitForThePromiseToSettle(event) {
      if (this._state === null) {
        this._nativeOfflineAudioContext.dispatchEvent(event);
      } else {
        setTimeout(() => this._waitForThePromiseToSettle(event));
      }
    }
  };
};
var DEFAULT_OPTIONS$4 = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  detune: 0,
  frequency: 440,
  periodicWave: void 0,
  type: "sine"
};
var createOscillatorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeOscillatorNode2, createOscillatorNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
  return class OscillatorNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$4, ...options2 };
      const nativeOscillatorNode = createNativeOscillatorNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer2() : null;
      const nyquist = context2.sampleRate / 2;
      super(context2, false, nativeOscillatorNode, oscillatorNodeRenderer);
      this._detune = createAudioParam2(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);
      this._frequency = createAudioParam2(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);
      this._nativeOscillatorNode = nativeOscillatorNode;
      this._onended = null;
      this._oscillatorNodeRenderer = oscillatorNodeRenderer;
      if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== void 0) {
        this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;
      }
    }
    get detune() {
      return this._detune;
    }
    get frequency() {
      return this._frequency;
    }
    get onended() {
      return this._onended;
    }
    set onended(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeOscillatorNode.onended = wrappedListener;
      const nativeOnEnded = this._nativeOscillatorNode.onended;
      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
    }
    get type() {
      return this._nativeOscillatorNode.type;
    }
    set type(value) {
      this._nativeOscillatorNode.type = value;
      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.periodicWave = null;
      }
    }
    setPeriodicWave(periodicWave) {
      this._nativeOscillatorNode.setPeriodicWave(periodicWave);
      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.periodicWave = periodicWave;
      }
    }
    start(when = 0) {
      this._nativeOscillatorNode.start(when);
      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.start = when;
      }
      if (this.context.state !== "closed") {
        setInternalStateToActive(this);
        const resetInternalStateToPassive = () => {
          this._nativeOscillatorNode.removeEventListener("ended", resetInternalStateToPassive);
          if (isActiveAudioNode(this)) {
            setInternalStateToPassive(this);
          }
        };
        this._nativeOscillatorNode.addEventListener("ended", resetInternalStateToPassive);
      }
    }
    stop(when = 0) {
      this._nativeOscillatorNode.stop(when);
      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.stop = when;
      }
    }
  };
};
var createOscillatorNodeRendererFactory = (connectAudioParam2, createNativeOscillatorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeOscillatorNodes = /* @__PURE__ */ new WeakMap();
    let periodicWave = null;
    let start22 = null;
    let stop = null;
    const createOscillatorNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeOscillatorNode = getNativeAudioNode2(proxy);
      const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);
      if (!nativeOscillatorNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeOscillatorNode.channelCount,
          channelCountMode: nativeOscillatorNode.channelCountMode,
          channelInterpretation: nativeOscillatorNode.channelInterpretation,
          detune: nativeOscillatorNode.detune.value,
          frequency: nativeOscillatorNode.frequency.value,
          periodicWave: periodicWave === null ? void 0 : periodicWave,
          type: nativeOscillatorNode.type
        };
        nativeOscillatorNode = createNativeOscillatorNode2(nativeOfflineAudioContext, options2);
        if (start22 !== null) {
          nativeOscillatorNode.start(start22);
        }
        if (stop !== null) {
          nativeOscillatorNode.stop(stop);
        }
      }
      renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);
      if (!nativeOscillatorNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
        await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeOscillatorNode);
      return nativeOscillatorNode;
    };
    return {
      set periodicWave(value) {
        periodicWave = value;
      },
      set start(value) {
        start22 = value;
      },
      set stop(value) {
        stop = value;
      },
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);
        if (renderedNativeOscillatorNode !== void 0) {
          return Promise.resolve(renderedNativeOscillatorNode);
        }
        return createOscillatorNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var DEFAULT_OPTIONS$3 = {
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  coneInnerAngle: 360,
  coneOuterAngle: 360,
  coneOuterGain: 0,
  distanceModel: "inverse",
  maxDistance: 1e4,
  orientationX: 1,
  orientationY: 0,
  orientationZ: 0,
  panningModel: "equalpower",
  positionX: 0,
  positionY: 0,
  positionZ: 0,
  refDistance: 1,
  rolloffFactor: 1
};
var createPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativePannerNode2, createPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class PannerNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$3, ...options2 };
      const nativePannerNode = createNativePannerNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const pannerNodeRenderer = isOffline ? createPannerNodeRenderer2() : null;
      super(context2, false, nativePannerNode, pannerNodeRenderer);
      this._nativePannerNode = nativePannerNode;
      this._orientationX = createAudioParam2(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._orientationY = createAudioParam2(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._orientationZ = createAudioParam2(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._positionX = createAudioParam2(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._positionY = createAudioParam2(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._positionZ = createAudioParam2(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      setAudioNodeTailTime2(this, 1);
    }
    get coneInnerAngle() {
      return this._nativePannerNode.coneInnerAngle;
    }
    set coneInnerAngle(value) {
      this._nativePannerNode.coneInnerAngle = value;
    }
    get coneOuterAngle() {
      return this._nativePannerNode.coneOuterAngle;
    }
    set coneOuterAngle(value) {
      this._nativePannerNode.coneOuterAngle = value;
    }
    get coneOuterGain() {
      return this._nativePannerNode.coneOuterGain;
    }
    set coneOuterGain(value) {
      this._nativePannerNode.coneOuterGain = value;
    }
    get distanceModel() {
      return this._nativePannerNode.distanceModel;
    }
    set distanceModel(value) {
      this._nativePannerNode.distanceModel = value;
    }
    get maxDistance() {
      return this._nativePannerNode.maxDistance;
    }
    set maxDistance(value) {
      this._nativePannerNode.maxDistance = value;
    }
    get orientationX() {
      return this._orientationX;
    }
    get orientationY() {
      return this._orientationY;
    }
    get orientationZ() {
      return this._orientationZ;
    }
    get panningModel() {
      return this._nativePannerNode.panningModel;
    }
    set panningModel(value) {
      this._nativePannerNode.panningModel = value;
    }
    get positionX() {
      return this._positionX;
    }
    get positionY() {
      return this._positionY;
    }
    get positionZ() {
      return this._positionZ;
    }
    get refDistance() {
      return this._nativePannerNode.refDistance;
    }
    set refDistance(value) {
      this._nativePannerNode.refDistance = value;
    }
    get rolloffFactor() {
      return this._nativePannerNode.rolloffFactor;
    }
    set rolloffFactor(value) {
      this._nativePannerNode.rolloffFactor = value;
    }
  };
};
var createPannerNodeRendererFactory = (connectAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativePannerNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
  return () => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    let renderedBufferPromise = null;
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeGainNode = null;
      let nativePannerNode = getNativeAudioNode2(proxy);
      const commonAudioNodeOptions = {
        channelCount: nativePannerNode.channelCount,
        channelCountMode: nativePannerNode.channelCountMode,
        channelInterpretation: nativePannerNode.channelInterpretation
      };
      const commonNativePannerNodeOptions = {
        ...commonAudioNodeOptions,
        coneInnerAngle: nativePannerNode.coneInnerAngle,
        coneOuterAngle: nativePannerNode.coneOuterAngle,
        coneOuterGain: nativePannerNode.coneOuterGain,
        distanceModel: nativePannerNode.distanceModel,
        maxDistance: nativePannerNode.maxDistance,
        panningModel: nativePannerNode.panningModel,
        refDistance: nativePannerNode.refDistance,
        rolloffFactor: nativePannerNode.rolloffFactor
      };
      const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);
      if ("bufferSize" in nativePannerNode) {
        nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
      } else if (!nativePannerNodeIsOwnedByContext) {
        const options2 = {
          ...commonNativePannerNodeOptions,
          orientationX: nativePannerNode.orientationX.value,
          orientationY: nativePannerNode.orientationY.value,
          orientationZ: nativePannerNode.orientationZ.value,
          positionX: nativePannerNode.positionX.value,
          positionY: nativePannerNode.positionY.value,
          positionZ: nativePannerNode.positionZ.value
        };
        nativePannerNode = createNativePannerNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);
      if (nativeGainNode !== null) {
        if (renderedBufferPromise === null) {
          if (nativeOfflineAudioContextConstructor2 === null) {
            throw new Error("Missing the native OfflineAudioContext constructor.");
          }
          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(6, proxy.context.length, nativeOfflineAudioContext.sampleRate);
          const nativeChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: 6
          });
          nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);
          renderedBufferPromise = (async () => {
            const nativeConstantSourceNodes = await Promise.all([
              proxy.orientationX,
              proxy.orientationY,
              proxy.orientationZ,
              proxy.positionX,
              proxy.positionY,
              proxy.positionZ
            ].map(async (audioParam, index2) => {
              const nativeConstantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                offset: index2 === 0 ? 1 : 0
              });
              await renderAutomation2(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);
              return nativeConstantSourceNode;
            }));
            for (let i2 = 0; i2 < 6; i2 += 1) {
              nativeConstantSourceNodes[i2].connect(nativeChannelMergerNode, 0, i2);
              nativeConstantSourceNodes[i2].start(0);
            }
            return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
          })();
        }
        const renderedBuffer = await renderedBufferPromise;
        const inputGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, inputGainNode);
        const channelDatas = [];
        for (let i2 = 0; i2 < renderedBuffer.numberOfChannels; i2 += 1) {
          channelDatas.push(renderedBuffer.getChannelData(i2));
        }
        let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];
        let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];
        let gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
        let partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, {
          ...commonNativePannerNodeOptions,
          orientationX: lastOrientation[0],
          orientationY: lastOrientation[1],
          orientationZ: lastOrientation[2],
          positionX: lastPosition[0],
          positionY: lastPosition[1],
          positionZ: lastPosition[2]
        });
        inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
        partialPannerNode.connect(nativeGainNode);
        for (let i2 = 128; i2 < renderedBuffer.length; i2 += 128) {
          const orientation = [channelDatas[0][i2], channelDatas[1][i2], channelDatas[2][i2]];
          const positon = [channelDatas[3][i2], channelDatas[4][i2], channelDatas[5][i2]];
          if (orientation.some((value, index2) => value !== lastOrientation[index2]) || positon.some((value, index2) => value !== lastPosition[index2])) {
            lastOrientation = orientation;
            lastPosition = positon;
            const currentTime = i2 / nativeOfflineAudioContext.sampleRate;
            gateGainNode.gain.setValueAtTime(0, currentTime);
            gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });
            partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, {
              ...commonNativePannerNodeOptions,
              orientationX: lastOrientation[0],
              orientationY: lastOrientation[1],
              orientationZ: lastOrientation[2],
              positionX: lastPosition[0],
              positionY: lastPosition[1],
              positionZ: lastPosition[2]
            });
            gateGainNode.gain.setValueAtTime(1, currentTime);
            inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
            partialPannerNode.connect(nativeGainNode);
          }
        }
        return nativeGainNode;
      }
      if (!nativePannerNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
        await renderAutomation2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
        await renderAutomation2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
        await renderAutomation2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
        await renderAutomation2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
        await renderAutomation2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
      }
      if (isNativeAudioNodeFaker(nativePannerNode)) {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode);
      }
      return nativePannerNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeGainNodeOrNativePannerNode !== void 0) {
          return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var DEFAULT_OPTIONS$2 = {
  disableNormalization: false
};
var createPeriodicWaveConstructor = (createNativePeriodicWave2, getNativeContext2, periodicWaveStore, sanitizePeriodicWaveOptions2) => {
  return class PeriodicWave {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = sanitizePeriodicWaveOptions2({ ...DEFAULT_OPTIONS$2, ...options2 });
      const periodicWave = createNativePeriodicWave2(nativeContext, mergedOptions);
      periodicWaveStore.add(periodicWave);
      return periodicWave;
    }
    static [Symbol.hasInstance](instance) {
      return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);
    }
  };
};
var createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam2) => {
  return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
    const audioParamRenderer = getAudioParamRenderer(audioParam);
    audioParamRenderer.replay(nativeAudioParam);
    return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
  };
};
var createRenderInputsOfAudioNode = (getAudioNodeConnections2, getAudioNodeRenderer2, isPartOfACycle2) => {
  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {
    const audioNodeConnections = getAudioNodeConnections2(audioNode);
    await Promise.all(audioNodeConnections.activeInputs.map((connections, input2) => Array.from(connections).map(async ([source, output]) => {
      const audioNodeRenderer = getAudioNodeRenderer2(source);
      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
      const destination = audioNode.context.destination;
      if (!isPartOfACycle2(source) && (audioNode !== destination || !isPartOfACycle2(audioNode))) {
        renderedNativeAudioNode.connect(nativeAudioNode, output, input2);
      }
    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));
  };
};
var createRenderInputsOfAudioParam = (getAudioNodeRenderer2, getAudioParamConnections2, isPartOfACycle2) => {
  return async (audioParam, nativeOfflineAudioContext, nativeAudioParam) => {
    const audioParamConnections = getAudioParamConnections2(audioParam);
    await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {
      const audioNodeRenderer = getAudioNodeRenderer2(source);
      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
      if (!isPartOfACycle2(source)) {
        renderedNativeAudioNode.connect(nativeAudioParam, output);
      }
    }));
  };
};
var createRenderNativeOfflineAudioContext = (cacheTestResult2, createNativeGainNode2, createNativeScriptProcessorNode2, testOfflineAudioContextCurrentTimeSupport) => {
  return (nativeOfflineAudioContext) => {
    if (cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
      return Promise.resolve(cacheTestResult2(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {
        if (!isOfflineAudioContextCurrentTimeSupported) {
          const scriptProcessorNode = createNativeScriptProcessorNode2(nativeOfflineAudioContext, 512, 0, 1);
          nativeOfflineAudioContext.oncomplete = () => {
            scriptProcessorNode.onaudioprocess = null;
            scriptProcessorNode.disconnect();
          };
          scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime;
          scriptProcessorNode.connect(nativeOfflineAudioContext.destination);
        }
        return nativeOfflineAudioContext.startRendering();
      });
    }
    return new Promise((resolve) => {
      const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: 0
      });
      nativeOfflineAudioContext.oncomplete = (event) => {
        gainNode.disconnect();
        resolve(event.renderedBuffer);
      };
      gainNode.connect(nativeOfflineAudioContext.destination);
      nativeOfflineAudioContext.startRendering();
    });
  };
};
var createSetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2) => {
  return (nativeAudioWorkletNode, activeInputs) => {
    activeAudioWorkletNodeInputsStore2.set(nativeAudioWorkletNode, activeInputs);
  };
};
var createSetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
  return (audioNode, tailTime) => audioNodeTailTimeStore2.set(audioNode, tailTime);
};
var createStartRendering = (audioBufferStore2, cacheTestResult2, getAudioNodeRenderer2, getUnrenderedAudioWorkletNodes2, renderNativeOfflineAudioContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
  return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer2(destination).render(destination, nativeOfflineAudioContext).then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes2(nativeOfflineAudioContext)).map((audioWorkletNode) => getAudioNodeRenderer2(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)))).then(() => renderNativeOfflineAudioContext2(nativeOfflineAudioContext)).then((audioBuffer) => {
    if (typeof audioBuffer.copyFromChannel !== "function") {
      wrapAudioBufferCopyChannelMethods2(audioBuffer);
      wrapAudioBufferGetChannelDataMethod(audioBuffer);
    } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
      wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
    }
    audioBufferStore2.add(audioBuffer);
    return audioBuffer;
  });
};
var DEFAULT_OPTIONS$1 = {
  channelCount: 2,
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  pan: 0
};
var createStereoPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeStereoPannerNode2, createStereoPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class StereoPannerNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$1, ...options2 };
      const nativeStereoPannerNode = createNativeStereoPannerNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer2() : null;
      super(context2, false, nativeStereoPannerNode, stereoPannerNodeRenderer);
      this._pan = createAudioParam2(this, isOffline, nativeStereoPannerNode.pan);
    }
    get pan() {
      return this._pan;
    }
  };
};
var createStereoPannerNodeRendererFactory = (connectAudioParam2, createNativeStereoPannerNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeStereoPannerNodes = /* @__PURE__ */ new WeakMap();
    const createStereoPannerNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeStereoPannerNode = getNativeAudioNode2(proxy);
      const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);
      if (!nativeStereoPannerNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeStereoPannerNode.channelCount,
          channelCountMode: nativeStereoPannerNode.channelCountMode,
          channelInterpretation: nativeStereoPannerNode.channelInterpretation,
          pan: nativeStereoPannerNode.pan.value
        };
        nativeStereoPannerNode = createNativeStereoPannerNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);
      if (!nativeStereoPannerNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
      }
      if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);
      }
      return nativeStereoPannerNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);
        if (renderedNativeStereoPannerNode !== void 0) {
          return Promise.resolve(renderedNativeStereoPannerNode);
        }
        return createStereoPannerNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor2) => {
  return () => {
    if (nativeAudioBufferConstructor2 === null) {
      return false;
    }
    try {
      new nativeAudioBufferConstructor2({ length: 1, sampleRate: 44100 });
    } catch {
      return false;
    }
    return true;
  };
};
var createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2) => {
  return async () => {
    if (nativeAudioWorkletNodeConstructor2 === null) {
      return true;
    }
    if (nativeOfflineAudioContextConstructor2 === null) {
      return false;
    }
    const blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
      type: "application/javascript; charset=utf-8"
    });
    const offlineAudioContext = new nativeOfflineAudioContextConstructor2(1, 128, 44100);
    const url = URL.createObjectURL(blob);
    let isEmittingMessageEvents = false;
    let isEmittingProcessorErrorEvents = false;
    try {
      await offlineAudioContext.audioWorklet.addModule(url);
      const audioWorkletNode = new nativeAudioWorkletNodeConstructor2(offlineAudioContext, "a", { numberOfOutputs: 0 });
      const oscillator = offlineAudioContext.createOscillator();
      audioWorkletNode.port.onmessage = () => isEmittingMessageEvents = true;
      audioWorkletNode.onprocessorerror = () => isEmittingProcessorErrorEvents = true;
      oscillator.connect(audioWorkletNode);
      oscillator.start(0);
      await offlineAudioContext.startRendering();
    } catch {
    } finally {
      URL.revokeObjectURL(url);
    }
    return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;
  };
};
var createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode2, nativeOfflineAudioContextConstructor2) => {
  return () => {
    if (nativeOfflineAudioContextConstructor2 === null) {
      return Promise.resolve(false);
    }
    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
    const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: 0
    });
    return new Promise((resolve) => {
      nativeOfflineAudioContext.oncomplete = () => {
        gainNode.disconnect();
        resolve(nativeOfflineAudioContext.currentTime !== 0);
      };
      nativeOfflineAudioContext.startRendering();
    });
  };
};
var createUnknownError = () => new DOMException("", "UnknownError");
var DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  curve: null,
  oversample: "none"
};
var createWaveShaperNodeConstructor = (audioNodeConstructor2, createInvalidStateError2, createNativeWaveShaperNode2, createWaveShaperNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class WaveShaperNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS, ...options2 };
      const nativeWaveShaperNode = createNativeWaveShaperNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer2() : null;
      super(context2, true, nativeWaveShaperNode, waveShaperNodeRenderer);
      this._isCurveNullified = false;
      this._nativeWaveShaperNode = nativeWaveShaperNode;
      setAudioNodeTailTime2(this, 1);
    }
    get curve() {
      if (this._isCurveNullified) {
        return null;
      }
      return this._nativeWaveShaperNode.curve;
    }
    set curve(value) {
      if (value === null) {
        this._isCurveNullified = true;
        this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
      } else {
        if (value.length < 2) {
          throw createInvalidStateError2();
        }
        this._isCurveNullified = false;
        this._nativeWaveShaperNode.curve = value;
      }
    }
    get oversample() {
      return this._nativeWaveShaperNode.oversample;
    }
    set oversample(value) {
      this._nativeWaveShaperNode.oversample = value;
    }
  };
};
var createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeWaveShaperNodes = /* @__PURE__ */ new WeakMap();
    const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeWaveShaperNode = getNativeAudioNode2(proxy);
      const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);
      if (!nativeWaveShaperNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeWaveShaperNode.channelCount,
          channelCountMode: nativeWaveShaperNode.channelCountMode,
          channelInterpretation: nativeWaveShaperNode.channelInterpretation,
          curve: nativeWaveShaperNode.curve,
          oversample: nativeWaveShaperNode.oversample
        };
        nativeWaveShaperNode = createNativeWaveShaperNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);
      if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);
      }
      return nativeWaveShaperNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);
        if (renderedNativeWaveShaperNode !== void 0) {
          return Promise.resolve(renderedNativeWaveShaperNode);
        }
        return createWaveShaperNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
var createWindow = () => typeof window === "undefined" ? null : window;
var createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong2, createIndexSizeError2) => {
  return (audioBuffer) => {
    audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
      const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
      const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
      if (channelNumber >= audioBuffer.numberOfChannels) {
        throw createIndexSizeError2();
      }
      const audioBufferLength = audioBuffer.length;
      const channelData = audioBuffer.getChannelData(channelNumber);
      const destinationLength = destination.length;
      for (let i2 = bufferOffset < 0 ? -bufferOffset : 0; i2 + bufferOffset < audioBufferLength && i2 < destinationLength; i2 += 1) {
        destination[i2] = channelData[i2 + bufferOffset];
      }
    };
    audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
      const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
      const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
      if (channelNumber >= audioBuffer.numberOfChannels) {
        throw createIndexSizeError2();
      }
      const audioBufferLength = audioBuffer.length;
      const channelData = audioBuffer.getChannelData(channelNumber);
      const sourceLength = source.length;
      for (let i2 = bufferOffset < 0 ? -bufferOffset : 0; i2 + bufferOffset < audioBufferLength && i2 < sourceLength; i2 += 1) {
        channelData[i2 + bufferOffset] = source[i2];
      }
    };
  };
};
var createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong2) => {
  return (audioBuffer) => {
    audioBuffer.copyFromChannel = ((copyFromChannel2) => {
      return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
        if (bufferOffset < audioBuffer.length) {
          return copyFromChannel2.call(audioBuffer, destination, channelNumber, bufferOffset);
        }
      };
    })(audioBuffer.copyFromChannel);
    audioBuffer.copyToChannel = ((copyToChannel2) => {
      return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
        if (bufferOffset < audioBuffer.length) {
          return copyToChannel2.call(audioBuffer, source, channelNumber, bufferOffset);
        }
      };
    })(audioBuffer.copyToChannel);
  };
};
var createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors2) => {
  return (nativeAudioBufferSourceNode, nativeContext) => {
    const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);
    if (nativeAudioBufferSourceNode.buffer === null) {
      nativeAudioBufferSourceNode.buffer = nullifiedBuffer;
    }
    overwriteAccessors2(nativeAudioBufferSourceNode, "buffer", (get2) => () => {
      const value = get2.call(nativeAudioBufferSourceNode);
      return value === nullifiedBuffer ? null : value;
    }, (set) => (value) => {
      return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);
    });
  };
};
var createWrapChannelMergerNode = (createInvalidStateError2, monitorConnections2) => {
  return (nativeContext, channelMergerNode) => {
    channelMergerNode.channelCount = 1;
    channelMergerNode.channelCountMode = "explicit";
    Object.defineProperty(channelMergerNode, "channelCount", {
      get: () => 1,
      set: () => {
        throw createInvalidStateError2();
      }
    });
    Object.defineProperty(channelMergerNode, "channelCountMode", {
      get: () => "explicit",
      set: () => {
        throw createInvalidStateError2();
      }
    });
    const audioBufferSourceNode = nativeContext.createBufferSource();
    const whenConnected = () => {
      const length = channelMergerNode.numberOfInputs;
      for (let i2 = 0; i2 < length; i2 += 1) {
        audioBufferSourceNode.connect(channelMergerNode, 0, i2);
      }
    };
    const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);
    monitorConnections2(channelMergerNode, whenConnected, whenDisconnected);
  };
};
var getFirstSample = (audioBuffer, buffer, channelNumber) => {
  if (audioBuffer.copyFromChannel === void 0) {
    return audioBuffer.getChannelData(channelNumber)[0];
  }
  audioBuffer.copyFromChannel(buffer, channelNumber);
  return buffer[0];
};
var isDCCurve = (curve) => {
  if (curve === null) {
    return false;
  }
  const length = curve.length;
  if (length % 2 !== 0) {
    return curve[Math.floor(length / 2)] !== 0;
  }
  return curve[length / 2 - 1] + curve[length / 2] !== 0;
};
var overwriteAccessors = (object, property, createGetter, createSetter) => {
  let prototype = object;
  while (!prototype.hasOwnProperty(property)) {
    prototype = Object.getPrototypeOf(prototype);
  }
  const { get: get2, set } = Object.getOwnPropertyDescriptor(prototype, property);
  Object.defineProperty(object, property, { get: createGetter(get2), set: createSetter(set) });
};
var sanitizeAudioWorkletNodeOptions = (options2) => {
  return {
    ...options2,
    outputChannelCount: options2.outputChannelCount !== void 0 ? options2.outputChannelCount : options2.numberOfInputs === 1 && options2.numberOfOutputs === 1 ? [options2.channelCount] : Array.from({ length: options2.numberOfOutputs }, () => 1)
  };
};
var sanitizeChannelSplitterOptions = (options2) => {
  return { ...options2, channelCount: options2.numberOfOutputs };
};
var sanitizePeriodicWaveOptions = (options2) => {
  const { imag, real } = options2;
  if (imag === void 0) {
    if (real === void 0) {
      return { ...options2, imag: [0, 0], real: [0, 0] };
    }
    return { ...options2, imag: Array.from(real, () => 0), real };
  }
  if (real === void 0) {
    return { ...options2, imag, real: Array.from(imag, () => 0) };
  }
  return { ...options2, imag, real };
};
var setValueAtTimeUntilPossible = (audioParam, value, startTime) => {
  try {
    audioParam.setValueAtTime(value, startTime);
  } catch (err) {
    if (err.code !== 9) {
      throw err;
    }
    setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);
  }
};
var testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  nativeAudioBufferSourceNode.start();
  try {
    nativeAudioBufferSourceNode.start();
  } catch {
    return true;
  }
  return false;
};
var testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
  nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
  try {
    nativeAudioBufferSourceNode.start(0, 1);
  } catch {
    return false;
  }
  return true;
};
var testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  nativeAudioBufferSourceNode.start();
  try {
    nativeAudioBufferSourceNode.stop();
  } catch {
    return false;
  }
  return true;
};
var testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createOscillator();
  try {
    nativeAudioBufferSourceNode.start(-1);
  } catch (err) {
    return err instanceof RangeError;
  }
  return false;
};
var testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext) => {
  const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
  nativeAudioBufferSourceNode.start();
  nativeAudioBufferSourceNode.stop();
  try {
    nativeAudioBufferSourceNode.stop();
    return true;
  } catch {
    return false;
  }
};
var testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createOscillator();
  try {
    nativeAudioBufferSourceNode.stop(-1);
  } catch (err) {
    return err instanceof RangeError;
  }
  return false;
};
var testAudioWorkletNodeOptionsClonability = (audioWorkletNodeOptions) => {
  const { port1, port2 } = new MessageChannel();
  try {
    port1.postMessage(audioWorkletNodeOptions);
  } finally {
    port1.close();
    port2.close();
  }
};
var wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {
  nativeAudioBufferSourceNode.start = ((start22) => {
    return (when = 0, offset = 0, duration2) => {
      const buffer = nativeAudioBufferSourceNode.buffer;
      const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);
      if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {
        start22.call(nativeAudioBufferSourceNode, when, 0, 0);
      } else {
        start22.call(nativeAudioBufferSourceNode, when, clampedOffset, duration2);
      }
    };
  })(nativeAudioBufferSourceNode.start);
};
var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {
  const nativeGainNode = nativeContext.createGain();
  nativeAudioScheduledSourceNode.connect(nativeGainNode);
  const disconnectGainNode = ((disconnect2) => {
    return () => {
      disconnect2.call(nativeAudioScheduledSourceNode, nativeGainNode);
      nativeAudioScheduledSourceNode.removeEventListener("ended", disconnectGainNode);
    };
  })(nativeAudioScheduledSourceNode.disconnect);
  nativeAudioScheduledSourceNode.addEventListener("ended", disconnectGainNode);
  interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);
  nativeAudioScheduledSourceNode.stop = ((stop) => {
    let isStopped = false;
    return (when = 0) => {
      if (isStopped) {
        try {
          stop.call(nativeAudioScheduledSourceNode, when);
        } catch {
          nativeGainNode.gain.setValueAtTime(0, when);
        }
      } else {
        stop.call(nativeAudioScheduledSourceNode, when);
        isStopped = true;
      }
    };
  })(nativeAudioScheduledSourceNode.stop);
};
var wrapEventListener = (target, eventListener) => {
  return (event) => {
    const descriptor = { value: target };
    Object.defineProperties(event, {
      currentTarget: descriptor,
      target: descriptor
    });
    if (typeof eventListener === "function") {
      return eventListener.call(target, event);
    }
    return eventListener.handleEvent.call(target, event);
  };
};
var addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);
var addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);
var deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);
var audioNodeTailTimeStore = /* @__PURE__ */ new WeakMap();
var getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);
var cacheTestResult = createCacheTestResult(/* @__PURE__ */ new Map(), /* @__PURE__ */ new WeakMap());
var window$1 = createWindow();
var createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);
var getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);
var renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);
var createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);
var getNativeContext = createGetNativeContext(CONTEXT_STORE);
var nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window$1);
var isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);
var audioParamAudioNodeStore = /* @__PURE__ */ new WeakMap();
var eventTargetConstructor = createEventTargetConstructor(wrapEventListener);
var nativeAudioContextConstructor = createNativeAudioContextConstructor(window$1);
var isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);
var isNativeAudioNode = createIsNativeAudioNode(window$1);
var isNativeAudioParam = createIsNativeAudioParam(window$1);
var nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window$1);
var audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);
var analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);
var audioBufferStore = /* @__PURE__ */ new WeakSet();
var nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window$1);
var convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));
var wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);
var wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);
var audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
var addSilentConnection = createAddSilentConnection(createNativeGainNode);
var renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);
var connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);
var createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
var renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);
var createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
var createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);
var audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
var audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);
var createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
var setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);
var biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
var monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);
var wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);
var createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);
var createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);
var channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);
var createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);
var channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);
var createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);
var createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);
var createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
var constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
var createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);
var createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);
var convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
var createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
var delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
var createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);
var createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
var dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
var createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
var gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);
var createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);
var renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));
var createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
var createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);
var iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
var createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);
var unrenderedAudioWorkletNodeStore = /* @__PURE__ */ new WeakMap();
var minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);
var createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
var createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
var oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
var createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);
var createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections);
var createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);
var createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections);
var createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);
var createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
var pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
var createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);
var periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, /* @__PURE__ */ new WeakSet(), sanitizePeriodicWaveOptions);
var nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);
var createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);
var createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
var stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);
var createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);
var waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
var isSecureContext = createIsSecureContext(window$1);
var exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window$1);
var backupOfflineAudioContextStore = /* @__PURE__ */ new WeakMap();
var getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);
var addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, createEvaluateSource(window$1), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, /* @__PURE__ */ new WeakMap(), /* @__PURE__ */ new WeakMap(), createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), window$1) : void 0;
var isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);
var decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, /* @__PURE__ */ new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
var baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);
var mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
var mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);
var mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
var createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext);
var mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);
var audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);
var getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);
var addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
var connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);
var deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
var disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);
var activeAudioWorkletNodeInputsStore = /* @__PURE__ */ new WeakMap();
var getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);
var createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);
var createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);
var createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
var getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);
var setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);
var audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) : void 0;
var createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);
var startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
var offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);
var isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);
var isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);
var isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);
var isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);
function isUndef(arg) {
  return typeof arg === "undefined";
}
function isDefined(arg) {
  return !isUndef(arg);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isObject(arg) {
  return Object.prototype.toString.call(arg) === "[object Object]" && arg.constructor === Object;
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isArray(arg) {
  return Array.isArray(arg);
}
function isString(arg) {
  return typeof arg === "string";
}
function isNote(arg) {
  return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
}
function assert(statement, error) {
  if (!statement) {
    throw new Error(error);
  }
}
function assertRange(value, gte, lte = Infinity) {
  if (!(gte <= value && value <= lte)) {
    throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);
  }
}
function assertContextRunning(context2) {
  if (!context2.isOffline && context2.state !== "running") {
    warn('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
  }
}
var isInsideScheduledCallback = false;
var printedScheduledWarning = false;
function enterScheduledCallback(insideCallback) {
  isInsideScheduledCallback = insideCallback;
}
function assertUsedScheduleTime(time) {
  if (isUndef(time) && isInsideScheduledCallback && !printedScheduledWarning) {
    printedScheduledWarning = true;
    warn("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing");
  }
}
var defaultLogger = console;
function log(...args) {
  defaultLogger.log(...args);
}
function warn(...args) {
  defaultLogger.warn(...args);
}
function createAudioContext(options2) {
  return new audioContextConstructor(options2);
}
function createOfflineAudioContext(channels2, length, sampleRate) {
  return new offlineAudioContextConstructor(channels2, length, sampleRate);
}
var theWindow = typeof self === "object" ? self : null;
var hasAudioContext = theWindow && (theWindow.hasOwnProperty("AudioContext") || theWindow.hasOwnProperty("webkitAudioContext"));
function createAudioWorkletNode(context2, name2, options2) {
  assert(isDefined(audioWorkletNodeConstructor), "This node only works in a secure context (https or localhost)");
  return new audioWorkletNodeConstructor(context2, name2, options2);
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var Ticker = class {
  constructor(callback, type, updateInterval, contextSampleRate) {
    this._callback = callback;
    this._type = type;
    this._minimumUpdateInterval = Math.max(128 / (contextSampleRate || 44100), 1e-3);
    this.updateInterval = updateInterval;
    this._createClock();
  }
  _createWorker() {
    const blob = new Blob([
      `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
    ], { type: "text/javascript" });
    const blobUrl = URL.createObjectURL(blob);
    const worker = new Worker(blobUrl);
    worker.onmessage = this._callback.bind(this);
    this._worker = worker;
  }
  _createTimeout() {
    this._timeout = setTimeout(() => {
      this._createTimeout();
      this._callback();
    }, this._updateInterval * 1e3);
  }
  _createClock() {
    if (this._type === "worker") {
      try {
        this._createWorker();
      } catch (e2) {
        this._type = "timeout";
        this._createClock();
      }
    } else if (this._type === "timeout") {
      this._createTimeout();
    }
  }
  _disposeClock() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (this._worker) {
      this._worker.terminate();
      this._worker.onmessage = null;
    }
  }
  get updateInterval() {
    return this._updateInterval;
  }
  set updateInterval(interval2) {
    var _a2;
    this._updateInterval = Math.max(interval2, this._minimumUpdateInterval);
    if (this._type === "worker") {
      (_a2 = this._worker) === null || _a2 === void 0 ? void 0 : _a2.postMessage(this._updateInterval * 1e3);
    }
  }
  get type() {
    return this._type;
  }
  set type(type) {
    this._disposeClock();
    this._type = type;
    this._createClock();
  }
  dispose() {
    this._disposeClock();
  }
};
function isAudioParam(arg) {
  return isAnyAudioParam(arg);
}
function isAudioNode(arg) {
  return isAnyAudioNode(arg);
}
function isOfflineAudioContext(arg) {
  return isAnyOfflineAudioContext(arg);
}
function isAudioContext(arg) {
  return isAnyAudioContext(arg);
}
function isAudioBuffer(arg) {
  return arg instanceof audioBufferConstructor;
}
function noCopy(key, arg) {
  return key === "value" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);
}
function deepMerge(target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (noCopy(key, source[key])) {
        target[key] = source[key];
      } else if (isObject(source[key])) {
        if (!target[key]) {
          Object.assign(target, { [key]: {} });
        }
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return deepMerge(target, ...sources);
}
function deepEquals(arrayA, arrayB) {
  return arrayA.length === arrayB.length && arrayA.every((element, index2) => arrayB[index2] === element);
}
function optionsFromArguments(defaults, argsArray, keys2 = [], objKey) {
  const opts = {};
  const args = Array.from(argsArray);
  if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {
    const partOfDefaults = Object.keys(args[0]).some((key) => Reflect.has(defaults, key));
    if (!partOfDefaults) {
      deepMerge(opts, { [objKey]: args[0] });
      keys2.splice(keys2.indexOf(objKey), 1);
      args.shift();
    }
  }
  if (args.length === 1 && isObject(args[0])) {
    deepMerge(opts, args[0]);
  } else {
    for (let i2 = 0; i2 < keys2.length; i2++) {
      if (isDefined(args[i2])) {
        opts[keys2[i2]] = args[i2];
      }
    }
  }
  return deepMerge(defaults, opts);
}
function getDefaultsFromInstance(instance) {
  return instance.constructor.getDefaults();
}
function defaultArg(given, fallback) {
  if (isUndef(given)) {
    return fallback;
  } else {
    return given;
  }
}
function omitFromObject(obj, omit) {
  omit.forEach((prop) => {
    if (Reflect.has(obj, prop)) {
      delete obj[prop];
    }
  });
  return obj;
}
var Tone = class {
  constructor() {
    this.debug = false;
    this._wasDisposed = false;
  }
  static getDefaults() {
    return {};
  }
  log(...args) {
    if (this.debug || theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS) {
      log(this, ...args);
    }
  }
  dispose() {
    this._wasDisposed = true;
    return this;
  }
  get disposed() {
    return this._wasDisposed;
  }
  toString() {
    return this.name;
  }
};
Tone.version = version;
var EPSILON = 1e-6;
function GT(a2, b2) {
  return a2 > b2 + EPSILON;
}
function GTE(a2, b2) {
  return GT(a2, b2) || EQ(a2, b2);
}
function LT(a2, b2) {
  return a2 + EPSILON < b2;
}
function EQ(a2, b2) {
  return Math.abs(a2 - b2) < EPSILON;
}
function clamp(value, min, max) {
  return Math.max(Math.min(value, max), min);
}
var Timeline = class extends Tone {
  constructor() {
    super();
    this.name = "Timeline";
    this._timeline = [];
    const options2 = optionsFromArguments(Timeline.getDefaults(), arguments, ["memory"]);
    this.memory = options2.memory;
    this.increasing = options2.increasing;
  }
  static getDefaults() {
    return {
      memory: Infinity,
      increasing: false
    };
  }
  get length() {
    return this._timeline.length;
  }
  add(event) {
    assert(Reflect.has(event, "time"), "Timeline: events must have a time attribute");
    event.time = event.time.valueOf();
    if (this.increasing && this.length) {
      const lastValue = this._timeline[this.length - 1];
      assert(GTE(event.time, lastValue.time), "The time must be greater than or equal to the last scheduled time");
      this._timeline.push(event);
    } else {
      const index2 = this._search(event.time);
      this._timeline.splice(index2 + 1, 0, event);
    }
    if (this.length > this.memory) {
      const diff = this.length - this.memory;
      this._timeline.splice(0, diff);
    }
    return this;
  }
  remove(event) {
    const index2 = this._timeline.indexOf(event);
    if (index2 !== -1) {
      this._timeline.splice(index2, 1);
    }
    return this;
  }
  get(time, param = "time") {
    const index2 = this._search(time, param);
    if (index2 !== -1) {
      return this._timeline[index2];
    } else {
      return null;
    }
  }
  peek() {
    return this._timeline[0];
  }
  shift() {
    return this._timeline.shift();
  }
  getAfter(time, param = "time") {
    const index2 = this._search(time, param);
    if (index2 + 1 < this._timeline.length) {
      return this._timeline[index2 + 1];
    } else {
      return null;
    }
  }
  getBefore(time) {
    const len = this._timeline.length;
    if (len > 0 && this._timeline[len - 1].time < time) {
      return this._timeline[len - 1];
    }
    const index2 = this._search(time);
    if (index2 - 1 >= 0) {
      return this._timeline[index2 - 1];
    } else {
      return null;
    }
  }
  cancel(after) {
    if (this._timeline.length > 1) {
      let index2 = this._search(after);
      if (index2 >= 0) {
        if (EQ(this._timeline[index2].time, after)) {
          for (let i2 = index2; i2 >= 0; i2--) {
            if (EQ(this._timeline[i2].time, after)) {
              index2 = i2;
            } else {
              break;
            }
          }
          this._timeline = this._timeline.slice(0, index2);
        } else {
          this._timeline = this._timeline.slice(0, index2 + 1);
        }
      } else {
        this._timeline = [];
      }
    } else if (this._timeline.length === 1) {
      if (GTE(this._timeline[0].time, after)) {
        this._timeline = [];
      }
    }
    return this;
  }
  cancelBefore(time) {
    const index2 = this._search(time);
    if (index2 >= 0) {
      this._timeline = this._timeline.slice(index2 + 1);
    }
    return this;
  }
  previousEvent(event) {
    const index2 = this._timeline.indexOf(event);
    if (index2 > 0) {
      return this._timeline[index2 - 1];
    } else {
      return null;
    }
  }
  _search(time, param = "time") {
    if (this._timeline.length === 0) {
      return -1;
    }
    let beginning = 0;
    const len = this._timeline.length;
    let end = len;
    if (len > 0 && this._timeline[len - 1][param] <= time) {
      return len - 1;
    }
    while (beginning < end) {
      let midPoint = Math.floor(beginning + (end - beginning) / 2);
      const event = this._timeline[midPoint];
      const nextEvent = this._timeline[midPoint + 1];
      if (EQ(event[param], time)) {
        for (let i2 = midPoint; i2 < this._timeline.length; i2++) {
          const testEvent = this._timeline[i2];
          if (EQ(testEvent[param], time)) {
            midPoint = i2;
          } else {
            break;
          }
        }
        return midPoint;
      } else if (LT(event[param], time) && GT(nextEvent[param], time)) {
        return midPoint;
      } else if (GT(event[param], time)) {
        end = midPoint;
      } else {
        beginning = midPoint + 1;
      }
    }
    return -1;
  }
  _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {
    this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);
  }
  forEach(callback) {
    this._iterate(callback);
    return this;
  }
  forEachBefore(time, callback) {
    const upperBound = this._search(time);
    if (upperBound !== -1) {
      this._iterate(callback, 0, upperBound);
    }
    return this;
  }
  forEachAfter(time, callback) {
    const lowerBound = this._search(time);
    this._iterate(callback, lowerBound + 1);
    return this;
  }
  forEachBetween(startTime, endTime, callback) {
    let lowerBound = this._search(startTime);
    let upperBound = this._search(endTime);
    if (lowerBound !== -1 && upperBound !== -1) {
      if (this._timeline[lowerBound].time !== startTime) {
        lowerBound += 1;
      }
      if (this._timeline[upperBound].time === endTime) {
        upperBound -= 1;
      }
      this._iterate(callback, lowerBound, upperBound);
    } else if (lowerBound === -1) {
      this._iterate(callback, 0, upperBound);
    }
    return this;
  }
  forEachFrom(time, callback) {
    let lowerBound = this._search(time);
    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {
      lowerBound--;
    }
    this._iterate(callback, lowerBound + 1);
    return this;
  }
  forEachAtTime(time, callback) {
    const upperBound = this._search(time);
    if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {
      let lowerBound = upperBound;
      for (let i2 = upperBound; i2 >= 0; i2--) {
        if (EQ(this._timeline[i2].time, time)) {
          lowerBound = i2;
        } else {
          break;
        }
      }
      this._iterate((event) => {
        callback(event);
      }, lowerBound, upperBound);
    }
    return this;
  }
  dispose() {
    super.dispose();
    this._timeline = [];
    return this;
  }
};
var notifyNewContext = [];
function onContextInit(cb) {
  notifyNewContext.push(cb);
}
function initializeContext(ctx) {
  notifyNewContext.forEach((cb) => cb(ctx));
}
var notifyCloseContext = [];
function onContextClose(cb) {
  notifyCloseContext.push(cb);
}
function closeContext(ctx) {
  notifyCloseContext.forEach((cb) => cb(ctx));
}
var Emitter = class extends Tone {
  constructor() {
    super(...arguments);
    this.name = "Emitter";
  }
  on(event, callback) {
    const events = event.split(/\W+/);
    events.forEach((eventName) => {
      if (isUndef(this._events)) {
        this._events = {};
      }
      if (!this._events.hasOwnProperty(eventName)) {
        this._events[eventName] = [];
      }
      this._events[eventName].push(callback);
    });
    return this;
  }
  once(event, callback) {
    const boundCallback = (...args) => {
      callback(...args);
      this.off(event, boundCallback);
    };
    this.on(event, boundCallback);
    return this;
  }
  off(event, callback) {
    const events = event.split(/\W+/);
    events.forEach((eventName) => {
      if (isUndef(this._events)) {
        this._events = {};
      }
      if (this._events.hasOwnProperty(eventName)) {
        if (isUndef(callback)) {
          this._events[eventName] = [];
        } else {
          const eventList = this._events[eventName];
          for (let i2 = eventList.length - 1; i2 >= 0; i2--) {
            if (eventList[i2] === callback) {
              eventList.splice(i2, 1);
            }
          }
        }
      }
    });
    return this;
  }
  emit(event, ...args) {
    if (this._events) {
      if (this._events.hasOwnProperty(event)) {
        const eventList = this._events[event].slice(0);
        for (let i2 = 0, len = eventList.length; i2 < len; i2++) {
          eventList[i2].apply(this, args);
        }
      }
    }
    return this;
  }
  static mixin(constr) {
    ["on", "once", "off", "emit"].forEach((name2) => {
      const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name2);
      Object.defineProperty(constr.prototype, name2, property);
    });
  }
  dispose() {
    super.dispose();
    this._events = void 0;
    return this;
  }
};
var BaseContext = class extends Emitter {
  constructor() {
    super(...arguments);
    this.isOffline = false;
  }
  toJSON() {
    return {};
  }
};
var Context = class extends BaseContext {
  constructor() {
    var _a2, _b;
    super();
    this.name = "Context";
    this._constants = /* @__PURE__ */ new Map();
    this._timeouts = new Timeline();
    this._timeoutIds = 0;
    this._initialized = false;
    this.isOffline = false;
    this._workletPromise = null;
    const options2 = optionsFromArguments(Context.getDefaults(), arguments, [
      "context"
    ]);
    if (options2.context) {
      this._context = options2.context;
      this._latencyHint = ((_a2 = arguments[0]) === null || _a2 === void 0 ? void 0 : _a2.latencyHint) || "";
    } else {
      this._context = createAudioContext({
        latencyHint: options2.latencyHint
      });
      this._latencyHint = options2.latencyHint;
    }
    this._ticker = new Ticker(this.emit.bind(this, "tick"), options2.clockSource, options2.updateInterval, this._context.sampleRate);
    this.on("tick", this._timeoutLoop.bind(this));
    this._context.onstatechange = () => {
      this.emit("statechange", this.state);
    };
    this[((_b = arguments[0]) === null || _b === void 0 ? void 0 : _b.hasOwnProperty("updateInterval")) ? "_lookAhead" : "lookAhead"] = options2.lookAhead;
  }
  static getDefaults() {
    return {
      clockSource: "worker",
      latencyHint: "interactive",
      lookAhead: 0.1,
      updateInterval: 0.05
    };
  }
  initialize() {
    if (!this._initialized) {
      initializeContext(this);
      this._initialized = true;
    }
    return this;
  }
  createAnalyser() {
    return this._context.createAnalyser();
  }
  createOscillator() {
    return this._context.createOscillator();
  }
  createBufferSource() {
    return this._context.createBufferSource();
  }
  createBiquadFilter() {
    return this._context.createBiquadFilter();
  }
  createBuffer(numberOfChannels, length, sampleRate) {
    return this._context.createBuffer(numberOfChannels, length, sampleRate);
  }
  createChannelMerger(numberOfInputs) {
    return this._context.createChannelMerger(numberOfInputs);
  }
  createChannelSplitter(numberOfOutputs) {
    return this._context.createChannelSplitter(numberOfOutputs);
  }
  createConstantSource() {
    return this._context.createConstantSource();
  }
  createConvolver() {
    return this._context.createConvolver();
  }
  createDelay(maxDelayTime) {
    return this._context.createDelay(maxDelayTime);
  }
  createDynamicsCompressor() {
    return this._context.createDynamicsCompressor();
  }
  createGain() {
    return this._context.createGain();
  }
  createIIRFilter(feedForward, feedback) {
    return this._context.createIIRFilter(feedForward, feedback);
  }
  createPanner() {
    return this._context.createPanner();
  }
  createPeriodicWave(real, imag, constraints) {
    return this._context.createPeriodicWave(real, imag, constraints);
  }
  createStereoPanner() {
    return this._context.createStereoPanner();
  }
  createWaveShaper() {
    return this._context.createWaveShaper();
  }
  createMediaStreamSource(stream) {
    assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
    const context2 = this._context;
    return context2.createMediaStreamSource(stream);
  }
  createMediaElementSource(element) {
    assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
    const context2 = this._context;
    return context2.createMediaElementSource(element);
  }
  createMediaStreamDestination() {
    assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
    const context2 = this._context;
    return context2.createMediaStreamDestination();
  }
  decodeAudioData(audioData) {
    return this._context.decodeAudioData(audioData);
  }
  get currentTime() {
    return this._context.currentTime;
  }
  get state() {
    return this._context.state;
  }
  get sampleRate() {
    return this._context.sampleRate;
  }
  get listener() {
    this.initialize();
    return this._listener;
  }
  set listener(l2) {
    assert(!this._initialized, "The listener cannot be set after initialization.");
    this._listener = l2;
  }
  get transport() {
    this.initialize();
    return this._transport;
  }
  set transport(t2) {
    assert(!this._initialized, "The transport cannot be set after initialization.");
    this._transport = t2;
  }
  get draw() {
    this.initialize();
    return this._draw;
  }
  set draw(d2) {
    assert(!this._initialized, "Draw cannot be set after initialization.");
    this._draw = d2;
  }
  get destination() {
    this.initialize();
    return this._destination;
  }
  set destination(d2) {
    assert(!this._initialized, "The destination cannot be set after initialization.");
    this._destination = d2;
  }
  createAudioWorkletNode(name2, options2) {
    return createAudioWorkletNode(this.rawContext, name2, options2);
  }
  addAudioWorkletModule(url) {
    return __awaiter(this, void 0, void 0, function* () {
      assert(isDefined(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)");
      if (!this._workletPromise) {
        this._workletPromise = this.rawContext.audioWorklet.addModule(url);
      }
      yield this._workletPromise;
    });
  }
  workletsAreReady() {
    return __awaiter(this, void 0, void 0, function* () {
      (yield this._workletPromise) ? this._workletPromise : Promise.resolve();
    });
  }
  get updateInterval() {
    return this._ticker.updateInterval;
  }
  set updateInterval(interval2) {
    this._ticker.updateInterval = interval2;
  }
  get clockSource() {
    return this._ticker.type;
  }
  set clockSource(type) {
    this._ticker.type = type;
  }
  get lookAhead() {
    return this._lookAhead;
  }
  set lookAhead(time) {
    this._lookAhead = time;
    this.updateInterval = time ? time / 2 : 0.01;
  }
  get latencyHint() {
    return this._latencyHint;
  }
  get rawContext() {
    return this._context;
  }
  now() {
    return this._context.currentTime + this._lookAhead;
  }
  immediate() {
    return this._context.currentTime;
  }
  resume() {
    if (isAudioContext(this._context)) {
      return this._context.resume();
    } else {
      return Promise.resolve();
    }
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      if (isAudioContext(this._context)) {
        yield this._context.close();
      }
      if (this._initialized) {
        closeContext(this);
      }
    });
  }
  getConstant(val) {
    if (this._constants.has(val)) {
      return this._constants.get(val);
    } else {
      const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);
      const arr = buffer.getChannelData(0);
      for (let i2 = 0; i2 < arr.length; i2++) {
        arr[i2] = val;
      }
      const constant = this._context.createBufferSource();
      constant.channelCount = 1;
      constant.channelCountMode = "explicit";
      constant.buffer = buffer;
      constant.loop = true;
      constant.start(0);
      this._constants.set(val, constant);
      return constant;
    }
  }
  dispose() {
    super.dispose();
    this._ticker.dispose();
    this._timeouts.dispose();
    Object.keys(this._constants).map((val) => this._constants[val].disconnect());
    return this;
  }
  _timeoutLoop() {
    const now2 = this.now();
    let firstEvent = this._timeouts.peek();
    while (this._timeouts.length && firstEvent && firstEvent.time <= now2) {
      firstEvent.callback();
      this._timeouts.shift();
      firstEvent = this._timeouts.peek();
    }
  }
  setTimeout(fn, timeout) {
    this._timeoutIds++;
    const now2 = this.now();
    this._timeouts.add({
      callback: fn,
      id: this._timeoutIds,
      time: now2 + timeout
    });
    return this._timeoutIds;
  }
  clearTimeout(id) {
    this._timeouts.forEach((event) => {
      if (event.id === id) {
        this._timeouts.remove(event);
      }
    });
    return this;
  }
  clearInterval(id) {
    return this.clearTimeout(id);
  }
  setInterval(fn, interval2) {
    const id = ++this._timeoutIds;
    const intervalFn = () => {
      const now2 = this.now();
      this._timeouts.add({
        callback: () => {
          fn();
          intervalFn();
        },
        id,
        time: now2 + interval2
      });
    };
    intervalFn();
    return id;
  }
};
var DummyContext = class extends BaseContext {
  constructor() {
    super(...arguments);
    this.lookAhead = 0;
    this.latencyHint = 0;
    this.isOffline = false;
  }
  createAnalyser() {
    return {};
  }
  createOscillator() {
    return {};
  }
  createBufferSource() {
    return {};
  }
  createBiquadFilter() {
    return {};
  }
  createBuffer(_numberOfChannels, _length, _sampleRate) {
    return {};
  }
  createChannelMerger(_numberOfInputs) {
    return {};
  }
  createChannelSplitter(_numberOfOutputs) {
    return {};
  }
  createConstantSource() {
    return {};
  }
  createConvolver() {
    return {};
  }
  createDelay(_maxDelayTime) {
    return {};
  }
  createDynamicsCompressor() {
    return {};
  }
  createGain() {
    return {};
  }
  createIIRFilter(_feedForward, _feedback) {
    return {};
  }
  createPanner() {
    return {};
  }
  createPeriodicWave(_real, _imag, _constraints) {
    return {};
  }
  createStereoPanner() {
    return {};
  }
  createWaveShaper() {
    return {};
  }
  createMediaStreamSource(_stream) {
    return {};
  }
  createMediaElementSource(_element) {
    return {};
  }
  createMediaStreamDestination() {
    return {};
  }
  decodeAudioData(_audioData) {
    return Promise.resolve({});
  }
  createAudioWorkletNode(_name, _options) {
    return {};
  }
  get rawContext() {
    return {};
  }
  addAudioWorkletModule(_url) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  resume() {
    return Promise.resolve();
  }
  setTimeout(_fn, _timeout) {
    return 0;
  }
  clearTimeout(_id) {
    return this;
  }
  setInterval(_fn, _interval) {
    return 0;
  }
  clearInterval(_id) {
    return this;
  }
  getConstant(_val) {
    return {};
  }
  get currentTime() {
    return 0;
  }
  get state() {
    return {};
  }
  get sampleRate() {
    return 0;
  }
  get listener() {
    return {};
  }
  get transport() {
    return {};
  }
  get draw() {
    return {};
  }
  set draw(_d) {
  }
  get destination() {
    return {};
  }
  set destination(_d) {
  }
  now() {
    return 0;
  }
  immediate() {
    return 0;
  }
};
function readOnly(target, property) {
  if (isArray(property)) {
    property.forEach((str) => readOnly(target, str));
  } else {
    Object.defineProperty(target, property, {
      enumerable: true,
      writable: false
    });
  }
}
function writable(target, property) {
  if (isArray(property)) {
    property.forEach((str) => writable(target, str));
  } else {
    Object.defineProperty(target, property, {
      writable: true
    });
  }
}
var noOp = () => {
};
var ToneAudioBuffer = class extends Tone {
  constructor() {
    super();
    this.name = "ToneAudioBuffer";
    this.onload = noOp;
    const options2 = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, ["url", "onload", "onerror"]);
    this.reverse = options2.reverse;
    this.onload = options2.onload;
    if (isString(options2.url)) {
      this.load(options2.url).catch(options2.onerror);
    } else if (options2.url) {
      this.set(options2.url);
    }
  }
  static getDefaults() {
    return {
      onerror: noOp,
      onload: noOp,
      reverse: false
    };
  }
  get sampleRate() {
    if (this._buffer) {
      return this._buffer.sampleRate;
    } else {
      return getContext().sampleRate;
    }
  }
  set(buffer) {
    if (buffer instanceof ToneAudioBuffer) {
      if (buffer.loaded) {
        this._buffer = buffer.get();
      } else {
        buffer.onload = () => {
          this.set(buffer);
          this.onload(this);
        };
      }
    } else {
      this._buffer = buffer;
    }
    if (this._reversed) {
      this._reverse();
    }
    return this;
  }
  get() {
    return this._buffer;
  }
  load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      const doneLoading = ToneAudioBuffer.load(url).then((audioBuffer) => {
        this.set(audioBuffer);
        this.onload(this);
      });
      ToneAudioBuffer.downloads.push(doneLoading);
      try {
        yield doneLoading;
      } finally {
        const index2 = ToneAudioBuffer.downloads.indexOf(doneLoading);
        ToneAudioBuffer.downloads.splice(index2, 1);
      }
      return this;
    });
  }
  dispose() {
    super.dispose();
    this._buffer = void 0;
    return this;
  }
  fromArray(array) {
    const isMultidimensional = isArray(array) && array[0].length > 0;
    const channels2 = isMultidimensional ? array.length : 1;
    const len = isMultidimensional ? array[0].length : array.length;
    const context2 = getContext();
    const buffer = context2.createBuffer(channels2, len, context2.sampleRate);
    const multiChannelArray = !isMultidimensional && channels2 === 1 ? [array] : array;
    for (let c2 = 0; c2 < channels2; c2++) {
      buffer.copyToChannel(multiChannelArray[c2], c2);
    }
    this._buffer = buffer;
    return this;
  }
  toMono(chanNum) {
    if (isNumber(chanNum)) {
      this.fromArray(this.toArray(chanNum));
    } else {
      let outputArray = new Float32Array(this.length);
      const numChannels = this.numberOfChannels;
      for (let channel = 0; channel < numChannels; channel++) {
        const channelArray = this.toArray(channel);
        for (let i2 = 0; i2 < channelArray.length; i2++) {
          outputArray[i2] += channelArray[i2];
        }
      }
      outputArray = outputArray.map((sample) => sample / numChannels);
      this.fromArray(outputArray);
    }
    return this;
  }
  toArray(channel) {
    if (isNumber(channel)) {
      return this.getChannelData(channel);
    } else if (this.numberOfChannels === 1) {
      return this.toArray(0);
    } else {
      const ret = [];
      for (let c2 = 0; c2 < this.numberOfChannels; c2++) {
        ret[c2] = this.getChannelData(c2);
      }
      return ret;
    }
  }
  getChannelData(channel) {
    if (this._buffer) {
      return this._buffer.getChannelData(channel);
    } else {
      return new Float32Array(0);
    }
  }
  slice(start22, end = this.duration) {
    assert(this.loaded, "Buffer is not loaded");
    const startSamples = Math.floor(start22 * this.sampleRate);
    const endSamples = Math.floor(end * this.sampleRate);
    assert(startSamples < endSamples, "The start time must be less than the end time");
    const length = endSamples - startSamples;
    const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);
    for (let channel = 0; channel < this.numberOfChannels; channel++) {
      retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);
    }
    return new ToneAudioBuffer(retBuffer);
  }
  _reverse() {
    if (this.loaded) {
      for (let i2 = 0; i2 < this.numberOfChannels; i2++) {
        this.getChannelData(i2).reverse();
      }
    }
    return this;
  }
  get loaded() {
    return this.length > 0;
  }
  get duration() {
    if (this._buffer) {
      return this._buffer.duration;
    } else {
      return 0;
    }
  }
  get length() {
    if (this._buffer) {
      return this._buffer.length;
    } else {
      return 0;
    }
  }
  get numberOfChannels() {
    if (this._buffer) {
      return this._buffer.numberOfChannels;
    } else {
      return 0;
    }
  }
  get reverse() {
    return this._reversed;
  }
  set reverse(rev) {
    if (this._reversed !== rev) {
      this._reversed = rev;
      this._reverse();
    }
  }
  static fromArray(array) {
    return new ToneAudioBuffer().fromArray(array);
  }
  static fromUrl(url) {
    return __awaiter(this, void 0, void 0, function* () {
      const buffer = new ToneAudioBuffer();
      return yield buffer.load(url);
    });
  }
  static load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      const matches = url.match(/\[([^\]\[]+\|.+)\]$/);
      if (matches) {
        const extensions = matches[1].split("|");
        let extension = extensions[0];
        for (const ext of extensions) {
          if (ToneAudioBuffer.supportsType(ext)) {
            extension = ext;
            break;
          }
        }
        url = url.replace(matches[0], extension);
      }
      const baseUrl = ToneAudioBuffer.baseUrl === "" || ToneAudioBuffer.baseUrl.endsWith("/") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + "/";
      const location = document.createElement("a");
      location.href = baseUrl + url;
      location.pathname = (location.pathname + location.hash).split("/").map(encodeURIComponent).join("/");
      const response = yield fetch(location.href);
      if (!response.ok) {
        throw new Error(`could not load url: ${url}`);
      }
      const arrayBuffer = yield response.arrayBuffer();
      const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);
      return audioBuffer;
    });
  }
  static supportsType(url) {
    const extensions = url.split(".");
    const extension = extensions[extensions.length - 1];
    const response = document.createElement("audio").canPlayType("audio/" + extension);
    return response !== "";
  }
  static loaded() {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.resolve();
      while (ToneAudioBuffer.downloads.length) {
        yield ToneAudioBuffer.downloads[0];
      }
    });
  }
};
ToneAudioBuffer.baseUrl = "";
ToneAudioBuffer.downloads = [];
var OfflineContext = class extends Context {
  constructor() {
    super({
      clockSource: "offline",
      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),
      lookAhead: 0,
      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
    });
    this.name = "OfflineContext";
    this._currentTime = 0;
    this.isOffline = true;
    this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
  }
  now() {
    return this._currentTime;
  }
  get currentTime() {
    return this._currentTime;
  }
  _renderClock(asynchronous) {
    return __awaiter(this, void 0, void 0, function* () {
      let index2 = 0;
      while (this._duration - this._currentTime >= 0) {
        this.emit("tick");
        this._currentTime += 128 / this.sampleRate;
        index2++;
        const yieldEvery = Math.floor(this.sampleRate / 128);
        if (asynchronous && index2 % yieldEvery === 0) {
          yield new Promise((done) => setTimeout(done, 1));
        }
      }
    });
  }
  render(asynchronous = true) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.workletsAreReady();
      yield this._renderClock(asynchronous);
      const buffer = yield this._context.startRendering();
      return new ToneAudioBuffer(buffer);
    });
  }
  close() {
    return Promise.resolve();
  }
};
var dummyContext = new DummyContext();
var globalContext = dummyContext;
function getContext() {
  if (globalContext === dummyContext && hasAudioContext) {
    setContext(new Context());
  }
  return globalContext;
}
function setContext(context2, disposeOld = false) {
  if (disposeOld) {
    globalContext.dispose();
  }
  if (isAudioContext(context2)) {
    globalContext = new Context(context2);
  } else if (isOfflineAudioContext(context2)) {
    globalContext = new OfflineContext(context2);
  } else {
    globalContext = context2;
  }
}
function start() {
  return globalContext.resume();
}
if (theWindow && !theWindow.TONE_SILENCE_LOGGING) {
  let prefix = "v";
  const printString = ` * Tone.js ${prefix}${version} * `;
  console.log(`%c${printString}`, "background: #000; color: #fff");
}
function dbToGain(db) {
  return Math.pow(10, db / 20);
}
function gainToDb(gain) {
  return 20 * (Math.log(gain) / Math.LN10);
}
function intervalToFrequencyRatio(interval2) {
  return Math.pow(2, interval2 / 12);
}
var A4 = 440;
function getA4() {
  return A4;
}
function setA4(freq2) {
  A4 = freq2;
}
function ftom(frequency) {
  return Math.round(ftomf(frequency));
}
function ftomf(frequency) {
  return 69 + 12 * Math.log2(frequency / A4);
}
function mtof(midi2) {
  return A4 * Math.pow(2, (midi2 - 69) / 12);
}
var TimeBaseClass = class extends Tone {
  constructor(context2, value, units) {
    super();
    this.defaultUnits = "s";
    this._val = value;
    this._units = units;
    this.context = context2;
    this._expressions = this._getExpressions();
  }
  _getExpressions() {
    return {
      hz: {
        method: (value) => {
          return this._frequencyToUnits(parseFloat(value));
        },
        regexp: /^(\d+(?:\.\d+)?)hz$/i
      },
      i: {
        method: (value) => {
          return this._ticksToUnits(parseInt(value, 10));
        },
        regexp: /^(\d+)i$/i
      },
      m: {
        method: (value) => {
          return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());
        },
        regexp: /^(\d+)m$/i
      },
      n: {
        method: (value, dot) => {
          const numericValue = parseInt(value, 10);
          const scalar = dot === "." ? 1.5 : 1;
          if (numericValue === 1) {
            return this._beatsToUnits(this._getTimeSignature()) * scalar;
          } else {
            return this._beatsToUnits(4 / numericValue) * scalar;
          }
        },
        regexp: /^(\d+)n(\.?)$/i
      },
      number: {
        method: (value) => {
          return this._expressions[this.defaultUnits].method.call(this, value);
        },
        regexp: /^(\d+(?:\.\d+)?)$/
      },
      s: {
        method: (value) => {
          return this._secondsToUnits(parseFloat(value));
        },
        regexp: /^(\d+(?:\.\d+)?)s$/
      },
      samples: {
        method: (value) => {
          return parseInt(value, 10) / this.context.sampleRate;
        },
        regexp: /^(\d+)samples$/
      },
      t: {
        method: (value) => {
          const numericValue = parseInt(value, 10);
          return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));
        },
        regexp: /^(\d+)t$/i
      },
      tr: {
        method: (m2, q, s2) => {
          let total = 0;
          if (m2 && m2 !== "0") {
            total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m2));
          }
          if (q && q !== "0") {
            total += this._beatsToUnits(parseFloat(q));
          }
          if (s2 && s2 !== "0") {
            total += this._beatsToUnits(parseFloat(s2) / 4);
          }
          return total;
        },
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
      }
    };
  }
  valueOf() {
    if (this._val instanceof TimeBaseClass) {
      this.fromType(this._val);
    }
    if (isUndef(this._val)) {
      return this._noArg();
    } else if (isString(this._val) && isUndef(this._units)) {
      for (const units in this._expressions) {
        if (this._expressions[units].regexp.test(this._val.trim())) {
          this._units = units;
          break;
        }
      }
    } else if (isObject(this._val)) {
      let total = 0;
      for (const typeName in this._val) {
        if (isDefined(this._val[typeName])) {
          const quantity = this._val[typeName];
          const time = new this.constructor(this.context, typeName).valueOf() * quantity;
          total += time;
        }
      }
      return total;
    }
    if (isDefined(this._units)) {
      const expr = this._expressions[this._units];
      const matching = this._val.toString().trim().match(expr.regexp);
      if (matching) {
        return expr.method.apply(this, matching.slice(1));
      } else {
        return expr.method.call(this, this._val);
      }
    } else if (isString(this._val)) {
      return parseFloat(this._val);
    } else {
      return this._val;
    }
  }
  _frequencyToUnits(freq2) {
    return 1 / freq2;
  }
  _beatsToUnits(beats) {
    return 60 / this._getBpm() * beats;
  }
  _secondsToUnits(seconds) {
    return seconds;
  }
  _ticksToUnits(ticks) {
    return ticks * this._beatsToUnits(1) / this._getPPQ();
  }
  _noArg() {
    return this._now();
  }
  _getBpm() {
    return this.context.transport.bpm.value;
  }
  _getTimeSignature() {
    return this.context.transport.timeSignature;
  }
  _getPPQ() {
    return this.context.transport.PPQ;
  }
  fromType(type) {
    this._units = void 0;
    switch (this.defaultUnits) {
      case "s":
        this._val = type.toSeconds();
        break;
      case "i":
        this._val = type.toTicks();
        break;
      case "hz":
        this._val = type.toFrequency();
        break;
      case "midi":
        this._val = type.toMidi();
        break;
    }
    return this;
  }
  toFrequency() {
    return 1 / this.toSeconds();
  }
  toSamples() {
    return this.toSeconds() * this.context.sampleRate;
  }
  toMilliseconds() {
    return this.toSeconds() * 1e3;
  }
};
var TimeClass = class extends TimeBaseClass {
  constructor() {
    super(...arguments);
    this.name = "TimeClass";
  }
  _getExpressions() {
    return Object.assign(super._getExpressions(), {
      now: {
        method: (capture) => {
          return this._now() + new this.constructor(this.context, capture).valueOf();
        },
        regexp: /^\+(.+)/
      },
      quantize: {
        method: (capture) => {
          const quantTo = new TimeClass(this.context, capture).valueOf();
          return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));
        },
        regexp: /^@(.+)/
      }
    });
  }
  quantize(subdiv, percent = 1) {
    const subdivision = new this.constructor(this.context, subdiv).valueOf();
    const value = this.valueOf();
    const multiple = Math.round(value / subdivision);
    const ideal = multiple * subdivision;
    const diff = ideal - value;
    return value + diff * percent;
  }
  toNotation() {
    const time = this.toSeconds();
    const testNotations = ["1m"];
    for (let power = 1; power < 9; power++) {
      const subdiv = Math.pow(2, power);
      testNotations.push(subdiv + "n.");
      testNotations.push(subdiv + "n");
      testNotations.push(subdiv + "t");
    }
    testNotations.push("0");
    let closest = testNotations[0];
    let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();
    testNotations.forEach((notation) => {
      const notationSeconds = new TimeClass(this.context, notation).toSeconds();
      if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {
        closest = notation;
        closestSeconds = notationSeconds;
      }
    });
    return closest;
  }
  toBarsBeatsSixteenths() {
    const quarterTime = this._beatsToUnits(1);
    let quarters = this.valueOf() / quarterTime;
    quarters = parseFloat(quarters.toFixed(4));
    const measures = Math.floor(quarters / this._getTimeSignature());
    let sixteenths = quarters % 1 * 4;
    quarters = Math.floor(quarters) % this._getTimeSignature();
    const sixteenthString = sixteenths.toString();
    if (sixteenthString.length > 3) {
      sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));
    }
    const progress = [measures, quarters, sixteenths];
    return progress.join(":");
  }
  toTicks() {
    const quarterTime = this._beatsToUnits(1);
    const quarters = this.valueOf() / quarterTime;
    return quarters * this._getPPQ();
  }
  toSeconds() {
    return this.valueOf();
  }
  toMidi() {
    return ftom(this.toFrequency());
  }
  _now() {
    return this.context.now();
  }
};
function Time(value, units) {
  return new TimeClass(getContext(), value, units);
}
var FrequencyClass = class extends TimeClass {
  constructor() {
    super(...arguments);
    this.name = "Frequency";
    this.defaultUnits = "hz";
  }
  static get A4() {
    return getA4();
  }
  static set A4(freq2) {
    setA4(freq2);
  }
  _getExpressions() {
    return Object.assign({}, super._getExpressions(), {
      midi: {
        regexp: /^(\d+(?:\.\d+)?midi)/,
        method(value) {
          if (this.defaultUnits === "midi") {
            return value;
          } else {
            return FrequencyClass.mtof(value);
          }
        }
      },
      note: {
        regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
        method(pitch, octave2) {
          const index2 = noteToScaleIndex[pitch.toLowerCase()];
          const noteNumber = index2 + (parseInt(octave2, 10) + 1) * 12;
          if (this.defaultUnits === "midi") {
            return noteNumber;
          } else {
            return FrequencyClass.mtof(noteNumber);
          }
        }
      },
      tr: {
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
        method(m2, q, s2) {
          let total = 1;
          if (m2 && m2 !== "0") {
            total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m2));
          }
          if (q && q !== "0") {
            total *= this._beatsToUnits(parseFloat(q));
          }
          if (s2 && s2 !== "0") {
            total *= this._beatsToUnits(parseFloat(s2) / 4);
          }
          return total;
        }
      }
    });
  }
  transpose(interval2) {
    return new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval2));
  }
  harmonize(intervals2) {
    return intervals2.map((interval2) => {
      return this.transpose(interval2);
    });
  }
  toMidi() {
    return ftom(this.valueOf());
  }
  toNote() {
    const freq2 = this.toFrequency();
    const log2 = Math.log2(freq2 / FrequencyClass.A4);
    let noteNumber = Math.round(12 * log2) + 57;
    const octave2 = Math.floor(noteNumber / 12);
    if (octave2 < 0) {
      noteNumber += -12 * octave2;
    }
    const noteName = scaleIndexToNote[noteNumber % 12];
    return noteName + octave2.toString();
  }
  toSeconds() {
    return 1 / super.toSeconds();
  }
  toTicks() {
    const quarterTime = this._beatsToUnits(1);
    const quarters = this.valueOf() / quarterTime;
    return Math.floor(quarters * this._getPPQ());
  }
  _noArg() {
    return 0;
  }
  _frequencyToUnits(freq2) {
    return freq2;
  }
  _ticksToUnits(ticks) {
    return 1 / (ticks * 60 / (this._getBpm() * this._getPPQ()));
  }
  _beatsToUnits(beats) {
    return 1 / super._beatsToUnits(beats);
  }
  _secondsToUnits(seconds) {
    return 1 / seconds;
  }
  static mtof(midi2) {
    return mtof(midi2);
  }
  static ftom(frequency) {
    return ftom(frequency);
  }
};
var noteToScaleIndex = {
  cbbb: -3,
  cbb: -2,
  cb: -1,
  c: 0,
  "c#": 1,
  cx: 2,
  "c##": 2,
  "c###": 3,
  "cx#": 3,
  "c#x": 3,
  dbbb: -1,
  dbb: 0,
  db: 1,
  d: 2,
  "d#": 3,
  dx: 4,
  "d##": 4,
  "d###": 5,
  "dx#": 5,
  "d#x": 5,
  ebbb: 1,
  ebb: 2,
  eb: 3,
  e: 4,
  "e#": 5,
  ex: 6,
  "e##": 6,
  "e###": 7,
  "ex#": 7,
  "e#x": 7,
  fbbb: 2,
  fbb: 3,
  fb: 4,
  f: 5,
  "f#": 6,
  fx: 7,
  "f##": 7,
  "f###": 8,
  "fx#": 8,
  "f#x": 8,
  gbbb: 4,
  gbb: 5,
  gb: 6,
  g: 7,
  "g#": 8,
  gx: 9,
  "g##": 9,
  "g###": 10,
  "gx#": 10,
  "g#x": 10,
  abbb: 6,
  abb: 7,
  ab: 8,
  a: 9,
  "a#": 10,
  ax: 11,
  "a##": 11,
  "a###": 12,
  "ax#": 12,
  "a#x": 12,
  bbbb: 8,
  bbb: 9,
  bb: 10,
  b: 11,
  "b#": 12,
  bx: 13,
  "b##": 13,
  "b###": 14,
  "bx#": 14,
  "b#x": 14
};
var scaleIndexToNote = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
function Frequency(value, units) {
  return new FrequencyClass(getContext(), value, units);
}
var TransportTimeClass = class extends TimeClass {
  constructor() {
    super(...arguments);
    this.name = "TransportTime";
  }
  _now() {
    return this.context.transport.seconds;
  }
};
var ToneWithContext = class extends Tone {
  constructor() {
    super();
    const options2 = optionsFromArguments(ToneWithContext.getDefaults(), arguments, ["context"]);
    if (this.defaultContext) {
      this.context = this.defaultContext;
    } else {
      this.context = options2.context;
    }
  }
  static getDefaults() {
    return {
      context: getContext()
    };
  }
  now() {
    return this.context.currentTime + this.context.lookAhead;
  }
  immediate() {
    return this.context.currentTime;
  }
  get sampleTime() {
    return 1 / this.context.sampleRate;
  }
  get blockTime() {
    return 128 / this.context.sampleRate;
  }
  toSeconds(time) {
    assertUsedScheduleTime(time);
    return new TimeClass(this.context, time).toSeconds();
  }
  toFrequency(freq2) {
    return new FrequencyClass(this.context, freq2).toFrequency();
  }
  toTicks(time) {
    return new TransportTimeClass(this.context, time).toTicks();
  }
  _getPartialProperties(props) {
    const options2 = this.get();
    Object.keys(options2).forEach((name2) => {
      if (isUndef(props[name2])) {
        delete options2[name2];
      }
    });
    return options2;
  }
  get() {
    const defaults = getDefaultsFromInstance(this);
    Object.keys(defaults).forEach((attribute) => {
      if (Reflect.has(this, attribute)) {
        const member = this[attribute];
        if (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {
          defaults[attribute] = member.value;
        } else if (member instanceof ToneWithContext) {
          defaults[attribute] = member._getPartialProperties(defaults[attribute]);
        } else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {
          defaults[attribute] = member;
        } else {
          delete defaults[attribute];
        }
      }
    });
    return defaults;
  }
  set(props) {
    Object.keys(props).forEach((attribute) => {
      if (Reflect.has(this, attribute) && isDefined(this[attribute])) {
        if (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {
          if (this[attribute].value !== props[attribute]) {
            this[attribute].value = props[attribute];
          }
        } else if (this[attribute] instanceof ToneWithContext) {
          this[attribute].set(props[attribute]);
        } else {
          this[attribute] = props[attribute];
        }
      }
    });
    return this;
  }
};
var StateTimeline = class extends Timeline {
  constructor(initial = "stopped") {
    super();
    this.name = "StateTimeline";
    this._initial = initial;
    this.setStateAtTime(this._initial, 0);
  }
  getValueAtTime(time) {
    const event = this.get(time);
    if (event !== null) {
      return event.state;
    } else {
      return this._initial;
    }
  }
  setStateAtTime(state, time, options2) {
    assertRange(time, 0);
    this.add(Object.assign({}, options2, {
      state,
      time
    }));
    return this;
  }
  getLastState(state, time) {
    const index2 = this._search(time);
    for (let i2 = index2; i2 >= 0; i2--) {
      const event = this._timeline[i2];
      if (event.state === state) {
        return event;
      }
    }
  }
  getNextState(state, time) {
    const index2 = this._search(time);
    if (index2 !== -1) {
      for (let i2 = index2; i2 < this._timeline.length; i2++) {
        const event = this._timeline[i2];
        if (event.state === state) {
          return event;
        }
      }
    }
  }
};
var Param = class extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(Param.getDefaults(), arguments, ["param", "units", "convert"]));
    this.name = "Param";
    this.overridden = false;
    this._minOutput = 1e-7;
    const options2 = optionsFromArguments(Param.getDefaults(), arguments, ["param", "units", "convert"]);
    assert(isDefined(options2.param) && (isAudioParam(options2.param) || options2.param instanceof Param), "param must be an AudioParam");
    while (!isAudioParam(options2.param)) {
      options2.param = options2.param._param;
    }
    this._swappable = isDefined(options2.swappable) ? options2.swappable : false;
    if (this._swappable) {
      this.input = this.context.createGain();
      this._param = options2.param;
      this.input.connect(this._param);
    } else {
      this._param = this.input = options2.param;
    }
    this._events = new Timeline(1e3);
    this._initialValue = this._param.defaultValue;
    this.units = options2.units;
    this.convert = options2.convert;
    this._minValue = options2.minValue;
    this._maxValue = options2.maxValue;
    if (isDefined(options2.value) && options2.value !== this._toType(this._initialValue)) {
      this.setValueAtTime(options2.value, 0);
    }
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      convert: true,
      units: "number"
    });
  }
  get value() {
    const now2 = this.now();
    return this.getValueAtTime(now2);
  }
  set value(value) {
    this.cancelScheduledValues(this.now());
    this.setValueAtTime(value, this.now());
  }
  get minValue() {
    if (isDefined(this._minValue)) {
      return this._minValue;
    } else if (this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples") {
      return 0;
    } else if (this.units === "audioRange") {
      return -1;
    } else if (this.units === "decibels") {
      return -Infinity;
    } else {
      return this._param.minValue;
    }
  }
  get maxValue() {
    if (isDefined(this._maxValue)) {
      return this._maxValue;
    } else if (this.units === "normalRange" || this.units === "audioRange") {
      return 1;
    } else {
      return this._param.maxValue;
    }
  }
  _is(arg, type) {
    return this.units === type;
  }
  _assertRange(value) {
    if (isDefined(this.maxValue) && isDefined(this.minValue)) {
      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));
    }
    return value;
  }
  _fromType(val) {
    if (this.convert && !this.overridden) {
      if (this._is(val, "time")) {
        return this.toSeconds(val);
      } else if (this._is(val, "decibels")) {
        return dbToGain(val);
      } else if (this._is(val, "frequency")) {
        return this.toFrequency(val);
      } else {
        return val;
      }
    } else if (this.overridden) {
      return 0;
    } else {
      return val;
    }
  }
  _toType(val) {
    if (this.convert && this.units === "decibels") {
      return gainToDb(val);
    } else {
      return val;
    }
  }
  setValueAtTime(value, time) {
    const computedTime = this.toSeconds(time);
    const numericValue = this._fromType(value);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);
    this._assertRange(numericValue);
    this.log(this.units, "setValueAtTime", value, computedTime);
    this._events.add({
      time: computedTime,
      type: "setValueAtTime",
      value: numericValue
    });
    this._param.setValueAtTime(numericValue, computedTime);
    return this;
  }
  getValueAtTime(time) {
    const computedTime = Math.max(this.toSeconds(time), 0);
    const after = this._events.getAfter(computedTime);
    const before = this._events.get(computedTime);
    let value = this._initialValue;
    if (before === null) {
      value = this._initialValue;
    } else if (before.type === "setTargetAtTime" && (after === null || after.type === "setValueAtTime")) {
      const previous = this._events.getBefore(before.time);
      let previousVal;
      if (previous === null) {
        previousVal = this._initialValue;
      } else {
        previousVal = previous.value;
      }
      if (before.type === "setTargetAtTime") {
        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);
      }
    } else if (after === null) {
      value = before.value;
    } else if (after.type === "linearRampToValueAtTime" || after.type === "exponentialRampToValueAtTime") {
      let beforeValue = before.value;
      if (before.type === "setTargetAtTime") {
        const previous = this._events.getBefore(before.time);
        if (previous === null) {
          beforeValue = this._initialValue;
        } else {
          beforeValue = previous.value;
        }
      }
      if (after.type === "linearRampToValueAtTime") {
        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
      } else {
        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
      }
    } else {
      value = before.value;
    }
    return this._toType(value);
  }
  setRampPoint(time) {
    time = this.toSeconds(time);
    let currentVal = this.getValueAtTime(time);
    this.cancelAndHoldAtTime(time);
    if (this._fromType(currentVal) === 0) {
      currentVal = this._toType(this._minOutput);
    }
    this.setValueAtTime(currentVal, time);
    return this;
  }
  linearRampToValueAtTime(value, endTime) {
    const numericValue = this._fromType(value);
    const computedTime = this.toSeconds(endTime);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
    this._assertRange(numericValue);
    this._events.add({
      time: computedTime,
      type: "linearRampToValueAtTime",
      value: numericValue
    });
    this.log(this.units, "linearRampToValueAtTime", value, computedTime);
    this._param.linearRampToValueAtTime(numericValue, computedTime);
    return this;
  }
  exponentialRampToValueAtTime(value, endTime) {
    let numericValue = this._fromType(value);
    numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;
    this._assertRange(numericValue);
    const computedTime = this.toSeconds(endTime);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
    this._events.add({
      time: computedTime,
      type: "exponentialRampToValueAtTime",
      value: numericValue
    });
    this.log(this.units, "exponentialRampToValueAtTime", value, computedTime);
    this._param.exponentialRampToValueAtTime(numericValue, computedTime);
    return this;
  }
  exponentialRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
    return this;
  }
  linearRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
    return this;
  }
  targetRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.exponentialApproachValueAtTime(value, startTime, rampTime);
    return this;
  }
  exponentialApproachValueAtTime(value, time, rampTime) {
    time = this.toSeconds(time);
    rampTime = this.toSeconds(rampTime);
    const timeConstant = Math.log(rampTime + 1) / Math.log(200);
    this.setTargetAtTime(value, time, timeConstant);
    this.cancelAndHoldAtTime(time + rampTime * 0.9);
    this.linearRampToValueAtTime(value, time + rampTime);
    return this;
  }
  setTargetAtTime(value, startTime, timeConstant) {
    const numericValue = this._fromType(value);
    assert(isFinite(timeConstant) && timeConstant > 0, "timeConstant must be a number greater than 0");
    const computedTime = this.toSeconds(startTime);
    this._assertRange(numericValue);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);
    this._events.add({
      constant: timeConstant,
      time: computedTime,
      type: "setTargetAtTime",
      value: numericValue
    });
    this.log(this.units, "setTargetAtTime", value, computedTime, timeConstant);
    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);
    return this;
  }
  setValueCurveAtTime(values, startTime, duration2, scaling = 1) {
    duration2 = this.toSeconds(duration2);
    startTime = this.toSeconds(startTime);
    const startingValue = this._fromType(values[0]) * scaling;
    this.setValueAtTime(this._toType(startingValue), startTime);
    const segTime = duration2 / (values.length - 1);
    for (let i2 = 1; i2 < values.length; i2++) {
      const numericValue = this._fromType(values[i2]) * scaling;
      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i2 * segTime);
    }
    return this;
  }
  cancelScheduledValues(time) {
    const computedTime = this.toSeconds(time);
    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);
    this._events.cancel(computedTime);
    this._param.cancelScheduledValues(computedTime);
    this.log(this.units, "cancelScheduledValues", computedTime);
    return this;
  }
  cancelAndHoldAtTime(time) {
    const computedTime = this.toSeconds(time);
    const valueAtTime = this._fromType(this.getValueAtTime(computedTime));
    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);
    this.log(this.units, "cancelAndHoldAtTime", computedTime, "value=" + valueAtTime);
    const before = this._events.get(computedTime);
    const after = this._events.getAfter(computedTime);
    if (before && EQ(before.time, computedTime)) {
      if (after) {
        this._param.cancelScheduledValues(after.time);
        this._events.cancel(after.time);
      } else {
        this._param.cancelAndHoldAtTime(computedTime);
        this._events.cancel(computedTime + this.sampleTime);
      }
    } else if (after) {
      this._param.cancelScheduledValues(after.time);
      this._events.cancel(after.time);
      if (after.type === "linearRampToValueAtTime") {
        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);
      } else if (after.type === "exponentialRampToValueAtTime") {
        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);
      }
    }
    this._events.add({
      time: computedTime,
      type: "setValueAtTime",
      value: valueAtTime
    });
    this._param.setValueAtTime(valueAtTime, computedTime);
    return this;
  }
  rampTo(value, rampTime = 0.1, startTime) {
    if (this.units === "frequency" || this.units === "bpm" || this.units === "decibels") {
      this.exponentialRampTo(value, rampTime, startTime);
    } else {
      this.linearRampTo(value, rampTime, startTime);
    }
    return this;
  }
  apply(param) {
    const now2 = this.context.currentTime;
    param.setValueAtTime(this.getValueAtTime(now2), now2);
    const previousEvent = this._events.get(now2);
    if (previousEvent && previousEvent.type === "setTargetAtTime") {
      const nextEvent = this._events.getAfter(previousEvent.time);
      const endTime = nextEvent ? nextEvent.time : now2 + 2;
      const subdivisions = (endTime - now2) / 10;
      for (let i2 = now2; i2 < endTime; i2 += subdivisions) {
        param.linearRampToValueAtTime(this.getValueAtTime(i2), i2);
      }
    }
    this._events.forEachAfter(this.context.currentTime, (event) => {
      if (event.type === "cancelScheduledValues") {
        param.cancelScheduledValues(event.time);
      } else if (event.type === "setTargetAtTime") {
        param.setTargetAtTime(event.value, event.time, event.constant);
      } else {
        param[event.type](event.value, event.time);
      }
    });
    return this;
  }
  setParam(param) {
    assert(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
    const input2 = this.input;
    input2.disconnect(this._param);
    this.apply(param);
    this._param = param;
    input2.connect(this._param);
    return this;
  }
  dispose() {
    super.dispose();
    this._events.dispose();
    return this;
  }
  get defaultValue() {
    return this._toType(this._param.defaultValue);
  }
  _exponentialApproach(t0, v0, v1, timeConstant, t2) {
    return v1 + (v0 - v1) * Math.exp(-(t2 - t0) / timeConstant);
  }
  _linearInterpolate(t0, v0, t1, v1, t2) {
    return v0 + (v1 - v0) * ((t2 - t0) / (t1 - t0));
  }
  _exponentialInterpolate(t0, v0, t1, v1, t2) {
    return v0 * Math.pow(v1 / v0, (t2 - t0) / (t1 - t0));
  }
};
var ToneAudioNode = class extends ToneWithContext {
  constructor() {
    super(...arguments);
    this._internalChannels = [];
  }
  get numberOfInputs() {
    if (isDefined(this.input)) {
      if (isAudioParam(this.input) || this.input instanceof Param) {
        return 1;
      } else {
        return this.input.numberOfInputs;
      }
    } else {
      return 0;
    }
  }
  get numberOfOutputs() {
    if (isDefined(this.output)) {
      return this.output.numberOfOutputs;
    } else {
      return 0;
    }
  }
  _isAudioNode(node) {
    return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));
  }
  _getInternalNodes() {
    const nodeList = this._internalChannels.slice(0);
    if (this._isAudioNode(this.input)) {
      nodeList.push(this.input);
    }
    if (this._isAudioNode(this.output)) {
      if (this.input !== this.output) {
        nodeList.push(this.output);
      }
    }
    return nodeList;
  }
  _setChannelProperties(options2) {
    const nodeList = this._getInternalNodes();
    nodeList.forEach((node) => {
      node.channelCount = options2.channelCount;
      node.channelCountMode = options2.channelCountMode;
      node.channelInterpretation = options2.channelInterpretation;
    });
  }
  _getChannelProperties() {
    const nodeList = this._getInternalNodes();
    assert(nodeList.length > 0, "ToneAudioNode does not have any internal nodes");
    const node = nodeList[0];
    return {
      channelCount: node.channelCount,
      channelCountMode: node.channelCountMode,
      channelInterpretation: node.channelInterpretation
    };
  }
  get channelCount() {
    return this._getChannelProperties().channelCount;
  }
  set channelCount(channelCount) {
    const props = this._getChannelProperties();
    this._setChannelProperties(Object.assign(props, { channelCount }));
  }
  get channelCountMode() {
    return this._getChannelProperties().channelCountMode;
  }
  set channelCountMode(channelCountMode) {
    const props = this._getChannelProperties();
    this._setChannelProperties(Object.assign(props, { channelCountMode }));
  }
  get channelInterpretation() {
    return this._getChannelProperties().channelInterpretation;
  }
  set channelInterpretation(channelInterpretation) {
    const props = this._getChannelProperties();
    this._setChannelProperties(Object.assign(props, { channelInterpretation }));
  }
  connect(destination, outputNum = 0, inputNum = 0) {
    connect(this, destination, outputNum, inputNum);
    return this;
  }
  toDestination() {
    this.connect(this.context.destination);
    return this;
  }
  toMaster() {
    warn("toMaster() has been renamed toDestination()");
    return this.toDestination();
  }
  disconnect(destination, outputNum = 0, inputNum = 0) {
    disconnect(this, destination, outputNum, inputNum);
    return this;
  }
  chain(...nodes) {
    connectSeries(this, ...nodes);
    return this;
  }
  fan(...nodes) {
    nodes.forEach((node) => this.connect(node));
    return this;
  }
  dispose() {
    super.dispose();
    if (isDefined(this.input)) {
      if (this.input instanceof ToneAudioNode) {
        this.input.dispose();
      } else if (isAudioNode(this.input)) {
        this.input.disconnect();
      }
    }
    if (isDefined(this.output)) {
      if (this.output instanceof ToneAudioNode) {
        this.output.dispose();
      } else if (isAudioNode(this.output)) {
        this.output.disconnect();
      }
    }
    this._internalChannels = [];
    return this;
  }
};
function connectSeries(...nodes) {
  const first = nodes.shift();
  nodes.reduce((prev, current) => {
    if (prev instanceof ToneAudioNode) {
      prev.connect(current);
    } else if (isAudioNode(prev)) {
      connect(prev, current);
    }
    return current;
  }, first);
}
function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
  assert(isDefined(srcNode), "Cannot connect from undefined node");
  assert(isDefined(dstNode), "Cannot connect to undefined node");
  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {
    assert(dstNode.numberOfInputs > 0, "Cannot connect to node with no inputs");
  }
  assert(srcNode.numberOfOutputs > 0, "Cannot connect from node with no outputs");
  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {
    if (isDefined(dstNode.input)) {
      dstNode = dstNode.input;
    }
  }
  while (srcNode instanceof ToneAudioNode) {
    if (isDefined(srcNode.output)) {
      srcNode = srcNode.output;
    }
  }
  if (isAudioParam(dstNode)) {
    srcNode.connect(dstNode, outputNumber);
  } else {
    srcNode.connect(dstNode, outputNumber, inputNumber);
  }
}
function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
  if (isDefined(dstNode)) {
    while (dstNode instanceof ToneAudioNode) {
      dstNode = dstNode.input;
    }
  }
  while (!isAudioNode(srcNode)) {
    if (isDefined(srcNode.output)) {
      srcNode = srcNode.output;
    }
  }
  if (isAudioParam(dstNode)) {
    srcNode.disconnect(dstNode, outputNumber);
  } else if (isAudioNode(dstNode)) {
    srcNode.disconnect(dstNode, outputNumber, inputNumber);
  } else {
    srcNode.disconnect();
  }
}
var Gain = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Gain.getDefaults(), arguments, ["gain", "units"]));
    this.name = "Gain";
    this._gainNode = this.context.createGain();
    this.input = this._gainNode;
    this.output = this._gainNode;
    const options2 = optionsFromArguments(Gain.getDefaults(), arguments, ["gain", "units"]);
    this.gain = new Param({
      context: this.context,
      convert: options2.convert,
      param: this._gainNode.gain,
      units: options2.units,
      value: options2.gain,
      minValue: options2.minValue,
      maxValue: options2.maxValue
    });
    readOnly(this, "gain");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      convert: true,
      gain: 1,
      units: "gain"
    });
  }
  dispose() {
    super.dispose();
    this._gainNode.disconnect();
    this.gain.dispose();
    return this;
  }
};
var OneShotSource = class extends ToneAudioNode {
  constructor(options2) {
    super(options2);
    this.onended = noOp;
    this._startTime = -1;
    this._stopTime = -1;
    this._timeout = -1;
    this.output = new Gain({
      context: this.context,
      gain: 0
    });
    this._gainNode = this.output;
    this.getStateAtTime = function(time) {
      const computedTime = this.toSeconds(time);
      if (this._startTime !== -1 && computedTime >= this._startTime && (this._stopTime === -1 || computedTime <= this._stopTime)) {
        return "started";
      } else {
        return "stopped";
      }
    };
    this._fadeIn = options2.fadeIn;
    this._fadeOut = options2.fadeOut;
    this._curve = options2.curve;
    this.onended = options2.onended;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      curve: "linear",
      fadeIn: 0,
      fadeOut: 0,
      onended: noOp
    });
  }
  _startGain(time, gain = 1) {
    assert(this._startTime === -1, "Source cannot be started more than once");
    const fadeInTime = this.toSeconds(this._fadeIn);
    this._startTime = time + fadeInTime;
    this._startTime = Math.max(this._startTime, this.context.currentTime);
    if (fadeInTime > 0) {
      this._gainNode.gain.setValueAtTime(0, time);
      if (this._curve === "linear") {
        this._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);
      } else {
        this._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);
      }
    } else {
      this._gainNode.gain.setValueAtTime(gain, time);
    }
    return this;
  }
  stop(time) {
    this.log("stop", time);
    this._stopGain(this.toSeconds(time));
    return this;
  }
  _stopGain(time) {
    assert(this._startTime !== -1, "'start' must be called before 'stop'");
    this.cancelStop();
    const fadeOutTime = this.toSeconds(this._fadeOut);
    this._stopTime = this.toSeconds(time) + fadeOutTime;
    this._stopTime = Math.max(this._stopTime, this.now());
    if (fadeOutTime > 0) {
      if (this._curve === "linear") {
        this._gainNode.gain.linearRampTo(0, fadeOutTime, time);
      } else {
        this._gainNode.gain.targetRampTo(0, fadeOutTime, time);
      }
    } else {
      this._gainNode.gain.cancelAndHoldAtTime(time);
      this._gainNode.gain.setValueAtTime(0, time);
    }
    this.context.clearTimeout(this._timeout);
    this._timeout = this.context.setTimeout(() => {
      const additionalTail = this._curve === "exponential" ? fadeOutTime * 2 : 0;
      this._stopSource(this.now() + additionalTail);
      this._onended();
    }, this._stopTime - this.context.currentTime);
    return this;
  }
  _onended() {
    if (this.onended !== noOp) {
      this.onended(this);
      this.onended = noOp;
      if (!this.context.isOffline) {
        const disposeCallback = () => this.dispose();
        if (typeof window.requestIdleCallback !== "undefined") {
          window.requestIdleCallback(disposeCallback);
        } else {
          setTimeout(disposeCallback, 1e3);
        }
      }
    }
  }
  get state() {
    return this.getStateAtTime(this.now());
  }
  cancelStop() {
    this.log("cancelStop");
    assert(this._startTime !== -1, "Source is not started");
    this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);
    this.context.clearTimeout(this._timeout);
    this._stopTime = -1;
    return this;
  }
  dispose() {
    super.dispose();
    this._gainNode.dispose();
    this.onended = noOp;
    return this;
  }
};
var ToneConstantSource = class extends OneShotSource {
  constructor() {
    super(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, ["offset"]));
    this.name = "ToneConstantSource";
    this._source = this.context.createConstantSource();
    const options2 = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, ["offset"]);
    connect(this._source, this._gainNode);
    this.offset = new Param({
      context: this.context,
      convert: options2.convert,
      param: this._source.offset,
      units: options2.units,
      value: options2.offset,
      minValue: options2.minValue,
      maxValue: options2.maxValue
    });
  }
  static getDefaults() {
    return Object.assign(OneShotSource.getDefaults(), {
      convert: true,
      offset: 1,
      units: "number"
    });
  }
  start(time) {
    const computedTime = this.toSeconds(time);
    this.log("start", computedTime);
    this._startGain(computedTime);
    this._source.start(computedTime);
    return this;
  }
  _stopSource(time) {
    this._source.stop(time);
  }
  dispose() {
    super.dispose();
    if (this.state === "started") {
      this.stop();
    }
    this._source.disconnect();
    this.offset.dispose();
    return this;
  }
};
var Signal = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Signal.getDefaults(), arguments, ["value", "units"]));
    this.name = "Signal";
    this.override = true;
    const options2 = optionsFromArguments(Signal.getDefaults(), arguments, ["value", "units"]);
    this.output = this._constantSource = new ToneConstantSource({
      context: this.context,
      convert: options2.convert,
      offset: options2.value,
      units: options2.units,
      minValue: options2.minValue,
      maxValue: options2.maxValue
    });
    this._constantSource.start(0);
    this.input = this._param = this._constantSource.offset;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      convert: true,
      units: "number",
      value: 0
    });
  }
  connect(destination, outputNum = 0, inputNum = 0) {
    connectSignal(this, destination, outputNum, inputNum);
    return this;
  }
  dispose() {
    super.dispose();
    this._param.dispose();
    this._constantSource.dispose();
    return this;
  }
  setValueAtTime(value, time) {
    this._param.setValueAtTime(value, time);
    return this;
  }
  getValueAtTime(time) {
    return this._param.getValueAtTime(time);
  }
  setRampPoint(time) {
    this._param.setRampPoint(time);
    return this;
  }
  linearRampToValueAtTime(value, time) {
    this._param.linearRampToValueAtTime(value, time);
    return this;
  }
  exponentialRampToValueAtTime(value, time) {
    this._param.exponentialRampToValueAtTime(value, time);
    return this;
  }
  exponentialRampTo(value, rampTime, startTime) {
    this._param.exponentialRampTo(value, rampTime, startTime);
    return this;
  }
  linearRampTo(value, rampTime, startTime) {
    this._param.linearRampTo(value, rampTime, startTime);
    return this;
  }
  targetRampTo(value, rampTime, startTime) {
    this._param.targetRampTo(value, rampTime, startTime);
    return this;
  }
  exponentialApproachValueAtTime(value, time, rampTime) {
    this._param.exponentialApproachValueAtTime(value, time, rampTime);
    return this;
  }
  setTargetAtTime(value, startTime, timeConstant) {
    this._param.setTargetAtTime(value, startTime, timeConstant);
    return this;
  }
  setValueCurveAtTime(values, startTime, duration2, scaling) {
    this._param.setValueCurveAtTime(values, startTime, duration2, scaling);
    return this;
  }
  cancelScheduledValues(time) {
    this._param.cancelScheduledValues(time);
    return this;
  }
  cancelAndHoldAtTime(time) {
    this._param.cancelAndHoldAtTime(time);
    return this;
  }
  rampTo(value, rampTime, startTime) {
    this._param.rampTo(value, rampTime, startTime);
    return this;
  }
  get value() {
    return this._param.value;
  }
  set value(value) {
    this._param.value = value;
  }
  get convert() {
    return this._param.convert;
  }
  set convert(convert) {
    this._param.convert = convert;
  }
  get units() {
    return this._param.units;
  }
  get overridden() {
    return this._param.overridden;
  }
  set overridden(overridden) {
    this._param.overridden = overridden;
  }
  get maxValue() {
    return this._param.maxValue;
  }
  get minValue() {
    return this._param.minValue;
  }
  apply(param) {
    this._param.apply(param);
    return this;
  }
};
function connectSignal(signal, destination, outputNum, inputNum) {
  if (destination instanceof Param || isAudioParam(destination) || destination instanceof Signal && destination.override) {
    destination.cancelScheduledValues(0);
    destination.setValueAtTime(0, 0);
    if (destination instanceof Signal) {
      destination.overridden = true;
    }
  }
  connect(signal, destination, outputNum, inputNum);
}
var TickParam = class extends Param {
  constructor() {
    super(optionsFromArguments(TickParam.getDefaults(), arguments, ["value"]));
    this.name = "TickParam";
    this._events = new Timeline(Infinity);
    this._multiplier = 1;
    const options2 = optionsFromArguments(TickParam.getDefaults(), arguments, ["value"]);
    this._multiplier = options2.multiplier;
    this._events.cancel(0);
    this._events.add({
      ticks: 0,
      time: 0,
      type: "setValueAtTime",
      value: this._fromType(options2.value)
    });
    this.setValueAtTime(options2.value, 0);
  }
  static getDefaults() {
    return Object.assign(Param.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  setTargetAtTime(value, time, constant) {
    time = this.toSeconds(time);
    this.setRampPoint(time);
    const computedValue = this._fromType(value);
    const prevEvent = this._events.get(time);
    const segments = Math.round(Math.max(1 / constant, 1));
    for (let i2 = 0; i2 <= segments; i2++) {
      const segTime = constant * i2 + time;
      const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);
      this.linearRampToValueAtTime(this._toType(rampVal), segTime);
    }
    return this;
  }
  setValueAtTime(value, time) {
    const computedTime = this.toSeconds(time);
    super.setValueAtTime(value, time);
    const event = this._events.get(computedTime);
    const previousEvent = this._events.previousEvent(event);
    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
    event.ticks = Math.max(ticksUntilTime, 0);
    return this;
  }
  linearRampToValueAtTime(value, time) {
    const computedTime = this.toSeconds(time);
    super.linearRampToValueAtTime(value, time);
    const event = this._events.get(computedTime);
    const previousEvent = this._events.previousEvent(event);
    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
    event.ticks = Math.max(ticksUntilTime, 0);
    return this;
  }
  exponentialRampToValueAtTime(value, time) {
    time = this.toSeconds(time);
    const computedVal = this._fromType(value);
    const prevEvent = this._events.get(time);
    const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));
    const segmentDur = (time - prevEvent.time) / segments;
    for (let i2 = 0; i2 <= segments; i2++) {
      const segTime = segmentDur * i2 + prevEvent.time;
      const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);
      this.linearRampToValueAtTime(this._toType(rampVal), segTime);
    }
    return this;
  }
  _getTicksUntilEvent(event, time) {
    if (event === null) {
      event = {
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: 0
      };
    } else if (isUndef(event.ticks)) {
      const previousEvent = this._events.previousEvent(event);
      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);
    }
    const val0 = this._fromType(this.getValueAtTime(event.time));
    let val1 = this._fromType(this.getValueAtTime(time));
    const onTheLineEvent = this._events.get(time);
    if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === "setValueAtTime") {
      val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));
    }
    return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;
  }
  getTicksAtTime(time) {
    const computedTime = this.toSeconds(time);
    const event = this._events.get(computedTime);
    return Math.max(this._getTicksUntilEvent(event, computedTime), 0);
  }
  getDurationOfTicks(ticks, time) {
    const computedTime = this.toSeconds(time);
    const currentTick = this.getTicksAtTime(time);
    return this.getTimeOfTick(currentTick + ticks) - computedTime;
  }
  getTimeOfTick(tick) {
    const before = this._events.get(tick, "ticks");
    const after = this._events.getAfter(tick, "ticks");
    if (before && before.ticks === tick) {
      return before.time;
    } else if (before && after && after.type === "linearRampToValueAtTime" && before.value !== after.value) {
      const val0 = this._fromType(this.getValueAtTime(before.time));
      const val1 = this._fromType(this.getValueAtTime(after.time));
      const delta = (val1 - val0) / (after.time - before.time);
      const k2 = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
      const sol1 = (-val0 + k2) / delta;
      const sol2 = (-val0 - k2) / delta;
      return (sol1 > 0 ? sol1 : sol2) + before.time;
    } else if (before) {
      if (before.value === 0) {
        return Infinity;
      } else {
        return before.time + (tick - before.ticks) / before.value;
      }
    } else {
      return tick / this._initialValue;
    }
  }
  ticksToTime(ticks, when) {
    return this.getDurationOfTicks(ticks, when);
  }
  timeToTicks(duration2, when) {
    const computedTime = this.toSeconds(when);
    const computedDuration = this.toSeconds(duration2);
    const startTicks = this.getTicksAtTime(computedTime);
    const endTicks = this.getTicksAtTime(computedTime + computedDuration);
    return endTicks - startTicks;
  }
  _fromType(val) {
    if (this.units === "bpm" && this.multiplier) {
      return 1 / (60 / val / this.multiplier);
    } else {
      return super._fromType(val);
    }
  }
  _toType(val) {
    if (this.units === "bpm" && this.multiplier) {
      return val / this.multiplier * 60;
    } else {
      return super._toType(val);
    }
  }
  get multiplier() {
    return this._multiplier;
  }
  set multiplier(m2) {
    const currentVal = this.value;
    this._multiplier = m2;
    this.cancelScheduledValues(0);
    this.setValueAtTime(currentVal, 0);
  }
};
var TickSignal = class extends Signal {
  constructor() {
    super(optionsFromArguments(TickSignal.getDefaults(), arguments, ["value"]));
    this.name = "TickSignal";
    const options2 = optionsFromArguments(TickSignal.getDefaults(), arguments, ["value"]);
    this.input = this._param = new TickParam({
      context: this.context,
      convert: options2.convert,
      multiplier: options2.multiplier,
      param: this._constantSource.offset,
      units: options2.units,
      value: options2.value
    });
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  ticksToTime(ticks, when) {
    return this._param.ticksToTime(ticks, when);
  }
  timeToTicks(duration2, when) {
    return this._param.timeToTicks(duration2, when);
  }
  getTimeOfTick(tick) {
    return this._param.getTimeOfTick(tick);
  }
  getDurationOfTicks(ticks, time) {
    return this._param.getDurationOfTicks(ticks, time);
  }
  getTicksAtTime(time) {
    return this._param.getTicksAtTime(time);
  }
  get multiplier() {
    return this._param.multiplier;
  }
  set multiplier(m2) {
    this._param.multiplier = m2;
  }
  dispose() {
    super.dispose();
    this._param.dispose();
    return this;
  }
};
var TickSource = class extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(TickSource.getDefaults(), arguments, ["frequency"]));
    this.name = "TickSource";
    this._state = new StateTimeline();
    this._tickOffset = new Timeline();
    this._ticksAtTime = new Timeline();
    this._secondsAtTime = new Timeline();
    const options2 = optionsFromArguments(TickSource.getDefaults(), arguments, ["frequency"]);
    this.frequency = new TickSignal({
      context: this.context,
      units: options2.units,
      value: options2.frequency
    });
    readOnly(this, "frequency");
    this._state.setStateAtTime("stopped", 0);
    this.setTicksAtTime(0, 0);
  }
  static getDefaults() {
    return Object.assign({
      frequency: 1,
      units: "hertz"
    }, ToneWithContext.getDefaults());
  }
  get state() {
    return this.getStateAtTime(this.now());
  }
  start(time, offset) {
    const computedTime = this.toSeconds(time);
    if (this._state.getValueAtTime(computedTime) !== "started") {
      this._state.setStateAtTime("started", computedTime);
      if (isDefined(offset)) {
        this.setTicksAtTime(offset, computedTime);
      }
      this._ticksAtTime.cancel(computedTime);
      this._secondsAtTime.cancel(computedTime);
    }
    return this;
  }
  stop(time) {
    const computedTime = this.toSeconds(time);
    if (this._state.getValueAtTime(computedTime) === "stopped") {
      const event = this._state.get(computedTime);
      if (event && event.time > 0) {
        this._tickOffset.cancel(event.time);
        this._state.cancel(event.time);
      }
    }
    this._state.cancel(computedTime);
    this._state.setStateAtTime("stopped", computedTime);
    this.setTicksAtTime(0, computedTime);
    this._ticksAtTime.cancel(computedTime);
    this._secondsAtTime.cancel(computedTime);
    return this;
  }
  pause(time) {
    const computedTime = this.toSeconds(time);
    if (this._state.getValueAtTime(computedTime) === "started") {
      this._state.setStateAtTime("paused", computedTime);
      this._ticksAtTime.cancel(computedTime);
      this._secondsAtTime.cancel(computedTime);
    }
    return this;
  }
  cancel(time) {
    time = this.toSeconds(time);
    this._state.cancel(time);
    this._tickOffset.cancel(time);
    this._ticksAtTime.cancel(time);
    this._secondsAtTime.cancel(time);
    return this;
  }
  getTicksAtTime(time) {
    const computedTime = this.toSeconds(time);
    const stopEvent = this._state.getLastState("stopped", computedTime);
    const memoizedEvent = this._ticksAtTime.get(computedTime);
    const tmpEvent = { state: "paused", time: computedTime };
    this._state.add(tmpEvent);
    let lastState = memoizedEvent ? memoizedEvent : stopEvent;
    let elapsedTicks = memoizedEvent ? memoizedEvent.ticks : 0;
    let eventToMemoize = null;
    this._state.forEachBetween(lastState.time, computedTime + this.sampleTime, (e2) => {
      let periodStartTime = lastState.time;
      const offsetEvent = this._tickOffset.get(e2.time);
      if (offsetEvent && offsetEvent.time >= lastState.time) {
        elapsedTicks = offsetEvent.ticks;
        periodStartTime = offsetEvent.time;
      }
      if (lastState.state === "started" && e2.state !== "started") {
        elapsedTicks += this.frequency.getTicksAtTime(e2.time) - this.frequency.getTicksAtTime(periodStartTime);
        if (e2.time != tmpEvent.time) {
          eventToMemoize = { state: e2.state, time: e2.time, ticks: elapsedTicks };
        }
      }
      lastState = e2;
    });
    this._state.remove(tmpEvent);
    if (eventToMemoize) {
      this._ticksAtTime.add(eventToMemoize);
    }
    return elapsedTicks;
  }
  get ticks() {
    return this.getTicksAtTime(this.now());
  }
  set ticks(t2) {
    this.setTicksAtTime(t2, this.now());
  }
  get seconds() {
    return this.getSecondsAtTime(this.now());
  }
  set seconds(s2) {
    const now2 = this.now();
    const ticks = this.frequency.timeToTicks(s2, now2);
    this.setTicksAtTime(ticks, now2);
  }
  getSecondsAtTime(time) {
    time = this.toSeconds(time);
    const stopEvent = this._state.getLastState("stopped", time);
    const tmpEvent = { state: "paused", time };
    this._state.add(tmpEvent);
    const memoizedEvent = this._secondsAtTime.get(time);
    let lastState = memoizedEvent ? memoizedEvent : stopEvent;
    let elapsedSeconds = memoizedEvent ? memoizedEvent.seconds : 0;
    let eventToMemoize = null;
    this._state.forEachBetween(lastState.time, time + this.sampleTime, (e2) => {
      let periodStartTime = lastState.time;
      const offsetEvent = this._tickOffset.get(e2.time);
      if (offsetEvent && offsetEvent.time >= lastState.time) {
        elapsedSeconds = offsetEvent.seconds;
        periodStartTime = offsetEvent.time;
      }
      if (lastState.state === "started" && e2.state !== "started") {
        elapsedSeconds += e2.time - periodStartTime;
        if (e2.time != tmpEvent.time) {
          eventToMemoize = { state: e2.state, time: e2.time, seconds: elapsedSeconds };
        }
      }
      lastState = e2;
    });
    this._state.remove(tmpEvent);
    if (eventToMemoize) {
      this._secondsAtTime.add(eventToMemoize);
    }
    return elapsedSeconds;
  }
  setTicksAtTime(ticks, time) {
    time = this.toSeconds(time);
    this._tickOffset.cancel(time);
    this._tickOffset.add({
      seconds: this.frequency.getDurationOfTicks(ticks, time),
      ticks,
      time
    });
    this._ticksAtTime.cancel(time);
    this._secondsAtTime.cancel(time);
    return this;
  }
  getStateAtTime(time) {
    time = this.toSeconds(time);
    return this._state.getValueAtTime(time);
  }
  getTimeOfTick(tick, before = this.now()) {
    const offset = this._tickOffset.get(before);
    const event = this._state.get(before);
    const startTime = Math.max(offset.time, event.time);
    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;
    return this.frequency.getTimeOfTick(absoluteTicks);
  }
  forEachTickBetween(startTime, endTime, callback) {
    let lastStateEvent = this._state.get(startTime);
    this._state.forEachBetween(startTime, endTime, (event) => {
      if (lastStateEvent && lastStateEvent.state === "started" && event.state !== "started") {
        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);
      }
      lastStateEvent = event;
    });
    let error = null;
    if (lastStateEvent && lastStateEvent.state === "started") {
      const maxStartTime = Math.max(lastStateEvent.time, startTime);
      const startTicks = this.frequency.getTicksAtTime(maxStartTime);
      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);
      const diff = startTicks - ticksAtStart;
      let offset = Math.ceil(diff) - diff;
      offset = EQ(offset, 1) ? 0 : offset;
      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);
      while (nextTickTime < endTime) {
        try {
          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));
        } catch (e2) {
          error = e2;
          break;
        }
        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);
      }
    }
    if (error) {
      throw error;
    }
    return this;
  }
  dispose() {
    super.dispose();
    this._state.dispose();
    this._tickOffset.dispose();
    this._ticksAtTime.dispose();
    this._secondsAtTime.dispose();
    this.frequency.dispose();
    return this;
  }
};
var Clock = class extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(Clock.getDefaults(), arguments, ["callback", "frequency"]));
    this.name = "Clock";
    this.callback = noOp;
    this._lastUpdate = 0;
    this._state = new StateTimeline("stopped");
    this._boundLoop = this._loop.bind(this);
    const options2 = optionsFromArguments(Clock.getDefaults(), arguments, ["callback", "frequency"]);
    this.callback = options2.callback;
    this._tickSource = new TickSource({
      context: this.context,
      frequency: options2.frequency,
      units: options2.units
    });
    this._lastUpdate = 0;
    this.frequency = this._tickSource.frequency;
    readOnly(this, "frequency");
    this._state.setStateAtTime("stopped", 0);
    this.context.on("tick", this._boundLoop);
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      callback: noOp,
      frequency: 1,
      units: "hertz"
    });
  }
  get state() {
    return this._state.getValueAtTime(this.now());
  }
  start(time, offset) {
    assertContextRunning(this.context);
    const computedTime = this.toSeconds(time);
    this.log("start", computedTime);
    if (this._state.getValueAtTime(computedTime) !== "started") {
      this._state.setStateAtTime("started", computedTime);
      this._tickSource.start(computedTime, offset);
      if (computedTime < this._lastUpdate) {
        this.emit("start", computedTime, offset);
      }
    }
    return this;
  }
  stop(time) {
    const computedTime = this.toSeconds(time);
    this.log("stop", computedTime);
    this._state.cancel(computedTime);
    this._state.setStateAtTime("stopped", computedTime);
    this._tickSource.stop(computedTime);
    if (computedTime < this._lastUpdate) {
      this.emit("stop", computedTime);
    }
    return this;
  }
  pause(time) {
    const computedTime = this.toSeconds(time);
    if (this._state.getValueAtTime(computedTime) === "started") {
      this._state.setStateAtTime("paused", computedTime);
      this._tickSource.pause(computedTime);
      if (computedTime < this._lastUpdate) {
        this.emit("pause", computedTime);
      }
    }
    return this;
  }
  get ticks() {
    return Math.ceil(this.getTicksAtTime(this.now()));
  }
  set ticks(t2) {
    this._tickSource.ticks = t2;
  }
  get seconds() {
    return this._tickSource.seconds;
  }
  set seconds(s2) {
    this._tickSource.seconds = s2;
  }
  getSecondsAtTime(time) {
    return this._tickSource.getSecondsAtTime(time);
  }
  setTicksAtTime(ticks, time) {
    this._tickSource.setTicksAtTime(ticks, time);
    return this;
  }
  getTimeOfTick(tick, before = this.now()) {
    return this._tickSource.getTimeOfTick(tick, before);
  }
  getTicksAtTime(time) {
    return this._tickSource.getTicksAtTime(time);
  }
  nextTickTime(offset, when) {
    const computedTime = this.toSeconds(when);
    const currentTick = this.getTicksAtTime(computedTime);
    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);
  }
  _loop() {
    const startTime = this._lastUpdate;
    const endTime = this.now();
    this._lastUpdate = endTime;
    this.log("loop", startTime, endTime);
    if (startTime !== endTime) {
      this._state.forEachBetween(startTime, endTime, (e2) => {
        switch (e2.state) {
          case "started":
            const offset = this._tickSource.getTicksAtTime(e2.time);
            this.emit("start", e2.time, offset);
            break;
          case "stopped":
            if (e2.time !== 0) {
              this.emit("stop", e2.time);
            }
            break;
          case "paused":
            this.emit("pause", e2.time);
            break;
        }
      });
      this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {
        this.callback(time, ticks);
      });
    }
  }
  getStateAtTime(time) {
    const computedTime = this.toSeconds(time);
    return this._state.getValueAtTime(computedTime);
  }
  dispose() {
    super.dispose();
    this.context.off("tick", this._boundLoop);
    this._tickSource.dispose();
    this._state.dispose();
    return this;
  }
};
Emitter.mixin(Clock);
var Delay = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Delay.getDefaults(), arguments, ["delayTime", "maxDelay"]));
    this.name = "Delay";
    const options2 = optionsFromArguments(Delay.getDefaults(), arguments, ["delayTime", "maxDelay"]);
    const maxDelayInSeconds = this.toSeconds(options2.maxDelay);
    this._maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options2.delayTime));
    this._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);
    this.delayTime = new Param({
      context: this.context,
      param: this._delayNode.delayTime,
      units: "time",
      value: options2.delayTime,
      minValue: 0,
      maxValue: this.maxDelay
    });
    readOnly(this, "delayTime");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      delayTime: 0,
      maxDelay: 1
    });
  }
  get maxDelay() {
    return this._maxDelay;
  }
  dispose() {
    super.dispose();
    this._delayNode.disconnect();
    this.delayTime.dispose();
    return this;
  }
};
var ToneAudioBuffers = class extends Tone {
  constructor() {
    super();
    this.name = "ToneAudioBuffers";
    this._buffers = /* @__PURE__ */ new Map();
    this._loadingCount = 0;
    const options2 = optionsFromArguments(ToneAudioBuffers.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    this.baseUrl = options2.baseUrl;
    Object.keys(options2.urls).forEach((name2) => {
      this._loadingCount++;
      const url = options2.urls[name2];
      this.add(name2, url, this._bufferLoaded.bind(this, options2.onload), options2.onerror);
    });
  }
  static getDefaults() {
    return {
      baseUrl: "",
      onerror: noOp,
      onload: noOp,
      urls: {}
    };
  }
  has(name2) {
    return this._buffers.has(name2.toString());
  }
  get(name2) {
    assert(this.has(name2), `ToneAudioBuffers has no buffer named: ${name2}`);
    return this._buffers.get(name2.toString());
  }
  _bufferLoaded(callback) {
    this._loadingCount--;
    if (this._loadingCount === 0 && callback) {
      callback();
    }
  }
  get loaded() {
    return Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);
  }
  add(name2, url, callback = noOp, onerror = noOp) {
    if (isString(url)) {
      if (this.baseUrl && url.trim().substring(0, 11).toLowerCase() === "data:audio/") {
        this.baseUrl = "";
      }
      this._buffers.set(name2.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));
    } else {
      this._buffers.set(name2.toString(), new ToneAudioBuffer(url, callback, onerror));
    }
    return this;
  }
  dispose() {
    super.dispose();
    this._buffers.forEach((buffer) => buffer.dispose());
    this._buffers.clear();
    return this;
  }
};
var MidiClass = class extends FrequencyClass {
  constructor() {
    super(...arguments);
    this.name = "MidiClass";
    this.defaultUnits = "midi";
  }
  _frequencyToUnits(freq2) {
    return ftom(super._frequencyToUnits(freq2));
  }
  _ticksToUnits(ticks) {
    return ftom(super._ticksToUnits(ticks));
  }
  _beatsToUnits(beats) {
    return ftom(super._beatsToUnits(beats));
  }
  _secondsToUnits(seconds) {
    return ftom(super._secondsToUnits(seconds));
  }
  toMidi() {
    return this.valueOf();
  }
  toFrequency() {
    return mtof(this.toMidi());
  }
  transpose(interval2) {
    return new MidiClass(this.context, this.toMidi() + interval2);
  }
};
function Midi(value, units) {
  return new MidiClass(getContext(), value, units);
}
var TicksClass = class extends TransportTimeClass {
  constructor() {
    super(...arguments);
    this.name = "Ticks";
    this.defaultUnits = "i";
  }
  _now() {
    return this.context.transport.ticks;
  }
  _beatsToUnits(beats) {
    return this._getPPQ() * beats;
  }
  _secondsToUnits(seconds) {
    return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());
  }
  _ticksToUnits(ticks) {
    return ticks;
  }
  toTicks() {
    return this.valueOf();
  }
  toSeconds() {
    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
  }
};
var Draw$1 = class extends ToneWithContext {
  constructor() {
    super(...arguments);
    this.name = "Draw";
    this.expiration = 0.25;
    this.anticipation = 8e-3;
    this._events = new Timeline();
    this._boundDrawLoop = this._drawLoop.bind(this);
    this._animationFrame = -1;
  }
  schedule(callback, time) {
    this._events.add({
      callback,
      time: this.toSeconds(time)
    });
    if (this._events.length === 1) {
      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
    }
    return this;
  }
  cancel(after) {
    this._events.cancel(this.toSeconds(after));
    return this;
  }
  _drawLoop() {
    const now2 = this.context.currentTime;
    while (this._events.length && this._events.peek().time - this.anticipation <= now2) {
      const event = this._events.shift();
      if (event && now2 - event.time <= this.expiration) {
        event.callback();
      }
    }
    if (this._events.length > 0) {
      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
    }
  }
  dispose() {
    super.dispose();
    this._events.dispose();
    cancelAnimationFrame(this._animationFrame);
    return this;
  }
};
onContextInit((context2) => {
  context2.draw = new Draw$1({ context: context2 });
});
onContextClose((context2) => {
  context2.draw.dispose();
});
var IntervalTimeline = class extends Tone {
  constructor() {
    super(...arguments);
    this.name = "IntervalTimeline";
    this._root = null;
    this._length = 0;
  }
  add(event) {
    assert(isDefined(event.time), "Events must have a time property");
    assert(isDefined(event.duration), "Events must have a duration parameter");
    event.time = event.time.valueOf();
    let node = new IntervalNode(event.time, event.time + event.duration, event);
    if (this._root === null) {
      this._root = node;
    } else {
      this._root.insert(node);
    }
    this._length++;
    while (node !== null) {
      node.updateHeight();
      node.updateMax();
      this._rebalance(node);
      node = node.parent;
    }
    return this;
  }
  remove(event) {
    if (this._root !== null) {
      const results = [];
      this._root.search(event.time, results);
      for (const node of results) {
        if (node.event === event) {
          this._removeNode(node);
          this._length--;
          break;
        }
      }
    }
    return this;
  }
  get length() {
    return this._length;
  }
  cancel(after) {
    this.forEachFrom(after, (event) => this.remove(event));
    return this;
  }
  _setRoot(node) {
    this._root = node;
    if (this._root !== null) {
      this._root.parent = null;
    }
  }
  _replaceNodeInParent(node, replacement) {
    if (node.parent !== null) {
      if (node.isLeftChild()) {
        node.parent.left = replacement;
      } else {
        node.parent.right = replacement;
      }
      this._rebalance(node.parent);
    } else {
      this._setRoot(replacement);
    }
  }
  _removeNode(node) {
    if (node.left === null && node.right === null) {
      this._replaceNodeInParent(node, null);
    } else if (node.right === null) {
      this._replaceNodeInParent(node, node.left);
    } else if (node.left === null) {
      this._replaceNodeInParent(node, node.right);
    } else {
      const balance = node.getBalance();
      let replacement;
      let temp = null;
      if (balance > 0) {
        if (node.left.right === null) {
          replacement = node.left;
          replacement.right = node.right;
          temp = replacement;
        } else {
          replacement = node.left.right;
          while (replacement.right !== null) {
            replacement = replacement.right;
          }
          if (replacement.parent) {
            replacement.parent.right = replacement.left;
            temp = replacement.parent;
            replacement.left = node.left;
            replacement.right = node.right;
          }
        }
      } else if (node.right.left === null) {
        replacement = node.right;
        replacement.left = node.left;
        temp = replacement;
      } else {
        replacement = node.right.left;
        while (replacement.left !== null) {
          replacement = replacement.left;
        }
        if (replacement.parent) {
          replacement.parent.left = replacement.right;
          temp = replacement.parent;
          replacement.left = node.left;
          replacement.right = node.right;
        }
      }
      if (node.parent !== null) {
        if (node.isLeftChild()) {
          node.parent.left = replacement;
        } else {
          node.parent.right = replacement;
        }
      } else {
        this._setRoot(replacement);
      }
      if (temp) {
        this._rebalance(temp);
      }
    }
    node.dispose();
  }
  _rotateLeft(node) {
    const parent = node.parent;
    const isLeftChild = node.isLeftChild();
    const pivotNode = node.right;
    if (pivotNode) {
      node.right = pivotNode.left;
      pivotNode.left = node;
    }
    if (parent !== null) {
      if (isLeftChild) {
        parent.left = pivotNode;
      } else {
        parent.right = pivotNode;
      }
    } else {
      this._setRoot(pivotNode);
    }
  }
  _rotateRight(node) {
    const parent = node.parent;
    const isLeftChild = node.isLeftChild();
    const pivotNode = node.left;
    if (pivotNode) {
      node.left = pivotNode.right;
      pivotNode.right = node;
    }
    if (parent !== null) {
      if (isLeftChild) {
        parent.left = pivotNode;
      } else {
        parent.right = pivotNode;
      }
    } else {
      this._setRoot(pivotNode);
    }
  }
  _rebalance(node) {
    const balance = node.getBalance();
    if (balance > 1 && node.left) {
      if (node.left.getBalance() < 0) {
        this._rotateLeft(node.left);
      } else {
        this._rotateRight(node);
      }
    } else if (balance < -1 && node.right) {
      if (node.right.getBalance() > 0) {
        this._rotateRight(node.right);
      } else {
        this._rotateLeft(node);
      }
    }
  }
  get(time) {
    if (this._root !== null) {
      const results = [];
      this._root.search(time, results);
      if (results.length > 0) {
        let max = results[0];
        for (let i2 = 1; i2 < results.length; i2++) {
          if (results[i2].low > max.low) {
            max = results[i2];
          }
        }
        return max.event;
      }
    }
    return null;
  }
  forEach(callback) {
    if (this._root !== null) {
      const allNodes = [];
      this._root.traverse((node) => allNodes.push(node));
      allNodes.forEach((node) => {
        if (node.event) {
          callback(node.event);
        }
      });
    }
    return this;
  }
  forEachAtTime(time, callback) {
    if (this._root !== null) {
      const results = [];
      this._root.search(time, results);
      results.forEach((node) => {
        if (node.event) {
          callback(node.event);
        }
      });
    }
    return this;
  }
  forEachFrom(time, callback) {
    if (this._root !== null) {
      const results = [];
      this._root.searchAfter(time, results);
      results.forEach((node) => {
        if (node.event) {
          callback(node.event);
        }
      });
    }
    return this;
  }
  dispose() {
    super.dispose();
    if (this._root !== null) {
      this._root.traverse((node) => node.dispose());
    }
    this._root = null;
    return this;
  }
};
var IntervalNode = class {
  constructor(low, high, event) {
    this._left = null;
    this._right = null;
    this.parent = null;
    this.height = 0;
    this.event = event;
    this.low = low;
    this.high = high;
    this.max = this.high;
  }
  insert(node) {
    if (node.low <= this.low) {
      if (this.left === null) {
        this.left = node;
      } else {
        this.left.insert(node);
      }
    } else if (this.right === null) {
      this.right = node;
    } else {
      this.right.insert(node);
    }
  }
  search(point, results) {
    if (point > this.max) {
      return;
    }
    if (this.left !== null) {
      this.left.search(point, results);
    }
    if (this.low <= point && this.high > point) {
      results.push(this);
    }
    if (this.low > point) {
      return;
    }
    if (this.right !== null) {
      this.right.search(point, results);
    }
  }
  searchAfter(point, results) {
    if (this.low >= point) {
      results.push(this);
      if (this.left !== null) {
        this.left.searchAfter(point, results);
      }
    }
    if (this.right !== null) {
      this.right.searchAfter(point, results);
    }
  }
  traverse(callback) {
    callback(this);
    if (this.left !== null) {
      this.left.traverse(callback);
    }
    if (this.right !== null) {
      this.right.traverse(callback);
    }
  }
  updateHeight() {
    if (this.left !== null && this.right !== null) {
      this.height = Math.max(this.left.height, this.right.height) + 1;
    } else if (this.right !== null) {
      this.height = this.right.height + 1;
    } else if (this.left !== null) {
      this.height = this.left.height + 1;
    } else {
      this.height = 0;
    }
  }
  updateMax() {
    this.max = this.high;
    if (this.left !== null) {
      this.max = Math.max(this.max, this.left.max);
    }
    if (this.right !== null) {
      this.max = Math.max(this.max, this.right.max);
    }
  }
  getBalance() {
    let balance = 0;
    if (this.left !== null && this.right !== null) {
      balance = this.left.height - this.right.height;
    } else if (this.left !== null) {
      balance = this.left.height + 1;
    } else if (this.right !== null) {
      balance = -(this.right.height + 1);
    }
    return balance;
  }
  isLeftChild() {
    return this.parent !== null && this.parent.left === this;
  }
  get left() {
    return this._left;
  }
  set left(node) {
    this._left = node;
    if (node !== null) {
      node.parent = this;
    }
    this.updateHeight();
    this.updateMax();
  }
  get right() {
    return this._right;
  }
  set right(node) {
    this._right = node;
    if (node !== null) {
      node.parent = this;
    }
    this.updateHeight();
    this.updateMax();
  }
  dispose() {
    this.parent = null;
    this._left = null;
    this._right = null;
    this.event = null;
  }
};
var Volume = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Volume.getDefaults(), arguments, ["volume"]));
    this.name = "Volume";
    const options2 = optionsFromArguments(Volume.getDefaults(), arguments, ["volume"]);
    this.input = this.output = new Gain({
      context: this.context,
      gain: options2.volume,
      units: "decibels"
    });
    this.volume = this.output.gain;
    readOnly(this, "volume");
    this._unmutedVolume = options2.volume;
    this.mute = options2.mute;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  get mute() {
    return this.volume.value === -Infinity;
  }
  set mute(mute) {
    if (!this.mute && mute) {
      this._unmutedVolume = this.volume.value;
      this.volume.value = -Infinity;
    } else if (this.mute && !mute) {
      this.volume.value = this._unmutedVolume;
    }
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this.volume.dispose();
    return this;
  }
};
var Destination = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Destination.getDefaults(), arguments));
    this.name = "Destination";
    this.input = new Volume({ context: this.context });
    this.output = new Gain({ context: this.context });
    this.volume = this.input.volume;
    const options2 = optionsFromArguments(Destination.getDefaults(), arguments);
    connectSeries(this.input, this.output, this.context.rawContext.destination);
    this.mute = options2.mute;
    this._internalChannels = [this.input, this.context.rawContext.destination, this.output];
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  get mute() {
    return this.input.mute;
  }
  set mute(mute) {
    this.input.mute = mute;
  }
  chain(...args) {
    this.input.disconnect();
    args.unshift(this.input);
    args.push(this.output);
    connectSeries(...args);
    return this;
  }
  get maxChannelCount() {
    return this.context.rawContext.destination.maxChannelCount;
  }
  dispose() {
    super.dispose();
    this.volume.dispose();
    return this;
  }
};
onContextInit((context2) => {
  context2.destination = new Destination({ context: context2 });
});
onContextClose((context2) => {
  context2.destination.dispose();
});
var TimelineValue = class extends Tone {
  constructor(initialValue) {
    super();
    this.name = "TimelineValue";
    this._timeline = new Timeline({ memory: 10 });
    this._initialValue = initialValue;
  }
  set(value, time) {
    this._timeline.add({
      value,
      time
    });
    return this;
  }
  get(time) {
    const event = this._timeline.get(time);
    if (event) {
      return event.value;
    } else {
      return this._initialValue;
    }
  }
};
var TransportEvent = class {
  constructor(transport, opts) {
    this.id = TransportEvent._eventId++;
    this._remainderTime = 0;
    const options2 = Object.assign(TransportEvent.getDefaults(), opts);
    this.transport = transport;
    this.callback = options2.callback;
    this._once = options2.once;
    this.time = Math.floor(options2.time);
    this._remainderTime = options2.time - this.time;
  }
  static getDefaults() {
    return {
      callback: noOp,
      once: false,
      time: 0
    };
  }
  get floatTime() {
    return this.time + this._remainderTime;
  }
  invoke(time) {
    if (this.callback) {
      const tickDuration = this.transport.bpm.getDurationOfTicks(1, time);
      this.callback(time + this._remainderTime * tickDuration);
      if (this._once) {
        this.transport.clear(this.id);
      }
    }
  }
  dispose() {
    this.callback = void 0;
    return this;
  }
};
TransportEvent._eventId = 0;
var TransportRepeatEvent = class extends TransportEvent {
  constructor(transport, opts) {
    super(transport, opts);
    this._currentId = -1;
    this._nextId = -1;
    this._nextTick = this.time;
    this._boundRestart = this._restart.bind(this);
    const options2 = Object.assign(TransportRepeatEvent.getDefaults(), opts);
    this.duration = options2.duration;
    this._interval = options2.interval;
    this._nextTick = options2.time;
    this.transport.on("start", this._boundRestart);
    this.transport.on("loopStart", this._boundRestart);
    this.transport.on("ticks", this._boundRestart);
    this.context = this.transport.context;
    this._restart();
  }
  static getDefaults() {
    return Object.assign({}, TransportEvent.getDefaults(), {
      duration: Infinity,
      interval: 1,
      once: false
    });
  }
  invoke(time) {
    this._createEvents(time);
    super.invoke(time);
  }
  _createEvent() {
    if (LT(this._nextTick, this.floatTime + this.duration)) {
      return this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
    }
    return -1;
  }
  _createEvents(time) {
    if (LT(this._nextTick + this._interval, this.floatTime + this.duration)) {
      this._nextTick += this._interval;
      this._currentId = this._nextId;
      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
    }
  }
  _restart(time) {
    this.transport.clear(this._currentId);
    this.transport.clear(this._nextId);
    this._nextTick = this.floatTime;
    const ticks = this.transport.getTicksAtTime(time);
    if (GT(ticks, this.time)) {
      this._nextTick = this.floatTime + Math.ceil((ticks - this.floatTime) / this._interval) * this._interval;
    }
    this._currentId = this._createEvent();
    this._nextTick += this._interval;
    this._nextId = this._createEvent();
  }
  dispose() {
    super.dispose();
    this.transport.clear(this._currentId);
    this.transport.clear(this._nextId);
    this.transport.off("start", this._boundRestart);
    this.transport.off("loopStart", this._boundRestart);
    this.transport.off("ticks", this._boundRestart);
    return this;
  }
};
var Transport$1 = class extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(Transport$1.getDefaults(), arguments));
    this.name = "Transport";
    this._loop = new TimelineValue(false);
    this._loopStart = 0;
    this._loopEnd = 0;
    this._scheduledEvents = {};
    this._timeline = new Timeline();
    this._repeatedEvents = new IntervalTimeline();
    this._syncedSignals = [];
    this._swingAmount = 0;
    const options2 = optionsFromArguments(Transport$1.getDefaults(), arguments);
    this._ppq = options2.ppq;
    this._clock = new Clock({
      callback: this._processTick.bind(this),
      context: this.context,
      frequency: 0,
      units: "bpm"
    });
    this._bindClockEvents();
    this.bpm = this._clock.frequency;
    this._clock.frequency.multiplier = options2.ppq;
    this.bpm.setValueAtTime(options2.bpm, 0);
    readOnly(this, "bpm");
    this._timeSignature = options2.timeSignature;
    this._swingTicks = options2.ppq / 2;
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      bpm: 120,
      loopEnd: "4m",
      loopStart: 0,
      ppq: 192,
      swing: 0,
      swingSubdivision: "8n",
      timeSignature: 4
    });
  }
  _processTick(tickTime, ticks) {
    if (this._loop.get(tickTime)) {
      if (ticks >= this._loopEnd) {
        this.emit("loopEnd", tickTime);
        this._clock.setTicksAtTime(this._loopStart, tickTime);
        ticks = this._loopStart;
        this.emit("loopStart", tickTime, this._clock.getSecondsAtTime(tickTime));
        this.emit("loop", tickTime);
      }
    }
    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && ticks % (this._swingTicks * 2) !== 0) {
      const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
      const amount = Math.sin(progress * Math.PI) * this._swingAmount;
      tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;
    }
    enterScheduledCallback(true);
    this._timeline.forEachAtTime(ticks, (event) => event.invoke(tickTime));
    enterScheduledCallback(false);
  }
  schedule(callback, time) {
    const event = new TransportEvent(this, {
      callback,
      time: new TransportTimeClass(this.context, time).toTicks()
    });
    return this._addEvent(event, this._timeline);
  }
  scheduleRepeat(callback, interval2, startTime, duration2 = Infinity) {
    const event = new TransportRepeatEvent(this, {
      callback,
      duration: new TimeClass(this.context, duration2).toTicks(),
      interval: new TimeClass(this.context, interval2).toTicks(),
      time: new TransportTimeClass(this.context, startTime).toTicks()
    });
    return this._addEvent(event, this._repeatedEvents);
  }
  scheduleOnce(callback, time) {
    const event = new TransportEvent(this, {
      callback,
      once: true,
      time: new TransportTimeClass(this.context, time).toTicks()
    });
    return this._addEvent(event, this._timeline);
  }
  clear(eventId) {
    if (this._scheduledEvents.hasOwnProperty(eventId)) {
      const item = this._scheduledEvents[eventId.toString()];
      item.timeline.remove(item.event);
      item.event.dispose();
      delete this._scheduledEvents[eventId.toString()];
    }
    return this;
  }
  _addEvent(event, timeline) {
    this._scheduledEvents[event.id.toString()] = {
      event,
      timeline
    };
    timeline.add(event);
    return event.id;
  }
  cancel(after = 0) {
    const computedAfter = this.toTicks(after);
    this._timeline.forEachFrom(computedAfter, (event) => this.clear(event.id));
    this._repeatedEvents.forEachFrom(computedAfter, (event) => this.clear(event.id));
    return this;
  }
  _bindClockEvents() {
    this._clock.on("start", (time, offset) => {
      offset = new TicksClass(this.context, offset).toSeconds();
      this.emit("start", time, offset);
    });
    this._clock.on("stop", (time) => {
      this.emit("stop", time);
    });
    this._clock.on("pause", (time) => {
      this.emit("pause", time);
    });
  }
  get state() {
    return this._clock.getStateAtTime(this.now());
  }
  start(time, offset) {
    this.context.resume();
    let offsetTicks;
    if (isDefined(offset)) {
      offsetTicks = this.toTicks(offset);
    }
    this._clock.start(time, offsetTicks);
    return this;
  }
  stop(time) {
    this._clock.stop(time);
    return this;
  }
  pause(time) {
    this._clock.pause(time);
    return this;
  }
  toggle(time) {
    time = this.toSeconds(time);
    if (this._clock.getStateAtTime(time) !== "started") {
      this.start(time);
    } else {
      this.stop(time);
    }
    return this;
  }
  get timeSignature() {
    return this._timeSignature;
  }
  set timeSignature(timeSig) {
    if (isArray(timeSig)) {
      timeSig = timeSig[0] / timeSig[1] * 4;
    }
    this._timeSignature = timeSig;
  }
  get loopStart() {
    return new TimeClass(this.context, this._loopStart, "i").toSeconds();
  }
  set loopStart(startPosition) {
    this._loopStart = this.toTicks(startPosition);
  }
  get loopEnd() {
    return new TimeClass(this.context, this._loopEnd, "i").toSeconds();
  }
  set loopEnd(endPosition) {
    this._loopEnd = this.toTicks(endPosition);
  }
  get loop() {
    return this._loop.get(this.now());
  }
  set loop(loop) {
    this._loop.set(loop, this.now());
  }
  setLoopPoints(startPosition, endPosition) {
    this.loopStart = startPosition;
    this.loopEnd = endPosition;
    return this;
  }
  get swing() {
    return this._swingAmount;
  }
  set swing(amount) {
    this._swingAmount = amount;
  }
  get swingSubdivision() {
    return new TicksClass(this.context, this._swingTicks).toNotation();
  }
  set swingSubdivision(subdivision) {
    this._swingTicks = this.toTicks(subdivision);
  }
  get position() {
    const now2 = this.now();
    const ticks = this._clock.getTicksAtTime(now2);
    return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();
  }
  set position(progress) {
    const ticks = this.toTicks(progress);
    this.ticks = ticks;
  }
  get seconds() {
    return this._clock.seconds;
  }
  set seconds(s2) {
    const now2 = this.now();
    const ticks = this._clock.frequency.timeToTicks(s2, now2);
    this.ticks = ticks;
  }
  get progress() {
    if (this.loop) {
      const now2 = this.now();
      const ticks = this._clock.getTicksAtTime(now2);
      return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);
    } else {
      return 0;
    }
  }
  get ticks() {
    return this._clock.ticks;
  }
  set ticks(t2) {
    if (this._clock.ticks !== t2) {
      const now2 = this.now();
      if (this.state === "started") {
        const ticks = this._clock.getTicksAtTime(now2);
        const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now2);
        const time = now2 + remainingTick;
        this.emit("stop", time);
        this._clock.setTicksAtTime(t2, time);
        this.emit("start", time, this._clock.getSecondsAtTime(time));
      } else {
        this.emit("ticks", now2);
        this._clock.setTicksAtTime(t2, now2);
      }
    }
  }
  getTicksAtTime(time) {
    return this._clock.getTicksAtTime(time);
  }
  getSecondsAtTime(time) {
    return this._clock.getSecondsAtTime(time);
  }
  get PPQ() {
    return this._clock.frequency.multiplier;
  }
  set PPQ(ppq) {
    this._clock.frequency.multiplier = ppq;
  }
  nextSubdivision(subdivision) {
    subdivision = this.toTicks(subdivision);
    if (this.state !== "started") {
      return 0;
    } else {
      const now2 = this.now();
      const transportPos = this.getTicksAtTime(now2);
      const remainingTicks = subdivision - transportPos % subdivision;
      return this._clock.nextTickTime(remainingTicks, now2);
    }
  }
  syncSignal(signal, ratio) {
    if (!ratio) {
      const now2 = this.now();
      if (signal.getValueAtTime(now2) !== 0) {
        const bpm = this.bpm.getValueAtTime(now2);
        const computedFreq = 1 / (60 / bpm / this.PPQ);
        ratio = signal.getValueAtTime(now2) / computedFreq;
      } else {
        ratio = 0;
      }
    }
    const ratioSignal = new Gain(ratio);
    this.bpm.connect(ratioSignal);
    ratioSignal.connect(signal._param);
    this._syncedSignals.push({
      initial: signal.value,
      ratio: ratioSignal,
      signal
    });
    signal.value = 0;
    return this;
  }
  unsyncSignal(signal) {
    for (let i2 = this._syncedSignals.length - 1; i2 >= 0; i2--) {
      const syncedSignal = this._syncedSignals[i2];
      if (syncedSignal.signal === signal) {
        syncedSignal.ratio.dispose();
        syncedSignal.signal.value = syncedSignal.initial;
        this._syncedSignals.splice(i2, 1);
      }
    }
    return this;
  }
  dispose() {
    super.dispose();
    this._clock.dispose();
    writable(this, "bpm");
    this._timeline.dispose();
    this._repeatedEvents.dispose();
    return this;
  }
};
Emitter.mixin(Transport$1);
onContextInit((context2) => {
  context2.transport = new Transport$1({ context: context2 });
});
onContextClose((context2) => {
  context2.transport.dispose();
});
var Source = class extends ToneAudioNode {
  constructor(options2) {
    super(options2);
    this.input = void 0;
    this._state = new StateTimeline("stopped");
    this._synced = false;
    this._scheduled = [];
    this._syncedStart = noOp;
    this._syncedStop = noOp;
    this._state.memory = 100;
    this._state.increasing = true;
    this._volume = this.output = new Volume({
      context: this.context,
      mute: options2.mute,
      volume: options2.volume
    });
    this.volume = this._volume.volume;
    readOnly(this, "volume");
    this.onstop = options2.onstop;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      onstop: noOp,
      volume: 0
    });
  }
  get state() {
    if (this._synced) {
      if (this.context.transport.state === "started") {
        return this._state.getValueAtTime(this.context.transport.seconds);
      } else {
        return "stopped";
      }
    } else {
      return this._state.getValueAtTime(this.now());
    }
  }
  get mute() {
    return this._volume.mute;
  }
  set mute(mute) {
    this._volume.mute = mute;
  }
  _clampToCurrentTime(time) {
    if (this._synced) {
      return time;
    } else {
      return Math.max(time, this.context.currentTime);
    }
  }
  start(time, offset, duration2) {
    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);
    computedTime = this._clampToCurrentTime(computedTime);
    if (!this._synced && this._state.getValueAtTime(computedTime) === "started") {
      assert(GT(computedTime, this._state.get(computedTime).time), "Start time must be strictly greater than previous start time");
      this._state.cancel(computedTime);
      this._state.setStateAtTime("started", computedTime);
      this.log("restart", computedTime);
      this.restart(computedTime, offset, duration2);
    } else {
      this.log("start", computedTime);
      this._state.setStateAtTime("started", computedTime);
      if (this._synced) {
        const event = this._state.get(computedTime);
        if (event) {
          event.offset = this.toSeconds(defaultArg(offset, 0));
          event.duration = duration2 ? this.toSeconds(duration2) : void 0;
        }
        const sched = this.context.transport.schedule((t2) => {
          this._start(t2, offset, duration2);
        }, computedTime);
        this._scheduled.push(sched);
        if (this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {
          this._syncedStart(this.now(), this.context.transport.seconds);
        }
      } else {
        assertContextRunning(this.context);
        this._start(computedTime, offset, duration2);
      }
    }
    return this;
  }
  stop(time) {
    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);
    computedTime = this._clampToCurrentTime(computedTime);
    if (this._state.getValueAtTime(computedTime) === "started" || isDefined(this._state.getNextState("started", computedTime))) {
      this.log("stop", computedTime);
      if (!this._synced) {
        this._stop(computedTime);
      } else {
        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);
        this._scheduled.push(sched);
      }
      this._state.cancel(computedTime);
      this._state.setStateAtTime("stopped", computedTime);
    }
    return this;
  }
  restart(time, offset, duration2) {
    time = this.toSeconds(time);
    if (this._state.getValueAtTime(time) === "started") {
      this._state.cancel(time);
      this._restart(time, offset, duration2);
    }
    return this;
  }
  sync() {
    if (!this._synced) {
      this._synced = true;
      this._syncedStart = (time, offset) => {
        if (GT(offset, 0)) {
          const stateEvent = this._state.get(offset);
          if (stateEvent && stateEvent.state === "started" && stateEvent.time !== offset) {
            const startOffset = offset - this.toSeconds(stateEvent.time);
            let duration2;
            if (stateEvent.duration) {
              duration2 = this.toSeconds(stateEvent.duration) - startOffset;
            }
            this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration2);
          }
        }
      };
      this._syncedStop = (time) => {
        const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));
        if (this._state.getValueAtTime(seconds) === "started") {
          this._stop(time);
        }
      };
      this.context.transport.on("start", this._syncedStart);
      this.context.transport.on("loopStart", this._syncedStart);
      this.context.transport.on("stop", this._syncedStop);
      this.context.transport.on("pause", this._syncedStop);
      this.context.transport.on("loopEnd", this._syncedStop);
    }
    return this;
  }
  unsync() {
    if (this._synced) {
      this.context.transport.off("stop", this._syncedStop);
      this.context.transport.off("pause", this._syncedStop);
      this.context.transport.off("loopEnd", this._syncedStop);
      this.context.transport.off("start", this._syncedStart);
      this.context.transport.off("loopStart", this._syncedStart);
    }
    this._synced = false;
    this._scheduled.forEach((id) => this.context.transport.clear(id));
    this._scheduled = [];
    this._state.cancel(0);
    this._stop(0);
    return this;
  }
  dispose() {
    super.dispose();
    this.onstop = noOp;
    this.unsync();
    this._volume.dispose();
    this._state.dispose();
    return this;
  }
};
var ToneBufferSource = class extends OneShotSource {
  constructor() {
    super(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, ["url", "onload"]));
    this.name = "ToneBufferSource";
    this._source = this.context.createBufferSource();
    this._internalChannels = [this._source];
    this._sourceStarted = false;
    this._sourceStopped = false;
    const options2 = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, ["url", "onload"]);
    connect(this._source, this._gainNode);
    this._source.onended = () => this._stopSource();
    this.playbackRate = new Param({
      context: this.context,
      param: this._source.playbackRate,
      units: "positive",
      value: options2.playbackRate
    });
    this.loop = options2.loop;
    this.loopStart = options2.loopStart;
    this.loopEnd = options2.loopEnd;
    this._buffer = new ToneAudioBuffer(options2.url, options2.onload, options2.onerror);
    this._internalChannels.push(this._source);
  }
  static getDefaults() {
    return Object.assign(OneShotSource.getDefaults(), {
      url: new ToneAudioBuffer(),
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      onload: noOp,
      onerror: noOp,
      playbackRate: 1
    });
  }
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(t2) {
    this._fadeIn = t2;
  }
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(t2) {
    this._fadeOut = t2;
  }
  get curve() {
    return this._curve;
  }
  set curve(t2) {
    this._curve = t2;
  }
  start(time, offset, duration2, gain = 1) {
    assert(this.buffer.loaded, "buffer is either not set or not loaded");
    const computedTime = this.toSeconds(time);
    this._startGain(computedTime, gain);
    if (this.loop) {
      offset = defaultArg(offset, this.loopStart);
    } else {
      offset = defaultArg(offset, 0);
    }
    let computedOffset = Math.max(this.toSeconds(offset), 0);
    if (this.loop) {
      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
      const loopStart = this.toSeconds(this.loopStart);
      const loopDuration = loopEnd - loopStart;
      if (GTE(computedOffset, loopEnd)) {
        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;
      }
      if (EQ(computedOffset, this.buffer.duration)) {
        computedOffset = 0;
      }
    }
    this._source.buffer = this.buffer.get();
    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
    if (LT(computedOffset, this.buffer.duration)) {
      this._sourceStarted = true;
      this._source.start(computedTime, computedOffset);
    }
    if (isDefined(duration2)) {
      let computedDur = this.toSeconds(duration2);
      computedDur = Math.max(computedDur, 0);
      this.stop(computedTime + computedDur);
    }
    return this;
  }
  _stopSource(time) {
    if (!this._sourceStopped && this._sourceStarted) {
      this._sourceStopped = true;
      this._source.stop(this.toSeconds(time));
      this._onended();
    }
  }
  get loopStart() {
    return this._source.loopStart;
  }
  set loopStart(loopStart) {
    this._source.loopStart = this.toSeconds(loopStart);
  }
  get loopEnd() {
    return this._source.loopEnd;
  }
  set loopEnd(loopEnd) {
    this._source.loopEnd = this.toSeconds(loopEnd);
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(buffer) {
    this._buffer.set(buffer);
  }
  get loop() {
    return this._source.loop;
  }
  set loop(loop) {
    this._source.loop = loop;
    if (this._sourceStarted) {
      this.cancelStop();
    }
  }
  dispose() {
    super.dispose();
    this._source.onended = null;
    this._source.disconnect();
    this._buffer.dispose();
    this.playbackRate.dispose();
    return this;
  }
};
var Noise = class extends Source {
  constructor() {
    super(optionsFromArguments(Noise.getDefaults(), arguments, ["type"]));
    this.name = "Noise";
    this._source = null;
    const options2 = optionsFromArguments(Noise.getDefaults(), arguments, ["type"]);
    this._playbackRate = options2.playbackRate;
    this.type = options2.type;
    this._fadeIn = options2.fadeIn;
    this._fadeOut = options2.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      fadeIn: 0,
      fadeOut: 0,
      playbackRate: 1,
      type: "white"
    });
  }
  get type() {
    return this._type;
  }
  set type(type) {
    assert(type in _noiseBuffers, "Noise: invalid type: " + type);
    if (this._type !== type) {
      this._type = type;
      if (this.state === "started") {
        const now2 = this.now();
        this._stop(now2);
        this._start(now2);
      }
    }
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    if (this._source) {
      this._source.playbackRate.value = rate;
    }
  }
  _start(time) {
    const buffer = _noiseBuffers[this._type];
    this._source = new ToneBufferSource({
      url: buffer,
      context: this.context,
      fadeIn: this._fadeIn,
      fadeOut: this._fadeOut,
      loop: true,
      onended: () => this.onstop(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 1e-3));
  }
  _stop(time) {
    if (this._source) {
      this._source.stop(this.toSeconds(time));
      this._source = null;
    }
  }
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(time) {
    this._fadeIn = time;
    if (this._source) {
      this._source.fadeIn = this._fadeIn;
    }
  }
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(time) {
    this._fadeOut = time;
    if (this._source) {
      this._source.fadeOut = this._fadeOut;
    }
  }
  _restart(time) {
    this._stop(time);
    this._start(time);
  }
  dispose() {
    super.dispose();
    if (this._source) {
      this._source.disconnect();
    }
    return this;
  }
};
var BUFFER_LENGTH = 44100 * 5;
var NUM_CHANNELS = 2;
var _noiseCache = {
  brown: null,
  pink: null,
  white: null
};
var _noiseBuffers = {
  get brown() {
    if (!_noiseCache.brown) {
      const buffer = [];
      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer[channelNum] = channel;
        let lastOut = 0;
        for (let i2 = 0; i2 < BUFFER_LENGTH; i2++) {
          const white = Math.random() * 2 - 1;
          channel[i2] = (lastOut + 0.02 * white) / 1.02;
          lastOut = channel[i2];
          channel[i2] *= 3.5;
        }
      }
      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);
    }
    return _noiseCache.brown;
  },
  get pink() {
    if (!_noiseCache.pink) {
      const buffer = [];
      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer[channelNum] = channel;
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
        for (let i2 = 0; i2 < BUFFER_LENGTH; i2++) {
          const white = Math.random() * 2 - 1;
          b0 = 0.99886 * b0 + white * 0.0555179;
          b1 = 0.99332 * b1 + white * 0.0750759;
          b2 = 0.969 * b2 + white * 0.153852;
          b3 = 0.8665 * b3 + white * 0.3104856;
          b4 = 0.55 * b4 + white * 0.5329522;
          b5 = -0.7616 * b5 - white * 0.016898;
          channel[i2] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
          channel[i2] *= 0.11;
          b6 = white * 0.115926;
        }
      }
      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);
    }
    return _noiseCache.pink;
  },
  get white() {
    if (!_noiseCache.white) {
      const buffer = [];
      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer[channelNum] = channel;
        for (let i2 = 0; i2 < BUFFER_LENGTH; i2++) {
          channel[i2] = Math.random() * 2 - 1;
        }
      }
      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);
    }
    return _noiseCache.white;
  }
};
var UserMedia = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(UserMedia.getDefaults(), arguments, ["volume"]));
    this.name = "UserMedia";
    const options2 = optionsFromArguments(UserMedia.getDefaults(), arguments, ["volume"]);
    this._volume = this.output = new Volume({
      context: this.context,
      volume: options2.volume
    });
    this.volume = this._volume.volume;
    readOnly(this, "volume");
    this.mute = options2.mute;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  open(labelOrId) {
    return __awaiter(this, void 0, void 0, function* () {
      assert(UserMedia.supported, "UserMedia is not supported");
      if (this.state === "started") {
        this.close();
      }
      const devices2 = yield UserMedia.enumerateDevices();
      if (isNumber(labelOrId)) {
        this._device = devices2[labelOrId];
      } else {
        this._device = devices2.find((device) => {
          return device.label === labelOrId || device.deviceId === labelOrId;
        });
        if (!this._device && devices2.length > 0) {
          this._device = devices2[0];
        }
        assert(isDefined(this._device), `No matching device ${labelOrId}`);
      }
      const constraints = {
        audio: {
          echoCancellation: false,
          sampleRate: this.context.sampleRate,
          noiseSuppression: false,
          mozNoiseSuppression: false
        }
      };
      if (this._device) {
        constraints.audio.deviceId = this._device.deviceId;
      }
      const stream = yield navigator.mediaDevices.getUserMedia(constraints);
      if (!this._stream) {
        this._stream = stream;
        const mediaStreamNode = this.context.createMediaStreamSource(stream);
        connect(mediaStreamNode, this.output);
        this._mediaStream = mediaStreamNode;
      }
      return this;
    });
  }
  close() {
    if (this._stream && this._mediaStream) {
      this._stream.getAudioTracks().forEach((track) => {
        track.stop();
      });
      this._stream = void 0;
      this._mediaStream.disconnect();
      this._mediaStream = void 0;
    }
    this._device = void 0;
    return this;
  }
  static enumerateDevices() {
    return __awaiter(this, void 0, void 0, function* () {
      const allDevices = yield navigator.mediaDevices.enumerateDevices();
      return allDevices.filter((device) => {
        return device.kind === "audioinput";
      });
    });
  }
  get state() {
    return this._stream && this._stream.active ? "started" : "stopped";
  }
  get deviceId() {
    if (this._device) {
      return this._device.deviceId;
    } else {
      return void 0;
    }
  }
  get groupId() {
    if (this._device) {
      return this._device.groupId;
    } else {
      return void 0;
    }
  }
  get label() {
    if (this._device) {
      return this._device.label;
    } else {
      return void 0;
    }
  }
  get mute() {
    return this._volume.mute;
  }
  set mute(mute) {
    this._volume.mute = mute;
  }
  dispose() {
    super.dispose();
    this.close();
    this._volume.dispose();
    this.volume.dispose();
    return this;
  }
  static get supported() {
    return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);
  }
};
function generateWaveform(instance, length) {
  return __awaiter(this, void 0, void 0, function* () {
    const duration2 = length / instance.context.sampleRate;
    const context2 = new OfflineContext(1, duration2, instance.context.sampleRate);
    const clone = new instance.constructor(Object.assign(instance.get(), {
      frequency: 2 / duration2,
      detune: 0,
      context: context2
    })).toDestination();
    clone.start(0);
    const buffer = yield context2.render();
    return buffer.getChannelData(0);
  });
}
var ToneOscillatorNode = class extends OneShotSource {
  constructor() {
    super(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "ToneOscillatorNode";
    this._oscillator = this.context.createOscillator();
    this._internalChannels = [this._oscillator];
    const options2 = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]);
    connect(this._oscillator, this._gainNode);
    this.type = options2.type;
    this.frequency = new Param({
      context: this.context,
      param: this._oscillator.frequency,
      units: "frequency",
      value: options2.frequency
    });
    this.detune = new Param({
      context: this.context,
      param: this._oscillator.detune,
      units: "cents",
      value: options2.detune
    });
    readOnly(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(OneShotSource.getDefaults(), {
      detune: 0,
      frequency: 440,
      type: "sine"
    });
  }
  start(time) {
    const computedTime = this.toSeconds(time);
    this.log("start", computedTime);
    this._startGain(computedTime);
    this._oscillator.start(computedTime);
    return this;
  }
  _stopSource(time) {
    this._oscillator.stop(time);
  }
  setPeriodicWave(periodicWave) {
    this._oscillator.setPeriodicWave(periodicWave);
    return this;
  }
  get type() {
    return this._oscillator.type;
  }
  set type(type) {
    this._oscillator.type = type;
  }
  dispose() {
    super.dispose();
    if (this.state === "started") {
      this.stop();
    }
    this._oscillator.disconnect();
    this.frequency.dispose();
    this.detune.dispose();
    return this;
  }
};
var Oscillator = class extends Source {
  constructor() {
    super(optionsFromArguments(Oscillator.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "Oscillator";
    this._oscillator = null;
    const options2 = optionsFromArguments(Oscillator.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    readOnly(this, "frequency");
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options2.detune
    });
    readOnly(this, "detune");
    this._partials = options2.partials;
    this._partialCount = options2.partialCount;
    this._type = options2.type;
    if (options2.partialCount && options2.type !== "custom") {
      this._type = this.baseType + options2.partialCount.toString();
    }
    this.phase = options2.phase;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      partialCount: 0,
      partials: [],
      phase: 0,
      type: "sine"
    });
  }
  _start(time) {
    const computedTime = this.toSeconds(time);
    const oscillator = new ToneOscillatorNode({
      context: this.context,
      onended: () => this.onstop(this)
    });
    this._oscillator = oscillator;
    if (this._wave) {
      this._oscillator.setPeriodicWave(this._wave);
    } else {
      this._oscillator.type = this._type;
    }
    this._oscillator.connect(this.output);
    this.frequency.connect(this._oscillator.frequency);
    this.detune.connect(this._oscillator.detune);
    this._oscillator.start(computedTime);
  }
  _stop(time) {
    const computedTime = this.toSeconds(time);
    if (this._oscillator) {
      this._oscillator.stop(computedTime);
    }
  }
  _restart(time) {
    const computedTime = this.toSeconds(time);
    this.log("restart", computedTime);
    if (this._oscillator) {
      this._oscillator.cancelStop();
    }
    this._state.cancel(computedTime);
    return this;
  }
  syncFrequency() {
    this.context.transport.syncSignal(this.frequency);
    return this;
  }
  unsyncFrequency() {
    this.context.transport.unsyncSignal(this.frequency);
    return this;
  }
  _getCachedPeriodicWave() {
    if (this._type === "custom") {
      const oscProps = Oscillator._periodicWaveCache.find((description) => {
        return description.phase === this._phase && deepEquals(description.partials, this._partials);
      });
      return oscProps;
    } else {
      const oscProps = Oscillator._periodicWaveCache.find((description) => {
        return description.type === this._type && description.phase === this._phase;
      });
      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;
      return oscProps;
    }
  }
  get type() {
    return this._type;
  }
  set type(type) {
    this._type = type;
    const isBasicType = ["sine", "square", "sawtooth", "triangle"].indexOf(type) !== -1;
    if (this._phase === 0 && isBasicType) {
      this._wave = void 0;
      this._partialCount = 0;
      if (this._oscillator !== null) {
        this._oscillator.type = type;
      }
    } else {
      const cache2 = this._getCachedPeriodicWave();
      if (isDefined(cache2)) {
        const { partials, wave } = cache2;
        this._wave = wave;
        this._partials = partials;
        if (this._oscillator !== null) {
          this._oscillator.setPeriodicWave(this._wave);
        }
      } else {
        const [real, imag] = this._getRealImaginary(type, this._phase);
        const periodicWave = this.context.createPeriodicWave(real, imag);
        this._wave = periodicWave;
        if (this._oscillator !== null) {
          this._oscillator.setPeriodicWave(this._wave);
        }
        Oscillator._periodicWaveCache.push({
          imag,
          partialCount: this._partialCount,
          partials: this._partials,
          phase: this._phase,
          real,
          type: this._type,
          wave: this._wave
        });
        if (Oscillator._periodicWaveCache.length > 100) {
          Oscillator._periodicWaveCache.shift();
        }
      }
    }
  }
  get baseType() {
    return this._type.replace(this.partialCount.toString(), "");
  }
  set baseType(baseType) {
    if (this.partialCount && this._type !== "custom" && baseType !== "custom") {
      this.type = baseType + this.partialCount;
    } else {
      this.type = baseType;
    }
  }
  get partialCount() {
    return this._partialCount;
  }
  set partialCount(p2) {
    assertRange(p2, 0);
    let type = this._type;
    const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
    if (partial) {
      type = partial[1];
    }
    if (this._type !== "custom") {
      if (p2 === 0) {
        this.type = type;
      } else {
        this.type = type + p2.toString();
      }
    } else {
      const fullPartials = new Float32Array(p2);
      this._partials.forEach((v2, i2) => fullPartials[i2] = v2);
      this._partials = Array.from(fullPartials);
      this.type = this._type;
    }
  }
  _getRealImaginary(type, phase) {
    const fftSize = 4096;
    let periodicWaveSize = fftSize / 2;
    const real = new Float32Array(periodicWaveSize);
    const imag = new Float32Array(periodicWaveSize);
    let partialCount = 1;
    if (type === "custom") {
      partialCount = this._partials.length + 1;
      this._partialCount = this._partials.length;
      periodicWaveSize = partialCount;
      if (this._partials.length === 0) {
        return [real, imag];
      }
    } else {
      const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
      if (partial) {
        partialCount = parseInt(partial[2], 10) + 1;
        this._partialCount = parseInt(partial[2], 10);
        type = partial[1];
        partialCount = Math.max(partialCount, 2);
        periodicWaveSize = partialCount;
      } else {
        this._partialCount = 0;
      }
      this._partials = [];
    }
    for (let n2 = 1; n2 < periodicWaveSize; ++n2) {
      const piFactor = 2 / (n2 * Math.PI);
      let b2;
      switch (type) {
        case "sine":
          b2 = n2 <= partialCount ? 1 : 0;
          this._partials[n2 - 1] = b2;
          break;
        case "square":
          b2 = n2 & 1 ? 2 * piFactor : 0;
          this._partials[n2 - 1] = b2;
          break;
        case "sawtooth":
          b2 = piFactor * (n2 & 1 ? 1 : -1);
          this._partials[n2 - 1] = b2;
          break;
        case "triangle":
          if (n2 & 1) {
            b2 = 2 * (piFactor * piFactor) * (n2 - 1 >> 1 & 1 ? -1 : 1);
          } else {
            b2 = 0;
          }
          this._partials[n2 - 1] = b2;
          break;
        case "custom":
          b2 = this._partials[n2 - 1];
          break;
        default:
          throw new TypeError("Oscillator: invalid type: " + type);
      }
      if (b2 !== 0) {
        real[n2] = -b2 * Math.sin(phase * n2);
        imag[n2] = b2 * Math.cos(phase * n2);
      } else {
        real[n2] = 0;
        imag[n2] = 0;
      }
    }
    return [real, imag];
  }
  _inverseFFT(real, imag, phase) {
    let sum = 0;
    const len = real.length;
    for (let i2 = 0; i2 < len; i2++) {
      sum += real[i2] * Math.cos(i2 * phase) + imag[i2] * Math.sin(i2 * phase);
    }
    return sum;
  }
  getInitialValue() {
    const [real, imag] = this._getRealImaginary(this._type, 0);
    let maxValue = 0;
    const twoPi = Math.PI * 2;
    const testPositions = 32;
    for (let i2 = 0; i2 < testPositions; i2++) {
      maxValue = Math.max(this._inverseFFT(real, imag, i2 / testPositions * twoPi), maxValue);
    }
    return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);
  }
  get partials() {
    return this._partials.slice(0, this.partialCount);
  }
  set partials(partials) {
    this._partials = partials;
    this._partialCount = this._partials.length;
    if (partials.length) {
      this.type = "custom";
    }
  }
  get phase() {
    return this._phase * (180 / Math.PI);
  }
  set phase(phase) {
    this._phase = phase * Math.PI / 180;
    this.type = this._type;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    if (this._oscillator !== null) {
      this._oscillator.dispose();
    }
    this._wave = void 0;
    this.frequency.dispose();
    this.detune.dispose();
    return this;
  }
};
Oscillator._periodicWaveCache = [];
var SignalOperator = class extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, ["context"])));
  }
  connect(destination, outputNum = 0, inputNum = 0) {
    connectSignal(this, destination, outputNum, inputNum);
    return this;
  }
};
var WaveShaper = class extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, ["mapping", "length"])));
    this.name = "WaveShaper";
    this._shaper = this.context.createWaveShaper();
    this.input = this._shaper;
    this.output = this._shaper;
    const options2 = optionsFromArguments(WaveShaper.getDefaults(), arguments, ["mapping", "length"]);
    if (isArray(options2.mapping) || options2.mapping instanceof Float32Array) {
      this.curve = Float32Array.from(options2.mapping);
    } else if (isFunction(options2.mapping)) {
      this.setMap(options2.mapping, options2.length);
    }
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      length: 1024
    });
  }
  setMap(mapping, length = 1024) {
    const array = new Float32Array(length);
    for (let i2 = 0, len = length; i2 < len; i2++) {
      const normalized = i2 / (len - 1) * 2 - 1;
      array[i2] = mapping(normalized, i2);
    }
    this.curve = array;
    return this;
  }
  get curve() {
    return this._shaper.curve;
  }
  set curve(mapping) {
    this._shaper.curve = mapping;
  }
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(oversampling) {
    const isOverSampleType = ["none", "2x", "4x"].some((str) => str.includes(oversampling));
    assert(isOverSampleType, "oversampling must be either 'none', '2x', or '4x'");
    this._shaper.oversample = oversampling;
  }
  dispose() {
    super.dispose();
    this._shaper.disconnect();
    return this;
  }
};
var AudioToGain = class extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "AudioToGain";
    this._norm = new WaveShaper({
      context: this.context,
      mapping: (x2) => (x2 + 1) / 2
    });
    this.input = this._norm;
    this.output = this._norm;
  }
  dispose() {
    super.dispose();
    this._norm.dispose();
    return this;
  }
};
var Multiply = class extends Signal {
  constructor() {
    super(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, ["value"])));
    this.name = "Multiply";
    this.override = false;
    const options2 = optionsFromArguments(Multiply.getDefaults(), arguments, ["value"]);
    this._mult = this.input = this.output = new Gain({
      context: this.context,
      minValue: options2.minValue,
      maxValue: options2.maxValue
    });
    this.factor = this._param = this._mult.gain;
    this.factor.setValueAtTime(options2.value, 0);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._mult.dispose();
    return this;
  }
};
var AMOscillator = class extends Source {
  constructor() {
    super(optionsFromArguments(AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
    this.name = "AMOscillator";
    this._modulationScale = new AudioToGain({ context: this.context });
    this._modulationNode = new Gain({
      context: this.context
    });
    const options2 = optionsFromArguments(AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new Oscillator({
      context: this.context,
      detune: options2.detune,
      frequency: options2.frequency,
      onstop: () => this.onstop(this),
      phase: options2.phase,
      type: options2.type
    });
    this.frequency = this._carrier.frequency, this.detune = this._carrier.detune;
    this._modulator = new Oscillator({
      context: this.context,
      phase: options2.phase,
      type: options2.modulationType
    });
    this.harmonicity = new Multiply({
      context: this.context,
      units: "positive",
      value: options2.harmonicity
    });
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this._modulator.chain(this._modulationScale, this._modulationNode.gain);
    this._carrier.chain(this._modulationNode, this.output);
    readOnly(this, ["frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      harmonicity: 1,
      modulationType: "square"
    });
  }
  _start(time) {
    this._modulator.start(time);
    this._carrier.start(time);
  }
  _stop(time) {
    this._modulator.stop(time);
    this._carrier.stop(time);
  }
  _restart(time) {
    this._modulator.restart(time);
    this._carrier.restart(time);
  }
  get type() {
    return this._carrier.type;
  }
  set type(type) {
    this._carrier.type = type;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(baseType) {
    this._carrier.baseType = baseType;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(partialCount) {
    this._carrier.partialCount = partialCount;
  }
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(type) {
    this._modulator.type = type;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(phase) {
    this._carrier.phase = phase;
    this._modulator.phase = phase;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(partials) {
    this._carrier.partials = partials;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.detune.dispose();
    this.harmonicity.dispose();
    this._carrier.dispose();
    this._modulator.dispose();
    this._modulationNode.dispose();
    this._modulationScale.dispose();
    return this;
  }
};
var FMOscillator = class extends Source {
  constructor() {
    super(optionsFromArguments(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
    this.name = "FMOscillator";
    this._modulationNode = new Gain({
      context: this.context,
      gain: 0
    });
    const options2 = optionsFromArguments(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new Oscillator({
      context: this.context,
      detune: options2.detune,
      frequency: 0,
      onstop: () => this.onstop(this),
      phase: options2.phase,
      type: options2.type
    });
    this.detune = this._carrier.detune;
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    this._modulator = new Oscillator({
      context: this.context,
      phase: options2.phase,
      type: options2.modulationType
    });
    this.harmonicity = new Multiply({
      context: this.context,
      units: "positive",
      value: options2.harmonicity
    });
    this.modulationIndex = new Multiply({
      context: this.context,
      units: "positive",
      value: options2.modulationIndex
    });
    this.frequency.connect(this._carrier.frequency);
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this.frequency.chain(this.modulationIndex, this._modulationNode);
    this._modulator.connect(this._modulationNode.gain);
    this._modulationNode.connect(this._carrier.frequency);
    this._carrier.connect(this.output);
    this.detune.connect(this._modulator.detune);
    readOnly(this, ["modulationIndex", "frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      harmonicity: 1,
      modulationIndex: 2,
      modulationType: "square"
    });
  }
  _start(time) {
    this._modulator.start(time);
    this._carrier.start(time);
  }
  _stop(time) {
    this._modulator.stop(time);
    this._carrier.stop(time);
  }
  _restart(time) {
    this._modulator.restart(time);
    this._carrier.restart(time);
    return this;
  }
  get type() {
    return this._carrier.type;
  }
  set type(type) {
    this._carrier.type = type;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(baseType) {
    this._carrier.baseType = baseType;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(partialCount) {
    this._carrier.partialCount = partialCount;
  }
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(type) {
    this._modulator.type = type;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(phase) {
    this._carrier.phase = phase;
    this._modulator.phase = phase;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(partials) {
    this._carrier.partials = partials;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.harmonicity.dispose();
    this._carrier.dispose();
    this._modulator.dispose();
    this._modulationNode.dispose();
    this.modulationIndex.dispose();
    return this;
  }
};
var PulseOscillator = class extends Source {
  constructor() {
    super(optionsFromArguments(PulseOscillator.getDefaults(), arguments, ["frequency", "width"]));
    this.name = "PulseOscillator";
    this._widthGate = new Gain({
      context: this.context,
      gain: 0
    });
    this._thresh = new WaveShaper({
      context: this.context,
      mapping: (val) => val <= 0 ? -1 : 1
    });
    const options2 = optionsFromArguments(PulseOscillator.getDefaults(), arguments, ["frequency", "width"]);
    this.width = new Signal({
      context: this.context,
      units: "audioRange",
      value: options2.width
    });
    this._triangle = new Oscillator({
      context: this.context,
      detune: options2.detune,
      frequency: options2.frequency,
      onstop: () => this.onstop(this),
      phase: options2.phase,
      type: "triangle"
    });
    this.frequency = this._triangle.frequency;
    this.detune = this._triangle.detune;
    this._triangle.chain(this._thresh, this.output);
    this.width.chain(this._widthGate, this._thresh);
    readOnly(this, ["width", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      phase: 0,
      type: "pulse",
      width: 0.2
    });
  }
  _start(time) {
    time = this.toSeconds(time);
    this._triangle.start(time);
    this._widthGate.gain.setValueAtTime(1, time);
  }
  _stop(time) {
    time = this.toSeconds(time);
    this._triangle.stop(time);
    this._widthGate.gain.cancelScheduledValues(time);
    this._widthGate.gain.setValueAtTime(0, time);
  }
  _restart(time) {
    this._triangle.restart(time);
    this._widthGate.gain.cancelScheduledValues(time);
    this._widthGate.gain.setValueAtTime(1, time);
  }
  get phase() {
    return this._triangle.phase;
  }
  set phase(phase) {
    this._triangle.phase = phase;
  }
  get type() {
    return "pulse";
  }
  get baseType() {
    return "pulse";
  }
  get partials() {
    return [];
  }
  get partialCount() {
    return 0;
  }
  set carrierType(type) {
    this._triangle.type = type;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    this._triangle.dispose();
    this.width.dispose();
    this._widthGate.dispose();
    this._thresh.dispose();
    return this;
  }
};
var FatOscillator = class extends Source {
  constructor() {
    super(optionsFromArguments(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]));
    this.name = "FatOscillator";
    this._oscillators = [];
    const options2 = optionsFromArguments(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]);
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options2.detune
    });
    this._spread = options2.spread;
    this._type = options2.type;
    this._phase = options2.phase;
    this._partials = options2.partials;
    this._partialCount = options2.partialCount;
    this.count = options2.count;
    readOnly(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      count: 3,
      spread: 20,
      type: "sawtooth"
    });
  }
  _start(time) {
    time = this.toSeconds(time);
    this._forEach((osc) => osc.start(time));
  }
  _stop(time) {
    time = this.toSeconds(time);
    this._forEach((osc) => osc.stop(time));
  }
  _restart(time) {
    this._forEach((osc) => osc.restart(time));
  }
  _forEach(iterator) {
    for (let i2 = 0; i2 < this._oscillators.length; i2++) {
      iterator(this._oscillators[i2], i2);
    }
  }
  get type() {
    return this._type;
  }
  set type(type) {
    this._type = type;
    this._forEach((osc) => osc.type = type);
  }
  get spread() {
    return this._spread;
  }
  set spread(spread) {
    this._spread = spread;
    if (this._oscillators.length > 1) {
      const start22 = -spread / 2;
      const step = spread / (this._oscillators.length - 1);
      this._forEach((osc, i2) => osc.detune.value = start22 + step * i2);
    }
  }
  get count() {
    return this._oscillators.length;
  }
  set count(count) {
    assertRange(count, 1);
    if (this._oscillators.length !== count) {
      this._forEach((osc) => osc.dispose());
      this._oscillators = [];
      for (let i2 = 0; i2 < count; i2++) {
        const osc = new Oscillator({
          context: this.context,
          volume: -6 - count * 1.1,
          type: this._type,
          phase: this._phase + i2 / count * 360,
          partialCount: this._partialCount,
          onstop: i2 === 0 ? () => this.onstop(this) : noOp
        });
        if (this.type === "custom") {
          osc.partials = this._partials;
        }
        this.frequency.connect(osc.frequency);
        this.detune.connect(osc.detune);
        osc.detune.overridden = false;
        osc.connect(this.output);
        this._oscillators[i2] = osc;
      }
      this.spread = this._spread;
      if (this.state === "started") {
        this._forEach((osc) => osc.start());
      }
    }
  }
  get phase() {
    return this._phase;
  }
  set phase(phase) {
    this._phase = phase;
    this._forEach((osc, i2) => osc.phase = this._phase + i2 / this.count * 360);
  }
  get baseType() {
    return this._oscillators[0].baseType;
  }
  set baseType(baseType) {
    this._forEach((osc) => osc.baseType = baseType);
    this._type = this._oscillators[0].type;
  }
  get partials() {
    return this._oscillators[0].partials;
  }
  set partials(partials) {
    this._partials = partials;
    this._partialCount = this._partials.length;
    if (partials.length) {
      this._type = "custom";
      this._forEach((osc) => osc.partials = partials);
    }
  }
  get partialCount() {
    return this._oscillators[0].partialCount;
  }
  set partialCount(partialCount) {
    this._partialCount = partialCount;
    this._forEach((osc) => osc.partialCount = partialCount);
    this._type = this._oscillators[0].type;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.detune.dispose();
    this._forEach((osc) => osc.dispose());
    return this;
  }
};
var PWMOscillator = class extends Source {
  constructor() {
    super(optionsFromArguments(PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]));
    this.name = "PWMOscillator";
    this.sourceType = "pwm";
    this._scale = new Multiply({
      context: this.context,
      value: 2
    });
    const options2 = optionsFromArguments(PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
    this._pulse = new PulseOscillator({
      context: this.context,
      frequency: options2.modulationFrequency
    });
    this._pulse.carrierType = "sine";
    this.modulationFrequency = this._pulse.frequency;
    this._modulator = new Oscillator({
      context: this.context,
      detune: options2.detune,
      frequency: options2.frequency,
      onstop: () => this.onstop(this),
      phase: options2.phase
    });
    this.frequency = this._modulator.frequency;
    this.detune = this._modulator.detune;
    this._modulator.chain(this._scale, this._pulse.width);
    this._pulse.connect(this.output);
    readOnly(this, ["modulationFrequency", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      modulationFrequency: 0.4,
      phase: 0,
      type: "pwm"
    });
  }
  _start(time) {
    time = this.toSeconds(time);
    this._modulator.start(time);
    this._pulse.start(time);
  }
  _stop(time) {
    time = this.toSeconds(time);
    this._modulator.stop(time);
    this._pulse.stop(time);
  }
  _restart(time) {
    this._modulator.restart(time);
    this._pulse.restart(time);
  }
  get type() {
    return "pwm";
  }
  get baseType() {
    return "pwm";
  }
  get partials() {
    return [];
  }
  get partialCount() {
    return 0;
  }
  get phase() {
    return this._modulator.phase;
  }
  set phase(phase) {
    this._modulator.phase = phase;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    this._pulse.dispose();
    this._scale.dispose();
    this._modulator.dispose();
    return this;
  }
};
var OmniOscillatorSourceMap = {
  am: AMOscillator,
  fat: FatOscillator,
  fm: FMOscillator,
  oscillator: Oscillator,
  pulse: PulseOscillator,
  pwm: PWMOscillator
};
var OmniOscillator = class extends Source {
  constructor() {
    super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "OmniOscillator";
    const options2 = optionsFromArguments(OmniOscillator.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options2.detune
    });
    readOnly(this, ["frequency", "detune"]);
    this.set(options2);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());
  }
  _start(time) {
    this._oscillator.start(time);
  }
  _stop(time) {
    this._oscillator.stop(time);
  }
  _restart(time) {
    this._oscillator.restart(time);
    return this;
  }
  get type() {
    let prefix = "";
    if (["am", "fm", "fat"].some((p2) => this._sourceType === p2)) {
      prefix = this._sourceType;
    }
    return prefix + this._oscillator.type;
  }
  set type(type) {
    if (type.substr(0, 2) === "fm") {
      this._createNewOscillator("fm");
      this._oscillator = this._oscillator;
      this._oscillator.type = type.substr(2);
    } else if (type.substr(0, 2) === "am") {
      this._createNewOscillator("am");
      this._oscillator = this._oscillator;
      this._oscillator.type = type.substr(2);
    } else if (type.substr(0, 3) === "fat") {
      this._createNewOscillator("fat");
      this._oscillator = this._oscillator;
      this._oscillator.type = type.substr(3);
    } else if (type === "pwm") {
      this._createNewOscillator("pwm");
      this._oscillator = this._oscillator;
    } else if (type === "pulse") {
      this._createNewOscillator("pulse");
    } else {
      this._createNewOscillator("oscillator");
      this._oscillator = this._oscillator;
      this._oscillator.type = type;
    }
  }
  get partials() {
    return this._oscillator.partials;
  }
  set partials(partials) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
      this._oscillator.partials = partials;
    }
  }
  get partialCount() {
    return this._oscillator.partialCount;
  }
  set partialCount(partialCount) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
      this._oscillator.partialCount = partialCount;
    }
  }
  set(props) {
    if (Reflect.has(props, "type") && props.type) {
      this.type = props.type;
    }
    super.set(props);
    return this;
  }
  _createNewOscillator(oscType) {
    if (oscType !== this._sourceType) {
      this._sourceType = oscType;
      const OscConstructor = OmniOscillatorSourceMap[oscType];
      const now2 = this.now();
      if (this._oscillator) {
        const oldOsc = this._oscillator;
        oldOsc.stop(now2);
        this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);
      }
      this._oscillator = new OscConstructor({
        context: this.context
      });
      this.frequency.connect(this._oscillator.frequency);
      this.detune.connect(this._oscillator.detune);
      this._oscillator.connect(this.output);
      this._oscillator.onstop = () => this.onstop(this);
      if (this.state === "started") {
        this._oscillator.start(now2);
      }
    }
  }
  get phase() {
    return this._oscillator.phase;
  }
  set phase(phase) {
    this._oscillator.phase = phase;
  }
  get sourceType() {
    return this._sourceType;
  }
  set sourceType(sType) {
    let baseType = "sine";
    if (this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse") {
      baseType = this._oscillator.type;
    }
    if (sType === "fm") {
      this.type = "fm" + baseType;
    } else if (sType === "am") {
      this.type = "am" + baseType;
    } else if (sType === "fat") {
      this.type = "fat" + baseType;
    } else if (sType === "oscillator") {
      this.type = baseType;
    } else if (sType === "pulse") {
      this.type = "pulse";
    } else if (sType === "pwm") {
      this.type = "pwm";
    }
  }
  _getOscType(osc, sourceType) {
    return osc instanceof OmniOscillatorSourceMap[sourceType];
  }
  get baseType() {
    return this._oscillator.baseType;
  }
  set baseType(baseType) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && baseType !== "pulse" && baseType !== "pwm") {
      this._oscillator.baseType = baseType;
    }
  }
  get width() {
    if (this._getOscType(this._oscillator, "pulse")) {
      return this._oscillator.width;
    } else {
      return void 0;
    }
  }
  get count() {
    if (this._getOscType(this._oscillator, "fat")) {
      return this._oscillator.count;
    } else {
      return void 0;
    }
  }
  set count(count) {
    if (this._getOscType(this._oscillator, "fat") && isNumber(count)) {
      this._oscillator.count = count;
    }
  }
  get spread() {
    if (this._getOscType(this._oscillator, "fat")) {
      return this._oscillator.spread;
    } else {
      return void 0;
    }
  }
  set spread(spread) {
    if (this._getOscType(this._oscillator, "fat") && isNumber(spread)) {
      this._oscillator.spread = spread;
    }
  }
  get modulationType() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
      return this._oscillator.modulationType;
    } else {
      return void 0;
    }
  }
  set modulationType(mType) {
    if ((this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && isString(mType)) {
      this._oscillator.modulationType = mType;
    }
  }
  get modulationIndex() {
    if (this._getOscType(this._oscillator, "fm")) {
      return this._oscillator.modulationIndex;
    } else {
      return void 0;
    }
  }
  get harmonicity() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
      return this._oscillator.harmonicity;
    } else {
      return void 0;
    }
  }
  get modulationFrequency() {
    if (this._getOscType(this._oscillator, "pwm")) {
      return this._oscillator.modulationFrequency;
    } else {
      return void 0;
    }
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    this.detune.dispose();
    this.frequency.dispose();
    this._oscillator.dispose();
    return this;
  }
};
var Add = class extends Signal {
  constructor() {
    super(Object.assign(optionsFromArguments(Add.getDefaults(), arguments, ["value"])));
    this.override = false;
    this.name = "Add";
    this._sum = new Gain({ context: this.context });
    this.input = this._sum;
    this.output = this._sum;
    this.addend = this._param;
    connectSeries(this._constantSource, this._sum);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._sum.dispose();
    return this;
  }
};
var Scale = class extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(Scale.getDefaults(), arguments, ["min", "max"])));
    this.name = "Scale";
    const options2 = optionsFromArguments(Scale.getDefaults(), arguments, ["min", "max"]);
    this._mult = this.input = new Multiply({
      context: this.context,
      value: options2.max - options2.min
    });
    this._add = this.output = new Add({
      context: this.context,
      value: options2.min
    });
    this._min = options2.min;
    this._max = options2.max;
    this.input.connect(this.output);
  }
  static getDefaults() {
    return Object.assign(SignalOperator.getDefaults(), {
      max: 1,
      min: 0
    });
  }
  get min() {
    return this._min;
  }
  set min(min) {
    this._min = min;
    this._setRange();
  }
  get max() {
    return this._max;
  }
  set max(max) {
    this._max = max;
    this._setRange();
  }
  _setRange() {
    this._add.value = this._min;
    this._mult.value = this._max - this._min;
  }
  dispose() {
    super.dispose();
    this._add.dispose();
    this._mult.dispose();
    return this;
  }
};
var Zero = class extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(Zero.getDefaults(), arguments)));
    this.name = "Zero";
    this._gain = new Gain({ context: this.context });
    this.output = this._gain;
    this.input = void 0;
    connect(this.context.getConstant(0), this._gain);
  }
  dispose() {
    super.dispose();
    disconnect(this.context.getConstant(0), this._gain);
    return this;
  }
};
var LFO = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(LFO.getDefaults(), arguments, ["frequency", "min", "max"]));
    this.name = "LFO";
    this._stoppedValue = 0;
    this._units = "number";
    this.convert = true;
    this._fromType = Param.prototype._fromType;
    this._toType = Param.prototype._toType;
    this._is = Param.prototype._is;
    this._clampValue = Param.prototype._clampValue;
    const options2 = optionsFromArguments(LFO.getDefaults(), arguments, ["frequency", "min", "max"]);
    this._oscillator = new Oscillator(options2);
    this.frequency = this._oscillator.frequency;
    this._amplitudeGain = new Gain({
      context: this.context,
      gain: options2.amplitude,
      units: "normalRange"
    });
    this.amplitude = this._amplitudeGain.gain;
    this._stoppedSignal = new Signal({
      context: this.context,
      units: "audioRange",
      value: 0
    });
    this._zeros = new Zero({ context: this.context });
    this._a2g = new AudioToGain({ context: this.context });
    this._scaler = this.output = new Scale({
      context: this.context,
      max: options2.max,
      min: options2.min
    });
    this.units = options2.units;
    this.min = options2.min;
    this.max = options2.max;
    this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);
    this._zeros.connect(this._a2g);
    this._stoppedSignal.connect(this._a2g);
    readOnly(this, ["amplitude", "frequency"]);
    this.phase = options2.phase;
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      amplitude: 1,
      frequency: "4n",
      max: 1,
      min: 0,
      type: "sine",
      units: "number"
    });
  }
  start(time) {
    time = this.toSeconds(time);
    this._stoppedSignal.setValueAtTime(0, time);
    this._oscillator.start(time);
    return this;
  }
  stop(time) {
    time = this.toSeconds(time);
    this._stoppedSignal.setValueAtTime(this._stoppedValue, time);
    this._oscillator.stop(time);
    return this;
  }
  sync() {
    this._oscillator.sync();
    this._oscillator.syncFrequency();
    return this;
  }
  unsync() {
    this._oscillator.unsync();
    this._oscillator.unsyncFrequency();
    return this;
  }
  _setStoppedValue() {
    this._stoppedValue = this._oscillator.getInitialValue();
    this._stoppedSignal.value = this._stoppedValue;
  }
  get min() {
    return this._toType(this._scaler.min);
  }
  set min(min) {
    min = this._fromType(min);
    this._scaler.min = min;
  }
  get max() {
    return this._toType(this._scaler.max);
  }
  set max(max) {
    max = this._fromType(max);
    this._scaler.max = max;
  }
  get type() {
    return this._oscillator.type;
  }
  set type(type) {
    this._oscillator.type = type;
    this._setStoppedValue();
  }
  get partials() {
    return this._oscillator.partials;
  }
  set partials(partials) {
    this._oscillator.partials = partials;
    this._setStoppedValue();
  }
  get phase() {
    return this._oscillator.phase;
  }
  set phase(phase) {
    this._oscillator.phase = phase;
    this._setStoppedValue();
  }
  get units() {
    return this._units;
  }
  set units(val) {
    const currentMin = this.min;
    const currentMax = this.max;
    this._units = val;
    this.min = currentMin;
    this.max = currentMax;
  }
  get state() {
    return this._oscillator.state;
  }
  connect(node, outputNum, inputNum) {
    if (node instanceof Param || node instanceof Signal) {
      this.convert = node.convert;
      this.units = node.units;
    }
    connectSignal(this, node, outputNum, inputNum);
    return this;
  }
  dispose() {
    super.dispose();
    this._oscillator.dispose();
    this._stoppedSignal.dispose();
    this._zeros.dispose();
    this._scaler.dispose();
    this._a2g.dispose();
    this._amplitudeGain.dispose();
    this.amplitude.dispose();
    return this;
  }
};
function range(min, max = Infinity) {
  const valueMap = /* @__PURE__ */ new WeakMap();
  return function(target, propertyKey) {
    Reflect.defineProperty(target, propertyKey, {
      configurable: true,
      enumerable: true,
      get: function() {
        return valueMap.get(this);
      },
      set: function(newValue) {
        assertRange(newValue, min, max);
        valueMap.set(this, newValue);
      }
    });
  };
}
function timeRange(min, max = Infinity) {
  const valueMap = /* @__PURE__ */ new WeakMap();
  return function(target, propertyKey) {
    Reflect.defineProperty(target, propertyKey, {
      configurable: true,
      enumerable: true,
      get: function() {
        return valueMap.get(this);
      },
      set: function(newValue) {
        assertRange(this.toSeconds(newValue), min, max);
        valueMap.set(this, newValue);
      }
    });
  };
}
var Player = class extends Source {
  constructor() {
    super(optionsFromArguments(Player.getDefaults(), arguments, [
      "url",
      "onload"
    ]));
    this.name = "Player";
    this._activeSources = /* @__PURE__ */ new Set();
    const options2 = optionsFromArguments(Player.getDefaults(), arguments, [
      "url",
      "onload"
    ]);
    this._buffer = new ToneAudioBuffer({
      onload: this._onload.bind(this, options2.onload),
      onerror: options2.onerror,
      reverse: options2.reverse,
      url: options2.url
    });
    this.autostart = options2.autostart;
    this._loop = options2.loop;
    this._loopStart = options2.loopStart;
    this._loopEnd = options2.loopEnd;
    this._playbackRate = options2.playbackRate;
    this.fadeIn = options2.fadeIn;
    this.fadeOut = options2.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      autostart: false,
      fadeIn: 0,
      fadeOut: 0,
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      onload: noOp,
      onerror: noOp,
      playbackRate: 1,
      reverse: false
    });
  }
  load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this._buffer.load(url);
      this._onload();
      return this;
    });
  }
  _onload(callback = noOp) {
    callback();
    if (this.autostart) {
      this.start();
    }
  }
  _onSourceEnd(source) {
    this.onstop(this);
    this._activeSources.delete(source);
    if (this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started") {
      this._state.cancel(this.now());
      this._state.setStateAtTime("stopped", this.now());
    }
  }
  start(time, offset, duration2) {
    super.start(time, offset, duration2);
    return this;
  }
  _start(startTime, offset, duration2) {
    if (this._loop) {
      offset = defaultArg(offset, this._loopStart);
    } else {
      offset = defaultArg(offset, 0);
    }
    const computedOffset = this.toSeconds(offset);
    const origDuration = duration2;
    duration2 = defaultArg(duration2, Math.max(this._buffer.duration - computedOffset, 0));
    let computedDuration = this.toSeconds(duration2);
    computedDuration = computedDuration / this._playbackRate;
    startTime = this.toSeconds(startTime);
    const source = new ToneBufferSource({
      url: this._buffer,
      context: this.context,
      fadeIn: this.fadeIn,
      fadeOut: this.fadeOut,
      loop: this._loop,
      loopEnd: this._loopEnd,
      loopStart: this._loopStart,
      onended: this._onSourceEnd.bind(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    if (!this._loop && !this._synced) {
      this._state.cancel(startTime + computedDuration);
      this._state.setStateAtTime("stopped", startTime + computedDuration, {
        implicitEnd: true
      });
    }
    this._activeSources.add(source);
    if (this._loop && isUndef(origDuration)) {
      source.start(startTime, computedOffset);
    } else {
      source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));
    }
  }
  _stop(time) {
    const computedTime = this.toSeconds(time);
    this._activeSources.forEach((source) => source.stop(computedTime));
  }
  restart(time, offset, duration2) {
    super.restart(time, offset, duration2);
    return this;
  }
  _restart(time, offset, duration2) {
    var _a2;
    (_a2 = [...this._activeSources].pop()) === null || _a2 === void 0 ? void 0 : _a2.stop(time);
    this._start(time, offset, duration2);
  }
  seek(offset, when) {
    const computedTime = this.toSeconds(when);
    if (this._state.getValueAtTime(computedTime) === "started") {
      const computedOffset = this.toSeconds(offset);
      this._stop(computedTime);
      this._start(computedTime, computedOffset);
    }
    return this;
  }
  setLoopPoints(loopStart, loopEnd) {
    this.loopStart = loopStart;
    this.loopEnd = loopEnd;
    return this;
  }
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(loopStart) {
    this._loopStart = loopStart;
    if (this.buffer.loaded) {
      assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);
    }
    this._activeSources.forEach((source) => {
      source.loopStart = loopStart;
    });
  }
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(loopEnd) {
    this._loopEnd = loopEnd;
    if (this.buffer.loaded) {
      assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);
    }
    this._activeSources.forEach((source) => {
      source.loopEnd = loopEnd;
    });
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(buffer) {
    this._buffer.set(buffer);
  }
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    if (this._loop === loop) {
      return;
    }
    this._loop = loop;
    this._activeSources.forEach((source) => {
      source.loop = loop;
    });
    if (loop) {
      const stopEvent = this._state.getNextState("stopped", this.now());
      if (stopEvent) {
        this._state.cancel(stopEvent.time);
      }
    }
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    const now2 = this.now();
    const stopEvent = this._state.getNextState("stopped", now2);
    if (stopEvent && stopEvent.implicitEnd) {
      this._state.cancel(stopEvent.time);
      this._activeSources.forEach((source) => source.cancelStop());
    }
    this._activeSources.forEach((source) => {
      source.playbackRate.setValueAtTime(rate, now2);
    });
  }
  get reverse() {
    return this._buffer.reverse;
  }
  set reverse(rev) {
    this._buffer.reverse = rev;
  }
  get loaded() {
    return this._buffer.loaded;
  }
  dispose() {
    super.dispose();
    this._activeSources.forEach((source) => source.dispose());
    this._activeSources.clear();
    this._buffer.dispose();
    return this;
  }
};
__decorate([
  timeRange(0)
], Player.prototype, "fadeIn", void 0);
__decorate([
  timeRange(0)
], Player.prototype, "fadeOut", void 0);
var Abs = class extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "Abs";
    this._abs = new WaveShaper({
      context: this.context,
      mapping: (val) => {
        if (Math.abs(val) < 1e-3) {
          return 0;
        } else {
          return Math.abs(val);
        }
      }
    });
    this.input = this._abs;
    this.output = this._abs;
  }
  dispose() {
    super.dispose();
    this._abs.dispose();
    return this;
  }
};
var GainToAudio = class extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "GainToAudio";
    this._norm = new WaveShaper({
      context: this.context,
      mapping: (x2) => Math.abs(x2) * 2 - 1
    });
    this.input = this._norm;
    this.output = this._norm;
  }
  dispose() {
    super.dispose();
    this._norm.dispose();
    return this;
  }
};
var Negate = class extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "Negate";
    this._multiply = new Multiply({
      context: this.context,
      value: -1
    });
    this.input = this._multiply;
    this.output = this._multiply;
  }
  dispose() {
    super.dispose();
    this._multiply.dispose();
    return this;
  }
};
var Subtract = class extends Signal {
  constructor() {
    super(Object.assign(optionsFromArguments(Subtract.getDefaults(), arguments, ["value"])));
    this.override = false;
    this.name = "Subtract";
    this._sum = new Gain({ context: this.context });
    this.input = this._sum;
    this.output = this._sum;
    this._neg = new Negate({ context: this.context });
    this.subtrahend = this._param;
    connectSeries(this._constantSource, this._neg, this._sum);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._neg.dispose();
    this._sum.dispose();
    return this;
  }
};
var GreaterThanZero = class extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(GreaterThanZero.getDefaults(), arguments)));
    this.name = "GreaterThanZero";
    this._thresh = this.output = new WaveShaper({
      context: this.context,
      length: 127,
      mapping: (val) => {
        if (val <= 0) {
          return 0;
        } else {
          return 1;
        }
      }
    });
    this._scale = this.input = new Multiply({
      context: this.context,
      value: 1e4
    });
    this._scale.connect(this._thresh);
  }
  dispose() {
    super.dispose();
    this._scale.dispose();
    this._thresh.dispose();
    return this;
  }
};
var GreaterThan = class extends Signal {
  constructor() {
    super(Object.assign(optionsFromArguments(GreaterThan.getDefaults(), arguments, ["value"])));
    this.name = "GreaterThan";
    this.override = false;
    const options2 = optionsFromArguments(GreaterThan.getDefaults(), arguments, ["value"]);
    this._subtract = this.input = new Subtract({
      context: this.context,
      value: options2.value
    });
    this._gtz = this.output = new GreaterThanZero({ context: this.context });
    this.comparator = this._param = this._subtract.subtrahend;
    readOnly(this, "comparator");
    this._subtract.connect(this._gtz);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._gtz.dispose();
    this._subtract.dispose();
    this.comparator.dispose();
    return this;
  }
};
var Pow = class extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(Pow.getDefaults(), arguments, ["value"])));
    this.name = "Pow";
    const options2 = optionsFromArguments(Pow.getDefaults(), arguments, ["value"]);
    this._exponentScaler = this.input = this.output = new WaveShaper({
      context: this.context,
      mapping: this._expFunc(options2.value),
      length: 8192
    });
    this._exponent = options2.value;
  }
  static getDefaults() {
    return Object.assign(SignalOperator.getDefaults(), {
      value: 1
    });
  }
  _expFunc(exponent) {
    return (val) => {
      return Math.pow(Math.abs(val), exponent);
    };
  }
  get value() {
    return this._exponent;
  }
  set value(exponent) {
    this._exponent = exponent;
    this._exponentScaler.setMap(this._expFunc(this._exponent));
  }
  dispose() {
    super.dispose();
    this._exponentScaler.dispose();
    return this;
  }
};
var Envelope = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
    this.name = "Envelope";
    this._sig = new Signal({
      context: this.context,
      value: 0
    });
    this.output = this._sig;
    this.input = void 0;
    const options2 = optionsFromArguments(Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    this.attack = options2.attack;
    this.decay = options2.decay;
    this.sustain = options2.sustain;
    this.release = options2.release;
    this.attackCurve = options2.attackCurve;
    this.releaseCurve = options2.releaseCurve;
    this.decayCurve = options2.decayCurve;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      attack: 0.01,
      attackCurve: "linear",
      decay: 0.1,
      decayCurve: "exponential",
      release: 1,
      releaseCurve: "exponential",
      sustain: 0.5
    });
  }
  get value() {
    return this.getValueAtTime(this.now());
  }
  _getCurve(curve, direction) {
    if (isString(curve)) {
      return curve;
    } else {
      let curveName;
      for (curveName in EnvelopeCurves) {
        if (EnvelopeCurves[curveName][direction] === curve) {
          return curveName;
        }
      }
      return curve;
    }
  }
  _setCurve(name2, direction, curve) {
    if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {
      const curveDef = EnvelopeCurves[curve];
      if (isObject(curveDef)) {
        if (name2 !== "_decayCurve") {
          this[name2] = curveDef[direction];
        }
      } else {
        this[name2] = curveDef;
      }
    } else if (isArray(curve) && name2 !== "_decayCurve") {
      this[name2] = curve;
    } else {
      throw new Error("Envelope: invalid curve: " + curve);
    }
  }
  get attackCurve() {
    return this._getCurve(this._attackCurve, "In");
  }
  set attackCurve(curve) {
    this._setCurve("_attackCurve", "In", curve);
  }
  get releaseCurve() {
    return this._getCurve(this._releaseCurve, "Out");
  }
  set releaseCurve(curve) {
    this._setCurve("_releaseCurve", "Out", curve);
  }
  get decayCurve() {
    return this._decayCurve;
  }
  set decayCurve(curve) {
    assert(["linear", "exponential"].some((c2) => c2 === curve), `Invalid envelope curve: ${curve}`);
    this._decayCurve = curve;
  }
  triggerAttack(time, velocity = 1) {
    this.log("triggerAttack", time, velocity);
    time = this.toSeconds(time);
    const originalAttack = this.toSeconds(this.attack);
    let attack = originalAttack;
    const decay = this.toSeconds(this.decay);
    const currentValue = this.getValueAtTime(time);
    if (currentValue > 0) {
      const attackRate = 1 / attack;
      const remainingDistance = 1 - currentValue;
      attack = remainingDistance / attackRate;
    }
    if (attack < this.sampleTime) {
      this._sig.cancelScheduledValues(time);
      this._sig.setValueAtTime(velocity, time);
    } else if (this._attackCurve === "linear") {
      this._sig.linearRampTo(velocity, attack, time);
    } else if (this._attackCurve === "exponential") {
      this._sig.targetRampTo(velocity, attack, time);
    } else {
      this._sig.cancelAndHoldAtTime(time);
      let curve = this._attackCurve;
      for (let i2 = 1; i2 < curve.length; i2++) {
        if (curve[i2 - 1] <= currentValue && currentValue <= curve[i2]) {
          curve = this._attackCurve.slice(i2);
          curve[0] = currentValue;
          break;
        }
      }
      this._sig.setValueCurveAtTime(curve, time, attack, velocity);
    }
    if (decay && this.sustain < 1) {
      const decayValue = velocity * this.sustain;
      const decayStart = time + attack;
      this.log("decay", decayStart);
      if (this._decayCurve === "linear") {
        this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);
      } else {
        this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);
      }
    }
    return this;
  }
  triggerRelease(time) {
    this.log("triggerRelease", time);
    time = this.toSeconds(time);
    const currentValue = this.getValueAtTime(time);
    if (currentValue > 0) {
      const release = this.toSeconds(this.release);
      if (release < this.sampleTime) {
        this._sig.setValueAtTime(0, time);
      } else if (this._releaseCurve === "linear") {
        this._sig.linearRampTo(0, release, time);
      } else if (this._releaseCurve === "exponential") {
        this._sig.targetRampTo(0, release, time);
      } else {
        assert(isArray(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array");
        this._sig.cancelAndHoldAtTime(time);
        this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);
      }
    }
    return this;
  }
  getValueAtTime(time) {
    return this._sig.getValueAtTime(time);
  }
  triggerAttackRelease(duration2, time, velocity = 1) {
    time = this.toSeconds(time);
    this.triggerAttack(time, velocity);
    this.triggerRelease(time + this.toSeconds(duration2));
    return this;
  }
  cancel(after) {
    this._sig.cancelScheduledValues(this.toSeconds(after));
    return this;
  }
  connect(destination, outputNumber = 0, inputNumber = 0) {
    connectSignal(this, destination, outputNumber, inputNumber);
    return this;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      const duration2 = length / this.context.sampleRate;
      const context2 = new OfflineContext(1, duration2, this.context.sampleRate);
      const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);
      const envelopeDuration = attackPortion + this.toSeconds(this.release);
      const sustainTime = envelopeDuration * 0.1;
      const totalDuration = envelopeDuration + sustainTime;
      const clone = new this.constructor(Object.assign(this.get(), {
        attack: duration2 * this.toSeconds(this.attack) / totalDuration,
        decay: duration2 * this.toSeconds(this.decay) / totalDuration,
        release: duration2 * this.toSeconds(this.release) / totalDuration,
        context: context2
      }));
      clone._sig.toDestination();
      clone.triggerAttackRelease(duration2 * (attackPortion + sustainTime) / totalDuration, 0);
      const buffer = yield context2.render();
      return buffer.getChannelData(0);
    });
  }
  dispose() {
    super.dispose();
    this._sig.dispose();
    return this;
  }
};
__decorate([
  timeRange(0)
], Envelope.prototype, "attack", void 0);
__decorate([
  timeRange(0)
], Envelope.prototype, "decay", void 0);
__decorate([
  range(0, 1)
], Envelope.prototype, "sustain", void 0);
__decorate([
  timeRange(0)
], Envelope.prototype, "release", void 0);
var EnvelopeCurves = (() => {
  const curveLen = 128;
  let i2;
  let k2;
  const cosineCurve = [];
  for (i2 = 0; i2 < curveLen; i2++) {
    cosineCurve[i2] = Math.sin(i2 / (curveLen - 1) * (Math.PI / 2));
  }
  const rippleCurve = [];
  const rippleCurveFreq = 6.4;
  for (i2 = 0; i2 < curveLen - 1; i2++) {
    k2 = i2 / (curveLen - 1);
    const sineWave = Math.sin(k2 * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
    rippleCurve[i2] = sineWave / 10 + k2 * 0.83;
  }
  rippleCurve[curveLen - 1] = 1;
  const stairsCurve = [];
  const steps = 5;
  for (i2 = 0; i2 < curveLen; i2++) {
    stairsCurve[i2] = Math.ceil(i2 / (curveLen - 1) * steps) / steps;
  }
  const sineCurve = [];
  for (i2 = 0; i2 < curveLen; i2++) {
    k2 = i2 / (curveLen - 1);
    sineCurve[i2] = 0.5 * (1 - Math.cos(Math.PI * k2));
  }
  const bounceCurve = [];
  for (i2 = 0; i2 < curveLen; i2++) {
    k2 = i2 / (curveLen - 1);
    const freq2 = Math.pow(k2, 3) * 4 + 0.2;
    const val = Math.cos(freq2 * Math.PI * 2 * k2);
    bounceCurve[i2] = Math.abs(val * (1 - k2));
  }
  function invertCurve(curve) {
    const out = new Array(curve.length);
    for (let j2 = 0; j2 < curve.length; j2++) {
      out[j2] = 1 - curve[j2];
    }
    return out;
  }
  function reverseCurve(curve) {
    return curve.slice(0).reverse();
  }
  return {
    bounce: {
      In: invertCurve(bounceCurve),
      Out: bounceCurve
    },
    cosine: {
      In: cosineCurve,
      Out: reverseCurve(cosineCurve)
    },
    exponential: "exponential",
    linear: "linear",
    ripple: {
      In: rippleCurve,
      Out: invertCurve(rippleCurve)
    },
    sine: {
      In: sineCurve,
      Out: invertCurve(sineCurve)
    },
    step: {
      In: stairsCurve,
      Out: invertCurve(stairsCurve)
    }
  };
})();
var Instrument = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Instrument.getDefaults(), arguments));
    this._scheduledEvents = [];
    this._synced = false;
    this._original_triggerAttack = this.triggerAttack;
    this._original_triggerRelease = this.triggerRelease;
    this._syncedRelease = (time) => this._original_triggerRelease(time);
    const options2 = optionsFromArguments(Instrument.getDefaults(), arguments);
    this._volume = this.output = new Volume({
      context: this.context,
      volume: options2.volume
    });
    this.volume = this._volume.volume;
    readOnly(this, "volume");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      volume: 0
    });
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);
      this._syncMethod("triggerRelease", 0);
      this.context.transport.on("stop", this._syncedRelease);
      this.context.transport.on("pause", this._syncedRelease);
      this.context.transport.on("loopEnd", this._syncedRelease);
    }
    return this;
  }
  _syncState() {
    let changed = false;
    if (!this._synced) {
      this._synced = true;
      changed = true;
    }
    return changed;
  }
  _syncMethod(method, timePosition) {
    const originalMethod = this["_original_" + method] = this[method];
    this[method] = (...args) => {
      const time = args[timePosition];
      const id = this.context.transport.schedule((t2) => {
        args[timePosition] = t2;
        originalMethod.apply(this, args);
      }, time);
      this._scheduledEvents.push(id);
    };
  }
  unsync() {
    this._scheduledEvents.forEach((id) => this.context.transport.clear(id));
    this._scheduledEvents = [];
    if (this._synced) {
      this._synced = false;
      this.triggerAttack = this._original_triggerAttack;
      this.triggerRelease = this._original_triggerRelease;
      this.context.transport.off("stop", this._syncedRelease);
      this.context.transport.off("pause", this._syncedRelease);
      this.context.transport.off("loopEnd", this._syncedRelease);
    }
    return this;
  }
  triggerAttackRelease(note2, duration2, time, velocity) {
    const computedTime = this.toSeconds(time);
    const computedDuration = this.toSeconds(duration2);
    this.triggerAttack(note2, computedTime, velocity);
    this.triggerRelease(computedTime + computedDuration);
    return this;
  }
  dispose() {
    super.dispose();
    this._volume.dispose();
    this.unsync();
    this._scheduledEvents = [];
    return this;
  }
};
var Monophonic = class extends Instrument {
  constructor() {
    super(optionsFromArguments(Monophonic.getDefaults(), arguments));
    const options2 = optionsFromArguments(Monophonic.getDefaults(), arguments);
    this.portamento = options2.portamento;
    this.onsilence = options2.onsilence;
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      detune: 0,
      onsilence: noOp,
      portamento: 0
    });
  }
  triggerAttack(note2, time, velocity = 1) {
    this.log("triggerAttack", note2, time, velocity);
    const seconds = this.toSeconds(time);
    this._triggerEnvelopeAttack(seconds, velocity);
    this.setNote(note2, seconds);
    return this;
  }
  triggerRelease(time) {
    this.log("triggerRelease", time);
    const seconds = this.toSeconds(time);
    this._triggerEnvelopeRelease(seconds);
    return this;
  }
  setNote(note2, time) {
    const computedTime = this.toSeconds(time);
    const computedFrequency = note2 instanceof FrequencyClass ? note2.toFrequency() : note2;
    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {
      const portTime = this.toSeconds(this.portamento);
      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);
    } else {
      this.frequency.setValueAtTime(computedFrequency, computedTime);
    }
    return this;
  }
};
__decorate([
  timeRange(0)
], Monophonic.prototype, "portamento", void 0);
var AmplitudeEnvelope = class extends Envelope {
  constructor() {
    super(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
    this.name = "AmplitudeEnvelope";
    this._gainNode = new Gain({
      context: this.context,
      gain: 0
    });
    this.output = this._gainNode;
    this.input = this._gainNode;
    this._sig.connect(this._gainNode.gain);
    this.output = this._gainNode;
    this.input = this._gainNode;
  }
  dispose() {
    super.dispose();
    this._gainNode.dispose();
    return this;
  }
};
var Synth = class extends Monophonic {
  constructor() {
    super(optionsFromArguments(Synth.getDefaults(), arguments));
    this.name = "Synth";
    const options2 = optionsFromArguments(Synth.getDefaults(), arguments);
    this.oscillator = new OmniOscillator(Object.assign({
      context: this.context,
      detune: options2.detune,
      onstop: () => this.onsilence(this)
    }, options2.oscillator));
    this.frequency = this.oscillator.frequency;
    this.detune = this.oscillator.detune;
    this.envelope = new AmplitudeEnvelope(Object.assign({
      context: this.context
    }, options2.envelope));
    this.oscillator.chain(this.envelope, this.output);
    readOnly(this, ["oscillator", "frequency", "detune", "envelope"]);
  }
  static getDefaults() {
    return Object.assign(Monophonic.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 5e-3,
        decay: 0.1,
        release: 1,
        sustain: 0.3
      }),
      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), "frequency", "detune"]), {
        type: "triangle"
      })
    });
  }
  _triggerEnvelopeAttack(time, velocity) {
    this.envelope.triggerAttack(time, velocity);
    this.oscillator.start(time);
    if (this.envelope.sustain === 0) {
      const computedAttack = this.toSeconds(this.envelope.attack);
      const computedDecay = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(time + computedAttack + computedDecay);
    }
  }
  _triggerEnvelopeRelease(time) {
    this.envelope.triggerRelease(time);
    this.oscillator.stop(time + this.toSeconds(this.envelope.release));
  }
  getLevelAtTime(time) {
    time = this.toSeconds(time);
    return this.envelope.getValueAtTime(time);
  }
  dispose() {
    super.dispose();
    this.oscillator.dispose();
    this.envelope.dispose();
    return this;
  }
};
var BiquadFilter = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(BiquadFilter.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "BiquadFilter";
    const options2 = optionsFromArguments(BiquadFilter.getDefaults(), arguments, ["frequency", "type"]);
    this._filter = this.context.createBiquadFilter();
    this.input = this.output = this._filter;
    this.Q = new Param({
      context: this.context,
      units: "number",
      value: options2.Q,
      param: this._filter.Q
    });
    this.frequency = new Param({
      context: this.context,
      units: "frequency",
      value: options2.frequency,
      param: this._filter.frequency
    });
    this.detune = new Param({
      context: this.context,
      units: "cents",
      value: options2.detune,
      param: this._filter.detune
    });
    this.gain = new Param({
      context: this.context,
      units: "decibels",
      convert: false,
      value: options2.gain,
      param: this._filter.gain
    });
    this.type = options2.type;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      Q: 1,
      type: "lowpass",
      frequency: 350,
      detune: 0,
      gain: 0
    });
  }
  get type() {
    return this._filter.type;
  }
  set type(type) {
    const types2 = [
      "lowpass",
      "highpass",
      "bandpass",
      "lowshelf",
      "highshelf",
      "notch",
      "allpass",
      "peaking"
    ];
    assert(types2.indexOf(type) !== -1, `Invalid filter type: ${type}`);
    this._filter.type = type;
  }
  getFrequencyResponse(len = 128) {
    const freqValues = new Float32Array(len);
    for (let i2 = 0; i2 < len; i2++) {
      const norm = Math.pow(i2 / len, 2);
      const freq2 = norm * (2e4 - 20) + 20;
      freqValues[i2] = freq2;
    }
    const magValues = new Float32Array(len);
    const phaseValues = new Float32Array(len);
    const filterClone = this.context.createBiquadFilter();
    filterClone.type = this.type;
    filterClone.Q.value = this.Q.value;
    filterClone.frequency.value = this.frequency.value;
    filterClone.gain.value = this.gain.value;
    filterClone.getFrequencyResponse(freqValues, magValues, phaseValues);
    return magValues;
  }
  dispose() {
    super.dispose();
    this._filter.disconnect();
    this.Q.dispose();
    this.frequency.dispose();
    this.gain.dispose();
    this.detune.dispose();
    return this;
  }
};
var Filter = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Filter.getDefaults(), arguments, ["frequency", "type", "rolloff"]));
    this.name = "Filter";
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    this._filters = [];
    const options2 = optionsFromArguments(Filter.getDefaults(), arguments, ["frequency", "type", "rolloff"]);
    this._filters = [];
    this.Q = new Signal({
      context: this.context,
      units: "positive",
      value: options2.Q
    });
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options2.detune
    });
    this.gain = new Signal({
      context: this.context,
      units: "decibels",
      convert: false,
      value: options2.gain
    });
    this._type = options2.type;
    this.rolloff = options2.rolloff;
    readOnly(this, ["detune", "frequency", "gain", "Q"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      Q: 1,
      detune: 0,
      frequency: 350,
      gain: 0,
      rolloff: -12,
      type: "lowpass"
    });
  }
  get type() {
    return this._type;
  }
  set type(type) {
    const types2 = [
      "lowpass",
      "highpass",
      "bandpass",
      "lowshelf",
      "highshelf",
      "notch",
      "allpass",
      "peaking"
    ];
    assert(types2.indexOf(type) !== -1, `Invalid filter type: ${type}`);
    this._type = type;
    this._filters.forEach((filter2) => filter2.type = type);
  }
  get rolloff() {
    return this._rolloff;
  }
  set rolloff(rolloff) {
    const rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10);
    const possibilities = [-12, -24, -48, -96];
    let cascadingCount = possibilities.indexOf(rolloffNum);
    assert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(", ")}`);
    cascadingCount += 1;
    this._rolloff = rolloffNum;
    this.input.disconnect();
    this._filters.forEach((filter2) => filter2.disconnect());
    this._filters = new Array(cascadingCount);
    for (let count = 0; count < cascadingCount; count++) {
      const filter2 = new BiquadFilter({
        context: this.context
      });
      filter2.type = this._type;
      this.frequency.connect(filter2.frequency);
      this.detune.connect(filter2.detune);
      this.Q.connect(filter2.Q);
      this.gain.connect(filter2.gain);
      this._filters[count] = filter2;
    }
    this._internalChannels = this._filters;
    connectSeries(this.input, ...this._internalChannels, this.output);
  }
  getFrequencyResponse(len = 128) {
    const filterClone = new BiquadFilter({
      frequency: this.frequency.value,
      gain: this.gain.value,
      Q: this.Q.value,
      type: this._type,
      detune: this.detune.value
    });
    const totalResponse = new Float32Array(len).map(() => 1);
    this._filters.forEach(() => {
      const response = filterClone.getFrequencyResponse(len);
      response.forEach((val, i2) => totalResponse[i2] *= val);
    });
    filterClone.dispose();
    return totalResponse;
  }
  dispose() {
    super.dispose();
    this._filters.forEach((filter2) => {
      filter2.dispose();
    });
    writable(this, ["detune", "frequency", "gain", "Q"]);
    this.frequency.dispose();
    this.Q.dispose();
    this.detune.dispose();
    this.gain.dispose();
    return this;
  }
};
var FrequencyEnvelope = class extends Envelope {
  constructor() {
    super(optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
    this.name = "FrequencyEnvelope";
    const options2 = optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    this._octaves = options2.octaves;
    this._baseFrequency = this.toFrequency(options2.baseFrequency);
    this._exponent = this.input = new Pow({
      context: this.context,
      value: options2.exponent
    });
    this._scale = this.output = new Scale({
      context: this.context,
      min: this._baseFrequency,
      max: this._baseFrequency * Math.pow(2, this._octaves)
    });
    this._sig.chain(this._exponent, this._scale);
  }
  static getDefaults() {
    return Object.assign(Envelope.getDefaults(), {
      baseFrequency: 200,
      exponent: 1,
      octaves: 4
    });
  }
  get baseFrequency() {
    return this._baseFrequency;
  }
  set baseFrequency(min) {
    const freq2 = this.toFrequency(min);
    assertRange(freq2, 0);
    this._baseFrequency = freq2;
    this._scale.min = this._baseFrequency;
    this.octaves = this._octaves;
  }
  get octaves() {
    return this._octaves;
  }
  set octaves(octaves) {
    this._octaves = octaves;
    this._scale.max = this._baseFrequency * Math.pow(2, octaves);
  }
  get exponent() {
    return this._exponent.value;
  }
  set exponent(exponent) {
    this._exponent.value = exponent;
  }
  dispose() {
    super.dispose();
    this._exponent.dispose();
    this._scale.dispose();
    return this;
  }
};
var MonoSynth = class extends Monophonic {
  constructor() {
    super(optionsFromArguments(MonoSynth.getDefaults(), arguments));
    this.name = "MonoSynth";
    const options2 = optionsFromArguments(MonoSynth.getDefaults(), arguments);
    this.oscillator = new OmniOscillator(Object.assign(options2.oscillator, {
      context: this.context,
      detune: options2.detune,
      onstop: () => this.onsilence(this)
    }));
    this.frequency = this.oscillator.frequency;
    this.detune = this.oscillator.detune;
    this.filter = new Filter(Object.assign(options2.filter, { context: this.context }));
    this.filterEnvelope = new FrequencyEnvelope(Object.assign(options2.filterEnvelope, { context: this.context }));
    this.envelope = new AmplitudeEnvelope(Object.assign(options2.envelope, { context: this.context }));
    this.oscillator.chain(this.filter, this.envelope, this.output);
    this.filterEnvelope.connect(this.filter.frequency);
    readOnly(this, ["oscillator", "frequency", "detune", "filter", "filterEnvelope", "envelope"]);
  }
  static getDefaults() {
    return Object.assign(Monophonic.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 5e-3,
        decay: 0.1,
        release: 1,
        sustain: 0.9
      }),
      filter: Object.assign(omitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        Q: 1,
        rolloff: -12,
        type: "lowpass"
      }),
      filterEnvelope: Object.assign(omitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 0.6,
        baseFrequency: 200,
        decay: 0.2,
        exponent: 2,
        octaves: 3,
        release: 2,
        sustain: 0.5
      }),
      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())), {
        type: "sawtooth"
      })
    });
  }
  _triggerEnvelopeAttack(time, velocity = 1) {
    this.envelope.triggerAttack(time, velocity);
    this.filterEnvelope.triggerAttack(time);
    this.oscillator.start(time);
    if (this.envelope.sustain === 0) {
      const computedAttack = this.toSeconds(this.envelope.attack);
      const computedDecay = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(time + computedAttack + computedDecay);
    }
  }
  _triggerEnvelopeRelease(time) {
    this.envelope.triggerRelease(time);
    this.filterEnvelope.triggerRelease(time);
    this.oscillator.stop(time + this.toSeconds(this.envelope.release));
  }
  getLevelAtTime(time) {
    time = this.toSeconds(time);
    return this.envelope.getValueAtTime(time);
  }
  dispose() {
    super.dispose();
    this.oscillator.dispose();
    this.envelope.dispose();
    this.filterEnvelope.dispose();
    this.filter.dispose();
    return this;
  }
};
var MembraneSynth = class extends Synth {
  constructor() {
    super(optionsFromArguments(MembraneSynth.getDefaults(), arguments));
    this.name = "MembraneSynth";
    this.portamento = 0;
    const options2 = optionsFromArguments(MembraneSynth.getDefaults(), arguments);
    this.pitchDecay = options2.pitchDecay;
    this.octaves = options2.octaves;
    readOnly(this, ["oscillator", "envelope"]);
  }
  static getDefaults() {
    return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {
      envelope: {
        attack: 1e-3,
        attackCurve: "exponential",
        decay: 0.4,
        release: 1.4,
        sustain: 0.01
      },
      octaves: 10,
      oscillator: {
        type: "sine"
      },
      pitchDecay: 0.05
    });
  }
  setNote(note2, time) {
    const seconds = this.toSeconds(time);
    const hertz = this.toFrequency(note2 instanceof FrequencyClass ? note2.toFrequency() : note2);
    const maxNote = hertz * this.octaves;
    this.oscillator.frequency.setValueAtTime(maxNote, seconds);
    this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));
    return this;
  }
  dispose() {
    super.dispose();
    return this;
  }
};
__decorate([
  range(0)
], MembraneSynth.prototype, "octaves", void 0);
__decorate([
  timeRange(0)
], MembraneSynth.prototype, "pitchDecay", void 0);
var NoiseSynth = class extends Instrument {
  constructor() {
    super(optionsFromArguments(NoiseSynth.getDefaults(), arguments));
    this.name = "NoiseSynth";
    const options2 = optionsFromArguments(NoiseSynth.getDefaults(), arguments);
    this.noise = new Noise(Object.assign({
      context: this.context
    }, options2.noise));
    this.envelope = new AmplitudeEnvelope(Object.assign({
      context: this.context
    }, options2.envelope));
    this.noise.chain(this.envelope, this.output);
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        decay: 0.1,
        sustain: 0
      }),
      noise: Object.assign(omitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())), {
        type: "white"
      })
    });
  }
  triggerAttack(time, velocity = 1) {
    time = this.toSeconds(time);
    this.envelope.triggerAttack(time, velocity);
    this.noise.start(time);
    if (this.envelope.sustain === 0) {
      this.noise.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));
    }
    return this;
  }
  triggerRelease(time) {
    time = this.toSeconds(time);
    this.envelope.triggerRelease(time);
    this.noise.stop(time + this.toSeconds(this.envelope.release));
    return this;
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 0);
      this._syncMethod("triggerRelease", 0);
    }
    return this;
  }
  triggerAttackRelease(duration2, time, velocity = 1) {
    time = this.toSeconds(time);
    duration2 = this.toSeconds(duration2);
    this.triggerAttack(time, velocity);
    this.triggerRelease(time + duration2);
    return this;
  }
  dispose() {
    super.dispose();
    this.noise.dispose();
    this.envelope.dispose();
    return this;
  }
};
var workletContext = /* @__PURE__ */ new Set();
function addToWorklet(classOrFunction) {
  workletContext.add(classOrFunction);
}
function registerProcessor(name2, classDesc) {
  const processor = `registerProcessor("${name2}", ${classDesc})`;
  workletContext.add(processor);
}
function getWorkletGlobalScope() {
  return Array.from(workletContext).join("\n");
}
var ToneAudioWorklet = class extends ToneAudioNode {
  constructor(options2) {
    super(options2);
    this.name = "ToneAudioWorklet";
    this.workletOptions = {};
    this.onprocessorerror = noOp;
    const blobUrl = URL.createObjectURL(new Blob([getWorkletGlobalScope()], { type: "text/javascript" }));
    const name2 = this._audioWorkletName();
    this._dummyGain = this.context.createGain();
    this._dummyParam = this._dummyGain.gain;
    this.context.addAudioWorkletModule(blobUrl).then(() => {
      if (!this.disposed) {
        this._worklet = this.context.createAudioWorkletNode(name2, this.workletOptions);
        this._worklet.onprocessorerror = this.onprocessorerror.bind(this);
        this.onReady(this._worklet);
      }
    });
  }
  dispose() {
    super.dispose();
    this._dummyGain.disconnect();
    if (this._worklet) {
      this._worklet.port.postMessage("dispose");
      this._worklet.disconnect();
    }
    return this;
  }
};
var toneAudioWorkletProcessor = `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;
addToWorklet(toneAudioWorkletProcessor);
var singleIOProcess = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
addToWorklet(singleIOProcess);
var delayLine = `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;
addToWorklet(delayLine);
var workletName$1 = "feedback-comb-filter";
var feedbackCombFilter = `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;
registerProcessor(workletName$1, feedbackCombFilter);
var OnePoleFilter = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(OnePoleFilter.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "OnePoleFilter";
    const options2 = optionsFromArguments(OnePoleFilter.getDefaults(), arguments, ["frequency", "type"]);
    this._frequency = options2.frequency;
    this._type = options2.type;
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    this._createFilter();
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      frequency: 880,
      type: "lowpass"
    });
  }
  _createFilter() {
    const oldFilter = this._filter;
    const freq2 = this.toFrequency(this._frequency);
    const t2 = 1 / (2 * Math.PI * freq2);
    if (this._type === "lowpass") {
      const a0 = 1 / (t2 * this.context.sampleRate);
      const b1 = a0 - 1;
      this._filter = this.context.createIIRFilter([a0, 0], [1, b1]);
    } else {
      const b1 = 1 / (t2 * this.context.sampleRate) - 1;
      this._filter = this.context.createIIRFilter([1, -1], [1, b1]);
    }
    this.input.chain(this._filter, this.output);
    if (oldFilter) {
      this.context.setTimeout(() => {
        if (!this.disposed) {
          this.input.disconnect(oldFilter);
          oldFilter.disconnect();
        }
      }, this.blockTime);
    }
  }
  get frequency() {
    return this._frequency;
  }
  set frequency(fq) {
    this._frequency = fq;
    this._createFilter();
  }
  get type() {
    return this._type;
  }
  set type(t2) {
    this._type = t2;
    this._createFilter();
  }
  getFrequencyResponse(len = 128) {
    const freqValues = new Float32Array(len);
    for (let i2 = 0; i2 < len; i2++) {
      const norm = Math.pow(i2 / len, 2);
      const freq2 = norm * (2e4 - 20) + 20;
      freqValues[i2] = freq2;
    }
    const magValues = new Float32Array(len);
    const phaseValues = new Float32Array(len);
    this._filter.getFrequencyResponse(freqValues, magValues, phaseValues);
    return magValues;
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();
    this._filter.disconnect();
    return this;
  }
};
var PolySynth = class extends Instrument {
  constructor() {
    super(optionsFromArguments(PolySynth.getDefaults(), arguments, ["voice", "options"]));
    this.name = "PolySynth";
    this._availableVoices = [];
    this._activeVoices = [];
    this._voices = [];
    this._gcTimeout = -1;
    this._averageActiveVoices = 0;
    this._syncedRelease = (time) => this.releaseAll(time);
    const options2 = optionsFromArguments(PolySynth.getDefaults(), arguments, ["voice", "options"]);
    assert(!isNumber(options2.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
    const defaults = options2.voice.getDefaults();
    this.options = Object.assign(defaults, options2.options);
    this.voice = options2.voice;
    this.maxPolyphony = options2.maxPolyphony;
    this._dummyVoice = this._getNextAvailableVoice();
    const index2 = this._voices.indexOf(this._dummyVoice);
    this._voices.splice(index2, 1);
    this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      maxPolyphony: 32,
      options: {},
      voice: Synth
    });
  }
  get activeVoices() {
    return this._activeVoices.length;
  }
  _makeVoiceAvailable(voice) {
    this._availableVoices.push(voice);
    const activeVoiceIndex = this._activeVoices.findIndex((e2) => e2.voice === voice);
    this._activeVoices.splice(activeVoiceIndex, 1);
  }
  _getNextAvailableVoice() {
    if (this._availableVoices.length) {
      return this._availableVoices.shift();
    } else if (this._voices.length < this.maxPolyphony) {
      const voice = new this.voice(Object.assign(this.options, {
        context: this.context,
        onsilence: this._makeVoiceAvailable.bind(this)
      }));
      assert(voice instanceof Monophonic, "Voice must extend Monophonic class");
      voice.connect(this.output);
      this._voices.push(voice);
      return voice;
    } else {
      warn("Max polyphony exceeded. Note dropped.");
    }
  }
  _collectGarbage() {
    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);
    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
      const firstAvail = this._availableVoices.shift();
      const index2 = this._voices.indexOf(firstAvail);
      this._voices.splice(index2, 1);
      if (!this.context.isOffline) {
        firstAvail.dispose();
      }
    }
  }
  _triggerAttack(notes2, time, velocity) {
    notes2.forEach((note2) => {
      const midiNote = new MidiClass(this.context, note2).toMidi();
      const voice = this._getNextAvailableVoice();
      if (voice) {
        voice.triggerAttack(note2, time, velocity);
        this._activeVoices.push({
          midi: midiNote,
          voice,
          released: false
        });
        this.log("triggerAttack", note2, time);
      }
    });
  }
  _triggerRelease(notes2, time) {
    notes2.forEach((note2) => {
      const midiNote = new MidiClass(this.context, note2).toMidi();
      const event = this._activeVoices.find(({ midi: midi2, released }) => midi2 === midiNote && !released);
      if (event) {
        event.voice.triggerRelease(time);
        event.released = true;
        this.log("triggerRelease", note2, time);
      }
    });
  }
  _scheduleEvent(type, notes2, time, velocity) {
    assert(!this.disposed, "Synth was already disposed");
    if (time <= this.now()) {
      if (type === "attack") {
        this._triggerAttack(notes2, time, velocity);
      } else {
        this._triggerRelease(notes2, time);
      }
    } else {
      this.context.setTimeout(() => {
        if (!this.disposed) {
          this._scheduleEvent(type, notes2, time, velocity);
        }
      }, time - this.now());
    }
  }
  triggerAttack(notes2, time, velocity) {
    if (!Array.isArray(notes2)) {
      notes2 = [notes2];
    }
    const computedTime = this.toSeconds(time);
    this._scheduleEvent("attack", notes2, computedTime, velocity);
    return this;
  }
  triggerRelease(notes2, time) {
    if (!Array.isArray(notes2)) {
      notes2 = [notes2];
    }
    const computedTime = this.toSeconds(time);
    this._scheduleEvent("release", notes2, computedTime);
    return this;
  }
  triggerAttackRelease(notes2, duration2, time, velocity) {
    const computedTime = this.toSeconds(time);
    this.triggerAttack(notes2, computedTime, velocity);
    if (isArray(duration2)) {
      assert(isArray(notes2), "If the duration is an array, the notes must also be an array");
      notes2 = notes2;
      for (let i2 = 0; i2 < notes2.length; i2++) {
        const d2 = duration2[Math.min(i2, duration2.length - 1)];
        const durationSeconds = this.toSeconds(d2);
        assert(durationSeconds > 0, "The duration must be greater than 0");
        this.triggerRelease(notes2[i2], computedTime + durationSeconds);
      }
    } else {
      const durationSeconds = this.toSeconds(duration2);
      assert(durationSeconds > 0, "The duration must be greater than 0");
      this.triggerRelease(notes2, computedTime + durationSeconds);
    }
    return this;
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);
      this._syncMethod("triggerRelease", 1);
      this.context.transport.on("stop", this._syncedRelease);
      this.context.transport.on("pause", this._syncedRelease);
      this.context.transport.on("loopEnd", this._syncedRelease);
    }
    return this;
  }
  set(options2) {
    const sanitizedOptions = omitFromObject(options2, ["onsilence", "context"]);
    this.options = deepMerge(this.options, sanitizedOptions);
    this._voices.forEach((voice) => voice.set(sanitizedOptions));
    this._dummyVoice.set(sanitizedOptions);
    return this;
  }
  get() {
    return this._dummyVoice.get();
  }
  releaseAll(time) {
    const computedTime = this.toSeconds(time);
    this._activeVoices.forEach(({ voice }) => {
      voice.triggerRelease(computedTime);
    });
    return this;
  }
  dispose() {
    super.dispose();
    this._dummyVoice.dispose();
    this._voices.forEach((v2) => v2.dispose());
    this._activeVoices = [];
    this._availableVoices = [];
    this.context.clearInterval(this._gcTimeout);
    return this;
  }
};
var Sampler = class extends Instrument {
  constructor() {
    super(optionsFromArguments(Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"));
    this.name = "Sampler";
    this._activeSources = /* @__PURE__ */ new Map();
    const options2 = optionsFromArguments(Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    const urlMap = {};
    Object.keys(options2.urls).forEach((note2) => {
      const noteNumber = parseInt(note2, 10);
      assert(isNote(note2) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note2}`);
      if (isNote(note2)) {
        const mid = new FrequencyClass(this.context, note2).toMidi();
        urlMap[mid] = options2.urls[note2];
      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {
        urlMap[noteNumber] = options2.urls[noteNumber];
      }
    });
    this._buffers = new ToneAudioBuffers({
      urls: urlMap,
      onload: options2.onload,
      baseUrl: options2.baseUrl,
      onerror: options2.onerror
    });
    this.attack = options2.attack;
    this.release = options2.release;
    this.curve = options2.curve;
    if (this._buffers.loaded) {
      Promise.resolve().then(options2.onload);
    }
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      attack: 0,
      baseUrl: "",
      curve: "exponential",
      onload: noOp,
      onerror: noOp,
      release: 0.1,
      urls: {}
    });
  }
  _findClosest(midi2) {
    const MAX_INTERVAL = 96;
    let interval2 = 0;
    while (interval2 < MAX_INTERVAL) {
      if (this._buffers.has(midi2 + interval2)) {
        return -interval2;
      } else if (this._buffers.has(midi2 - interval2)) {
        return interval2;
      }
      interval2++;
    }
    throw new Error(`No available buffers for note: ${midi2}`);
  }
  triggerAttack(notes2, time, velocity = 1) {
    this.log("triggerAttack", notes2, time, velocity);
    if (!Array.isArray(notes2)) {
      notes2 = [notes2];
    }
    notes2.forEach((note2) => {
      const midiFloat = ftomf(new FrequencyClass(this.context, note2).toFrequency());
      const midi2 = Math.round(midiFloat);
      const remainder = midiFloat - midi2;
      const difference = this._findClosest(midi2);
      const closestNote = midi2 - difference;
      const buffer = this._buffers.get(closestNote);
      const playbackRate = intervalToFrequencyRatio(difference + remainder);
      const source = new ToneBufferSource({
        url: buffer,
        context: this.context,
        curve: this.curve,
        fadeIn: this.attack,
        fadeOut: this.release,
        playbackRate
      }).connect(this.output);
      source.start(time, 0, buffer.duration / playbackRate, velocity);
      if (!isArray(this._activeSources.get(midi2))) {
        this._activeSources.set(midi2, []);
      }
      this._activeSources.get(midi2).push(source);
      source.onended = () => {
        if (this._activeSources && this._activeSources.has(midi2)) {
          const sources = this._activeSources.get(midi2);
          const index2 = sources.indexOf(source);
          if (index2 !== -1) {
            sources.splice(index2, 1);
          }
        }
      };
    });
    return this;
  }
  triggerRelease(notes2, time) {
    this.log("triggerRelease", notes2, time);
    if (!Array.isArray(notes2)) {
      notes2 = [notes2];
    }
    notes2.forEach((note2) => {
      const midi2 = new FrequencyClass(this.context, note2).toMidi();
      if (this._activeSources.has(midi2) && this._activeSources.get(midi2).length) {
        const sources = this._activeSources.get(midi2);
        time = this.toSeconds(time);
        sources.forEach((source) => {
          source.stop(time);
        });
        this._activeSources.set(midi2, []);
      }
    });
    return this;
  }
  releaseAll(time) {
    const computedTime = this.toSeconds(time);
    this._activeSources.forEach((sources) => {
      while (sources.length) {
        const source = sources.shift();
        source.stop(computedTime);
      }
    });
    return this;
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);
      this._syncMethod("triggerRelease", 1);
    }
    return this;
  }
  triggerAttackRelease(notes2, duration2, time, velocity = 1) {
    const computedTime = this.toSeconds(time);
    this.triggerAttack(notes2, computedTime, velocity);
    if (isArray(duration2)) {
      assert(isArray(notes2), "notes must be an array when duration is array");
      notes2.forEach((note2, index2) => {
        const d2 = duration2[Math.min(index2, duration2.length - 1)];
        this.triggerRelease(note2, computedTime + this.toSeconds(d2));
      });
    } else {
      this.triggerRelease(notes2, computedTime + this.toSeconds(duration2));
    }
    return this;
  }
  add(note2, url, callback) {
    assert(isNote(note2) || isFinite(note2), `note must be a pitch or midi: ${note2}`);
    if (isNote(note2)) {
      const mid = new FrequencyClass(this.context, note2).toMidi();
      this._buffers.add(mid, url, callback);
    } else {
      this._buffers.add(note2, url, callback);
    }
    return this;
  }
  get loaded() {
    return this._buffers.loaded;
  }
  dispose() {
    super.dispose();
    this._buffers.dispose();
    this._activeSources.forEach((sources) => {
      sources.forEach((source) => source.dispose());
    });
    this._activeSources.clear();
    return this;
  }
};
__decorate([
  timeRange(0)
], Sampler.prototype, "attack", void 0);
__decorate([
  timeRange(0)
], Sampler.prototype, "release", void 0);
var ToneEvent = class extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(ToneEvent.getDefaults(), arguments, ["callback", "value"]));
    this.name = "ToneEvent";
    this._state = new StateTimeline("stopped");
    this._startOffset = 0;
    const options2 = optionsFromArguments(ToneEvent.getDefaults(), arguments, ["callback", "value"]);
    this._loop = options2.loop;
    this.callback = options2.callback;
    this.value = options2.value;
    this._loopStart = this.toTicks(options2.loopStart);
    this._loopEnd = this.toTicks(options2.loopEnd);
    this._playbackRate = options2.playbackRate;
    this._probability = options2.probability;
    this._humanize = options2.humanize;
    this.mute = options2.mute;
    this._playbackRate = options2.playbackRate;
    this._state.increasing = true;
    this._rescheduleEvents();
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      callback: noOp,
      humanize: false,
      loop: false,
      loopEnd: "1m",
      loopStart: 0,
      mute: false,
      playbackRate: 1,
      probability: 1,
      value: null
    });
  }
  _rescheduleEvents(after = -1) {
    this._state.forEachFrom(after, (event) => {
      let duration2;
      if (event.state === "started") {
        if (event.id !== -1) {
          this.context.transport.clear(event.id);
        }
        const startTick = event.time + Math.round(this.startOffset / this._playbackRate);
        if (this._loop === true || isNumber(this._loop) && this._loop > 1) {
          duration2 = Infinity;
          if (isNumber(this._loop)) {
            duration2 = this._loop * this._getLoopDuration();
          }
          const nextEvent = this._state.getAfter(startTick);
          if (nextEvent !== null) {
            duration2 = Math.min(duration2, nextEvent.time - startTick);
          }
          if (duration2 !== Infinity) {
            duration2 = new TicksClass(this.context, duration2);
          }
          const interval2 = new TicksClass(this.context, this._getLoopDuration());
          event.id = this.context.transport.scheduleRepeat(this._tick.bind(this), interval2, new TicksClass(this.context, startTick), duration2);
        } else {
          event.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));
        }
      }
    });
  }
  get state() {
    return this._state.getValueAtTime(this.context.transport.ticks);
  }
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(offset) {
    this._startOffset = offset;
  }
  get probability() {
    return this._probability;
  }
  set probability(prob) {
    this._probability = prob;
  }
  get humanize() {
    return this._humanize;
  }
  set humanize(variation) {
    this._humanize = variation;
  }
  start(time) {
    const ticks = this.toTicks(time);
    if (this._state.getValueAtTime(ticks) === "stopped") {
      this._state.add({
        id: -1,
        state: "started",
        time: ticks
      });
      this._rescheduleEvents(ticks);
    }
    return this;
  }
  stop(time) {
    this.cancel(time);
    const ticks = this.toTicks(time);
    if (this._state.getValueAtTime(ticks) === "started") {
      this._state.setStateAtTime("stopped", ticks, { id: -1 });
      const previousEvent = this._state.getBefore(ticks);
      let rescheduleTime = ticks;
      if (previousEvent !== null) {
        rescheduleTime = previousEvent.time;
      }
      this._rescheduleEvents(rescheduleTime);
    }
    return this;
  }
  cancel(time) {
    time = defaultArg(time, -Infinity);
    const ticks = this.toTicks(time);
    this._state.forEachFrom(ticks, (event) => {
      this.context.transport.clear(event.id);
    });
    this._state.cancel(ticks);
    return this;
  }
  _tick(time) {
    const ticks = this.context.transport.getTicksAtTime(time);
    if (!this.mute && this._state.getValueAtTime(ticks) === "started") {
      if (this.probability < 1 && Math.random() > this.probability) {
        return;
      }
      if (this.humanize) {
        let variation = 0.02;
        if (!isBoolean(this.humanize)) {
          variation = this.toSeconds(this.humanize);
        }
        time += (Math.random() * 2 - 1) * variation;
      }
      this.callback(time, this.value);
    }
  }
  _getLoopDuration() {
    return (this._loopEnd - this._loopStart) / this._playbackRate;
  }
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    this._loop = loop;
    this._rescheduleEvents();
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    this._rescheduleEvents();
  }
  get loopEnd() {
    return new TicksClass(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(loopEnd) {
    this._loopEnd = this.toTicks(loopEnd);
    if (this._loop) {
      this._rescheduleEvents();
    }
  }
  get loopStart() {
    return new TicksClass(this.context, this._loopStart).toSeconds();
  }
  set loopStart(loopStart) {
    this._loopStart = this.toTicks(loopStart);
    if (this._loop) {
      this._rescheduleEvents();
    }
  }
  get progress() {
    if (this._loop) {
      const ticks = this.context.transport.ticks;
      const lastEvent = this._state.get(ticks);
      if (lastEvent !== null && lastEvent.state === "started") {
        const loopDuration = this._getLoopDuration();
        const progress = (ticks - lastEvent.time) % loopDuration;
        return progress / loopDuration;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  }
  dispose() {
    super.dispose();
    this.cancel();
    this._state.dispose();
    return this;
  }
};
var Loop = class extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(Loop.getDefaults(), arguments, ["callback", "interval"]));
    this.name = "Loop";
    const options2 = optionsFromArguments(Loop.getDefaults(), arguments, ["callback", "interval"]);
    this._event = new ToneEvent({
      context: this.context,
      callback: this._tick.bind(this),
      loop: true,
      loopEnd: options2.interval,
      playbackRate: options2.playbackRate,
      probability: options2.probability
    });
    this.callback = options2.callback;
    this.iterations = options2.iterations;
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      interval: "4n",
      callback: noOp,
      playbackRate: 1,
      iterations: Infinity,
      probability: 1,
      mute: false,
      humanize: false
    });
  }
  start(time) {
    this._event.start(time);
    return this;
  }
  stop(time) {
    this._event.stop(time);
    return this;
  }
  cancel(time) {
    this._event.cancel(time);
    return this;
  }
  _tick(time) {
    this.callback(time);
  }
  get state() {
    return this._event.state;
  }
  get progress() {
    return this._event.progress;
  }
  get interval() {
    return this._event.loopEnd;
  }
  set interval(interval2) {
    this._event.loopEnd = interval2;
  }
  get playbackRate() {
    return this._event.playbackRate;
  }
  set playbackRate(rate) {
    this._event.playbackRate = rate;
  }
  get humanize() {
    return this._event.humanize;
  }
  set humanize(variation) {
    this._event.humanize = variation;
  }
  get probability() {
    return this._event.probability;
  }
  set probability(prob) {
    this._event.probability = prob;
  }
  get mute() {
    return this._event.mute;
  }
  set mute(mute) {
    this._event.mute = mute;
  }
  get iterations() {
    if (this._event.loop === true) {
      return Infinity;
    } else {
      return this._event.loop;
    }
  }
  set iterations(iters) {
    if (iters === Infinity) {
      this._event.loop = true;
    } else {
      this._event.loop = iters;
    }
  }
  dispose() {
    super.dispose();
    this._event.dispose();
    return this;
  }
};
var Part = class extends ToneEvent {
  constructor() {
    super(optionsFromArguments(Part.getDefaults(), arguments, ["callback", "events"]));
    this.name = "Part";
    this._state = new StateTimeline("stopped");
    this._events = /* @__PURE__ */ new Set();
    const options2 = optionsFromArguments(Part.getDefaults(), arguments, ["callback", "events"]);
    this._state.increasing = true;
    options2.events.forEach((event) => {
      if (isArray(event)) {
        this.add(event[0], event[1]);
      } else {
        this.add(event);
      }
    });
  }
  static getDefaults() {
    return Object.assign(ToneEvent.getDefaults(), {
      events: []
    });
  }
  start(time, offset) {
    const ticks = this.toTicks(time);
    if (this._state.getValueAtTime(ticks) !== "started") {
      offset = defaultArg(offset, this._loop ? this._loopStart : 0);
      if (this._loop) {
        offset = defaultArg(offset, this._loopStart);
      } else {
        offset = defaultArg(offset, 0);
      }
      const computedOffset = this.toTicks(offset);
      this._state.add({
        id: -1,
        offset: computedOffset,
        state: "started",
        time: ticks
      });
      this._forEach((event) => {
        this._startNote(event, ticks, computedOffset);
      });
    }
    return this;
  }
  _startNote(event, ticks, offset) {
    ticks -= offset;
    if (this._loop) {
      if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {
        if (event.startOffset < offset) {
          ticks += this._getLoopDuration();
        }
        event.start(new TicksClass(this.context, ticks));
      } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {
        event.loop = false;
        event.start(new TicksClass(this.context, ticks));
      }
    } else if (event.startOffset >= offset) {
      event.start(new TicksClass(this.context, ticks));
    }
  }
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(offset) {
    this._startOffset = offset;
    this._forEach((event) => {
      event.startOffset += this._startOffset;
    });
  }
  stop(time) {
    const ticks = this.toTicks(time);
    this._state.cancel(ticks);
    this._state.setStateAtTime("stopped", ticks);
    this._forEach((event) => {
      event.stop(time);
    });
    return this;
  }
  at(time, value) {
    const timeInTicks = new TransportTimeClass(this.context, time).toTicks();
    const tickTime = new TicksClass(this.context, 1).toSeconds();
    const iterator = this._events.values();
    let result = iterator.next();
    while (!result.done) {
      const event = result.value;
      if (Math.abs(timeInTicks - event.startOffset) < tickTime) {
        if (isDefined(value)) {
          event.value = value;
        }
        return event;
      }
      result = iterator.next();
    }
    if (isDefined(value)) {
      this.add(time, value);
      return this.at(time);
    } else {
      return null;
    }
  }
  add(time, value) {
    if (time instanceof Object && Reflect.has(time, "time")) {
      value = time;
      time = value.time;
    }
    const ticks = this.toTicks(time);
    let event;
    if (value instanceof ToneEvent) {
      event = value;
      event.callback = this._tick.bind(this);
    } else {
      event = new ToneEvent({
        callback: this._tick.bind(this),
        context: this.context,
        value
      });
    }
    event.startOffset = ticks;
    event.set({
      humanize: this.humanize,
      loop: this.loop,
      loopEnd: this.loopEnd,
      loopStart: this.loopStart,
      playbackRate: this.playbackRate,
      probability: this.probability
    });
    this._events.add(event);
    this._restartEvent(event);
    return this;
  }
  _restartEvent(event) {
    this._state.forEach((stateEvent) => {
      if (stateEvent.state === "started") {
        this._startNote(event, stateEvent.time, stateEvent.offset);
      } else {
        event.stop(new TicksClass(this.context, stateEvent.time));
      }
    });
  }
  remove(time, value) {
    if (isObject(time) && time.hasOwnProperty("time")) {
      value = time;
      time = value.time;
    }
    time = this.toTicks(time);
    this._events.forEach((event) => {
      if (event.startOffset === time) {
        if (isUndef(value) || isDefined(value) && event.value === value) {
          this._events.delete(event);
          event.dispose();
        }
      }
    });
    return this;
  }
  clear() {
    this._forEach((event) => event.dispose());
    this._events.clear();
    return this;
  }
  cancel(after) {
    this._forEach((event) => event.cancel(after));
    this._state.cancel(this.toTicks(after));
    return this;
  }
  _forEach(callback) {
    if (this._events) {
      this._events.forEach((event) => {
        if (event instanceof Part) {
          event._forEach(callback);
        } else {
          callback(event);
        }
      });
    }
    return this;
  }
  _setAll(attr, value) {
    this._forEach((event) => {
      event[attr] = value;
    });
  }
  _tick(time, value) {
    if (!this.mute) {
      this.callback(time, value);
    }
  }
  _testLoopBoundries(event) {
    if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {
      event.cancel(0);
    } else if (event.state === "stopped") {
      this._restartEvent(event);
    }
  }
  get probability() {
    return this._probability;
  }
  set probability(prob) {
    this._probability = prob;
    this._setAll("probability", prob);
  }
  get humanize() {
    return this._humanize;
  }
  set humanize(variation) {
    this._humanize = variation;
    this._setAll("humanize", variation);
  }
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    this._loop = loop;
    this._forEach((event) => {
      event.loopStart = this.loopStart;
      event.loopEnd = this.loopEnd;
      event.loop = loop;
      this._testLoopBoundries(event);
    });
  }
  get loopEnd() {
    return new TicksClass(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(loopEnd) {
    this._loopEnd = this.toTicks(loopEnd);
    if (this._loop) {
      this._forEach((event) => {
        event.loopEnd = loopEnd;
        this._testLoopBoundries(event);
      });
    }
  }
  get loopStart() {
    return new TicksClass(this.context, this._loopStart).toSeconds();
  }
  set loopStart(loopStart) {
    this._loopStart = this.toTicks(loopStart);
    if (this._loop) {
      this._forEach((event) => {
        event.loopStart = this.loopStart;
        this._testLoopBoundries(event);
      });
    }
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    this._setAll("playbackRate", rate);
  }
  get length() {
    return this._events.size;
  }
  dispose() {
    super.dispose();
    this.clear();
    return this;
  }
};
var Sequence = class extends ToneEvent {
  constructor() {
    super(optionsFromArguments(Sequence.getDefaults(), arguments, ["callback", "events", "subdivision"]));
    this.name = "Sequence";
    this._part = new Part({
      callback: this._seqCallback.bind(this),
      context: this.context
    });
    this._events = [];
    this._eventsArray = [];
    const options2 = optionsFromArguments(Sequence.getDefaults(), arguments, ["callback", "events", "subdivision"]);
    this._subdivision = this.toTicks(options2.subdivision);
    this.events = options2.events;
    this.loop = options2.loop;
    this.loopStart = options2.loopStart;
    this.loopEnd = options2.loopEnd;
    this.playbackRate = options2.playbackRate;
    this.probability = options2.probability;
    this.humanize = options2.humanize;
    this.mute = options2.mute;
    this.playbackRate = options2.playbackRate;
  }
  static getDefaults() {
    return Object.assign(omitFromObject(ToneEvent.getDefaults(), ["value"]), {
      events: [],
      loop: true,
      loopEnd: 0,
      loopStart: 0,
      subdivision: "8n"
    });
  }
  _seqCallback(time, value) {
    if (value !== null && !this.mute) {
      this.callback(time, value);
    }
  }
  get events() {
    return this._events;
  }
  set events(s2) {
    this.clear();
    this._eventsArray = s2;
    this._events = this._createSequence(this._eventsArray);
    this._eventsUpdated();
  }
  start(time, offset) {
    this._part.start(time, offset ? this._indexTime(offset) : offset);
    return this;
  }
  stop(time) {
    this._part.stop(time);
    return this;
  }
  get subdivision() {
    return new TicksClass(this.context, this._subdivision).toSeconds();
  }
  _createSequence(array) {
    return new Proxy(array, {
      get: (target, property) => {
        return target[property];
      },
      set: (target, property, value) => {
        if (isString(property) && isFinite(parseInt(property, 10))) {
          if (isArray(value)) {
            target[property] = this._createSequence(value);
          } else {
            target[property] = value;
          }
        } else {
          target[property] = value;
        }
        this._eventsUpdated();
        return true;
      }
    });
  }
  _eventsUpdated() {
    this._part.clear();
    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);
    this.loopEnd = this.loopEnd;
  }
  _rescheduleSequence(sequence, subdivision, startOffset) {
    sequence.forEach((value, index2) => {
      const eventOffset = index2 * subdivision + startOffset;
      if (isArray(value)) {
        this._rescheduleSequence(value, subdivision / value.length, eventOffset);
      } else {
        const startTime = new TicksClass(this.context, eventOffset, "i").toSeconds();
        this._part.add(startTime, value);
      }
    });
  }
  _indexTime(index2) {
    return new TicksClass(this.context, index2 * this._subdivision + this.startOffset).toSeconds();
  }
  clear() {
    this._part.clear();
    return this;
  }
  dispose() {
    super.dispose();
    this._part.dispose();
    return this;
  }
  get loop() {
    return this._part.loop;
  }
  set loop(l2) {
    this._part.loop = l2;
  }
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(index2) {
    this._loopStart = index2;
    this._part.loopStart = this._indexTime(index2);
  }
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(index2) {
    this._loopEnd = index2;
    if (index2 === 0) {
      this._part.loopEnd = this._indexTime(this._eventsArray.length);
    } else {
      this._part.loopEnd = this._indexTime(index2);
    }
  }
  get startOffset() {
    return this._part.startOffset;
  }
  set startOffset(start22) {
    this._part.startOffset = start22;
  }
  get playbackRate() {
    return this._part.playbackRate;
  }
  set playbackRate(rate) {
    this._part.playbackRate = rate;
  }
  get probability() {
    return this._part.probability;
  }
  set probability(prob) {
    this._part.probability = prob;
  }
  get progress() {
    return this._part.progress;
  }
  get humanize() {
    return this._part.humanize;
  }
  set humanize(variation) {
    this._part.humanize = variation;
  }
  get length() {
    return this._part.length;
  }
};
var CrossFade = class extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, ["fade"])));
    this.name = "CrossFade";
    this._panner = this.context.createStereoPanner();
    this._split = this.context.createChannelSplitter(2);
    this._g2a = new GainToAudio({ context: this.context });
    this.a = new Gain({
      context: this.context,
      gain: 0
    });
    this.b = new Gain({
      context: this.context,
      gain: 0
    });
    this.output = new Gain({ context: this.context });
    this._internalChannels = [this.a, this.b];
    const options2 = optionsFromArguments(CrossFade.getDefaults(), arguments, ["fade"]);
    this.fade = new Signal({
      context: this.context,
      units: "normalRange",
      value: options2.fade
    });
    readOnly(this, "fade");
    this.context.getConstant(1).connect(this._panner);
    this._panner.connect(this._split);
    this._panner.channelCount = 1;
    this._panner.channelCountMode = "explicit";
    connect(this._split, this.a.gain, 0);
    connect(this._split, this.b.gain, 1);
    this.fade.chain(this._g2a, this._panner.pan);
    this.a.connect(this.output);
    this.b.connect(this.output);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      fade: 0.5
    });
  }
  dispose() {
    super.dispose();
    this.a.dispose();
    this.b.dispose();
    this.output.dispose();
    this.fade.dispose();
    this._g2a.dispose();
    this._panner.disconnect();
    this._split.disconnect();
    return this;
  }
};
var Effect = class extends ToneAudioNode {
  constructor(options2) {
    super(options2);
    this.name = "Effect";
    this._dryWet = new CrossFade({ context: this.context });
    this.wet = this._dryWet.fade;
    this.effectSend = new Gain({ context: this.context });
    this.effectReturn = new Gain({ context: this.context });
    this.input = new Gain({ context: this.context });
    this.output = this._dryWet;
    this.input.fan(this._dryWet.a, this.effectSend);
    this.effectReturn.connect(this._dryWet.b);
    this.wet.setValueAtTime(options2.wet, 0);
    this._internalChannels = [this.effectReturn, this.effectSend];
    readOnly(this, "wet");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      wet: 1
    });
  }
  connectEffect(effect) {
    this._internalChannels.push(effect);
    this.effectSend.chain(effect, this.effectReturn);
    return this;
  }
  dispose() {
    super.dispose();
    this._dryWet.dispose();
    this.effectSend.dispose();
    this.effectReturn.dispose();
    this.wet.dispose();
    return this;
  }
};
var LFOEffect = class extends Effect {
  constructor(options2) {
    super(options2);
    this.name = "LFOEffect";
    this._lfo = new LFO({
      context: this.context,
      frequency: options2.frequency,
      amplitude: options2.depth
    });
    this.depth = this._lfo.amplitude;
    this.frequency = this._lfo.frequency;
    this.type = options2.type;
    readOnly(this, ["frequency", "depth"]);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      frequency: 1,
      type: "sine",
      depth: 1
    });
  }
  start(time) {
    this._lfo.start(time);
    return this;
  }
  stop(time) {
    this._lfo.stop(time);
    return this;
  }
  sync() {
    this._lfo.sync();
    return this;
  }
  unsync() {
    this._lfo.unsync();
    return this;
  }
  get type() {
    return this._lfo.type;
  }
  set type(type) {
    this._lfo.type = type;
  }
  dispose() {
    super.dispose();
    this._lfo.dispose();
    this.frequency.dispose();
    this.depth.dispose();
    return this;
  }
};
var AutoFilter = class extends LFOEffect {
  constructor() {
    super(optionsFromArguments(AutoFilter.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]));
    this.name = "AutoFilter";
    const options2 = optionsFromArguments(AutoFilter.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]);
    this.filter = new Filter(Object.assign(options2.filter, {
      context: this.context
    }));
    this.connectEffect(this.filter);
    this._lfo.connect(this.filter.frequency);
    this.octaves = options2.octaves;
    this.baseFrequency = options2.baseFrequency;
  }
  static getDefaults() {
    return Object.assign(LFOEffect.getDefaults(), {
      baseFrequency: 200,
      octaves: 2.6,
      filter: {
        type: "lowpass",
        rolloff: -12,
        Q: 1
      }
    });
  }
  get baseFrequency() {
    return this._lfo.min;
  }
  set baseFrequency(freq2) {
    this._lfo.min = this.toFrequency(freq2);
    this.octaves = this._octaves;
  }
  get octaves() {
    return this._octaves;
  }
  set octaves(oct) {
    this._octaves = oct;
    this._lfo.max = this._lfo.min * Math.pow(2, oct);
  }
  dispose() {
    super.dispose();
    this.filter.dispose();
    return this;
  }
};
var Panner = class extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, ["pan"])));
    this.name = "Panner";
    this._panner = this.context.createStereoPanner();
    this.input = this._panner;
    this.output = this._panner;
    const options2 = optionsFromArguments(Panner.getDefaults(), arguments, ["pan"]);
    this.pan = new Param({
      context: this.context,
      param: this._panner.pan,
      value: options2.pan,
      minValue: -1,
      maxValue: 1
    });
    this._panner.channelCount = options2.channelCount;
    this._panner.channelCountMode = "explicit";
    readOnly(this, "pan");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      pan: 0,
      channelCount: 1
    });
  }
  dispose() {
    super.dispose();
    this._panner.disconnect();
    this.pan.dispose();
    return this;
  }
};
var AutoPanner = class extends LFOEffect {
  constructor() {
    super(optionsFromArguments(AutoPanner.getDefaults(), arguments, ["frequency"]));
    this.name = "AutoPanner";
    const options2 = optionsFromArguments(AutoPanner.getDefaults(), arguments, ["frequency"]);
    this._panner = new Panner({
      context: this.context,
      channelCount: options2.channelCount
    });
    this.connectEffect(this._panner);
    this._lfo.connect(this._panner.pan);
    this._lfo.min = -1;
    this._lfo.max = 1;
  }
  static getDefaults() {
    return Object.assign(LFOEffect.getDefaults(), {
      channelCount: 1
    });
  }
  dispose() {
    super.dispose();
    this._panner.dispose();
    return this;
  }
};
var Follower = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Follower.getDefaults(), arguments, ["smoothing"]));
    this.name = "Follower";
    const options2 = optionsFromArguments(Follower.getDefaults(), arguments, ["smoothing"]);
    this._abs = this.input = new Abs({ context: this.context });
    this._lowpass = this.output = new OnePoleFilter({
      context: this.context,
      frequency: 1 / this.toSeconds(options2.smoothing),
      type: "lowpass"
    });
    this._abs.connect(this._lowpass);
    this._smoothing = options2.smoothing;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      smoothing: 0.05
    });
  }
  get smoothing() {
    return this._smoothing;
  }
  set smoothing(smoothing) {
    this._smoothing = smoothing;
    this._lowpass.frequency = 1 / this.toSeconds(this.smoothing);
  }
  dispose() {
    super.dispose();
    this._abs.dispose();
    this._lowpass.dispose();
    return this;
  }
};
var workletName = "bit-crusher";
var bitCrusherWorklet = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
registerProcessor(workletName, bitCrusherWorklet);
var BitCrusher = class extends Effect {
  constructor() {
    super(optionsFromArguments(BitCrusher.getDefaults(), arguments, ["bits"]));
    this.name = "BitCrusher";
    const options2 = optionsFromArguments(BitCrusher.getDefaults(), arguments, ["bits"]);
    this._bitCrusherWorklet = new BitCrusherWorklet({
      context: this.context,
      bits: options2.bits
    });
    this.connectEffect(this._bitCrusherWorklet);
    this.bits = this._bitCrusherWorklet.bits;
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      bits: 4
    });
  }
  dispose() {
    super.dispose();
    this._bitCrusherWorklet.dispose();
    return this;
  }
};
var BitCrusherWorklet = class extends ToneAudioWorklet {
  constructor() {
    super(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));
    this.name = "BitCrusherWorklet";
    const options2 = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    this.bits = new Param({
      context: this.context,
      value: options2.bits,
      units: "positive",
      minValue: 1,
      maxValue: 16,
      param: this._dummyParam,
      swappable: true
    });
  }
  static getDefaults() {
    return Object.assign(ToneAudioWorklet.getDefaults(), {
      bits: 12
    });
  }
  _audioWorkletName() {
    return workletName;
  }
  onReady(node) {
    connectSeries(this.input, node, this.output);
    const bits = node.parameters.get("bits");
    this.bits.setParam(bits);
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();
    this.bits.dispose();
    return this;
  }
};
var Split = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Split.getDefaults(), arguments, ["channels"]));
    this.name = "Split";
    const options2 = optionsFromArguments(Split.getDefaults(), arguments, ["channels"]);
    this._splitter = this.input = this.output = this.context.createChannelSplitter(options2.channels);
    this._internalChannels = [this._splitter];
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      channels: 2
    });
  }
  dispose() {
    super.dispose();
    this._splitter.disconnect();
    return this;
  }
};
var Merge = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Merge.getDefaults(), arguments, ["channels"]));
    this.name = "Merge";
    const options2 = optionsFromArguments(Merge.getDefaults(), arguments, ["channels"]);
    this._merger = this.output = this.input = this.context.createChannelMerger(options2.channels);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      channels: 2
    });
  }
  dispose() {
    super.dispose();
    this._merger.disconnect();
    return this;
  }
};
var StereoEffect = class extends ToneAudioNode {
  constructor(options2) {
    super(options2);
    this.name = "StereoEffect";
    this.input = new Gain({ context: this.context });
    this.input.channelCount = 2;
    this.input.channelCountMode = "explicit";
    this._dryWet = this.output = new CrossFade({
      context: this.context,
      fade: options2.wet
    });
    this.wet = this._dryWet.fade;
    this._split = new Split({ context: this.context, channels: 2 });
    this._merge = new Merge({ context: this.context, channels: 2 });
    this.input.connect(this._split);
    this.input.connect(this._dryWet.a);
    this._merge.connect(this._dryWet.b);
    readOnly(this, ["wet"]);
  }
  connectEffectLeft(...nodes) {
    this._split.connect(nodes[0], 0, 0);
    connectSeries(...nodes);
    connect(nodes[nodes.length - 1], this._merge, 0, 0);
  }
  connectEffectRight(...nodes) {
    this._split.connect(nodes[0], 1, 0);
    connectSeries(...nodes);
    connect(nodes[nodes.length - 1], this._merge, 0, 1);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      wet: 1
    });
  }
  dispose() {
    super.dispose();
    this._dryWet.dispose();
    this._split.dispose();
    this._merge.dispose();
    return this;
  }
};
var StereoFeedbackEffect = class extends StereoEffect {
  constructor(options2) {
    super(options2);
    this.feedback = new Signal({
      context: this.context,
      value: options2.feedback,
      units: "normalRange"
    });
    this._feedbackL = new Gain({ context: this.context });
    this._feedbackR = new Gain({ context: this.context });
    this._feedbackSplit = new Split({ context: this.context, channels: 2 });
    this._feedbackMerge = new Merge({ context: this.context, channels: 2 });
    this._merge.connect(this._feedbackSplit);
    this._feedbackMerge.connect(this._split);
    this._feedbackSplit.connect(this._feedbackL, 0, 0);
    this._feedbackL.connect(this._feedbackMerge, 0, 0);
    this._feedbackSplit.connect(this._feedbackR, 1, 0);
    this._feedbackR.connect(this._feedbackMerge, 0, 1);
    this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
    readOnly(this, ["feedback"]);
  }
  static getDefaults() {
    return Object.assign(StereoEffect.getDefaults(), {
      feedback: 0.5
    });
  }
  dispose() {
    super.dispose();
    this.feedback.dispose();
    this._feedbackL.dispose();
    this._feedbackR.dispose();
    this._feedbackSplit.dispose();
    this._feedbackMerge.dispose();
    return this;
  }
};
var StereoXFeedbackEffect = class extends StereoFeedbackEffect {
  constructor(options2) {
    super(options2);
    this._feedbackL.disconnect();
    this._feedbackL.connect(this._feedbackMerge, 0, 1);
    this._feedbackR.disconnect();
    this._feedbackR.connect(this._feedbackMerge, 0, 0);
    readOnly(this, ["feedback"]);
  }
};
var PingPongDelay = class extends StereoXFeedbackEffect {
  constructor() {
    super(optionsFromArguments(PingPongDelay.getDefaults(), arguments, ["delayTime", "feedback"]));
    this.name = "PingPongDelay";
    const options2 = optionsFromArguments(PingPongDelay.getDefaults(), arguments, ["delayTime", "feedback"]);
    this._leftDelay = new Delay({
      context: this.context,
      maxDelay: options2.maxDelay
    });
    this._rightDelay = new Delay({
      context: this.context,
      maxDelay: options2.maxDelay
    });
    this._rightPreDelay = new Delay({
      context: this.context,
      maxDelay: options2.maxDelay
    });
    this.delayTime = new Signal({
      context: this.context,
      units: "time",
      value: options2.delayTime
    });
    this.connectEffectLeft(this._leftDelay);
    this.connectEffectRight(this._rightPreDelay, this._rightDelay);
    this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);
    this._feedbackL.disconnect();
    this._feedbackL.connect(this._rightDelay);
    readOnly(this, ["delayTime"]);
  }
  static getDefaults() {
    return Object.assign(StereoXFeedbackEffect.getDefaults(), {
      delayTime: 0.25,
      maxDelay: 1
    });
  }
  dispose() {
    super.dispose();
    this._leftDelay.dispose();
    this._rightDelay.dispose();
    this._rightPreDelay.dispose();
    this.delayTime.dispose();
    return this;
  }
};
var Reverb = class extends Effect {
  constructor() {
    super(optionsFromArguments(Reverb.getDefaults(), arguments, ["decay"]));
    this.name = "Reverb";
    this._convolver = this.context.createConvolver();
    this.ready = Promise.resolve();
    const options2 = optionsFromArguments(Reverb.getDefaults(), arguments, ["decay"]);
    this._decay = options2.decay;
    this._preDelay = options2.preDelay;
    this.generate();
    this.connectEffect(this._convolver);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      decay: 1.5,
      preDelay: 0.01
    });
  }
  get decay() {
    return this._decay;
  }
  set decay(time) {
    time = this.toSeconds(time);
    assertRange(time, 1e-3);
    this._decay = time;
    this.generate();
  }
  get preDelay() {
    return this._preDelay;
  }
  set preDelay(time) {
    time = this.toSeconds(time);
    assertRange(time, 0);
    this._preDelay = time;
    this.generate();
  }
  generate() {
    return __awaiter(this, void 0, void 0, function* () {
      const previousReady = this.ready;
      const context2 = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);
      const noiseL = new Noise({ context: context2 });
      const noiseR = new Noise({ context: context2 });
      const merge = new Merge({ context: context2 });
      noiseL.connect(merge, 0, 0);
      noiseR.connect(merge, 0, 1);
      const gainNode = new Gain({ context: context2 }).toDestination();
      merge.connect(gainNode);
      noiseL.start(0);
      noiseR.start(0);
      gainNode.gain.setValueAtTime(0, 0);
      gainNode.gain.setValueAtTime(1, this._preDelay);
      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);
      const renderPromise = context2.render();
      this.ready = renderPromise.then(noOp);
      yield previousReady;
      this._convolver.buffer = (yield renderPromise).get();
      return this;
    });
  }
  dispose() {
    super.dispose();
    this._convolver.disconnect();
    return this;
  }
};
var MidSideSplit = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(MidSideSplit.getDefaults(), arguments));
    this.name = "MidSideSplit";
    this._split = this.input = new Split({
      channels: 2,
      context: this.context
    });
    this._midAdd = new Add({ context: this.context });
    this.mid = new Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._sideSubtract = new Subtract({ context: this.context });
    this.side = new Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._split.connect(this._midAdd, 0);
    this._split.connect(this._midAdd.addend, 1);
    this._split.connect(this._sideSubtract, 0);
    this._split.connect(this._sideSubtract.subtrahend, 1);
    this._midAdd.connect(this.mid);
    this._sideSubtract.connect(this.side);
  }
  dispose() {
    super.dispose();
    this.mid.dispose();
    this.side.dispose();
    this._midAdd.dispose();
    this._sideSubtract.dispose();
    this._split.dispose();
    return this;
  }
};
var MidSideMerge = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(MidSideMerge.getDefaults(), arguments));
    this.name = "MidSideMerge";
    this.mid = new Gain({ context: this.context });
    this.side = new Gain({ context: this.context });
    this._left = new Add({ context: this.context });
    this._leftMult = new Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._right = new Subtract({ context: this.context });
    this._rightMult = new Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._merge = this.output = new Merge({ context: this.context });
    this.mid.fan(this._left);
    this.side.connect(this._left.addend);
    this.mid.connect(this._right);
    this.side.connect(this._right.subtrahend);
    this._left.connect(this._leftMult);
    this._right.connect(this._rightMult);
    this._leftMult.connect(this._merge, 0, 0);
    this._rightMult.connect(this._merge, 0, 1);
  }
  dispose() {
    super.dispose();
    this.mid.dispose();
    this.side.dispose();
    this._leftMult.dispose();
    this._rightMult.dispose();
    this._left.dispose();
    this._right.dispose();
    return this;
  }
};
var MidSideEffect = class extends Effect {
  constructor(options2) {
    super(options2);
    this.name = "MidSideEffect";
    this._midSideMerge = new MidSideMerge({ context: this.context });
    this._midSideSplit = new MidSideSplit({ context: this.context });
    this._midSend = this._midSideSplit.mid;
    this._sideSend = this._midSideSplit.side;
    this._midReturn = this._midSideMerge.mid;
    this._sideReturn = this._midSideMerge.side;
    this.effectSend.connect(this._midSideSplit);
    this._midSideMerge.connect(this.effectReturn);
  }
  connectEffectMid(...nodes) {
    this._midSend.chain(...nodes, this._midReturn);
  }
  connectEffectSide(...nodes) {
    this._sideSend.chain(...nodes, this._sideReturn);
  }
  dispose() {
    super.dispose();
    this._midSideSplit.dispose();
    this._midSideMerge.dispose();
    this._midSend.dispose();
    this._sideSend.dispose();
    this._midReturn.dispose();
    this._sideReturn.dispose();
    return this;
  }
};
var StereoWidener = class extends MidSideEffect {
  constructor() {
    super(optionsFromArguments(StereoWidener.getDefaults(), arguments, ["width"]));
    this.name = "StereoWidener";
    const options2 = optionsFromArguments(StereoWidener.getDefaults(), arguments, ["width"]);
    this.width = new Signal({
      context: this.context,
      value: options2.width,
      units: "normalRange"
    });
    readOnly(this, ["width"]);
    this._twoTimesWidthMid = new Multiply({
      context: this.context,
      value: 2
    });
    this._twoTimesWidthSide = new Multiply({
      context: this.context,
      value: 2
    });
    this._midMult = new Multiply({ context: this.context });
    this._twoTimesWidthMid.connect(this._midMult.factor);
    this.connectEffectMid(this._midMult);
    this._oneMinusWidth = new Subtract({ context: this.context });
    this._oneMinusWidth.connect(this._twoTimesWidthMid);
    connect(this.context.getConstant(1), this._oneMinusWidth);
    this.width.connect(this._oneMinusWidth.subtrahend);
    this._sideMult = new Multiply({ context: this.context });
    this.width.connect(this._twoTimesWidthSide);
    this._twoTimesWidthSide.connect(this._sideMult.factor);
    this.connectEffectSide(this._sideMult);
  }
  static getDefaults() {
    return Object.assign(MidSideEffect.getDefaults(), {
      width: 0.5
    });
  }
  dispose() {
    super.dispose();
    this.width.dispose();
    this._midMult.dispose();
    this._sideMult.dispose();
    this._twoTimesWidthMid.dispose();
    this._twoTimesWidthSide.dispose();
    this._oneMinusWidth.dispose();
    return this;
  }
};
var Analyser = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Analyser.getDefaults(), arguments, ["type", "size"]));
    this.name = "Analyser";
    this._analysers = [];
    this._buffers = [];
    const options2 = optionsFromArguments(Analyser.getDefaults(), arguments, ["type", "size"]);
    this.input = this.output = this._gain = new Gain({ context: this.context });
    this._split = new Split({
      context: this.context,
      channels: options2.channels
    });
    this.input.connect(this._split);
    assertRange(options2.channels, 1);
    for (let channel = 0; channel < options2.channels; channel++) {
      this._analysers[channel] = this.context.createAnalyser();
      this._split.connect(this._analysers[channel], channel, 0);
    }
    this.size = options2.size;
    this.type = options2.type;
    this.smoothing = options2.smoothing;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      size: 1024,
      smoothing: 0.8,
      type: "fft",
      channels: 1
    });
  }
  getValue() {
    this._analysers.forEach((analyser, index2) => {
      const buffer = this._buffers[index2];
      if (this._type === "fft") {
        analyser.getFloatFrequencyData(buffer);
      } else if (this._type === "waveform") {
        analyser.getFloatTimeDomainData(buffer);
      }
    });
    if (this.channels === 1) {
      return this._buffers[0];
    } else {
      return this._buffers;
    }
  }
  get size() {
    return this._analysers[0].frequencyBinCount;
  }
  set size(size) {
    this._analysers.forEach((analyser, index2) => {
      analyser.fftSize = size * 2;
      this._buffers[index2] = new Float32Array(size);
    });
  }
  get channels() {
    return this._analysers.length;
  }
  get type() {
    return this._type;
  }
  set type(type) {
    assert(type === "waveform" || type === "fft", `Analyser: invalid type: ${type}`);
    this._type = type;
  }
  get smoothing() {
    return this._analysers[0].smoothingTimeConstant;
  }
  set smoothing(val) {
    this._analysers.forEach((a2) => a2.smoothingTimeConstant = val);
  }
  dispose() {
    super.dispose();
    this._analysers.forEach((a2) => a2.disconnect());
    this._split.dispose();
    this._gain.dispose();
    return this;
  }
};
var MeterBase = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(MeterBase.getDefaults(), arguments));
    this.name = "MeterBase";
    this.input = this.output = this._analyser = new Analyser({
      context: this.context,
      size: 256,
      type: "waveform"
    });
  }
  dispose() {
    super.dispose();
    this._analyser.dispose();
    return this;
  }
};
var Meter = class extends MeterBase {
  constructor() {
    super(optionsFromArguments(Meter.getDefaults(), arguments, ["smoothing"]));
    this.name = "Meter";
    const options2 = optionsFromArguments(Meter.getDefaults(), arguments, ["smoothing"]);
    this.input = this.output = this._analyser = new Analyser({
      context: this.context,
      size: 256,
      type: "waveform",
      channels: options2.channelCount
    });
    this.smoothing = options2.smoothing, this.normalRange = options2.normalRange;
    this._rms = new Array(options2.channelCount);
    this._rms.fill(0);
  }
  static getDefaults() {
    return Object.assign(MeterBase.getDefaults(), {
      smoothing: 0.8,
      normalRange: false,
      channelCount: 1
    });
  }
  getLevel() {
    warn("'getLevel' has been changed to 'getValue'");
    return this.getValue();
  }
  getValue() {
    const aValues = this._analyser.getValue();
    const channelValues = this.channels === 1 ? [aValues] : aValues;
    const vals = channelValues.map((values, index2) => {
      const totalSquared = values.reduce((total, current) => total + current * current, 0);
      const rms = Math.sqrt(totalSquared / values.length);
      this._rms[index2] = Math.max(rms, this._rms[index2] * this.smoothing);
      return this.normalRange ? this._rms[index2] : gainToDb(this._rms[index2]);
    });
    if (this.channels === 1) {
      return vals[0];
    } else {
      return vals;
    }
  }
  get channels() {
    return this._analyser.channels;
  }
  dispose() {
    super.dispose();
    this._analyser.dispose();
    return this;
  }
};
var FFT = class extends MeterBase {
  constructor() {
    super(optionsFromArguments(FFT.getDefaults(), arguments, ["size"]));
    this.name = "FFT";
    const options2 = optionsFromArguments(FFT.getDefaults(), arguments, ["size"]);
    this.normalRange = options2.normalRange;
    this._analyser.type = "fft";
    this.size = options2.size;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      normalRange: false,
      size: 1024,
      smoothing: 0.8
    });
  }
  getValue() {
    const values = this._analyser.getValue();
    return values.map((v2) => this.normalRange ? dbToGain(v2) : v2);
  }
  get size() {
    return this._analyser.size;
  }
  set size(size) {
    this._analyser.size = size;
  }
  get smoothing() {
    return this._analyser.smoothing;
  }
  set smoothing(val) {
    this._analyser.smoothing = val;
  }
  getFrequencyOfIndex(index2) {
    assert(0 <= index2 && index2 < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);
    return index2 * this.context.sampleRate / (this.size * 2);
  }
};
var Solo = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Solo.getDefaults(), arguments, ["solo"]));
    this.name = "Solo";
    const options2 = optionsFromArguments(Solo.getDefaults(), arguments, ["solo"]);
    this.input = this.output = new Gain({
      context: this.context
    });
    if (!Solo._allSolos.has(this.context)) {
      Solo._allSolos.set(this.context, /* @__PURE__ */ new Set());
    }
    Solo._allSolos.get(this.context).add(this);
    this.solo = options2.solo;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      solo: false
    });
  }
  get solo() {
    return this._isSoloed();
  }
  set solo(solo) {
    if (solo) {
      this._addSolo();
    } else {
      this._removeSolo();
    }
    Solo._allSolos.get(this.context).forEach((instance) => instance._updateSolo());
  }
  get muted() {
    return this.input.gain.value === 0;
  }
  _addSolo() {
    if (!Solo._soloed.has(this.context)) {
      Solo._soloed.set(this.context, /* @__PURE__ */ new Set());
    }
    Solo._soloed.get(this.context).add(this);
  }
  _removeSolo() {
    if (Solo._soloed.has(this.context)) {
      Solo._soloed.get(this.context).delete(this);
    }
  }
  _isSoloed() {
    return Solo._soloed.has(this.context) && Solo._soloed.get(this.context).has(this);
  }
  _noSolos() {
    return !Solo._soloed.has(this.context) || Solo._soloed.has(this.context) && Solo._soloed.get(this.context).size === 0;
  }
  _updateSolo() {
    if (this._isSoloed()) {
      this.input.gain.value = 1;
    } else if (this._noSolos()) {
      this.input.gain.value = 1;
    } else {
      this.input.gain.value = 0;
    }
  }
  dispose() {
    super.dispose();
    Solo._allSolos.get(this.context).delete(this);
    this._removeSolo();
    return this;
  }
};
Solo._allSolos = /* @__PURE__ */ new Map();
Solo._soloed = /* @__PURE__ */ new Map();
var PanVol = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(PanVol.getDefaults(), arguments, ["pan", "volume"]));
    this.name = "PanVol";
    const options2 = optionsFromArguments(PanVol.getDefaults(), arguments, ["pan", "volume"]);
    this._panner = this.input = new Panner({
      context: this.context,
      pan: options2.pan,
      channelCount: options2.channelCount
    });
    this.pan = this._panner.pan;
    this._volume = this.output = new Volume({
      context: this.context,
      volume: options2.volume
    });
    this.volume = this._volume.volume;
    this._panner.connect(this._volume);
    this.mute = options2.mute;
    readOnly(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      pan: 0,
      volume: 0,
      channelCount: 1
    });
  }
  get mute() {
    return this._volume.mute;
  }
  set mute(mute) {
    this._volume.mute = mute;
  }
  dispose() {
    super.dispose();
    this._panner.dispose();
    this.pan.dispose();
    this._volume.dispose();
    this.volume.dispose();
    return this;
  }
};
var Channel = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Channel.getDefaults(), arguments, ["volume", "pan"]));
    this.name = "Channel";
    const options2 = optionsFromArguments(Channel.getDefaults(), arguments, ["volume", "pan"]);
    this._solo = this.input = new Solo({
      solo: options2.solo,
      context: this.context
    });
    this._panVol = this.output = new PanVol({
      context: this.context,
      pan: options2.pan,
      volume: options2.volume,
      mute: options2.mute,
      channelCount: options2.channelCount
    });
    this.pan = this._panVol.pan;
    this.volume = this._panVol.volume;
    this._solo.connect(this._panVol);
    readOnly(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      pan: 0,
      volume: 0,
      mute: false,
      solo: false,
      channelCount: 1
    });
  }
  get solo() {
    return this._solo.solo;
  }
  set solo(solo) {
    this._solo.solo = solo;
  }
  get muted() {
    return this._solo.muted || this.mute;
  }
  get mute() {
    return this._panVol.mute;
  }
  set mute(mute) {
    this._panVol.mute = mute;
  }
  _getBus(name2) {
    if (!Channel.buses.has(name2)) {
      Channel.buses.set(name2, new Gain({ context: this.context }));
    }
    return Channel.buses.get(name2);
  }
  send(name2, volume = 0) {
    const bus = this._getBus(name2);
    const sendKnob = new Gain({
      context: this.context,
      units: "decibels",
      gain: volume
    });
    this.connect(sendKnob);
    sendKnob.connect(bus);
    return sendKnob;
  }
  receive(name2) {
    const bus = this._getBus(name2);
    bus.connect(this);
    return this;
  }
  dispose() {
    super.dispose();
    this._panVol.dispose();
    this.pan.dispose();
    this.volume.dispose();
    this._solo.dispose();
    return this;
  }
};
Channel.buses = /* @__PURE__ */ new Map();
var Listener = class extends ToneAudioNode {
  constructor() {
    super(...arguments);
    this.name = "Listener";
    this.positionX = new Param({
      context: this.context,
      param: this.context.rawContext.listener.positionX
    });
    this.positionY = new Param({
      context: this.context,
      param: this.context.rawContext.listener.positionY
    });
    this.positionZ = new Param({
      context: this.context,
      param: this.context.rawContext.listener.positionZ
    });
    this.forwardX = new Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardX
    });
    this.forwardY = new Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardY
    });
    this.forwardZ = new Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardZ
    });
    this.upX = new Param({
      context: this.context,
      param: this.context.rawContext.listener.upX
    });
    this.upY = new Param({
      context: this.context,
      param: this.context.rawContext.listener.upY
    });
    this.upZ = new Param({
      context: this.context,
      param: this.context.rawContext.listener.upZ
    });
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      forwardX: 0,
      forwardY: 0,
      forwardZ: -1,
      upX: 0,
      upY: 1,
      upZ: 0
    });
  }
  dispose() {
    super.dispose();
    this.positionX.dispose();
    this.positionY.dispose();
    this.positionZ.dispose();
    this.forwardX.dispose();
    this.forwardY.dispose();
    this.forwardZ.dispose();
    this.upX.dispose();
    this.upY.dispose();
    this.upZ.dispose();
    return this;
  }
};
onContextInit((context2) => {
  context2.listener = new Listener({ context: context2 });
});
onContextClose((context2) => {
  context2.listener.dispose();
});
var Recorder = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Recorder.getDefaults(), arguments));
    this.name = "Recorder";
    const options2 = optionsFromArguments(Recorder.getDefaults(), arguments);
    this.input = new Gain({
      context: this.context
    });
    assert(Recorder.supported, "Media Recorder API is not available");
    this._stream = this.context.createMediaStreamDestination();
    this.input.connect(this._stream);
    this._recorder = new MediaRecorder(this._stream.stream, {
      mimeType: options2.mimeType
    });
  }
  static getDefaults() {
    return ToneAudioNode.getDefaults();
  }
  get mimeType() {
    return this._recorder.mimeType;
  }
  static get supported() {
    return theWindow !== null && Reflect.has(theWindow, "MediaRecorder");
  }
  get state() {
    if (this._recorder.state === "inactive") {
      return "stopped";
    } else if (this._recorder.state === "paused") {
      return "paused";
    } else {
      return "started";
    }
  }
  start() {
    return __awaiter(this, void 0, void 0, function* () {
      assert(this.state !== "started", "Recorder is already started");
      const startPromise = new Promise((done) => {
        const handleStart = () => {
          this._recorder.removeEventListener("start", handleStart, false);
          done();
        };
        this._recorder.addEventListener("start", handleStart, false);
      });
      this._recorder.start();
      return yield startPromise;
    });
  }
  stop() {
    return __awaiter(this, void 0, void 0, function* () {
      assert(this.state !== "stopped", "Recorder is not started");
      const dataPromise = new Promise((done) => {
        const handleData = (e2) => {
          this._recorder.removeEventListener("dataavailable", handleData, false);
          done(e2.data);
        };
        this._recorder.addEventListener("dataavailable", handleData, false);
      });
      this._recorder.stop();
      return yield dataPromise;
    });
  }
  pause() {
    assert(this.state === "started", "Recorder must be started");
    this._recorder.pause();
    return this;
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this._stream.disconnect();
    return this;
  }
};
var Compressor = class extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(Compressor.getDefaults(), arguments, ["threshold", "ratio"]));
    this.name = "Compressor";
    this._compressor = this.context.createDynamicsCompressor();
    this.input = this._compressor;
    this.output = this._compressor;
    const options2 = optionsFromArguments(Compressor.getDefaults(), arguments, ["threshold", "ratio"]);
    this.threshold = new Param({
      minValue: this._compressor.threshold.minValue,
      maxValue: this._compressor.threshold.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.threshold,
      units: "decibels",
      value: options2.threshold
    });
    this.attack = new Param({
      minValue: this._compressor.attack.minValue,
      maxValue: this._compressor.attack.maxValue,
      context: this.context,
      param: this._compressor.attack,
      units: "time",
      value: options2.attack
    });
    this.release = new Param({
      minValue: this._compressor.release.minValue,
      maxValue: this._compressor.release.maxValue,
      context: this.context,
      param: this._compressor.release,
      units: "time",
      value: options2.release
    });
    this.knee = new Param({
      minValue: this._compressor.knee.minValue,
      maxValue: this._compressor.knee.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.knee,
      units: "decibels",
      value: options2.knee
    });
    this.ratio = new Param({
      minValue: this._compressor.ratio.minValue,
      maxValue: this._compressor.ratio.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.ratio,
      units: "positive",
      value: options2.ratio
    });
    readOnly(this, ["knee", "release", "attack", "ratio", "threshold"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      attack: 3e-3,
      knee: 30,
      ratio: 12,
      release: 0.25,
      threshold: -24
    });
  }
  get reduction() {
    return this._compressor.reduction;
  }
  dispose() {
    super.dispose();
    this._compressor.disconnect();
    this.attack.dispose();
    this.release.dispose();
    this.threshold.dispose();
    this.ratio.dispose();
    this.knee.dispose();
    return this;
  }
};
var Gate = class extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(Gate.getDefaults(), arguments, ["threshold", "smoothing"])));
    this.name = "Gate";
    const options2 = optionsFromArguments(Gate.getDefaults(), arguments, ["threshold", "smoothing"]);
    this._follower = new Follower({
      context: this.context,
      smoothing: options2.smoothing
    });
    this._gt = new GreaterThan({
      context: this.context,
      value: dbToGain(options2.threshold)
    });
    this.input = new Gain({ context: this.context });
    this._gate = this.output = new Gain({ context: this.context });
    this.input.connect(this._gate);
    this.input.chain(this._follower, this._gt, this._gate.gain);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      smoothing: 0.1,
      threshold: -40
    });
  }
  get threshold() {
    return gainToDb(this._gt.value);
  }
  set threshold(thresh) {
    this._gt.value = dbToGain(thresh);
  }
  get smoothing() {
    return this._follower.smoothing;
  }
  set smoothing(smoothingTime) {
    this._follower.smoothing = smoothingTime;
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this._follower.dispose();
    this._gt.dispose();
    this._gate.dispose();
    return this;
  }
};
var Limiter = class extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(Limiter.getDefaults(), arguments, ["threshold"])));
    this.name = "Limiter";
    const options2 = optionsFromArguments(Limiter.getDefaults(), arguments, ["threshold"]);
    this._compressor = this.input = this.output = new Compressor({
      context: this.context,
      ratio: 20,
      attack: 3e-3,
      release: 0.01,
      threshold: options2.threshold
    });
    this.threshold = this._compressor.threshold;
    readOnly(this, "threshold");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      threshold: -12
    });
  }
  get reduction() {
    return this._compressor.reduction;
  }
  dispose() {
    super.dispose();
    this._compressor.dispose();
    this.threshold.dispose();
    return this;
  }
};
function now() {
  return getContext().now();
}
var Transport = getContext().transport;
getContext().destination;
getContext().destination;
function getDestination() {
  return getContext().destination;
}
getContext().listener;
var Draw = getContext().draw;
var context = getContext();

// node_modules/.pnpm/chromatone.center@1.9.0/node_modules/chromatone.center/lib/index.js
var Aubio = function(Aubio2) {
  Aubio2 = Aubio2 || {};
  var c2;
  c2 || (c2 = typeof Aubio2 !== "undefined" ? Aubio2 : {});
  var n2 = {}, r2;
  for (r2 in c2)
    c2.hasOwnProperty(r2) && (n2[r2] = c2[r2]);
  c2.arguments = [];
  c2.thisProgram = "./this.program";
  c2.quit = function(a2, b2) {
    throw b2;
  };
  c2.preRun = [];
  c2.postRun = [];
  var u2 = false, v2 = false, aa = false, ba = false;
  u2 = typeof window === "object";
  v2 = typeof importScripts === "function";
  aa = typeof process === "object" && typeof __require === "function" && !u2 && !v2;
  ba = !u2 && !aa && !v2;
  var w2 = "";
  function ca(a2) {
    return c2.locateFile ? c2.locateFile(a2, w2) : w2 + a2;
  }
  if (aa) {
    w2 = __dirname + "/";
    var da, ea;
    c2.read = function(a2, b2) {
      da || (da = require_fs());
      ea || (ea = require_path());
      a2 = ea.normalize(a2);
      a2 = da.readFileSync(a2);
      return b2 ? a2 : a2.toString();
    };
    c2.readBinary = function(a2) {
      a2 = c2.read(a2, true);
      a2.buffer || (a2 = new Uint8Array(a2));
      assert2(a2.buffer);
      return a2;
    };
    1 < process.argv.length && (c2.thisProgram = process.argv[1].replace(/\\/g, "/"));
    c2.arguments = process.argv.slice(2);
    process.on("uncaughtException", function(a2) {
      throw a2;
    });
    process.on("unhandledRejection", function() {
      process.exit(1);
    });
    c2.quit = function(a2) {
      process.exit(a2);
    };
    c2.inspect = function() {
      return "[Emscripten Module object]";
    };
  } else if (ba)
    typeof read != "undefined" && (c2.read = function(a2) {
      return read(a2);
    }), c2.readBinary = function(a2) {
      if (typeof readbuffer === "function")
        return new Uint8Array(readbuffer(a2));
      a2 = read(a2, "binary");
      assert2(typeof a2 === "object");
      return a2;
    }, typeof scriptArgs != "undefined" ? c2.arguments = scriptArgs : typeof arguments != "undefined" && (c2.arguments = arguments), typeof quit === "function" && (c2.quit = function(a2) {
      quit(a2);
    });
  else if (u2 || v2) {
    if (u2) {
      var fa = this._currentScript;
      fa.src.indexOf("blob:") !== 0 && (w2 = "/");
    } else
      v2 && (w2 = "/");
    c2.read = function(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("GET", a2, false);
      b2.send(null);
      return b2.responseText;
    };
    v2 && (c2.readBinary = function(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("GET", a2, false);
      b2.responseType = "arraybuffer";
      b2.send(null);
      return new Uint8Array(b2.response);
    });
    c2.readAsync = function(a2, b2, d2) {
      var e2 = new XMLHttpRequest();
      e2.open("GET", a2, true);
      e2.responseType = "arraybuffer";
      e2.onload = function() {
        e2.status == 200 || e2.status == 0 && e2.response ? b2(e2.response) : d2();
      };
      e2.onerror = d2;
      e2.send(null);
    };
    c2.setWindowTitle = function(a2) {
    };
  }
  var ha = c2.print || (typeof console !== "undefined" ? console.log.bind(console) : typeof print !== "undefined" ? print : null), x2 = c2.printErr || (typeof printErr !== "undefined" ? printErr : typeof console !== "undefined" && console.warn.bind(console) || ha);
  for (r2 in n2)
    n2.hasOwnProperty(r2) && (c2[r2] = n2[r2]);
  n2 = void 0;
  function ia(a2) {
    var b2;
    b2 || (b2 = 16);
    return Math.ceil(a2 / b2) * b2;
  }
  var ja = {
    "f64-rem": function(a2, b2) {
      return a2 % b2;
    },
    debugger: function() {
      debugger;
    }
  }, ka = 0;
  function assert2(a2, b2) {
    a2 || y2("Assertion failed: " + b2);
  }
  var la = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  typeof TextDecoder !== "undefined" && new TextDecoder("utf-16le");
  var buffer, ma, z, na, oa, A, B, pa, qa;
  function ra() {
    c2.HEAP8 = ma = new Int8Array(buffer);
    c2.HEAP16 = na = new Int16Array(buffer);
    c2.HEAP32 = A = new Int32Array(buffer);
    c2.HEAPU8 = z = new Uint8Array(buffer);
    c2.HEAPU16 = oa = new Uint16Array(buffer);
    c2.HEAPU32 = B = new Uint32Array(buffer);
    c2.HEAPF32 = pa = new Float32Array(buffer);
    c2.HEAPF64 = qa = new Float64Array(buffer);
  }
  var sa, C, ta, ua, va, wa, xa;
  sa = C = ta = ua = va = wa = xa = 0;
  function ya() {
    y2("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + E + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
  }
  var za = c2.TOTAL_STACK || 5242880, E = c2.TOTAL_MEMORY || 16777216;
  E < za && x2("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + E + "! (TOTAL_STACK=" + za + ")");
  c2.buffer ? buffer = c2.buffer : (typeof WebAssembly === "object" && typeof WebAssembly.Memory === "function" ? (c2.wasmMemory = new WebAssembly.Memory({
    initial: E / 65536,
    maximum: E / 65536
  }), buffer = c2.wasmMemory.buffer) : buffer = new ArrayBuffer(E), c2.buffer = buffer);
  ra();
  function Aa(a2) {
    for (; 0 < a2.length; ) {
      var b2 = a2.shift();
      if (typeof b2 == "function")
        b2();
      else {
        var d2 = b2.B;
        typeof d2 === "number" ? b2.F === void 0 ? c2.dynCall_v(d2) : c2.dynCall_vi(d2, b2.F) : d2(b2.F === void 0 ? null : b2.F);
      }
    }
  }
  var Ba = [], Ca = [], Da = [], Ea = [], Fa = false;
  function Ga() {
    var a2 = c2.preRun.shift();
    Ba.unshift(a2);
  }
  var Ha = Math.cos, Ia = Math.sin, F = 0, G = null;
  c2.preloadedImages = {};
  c2.preloadedAudios = {};
  function Ka(a2) {
    return String.prototype.startsWith ? a2.startsWith("data:application/octet-stream;base64,") : a2.indexOf("data:application/octet-stream;base64,") === 0;
  }
  (function() {
    function a2() {
      try {
        if (c2.wasmBinary)
          return new Uint8Array(c2.wasmBinary);
        if (c2.readBinary)
          return c2.readBinary(f2);
        throw "both async and sync fetching of the wasm failed";
      } catch (g2) {
        y2(g2);
      }
    }
    function b2() {
      return c2.wasmBinary || !u2 && !v2 || typeof fetch !== "function" ? new Promise(function(b3) {
        b3(a2());
      }) : fetch(f2, { credentials: "same-origin" }).then(function(a3) {
        if (!a3.ok)
          throw "failed to load wasm binary file at '" + f2 + "'";
        return a3.arrayBuffer();
      }).catch(function() {
        return a2();
      });
    }
    function d2(a3) {
      function d3(a4) {
        k2 = a4.exports;
        if (k2.memory) {
          a4 = k2.memory;
          var b3 = c2.buffer;
          a4.byteLength < b3.byteLength && x2("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");
          b3 = new Int8Array(b3);
          new Int8Array(a4).set(b3);
          c2.buffer = buffer = a4;
          ra();
        }
        c2.asm = k2;
        c2.usingWasm = true;
        F--;
        c2.monitorRunDependencies && c2.monitorRunDependencies(F);
        F == 0 && (G && (a4 = G, G = null, a4()));
      }
      function e3(a4) {
        d3(a4.instance);
      }
      function g2(a4) {
        b2().then(function(a5) {
          return WebAssembly.instantiate(a5, h2);
        }).then(a4).catch(function(a5) {
          x2("failed to asynchronously prepare wasm: " + a5);
          y2(a5);
        });
      }
      if (typeof WebAssembly !== "object")
        return x2("no native wasm support detected"), false;
      if (!(c2.wasmMemory instanceof WebAssembly.Memory))
        return x2("no native wasm Memory in use"), false;
      a3.memory = c2.wasmMemory;
      h2.global = { NaN: NaN, Infinity: Infinity };
      h2["global.Math"] = Math;
      h2.env = a3;
      F++;
      c2.monitorRunDependencies && c2.monitorRunDependencies(F);
      if (c2.instantiateWasm)
        try {
          return c2.instantiateWasm(h2, d3);
        } catch (vb) {
          return x2("Module.instantiateWasm callback failed with error: " + vb), false;
        }
      c2.wasmBinary || typeof WebAssembly.instantiateStreaming !== "function" || Ka(f2) || typeof fetch !== "function" ? g2(e3) : WebAssembly.instantiateStreaming(fetch(f2, { credentials: "same-origin" }), h2).then(e3).catch(function(a4) {
        x2("wasm streaming compile failed: " + a4);
        x2("falling back to ArrayBuffer instantiation");
        g2(e3);
      });
      return {};
    }
    var e2 = "aubio.wast", f2 = "aubio.wasm", l2 = "aubio.temp.asm.js";
    Ka(e2) || (e2 = ca(e2));
    Ka(f2) || (f2 = ca(f2));
    Ka(l2) || (l2 = ca(l2));
    var h2 = { global: null, env: null, asm2wasm: ja, parent: c2 }, k2 = null;
    c2.asmPreload = c2.asm;
    var m2 = c2.reallocBuffer;
    c2.reallocBuffer = function(a3) {
      if (p2 === "asmjs")
        var b3 = m2(a3);
      else
        a: {
          var d3 = c2.usingWasm ? 65536 : 16777216;
          0 < a3 % d3 && (a3 += d3 - a3 % d3);
          d3 = c2.buffer.byteLength;
          if (c2.usingWasm)
            try {
              b3 = c2.wasmMemory.grow((a3 - d3) / 65536) !== -1 ? c2.buffer = c2.wasmMemory.buffer : null;
              break a;
            } catch (t2) {
              b3 = null;
              break a;
            }
          b3 = void 0;
        }
      return b3;
    };
    var p2 = "";
    c2.asm = function(a3, b3) {
      if (!b3.table) {
        a3 = c2.wasmTableSize;
        a3 === void 0 && (a3 = 1024);
        var e3 = c2.wasmMaxTableSize;
        b3.table = typeof WebAssembly === "object" && typeof WebAssembly.Table === "function" ? e3 !== void 0 ? new WebAssembly.Table({
          initial: a3,
          maximum: e3,
          element: "anyfunc"
        }) : new WebAssembly.Table({ initial: a3, element: "anyfunc" }) : Array(a3);
        c2.wasmTable = b3.table;
      }
      b3.memoryBase || (b3.memoryBase = c2.STATIC_BASE);
      b3.tableBase || (b3.tableBase = 0);
      b3 = d2(b3);
      assert2(b3, "no binaryen method succeeded.");
      return b3;
    };
  })();
  sa = 1024;
  C = sa + 9312;
  Ca.push({
    B: function() {
      La();
    }
  }, {
    B: function() {
      Ma();
    }
  }, {
    B: function() {
      Na();
    }
  }, {
    B: function() {
      Oa();
    }
  });
  c2.STATIC_BASE = sa;
  c2.STATIC_BUMP = 9312;
  C += 16;
  var H2 = 0;
  function I() {
    H2 += 4;
    return A[H2 - 4 >> 2];
  }
  var Pa = {};
  function J(a2, b2) {
    H2 = b2;
    try {
      var d2 = I(), e2 = I(), f2 = I();
      a2 = 0;
      J.J || (J.J = [null, [], []], J.P = function(a3, b3) {
        var d3 = J.J[a3];
        assert2(d3);
        if (b3 === 0 || b3 === 10) {
          a3 = a3 === 1 ? ha : x2;
          a: {
            for (var e3 = b3 = 0; d3[e3]; )
              ++e3;
            if (16 < e3 - b3 && d3.subarray && la)
              b3 = la.decode(d3.subarray(b3, e3));
            else
              for (e3 = ""; ; ) {
                var f3 = d3[b3++];
                if (!f3) {
                  b3 = e3;
                  break a;
                }
                if (f3 & 128) {
                  var k3 = d3[b3++] & 63;
                  if ((f3 & 224) == 192)
                    e3 += String.fromCharCode((f3 & 31) << 6 | k3);
                  else {
                    var l3 = d3[b3++] & 63;
                    if ((f3 & 240) == 224)
                      f3 = (f3 & 15) << 12 | k3 << 6 | l3;
                    else {
                      var h3 = d3[b3++] & 63;
                      if ((f3 & 248) == 240)
                        f3 = (f3 & 7) << 18 | k3 << 12 | l3 << 6 | h3;
                      else {
                        var bb = d3[b3++] & 63;
                        if ((f3 & 252) == 248)
                          f3 = (f3 & 3) << 24 | k3 << 18 | l3 << 12 | h3 << 6 | bb;
                        else {
                          var m2 = d3[b3++] & 63;
                          f3 = (f3 & 1) << 30 | k3 << 24 | l3 << 18 | h3 << 12 | bb << 6 | m2;
                        }
                      }
                    }
                    65536 > f3 ? e3 += String.fromCharCode(f3) : (f3 -= 65536, e3 += String.fromCharCode(55296 | f3 >> 10, 56320 | f3 & 1023));
                  }
                } else
                  e3 += String.fromCharCode(f3);
              }
          }
          a3(b3);
          d3.length = 0;
        } else
          d3.push(b3);
      });
      for (b2 = 0; b2 < f2; b2++) {
        for (var l2 = A[e2 + 8 * b2 >> 2], h2 = A[e2 + (8 * b2 + 4) >> 2], k2 = 0; k2 < h2; k2++)
          J.P(d2, z[l2 + k2]);
        a2 += h2;
      }
      return a2;
    } catch (m2) {
      return typeof FS !== "undefined" && m2 instanceof FS.I || y2(m2), -m2.L;
    }
  }
  function Qa(a2) {
    switch (a2) {
      case 1:
        return 0;
      case 2:
        return 1;
      case 4:
        return 2;
      case 8:
        return 3;
      default:
        throw new TypeError("Unknown type size: " + a2);
    }
  }
  var Ra = void 0;
  function K(a2) {
    for (var b2 = ""; z[a2]; )
      b2 += Ra[z[a2++]];
    return b2;
  }
  var L = {}, M2 = {}, Sa = {};
  function Ta(a2) {
    if (a2 === void 0)
      return "_unknown";
    a2 = a2.replace(/[^a-zA-Z0-9_]/g, "$");
    var b2 = a2.charCodeAt(0);
    return 48 <= b2 && 57 >= b2 ? "_" + a2 : a2;
  }
  function Ua(a2, b2) {
    a2 = Ta(a2);
    return new Function("body", "return function " + a2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(b2);
  }
  function Va(a2) {
    var b2 = Error, d2 = Ua(a2, function(b3) {
      this.name = a2;
      this.message = b3;
      b3 = Error(b3).stack;
      b3 !== void 0 && (this.stack = this.toString() + "\n" + b3.replace(/^Error(:[^\n]*)?\n/, ""));
    });
    d2.prototype = Object.create(b2.prototype);
    d2.prototype.constructor = d2;
    d2.prototype.toString = function() {
      return this.message === void 0 ? this.name : this.name + ": " + this.message;
    };
    return d2;
  }
  var O = void 0;
  function P(a2) {
    throw new O(a2);
  }
  var Wa = void 0;
  function Xa(a2) {
    throw new Wa(a2);
  }
  function Ya(a2, b2, d2) {
    function e2(b3) {
      b3 = d2(b3);
      b3.length !== a2.length && Xa("Mismatched type converter count");
      for (var e3 = 0; e3 < a2.length; ++e3)
        Q(a2[e3], b3[e3]);
    }
    a2.forEach(function(a3) {
      Sa[a3] = b2;
    });
    var f2 = Array(b2.length), l2 = [], h2 = 0;
    b2.forEach(function(a3, b3) {
      M2.hasOwnProperty(a3) ? f2[b3] = M2[a3] : (l2.push(a3), L.hasOwnProperty(a3) || (L[a3] = []), L[a3].push(function() {
        f2[b3] = M2[a3];
        ++h2;
        h2 === l2.length && e2(f2);
      }));
    });
    l2.length === 0 && e2(f2);
  }
  function Q(a2, b2, d2) {
    d2 = d2 || {};
    if (!("argPackAdvance" in b2))
      throw new TypeError("registerType registeredInstance requires argPackAdvance");
    var e2 = b2.name;
    a2 || P('type "' + e2 + '" must have a positive integer typeid pointer');
    if (M2.hasOwnProperty(a2)) {
      if (d2.X)
        return;
      P("Cannot register type '" + e2 + "' twice");
    }
    M2[a2] = b2;
    delete Sa[a2];
    L.hasOwnProperty(a2) && (b2 = L[a2], delete L[a2], b2.forEach(function(a3) {
      a3();
    }));
  }
  function Za(a2) {
    P(a2.a.f.b.name + " instance already deleted");
  }
  var $a = void 0, ab = [];
  function cb() {
    for (; ab.length; ) {
      var a2 = ab.pop();
      a2.a.s = false;
      a2["delete"]();
    }
  }
  function R() {
  }
  var db = {};
  function eb(a2, b2, d2) {
    if (a2[b2].j === void 0) {
      var e2 = a2[b2];
      a2[b2] = function() {
        a2[b2].j.hasOwnProperty(arguments.length) || P("Function '" + d2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a2[b2].j + ")!");
        return a2[b2].j[arguments.length].apply(this, arguments);
      };
      a2[b2].j = [];
      a2[b2].j[e2.A] = e2;
    }
  }
  function fb(a2, b2) {
    c2.hasOwnProperty(a2) ? (P("Cannot register public name '" + a2 + "' twice"), eb(c2, a2, a2), c2.hasOwnProperty(void 0) && P("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), c2[a2].j[void 0] = b2) : c2[a2] = b2;
  }
  function gb(a2, b2, d2, e2, f2, l2, h2, k2) {
    this.name = a2;
    this.constructor = b2;
    this.u = d2;
    this.o = e2;
    this.i = f2;
    this.T = l2;
    this.w = h2;
    this.S = k2;
    this.Z = [];
  }
  function hb(a2, b2, d2) {
    for (; b2 !== d2; )
      b2.w || P("Expected null or instance of " + d2.name + ", got an instance of " + b2.name), a2 = b2.w(a2), b2 = b2.i;
    return a2;
  }
  function ib(a2, b2) {
    if (b2 === null)
      return this.G && P("null is not a valid " + this.name), 0;
    b2.a || P('Cannot pass "' + S2(b2) + '" as a ' + this.name);
    b2.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
    return hb(b2.a.c, b2.a.f.b, this.b);
  }
  function jb(a2, b2) {
    if (b2 === null) {
      this.G && P("null is not a valid " + this.name);
      if (this.D) {
        var d2 = this.$();
        a2 !== null && a2.push(this.o, d2);
        return d2;
      }
      return 0;
    }
    b2.a || P('Cannot pass "' + S2(b2) + '" as a ' + this.name);
    b2.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
    !this.C && b2.a.f.C && P("Cannot convert argument of type " + (b2.a.h ? b2.a.h.name : b2.a.f.name) + " to parameter type " + this.name);
    d2 = hb(b2.a.c, b2.a.f.b, this.b);
    if (this.D)
      switch (b2.a.g === void 0 && P("Passing raw pointer to smart pointer is illegal"), this.ba) {
        case 0:
          b2.a.h === this ? d2 = b2.a.g : P("Cannot convert argument of type " + (b2.a.h ? b2.a.h.name : b2.a.f.name) + " to parameter type " + this.name);
          break;
        case 1:
          d2 = b2.a.g;
          break;
        case 2:
          if (b2.a.h === this)
            d2 = b2.a.g;
          else {
            var e2 = b2.clone();
            d2 = this.aa(d2, T(function() {
              e2["delete"]();
            }));
            a2 !== null && a2.push(this.o, d2);
          }
          break;
        default:
          P("Unsupporting sharing policy");
      }
    return d2;
  }
  function kb(a2, b2) {
    if (b2 === null)
      return this.G && P("null is not a valid " + this.name), 0;
    b2.a || P('Cannot pass "' + S2(b2) + '" as a ' + this.name);
    b2.a.c || P("Cannot pass deleted object as a pointer of type " + this.name);
    b2.a.f.C && P("Cannot convert argument of type " + b2.a.f.name + " to parameter type " + this.name);
    return hb(b2.a.c, b2.a.f.b, this.b);
  }
  function lb(a2) {
    return this.fromWireType(B[a2 >> 2]);
  }
  function ob(a2, b2, d2) {
    if (b2 === d2)
      return a2;
    if (d2.i === void 0)
      return null;
    a2 = ob(a2, b2, d2.i);
    return a2 === null ? null : d2.S(a2);
  }
  var pb = {};
  function qb(a2, b2) {
    for (b2 === void 0 && P("ptr should not be undefined"); a2.i; )
      b2 = a2.w(b2), a2 = a2.i;
    return pb[b2];
  }
  function rb(a2, b2) {
    b2.f && b2.c || Xa("makeClassHandle requires ptr and ptrType");
    !!b2.h !== !!b2.g && Xa("Both smartPtrType and smartPtr must be specified");
    b2.count = { value: 1 };
    return Object.create(a2, { a: { value: b2 } });
  }
  function U(a2, b2, d2, e2, f2, l2, h2, k2, m2, p2, g2) {
    this.name = a2;
    this.b = b2;
    this.G = d2;
    this.C = e2;
    this.D = f2;
    this.Y = l2;
    this.ba = h2;
    this.M = k2;
    this.$ = m2;
    this.aa = p2;
    this.o = g2;
    f2 || b2.i !== void 0 ? this.toWireType = jb : (this.toWireType = e2 ? ib : kb, this.l = null);
  }
  function sb(a2, b2) {
    c2.hasOwnProperty(a2) || Xa("Replacing nonexistant public symbol");
    c2[a2] = b2;
    c2[a2].A = void 0;
  }
  function V(a2, b2) {
    a2 = K(a2);
    if (c2["FUNCTION_TABLE_" + a2] !== void 0)
      var d2 = c2["FUNCTION_TABLE_" + a2][b2];
    else if (typeof FUNCTION_TABLE !== "undefined")
      d2 = FUNCTION_TABLE[b2];
    else {
      d2 = c2.asm["dynCall_" + a2];
      d2 === void 0 && (d2 = c2.asm["dynCall_" + a2.replace(/f/g, "d")], d2 === void 0 && P("No dynCall invoker for signature: " + a2));
      for (var e2 = [], f2 = 1; f2 < a2.length; ++f2)
        e2.push("a" + f2);
      f2 = "return function " + ("dynCall_" + a2 + "_" + b2) + "(" + e2.join(", ") + ") {\n";
      f2 += "    return dynCall(rawFunction" + (e2.length ? ", " : "") + e2.join(", ") + ");\n";
      d2 = new Function("dynCall", "rawFunction", f2 + "};\n")(d2, b2);
    }
    typeof d2 !== "function" && P("unknown function pointer with signature " + a2 + ": " + b2);
    return d2;
  }
  var tb = void 0;
  function ub(a2) {
    a2 = wb(a2);
    var b2 = K(a2);
    X(a2);
    return b2;
  }
  function xb(a2, b2) {
    function d2(a3) {
      f2[a3] || M2[a3] || (Sa[a3] ? Sa[a3].forEach(d2) : (e2.push(a3), f2[a3] = true));
    }
    var e2 = [], f2 = {};
    b2.forEach(d2);
    throw new tb(a2 + ": " + e2.map(ub).join([", "]));
  }
  function yb(a2, b2) {
    for (var d2 = [], e2 = 0; e2 < a2; e2++)
      d2.push(A[(b2 >> 2) + e2]);
    return d2;
  }
  function zb(a2) {
    for (; a2.length; ) {
      var b2 = a2.pop();
      a2.pop()(b2);
    }
  }
  function Ab(a2) {
    var b2 = Function;
    if (!(b2 instanceof Function))
      throw new TypeError("new_ called with constructor type " + typeof b2 + " which is not a function");
    var d2 = Ua(b2.name || "unknownFunctionName", function() {
    });
    d2.prototype = b2.prototype;
    d2 = new d2();
    a2 = b2.apply(d2, a2);
    return a2 instanceof Object ? a2 : d2;
  }
  var Bb = [], Y = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
  function Cb(a2) {
    4 < a2 && --Y[a2].H === 0 && (Y[a2] = void 0, Bb.push(a2));
  }
  function T(a2) {
    switch (a2) {
      case void 0:
        return 1;
      case null:
        return 2;
      case true:
        return 3;
      case false:
        return 4;
      default:
        var b2 = Bb.length ? Bb.pop() : Y.length;
        Y[b2] = { H: 1, value: a2 };
        return b2;
    }
  }
  function S2(a2) {
    if (a2 === null)
      return "null";
    var b2 = typeof a2;
    return b2 === "object" || b2 === "array" || b2 === "function" ? a2.toString() : "" + a2;
  }
  function Db(a2, b2) {
    switch (b2) {
      case 2:
        return function(a3) {
          return this.fromWireType(pa[a3 >> 2]);
        };
      case 3:
        return function(a3) {
          return this.fromWireType(qa[a3 >> 3]);
        };
      default:
        throw new TypeError("Unknown float type: " + a2);
    }
  }
  function Eb(a2, b2, d2) {
    switch (b2) {
      case 0:
        return d2 ? function(a3) {
          return ma[a3];
        } : function(a3) {
          return z[a3];
        };
      case 1:
        return d2 ? function(a3) {
          return na[a3 >> 1];
        } : function(a3) {
          return oa[a3 >> 1];
        };
      case 2:
        return d2 ? function(a3) {
          return A[a3 >> 2];
        } : function(a3) {
          return B[a3 >> 2];
        };
      default:
        throw new TypeError("Unknown integer type: " + a2);
    }
  }
  function Z(a2) {
    a2 || P("Cannot use deleted val. handle = " + a2);
    return Y[a2].value;
  }
  function Fb(a2, b2) {
    var d2 = M2[a2];
    d2 === void 0 && P(b2 + " has unknown type " + ub(a2));
    return d2;
  }
  for (var Gb = {}, Hb = Array(256), Ib = 0; 256 > Ib; ++Ib)
    Hb[Ib] = String.fromCharCode(Ib);
  Ra = Hb;
  O = c2.BindingError = Va("BindingError");
  Wa = c2.InternalError = Va("InternalError");
  R.prototype.isAliasOf = function(a2) {
    if (!(this instanceof R && a2 instanceof R))
      return false;
    var b2 = this.a.f.b, d2 = this.a.c, e2 = a2.a.f.b;
    for (a2 = a2.a.c; b2.i; )
      d2 = b2.w(d2), b2 = b2.i;
    for (; e2.i; )
      a2 = e2.w(a2), e2 = e2.i;
    return b2 === e2 && d2 === a2;
  };
  R.prototype.clone = function() {
    this.a.c || Za(this);
    if (this.a.v)
      return this.a.count.value += 1, this;
    var a2 = this.a;
    a2 = Object.create(Object.getPrototypeOf(this), {
      a: {
        value: {
          count: a2.count,
          s: a2.s,
          v: a2.v,
          c: a2.c,
          f: a2.f,
          g: a2.g,
          h: a2.h
        }
      }
    });
    a2.a.count.value += 1;
    a2.a.s = false;
    return a2;
  };
  R.prototype["delete"] = function() {
    this.a.c || Za(this);
    this.a.s && !this.a.v && P("Object already scheduled for deletion");
    --this.a.count.value;
    if (this.a.count.value === 0) {
      var a2 = this.a;
      a2.g ? a2.h.o(a2.g) : a2.f.b.o(a2.c);
    }
    this.a.v || (this.a.g = void 0, this.a.c = void 0);
  };
  R.prototype.isDeleted = function() {
    return !this.a.c;
  };
  R.prototype.deleteLater = function() {
    this.a.c || Za(this);
    this.a.s && !this.a.v && P("Object already scheduled for deletion");
    ab.push(this);
    ab.length === 1 && $a && $a(cb);
    this.a.s = true;
    return this;
  };
  U.prototype.U = function(a2) {
    this.M && (a2 = this.M(a2));
    return a2;
  };
  U.prototype.K = function(a2) {
    this.o && this.o(a2);
  };
  U.prototype.argPackAdvance = 8;
  U.prototype.readValueFromPointer = lb;
  U.prototype.deleteObject = function(a2) {
    if (a2 !== null)
      a2["delete"]();
  };
  U.prototype.fromWireType = function(a2) {
    function b2() {
      return this.D ? rb(this.b.u, { f: this.Y, c: d2, h: this, g: a2 }) : rb(this.b.u, { f: this, c: a2 });
    }
    var d2 = this.U(a2);
    if (!d2)
      return this.K(a2), null;
    var e2 = qb(this.b, d2);
    if (e2 !== void 0) {
      if (e2.a.count.value === 0)
        return e2.a.c = d2, e2.a.g = a2, e2.clone();
      e2 = e2.clone();
      this.K(a2);
      return e2;
    }
    e2 = this.b.T(d2);
    e2 = db[e2];
    if (!e2)
      return b2.call(this);
    e2 = this.C ? e2.R : e2.pointerType;
    var f2 = ob(d2, this.b, e2.b);
    return f2 === null ? b2.call(this) : this.D ? rb(e2.b.u, { f: e2, c: f2, h: this, g: a2 }) : rb(e2.b.u, { f: e2, c: f2 });
  };
  c2.getInheritedInstanceCount = function() {
    return Object.keys(pb).length;
  };
  c2.getLiveInheritedInstances = function() {
    var a2 = [], b2;
    for (b2 in pb)
      pb.hasOwnProperty(b2) && a2.push(pb[b2]);
    return a2;
  };
  c2.flushPendingDeletes = cb;
  c2.setDelayFunction = function(a2) {
    $a = a2;
    ab.length && $a && $a(cb);
  };
  tb = c2.UnboundTypeError = Va("UnboundTypeError");
  c2.count_emval_handles = function() {
    for (var a2 = 0, b2 = 5; b2 < Y.length; ++b2)
      Y[b2] !== void 0 && ++a2;
    return a2;
  };
  c2.get_first_emval = function() {
    for (var a2 = 5; a2 < Y.length; ++a2)
      if (Y[a2] !== void 0)
        return Y[a2];
    return null;
  };
  var Jb = C;
  C = C + 4 + 15 & -16;
  xa = Jb;
  ta = ua = ia(C);
  va = ta + za;
  wa = ia(va);
  A[xa >> 2] = wa;
  c2.wasmTableSize = 83;
  c2.wasmMaxTableSize = 83;
  c2.N = {};
  c2.O = {
    abort: y2,
    enlargeMemory: function() {
      ya();
    },
    getTotalMemory: function() {
      return E;
    },
    abortOnCannotGrowMemory: ya,
    ___setErrNo: function(a2) {
      c2.___errno_location && (A[c2.___errno_location() >> 2] = a2);
      return a2;
    },
    ___syscall140: function(a2, b2) {
      H2 = b2;
      try {
        var d2 = Pa.V();
        I();
        var e2 = I(), f2 = I(), l2 = I();
        FS.ea(d2, e2, l2);
        A[f2 >> 2] = d2.position;
        d2.W && e2 === 0 && l2 === 0 && (d2.W = null);
        return 0;
      } catch (h2) {
        return typeof FS !== "undefined" && h2 instanceof FS.I || y2(h2), -h2.L;
      }
    },
    ___syscall146: J,
    ___syscall54: function(a2, b2) {
      H2 = b2;
      return 0;
    },
    ___syscall6: function(a2, b2) {
      H2 = b2;
      try {
        var d2 = Pa.V();
        FS.close(d2);
        return 0;
      } catch (e2) {
        return typeof FS !== "undefined" && e2 instanceof FS.I || y2(e2), -e2.L;
      }
    },
    __embind_register_bool: function(a2, b2, d2, e2, f2) {
      var l2 = Qa(d2);
      b2 = K(b2);
      Q(a2, {
        name: b2,
        fromWireType: function(a3) {
          return !!a3;
        },
        toWireType: function(a3, b3) {
          return b3 ? e2 : f2;
        },
        argPackAdvance: 8,
        readValueFromPointer: function(a3) {
          if (d2 === 1)
            var e3 = ma;
          else if (d2 === 2)
            e3 = na;
          else if (d2 === 4)
            e3 = A;
          else
            throw new TypeError("Unknown boolean type size: " + b2);
          return this.fromWireType(e3[a3 >> l2]);
        },
        l: null
      });
    },
    __embind_register_class: function(a2, b2, d2, e2, f2, l2, h2, k2, m2, p2, g2, q, D) {
      g2 = K(g2);
      l2 = V(f2, l2);
      k2 && (k2 = V(h2, k2));
      p2 && (p2 = V(m2, p2));
      D = V(q, D);
      var t2 = Ta(g2);
      fb(t2, function() {
        xb("Cannot construct " + g2 + " due to unbound types", [e2]);
      });
      Ya([a2, b2, d2], e2 ? [e2] : [], function(b3) {
        b3 = b3[0];
        if (e2) {
          var d3 = b3.b;
          var f3 = d3.u;
        } else
          f3 = R.prototype;
        b3 = Ua(t2, function() {
          if (Object.getPrototypeOf(this) !== h3)
            throw new O("Use 'new' to construct " + g2);
          if (m3.m === void 0)
            throw new O(g2 + " has no accessible constructor");
          var a3 = m3.m[arguments.length];
          if (a3 === void 0)
            throw new O("Tried to invoke ctor of " + g2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(m3.m).toString() + ") parameters instead!");
          return a3.apply(this, arguments);
        });
        var h3 = Object.create(f3, { constructor: { value: b3 } });
        b3.prototype = h3;
        var m3 = new gb(g2, b3, h3, D, d3, l2, k2, p2);
        d3 = new U(g2, m3, true, false, false);
        f3 = new U(g2 + "*", m3, false, false, false);
        var q2 = new U(g2 + " const*", m3, false, true, false);
        db[a2] = { pointerType: f3, R: q2 };
        sb(t2, b3);
        return [d3, f3, q2];
      });
    },
    __embind_register_class_constructor: function(a2, b2, d2, e2, f2, l2) {
      var h2 = yb(b2, d2);
      f2 = V(e2, f2);
      Ya([], [a2], function(a3) {
        a3 = a3[0];
        var d3 = "constructor " + a3.name;
        a3.b.m === void 0 && (a3.b.m = []);
        if (a3.b.m[b2 - 1] !== void 0)
          throw new O("Cannot register multiple constructors with identical number of parameters (" + (b2 - 1) + ") for class '" + a3.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        a3.b.m[b2 - 1] = function() {
          xb("Cannot construct " + a3.name + " due to unbound types", h2);
        };
        Ya([], h2, function(e3) {
          a3.b.m[b2 - 1] = function() {
            arguments.length !== b2 - 1 && P(d3 + " called with " + arguments.length + " arguments, expected " + (b2 - 1));
            var a4 = [], h3 = Array(b2);
            h3[0] = l2;
            for (var k2 = 1; k2 < b2; ++k2)
              h3[k2] = e3[k2].toWireType(a4, arguments[k2 - 1]);
            h3 = f2.apply(null, h3);
            zb(a4);
            return e3[0].fromWireType(h3);
          };
          return [];
        });
        return [];
      });
    },
    __embind_register_class_function: function(a2, b2, d2, e2, f2, l2, h2, k2) {
      var m2 = yb(d2, e2);
      b2 = K(b2);
      l2 = V(f2, l2);
      Ya([], [a2], function(a3) {
        function e3() {
          xb("Cannot call " + f3 + " due to unbound types", m2);
        }
        a3 = a3[0];
        var f3 = a3.name + "." + b2;
        k2 && a3.b.Z.push(b2);
        var p2 = a3.b.u, t2 = p2[b2];
        t2 === void 0 || t2.j === void 0 && t2.className !== a3.name && t2.A === d2 - 2 ? (e3.A = d2 - 2, e3.className = a3.name, p2[b2] = e3) : (eb(p2, b2, f3), p2[b2].j[d2 - 2] = e3);
        Ya([], m2, function(e4) {
          var k3 = f3, g2 = a3, m3 = l2, q = e4.length;
          2 > q && P("argTypes array size mismatch! Must at least get return value and 'this' types!");
          var t3 = e4[1] !== null && g2 !== null, D = false;
          for (g2 = 1; g2 < e4.length; ++g2)
            if (e4[g2] !== null && e4[g2].l === void 0) {
              D = true;
              break;
            }
          var mb = e4[0].name !== "void", N2 = "", W = "";
          for (g2 = 0; g2 < q - 2; ++g2)
            N2 += (g2 !== 0 ? ", " : "") + "arg" + g2, W += (g2 !== 0 ? ", " : "") + "arg" + g2 + "Wired";
          k3 = "return function " + Ta(k3) + "(" + N2 + ") {\nif (arguments.length !== " + (q - 2) + ") {\nthrowBindingError('function " + k3 + " called with ' + arguments.length + ' arguments, expected " + (q - 2) + " args!');\n}\n";
          D && (k3 += "var destructors = [];\n");
          var nb = D ? "destructors" : "null";
          N2 = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
          m3 = [P, m3, h2, zb, e4[0], e4[1]];
          t3 && (k3 += "var thisWired = classParam.toWireType(" + nb + ", this);\n");
          for (g2 = 0; g2 < q - 2; ++g2)
            k3 += "var arg" + g2 + "Wired = argType" + g2 + ".toWireType(" + nb + ", arg" + g2 + "); // " + e4[g2 + 2].name + "\n", N2.push("argType" + g2), m3.push(e4[g2 + 2]);
          t3 && (W = "thisWired" + (0 < W.length ? ", " : "") + W);
          k3 += (mb ? "var rv = " : "") + "invoker(fn" + (0 < W.length ? ", " : "") + W + ");\n";
          if (D)
            k3 += "runDestructors(destructors);\n";
          else
            for (g2 = t3 ? 1 : 2; g2 < e4.length; ++g2)
              q = g2 === 1 ? "thisWired" : "arg" + (g2 - 2) + "Wired", e4[g2].l !== null && (k3 += q + "_dtor(" + q + "); // " + e4[g2].name + "\n", N2.push(q + "_dtor"), m3.push(e4[g2].l));
          mb && (k3 += "var ret = retType.fromWireType(rv);\nreturn ret;\n");
          N2.push(k3 + "}\n");
          e4 = Ab(N2).apply(null, m3);
          p2[b2].j === void 0 ? (e4.A = d2 - 2, p2[b2] = e4) : p2[b2].j[d2 - 2] = e4;
          return [];
        });
        return [];
      });
    },
    __embind_register_emval: function(a2, b2) {
      b2 = K(b2);
      Q(a2, {
        name: b2,
        fromWireType: function(a3) {
          var b3 = Y[a3].value;
          Cb(a3);
          return b3;
        },
        toWireType: function(a3, b3) {
          return T(b3);
        },
        argPackAdvance: 8,
        readValueFromPointer: lb,
        l: null
      });
    },
    __embind_register_float: function(a2, b2, d2) {
      d2 = Qa(d2);
      b2 = K(b2);
      Q(a2, {
        name: b2,
        fromWireType: function(a3) {
          return a3;
        },
        toWireType: function(a3, b3) {
          if (typeof b3 !== "number" && typeof b3 !== "boolean")
            throw new TypeError('Cannot convert "' + S2(b3) + '" to ' + this.name);
          return b3;
        },
        argPackAdvance: 8,
        readValueFromPointer: Db(b2, d2),
        l: null
      });
    },
    __embind_register_integer: function(a2, b2, d2, e2, f2) {
      function l2(a3) {
        return a3;
      }
      b2 = K(b2);
      f2 === -1 && (f2 = 4294967295);
      var h2 = Qa(d2);
      if (e2 === 0) {
        var k2 = 32 - 8 * d2;
        l2 = function(a3) {
          return a3 << k2 >>> k2;
        };
      }
      var m2 = b2.indexOf("unsigned") != -1;
      Q(a2, {
        name: b2,
        fromWireType: l2,
        toWireType: function(a3, d3) {
          if (typeof d3 !== "number" && typeof d3 !== "boolean")
            throw new TypeError('Cannot convert "' + S2(d3) + '" to ' + this.name);
          if (d3 < e2 || d3 > f2)
            throw new TypeError('Passing a number "' + S2(d3) + '" from JS side to C/C++ side to an argument of type "' + b2 + '", which is outside the valid range [' + e2 + ", " + f2 + "]!");
          return m2 ? d3 >>> 0 : d3 | 0;
        },
        argPackAdvance: 8,
        readValueFromPointer: Eb(b2, h2, e2 !== 0),
        l: null
      });
    },
    __embind_register_memory_view: function(a2, b2, d2) {
      function e2(a3) {
        a3 >>= 2;
        var b3 = B;
        return new f2(b3.buffer, b3[a3 + 1], b3[a3]);
      }
      var f2 = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ][b2];
      d2 = K(d2);
      Q(a2, {
        name: d2,
        fromWireType: e2,
        argPackAdvance: 8,
        readValueFromPointer: e2
      }, { X: true });
    },
    __embind_register_std_string: function(a2, b2) {
      b2 = K(b2);
      Q(a2, {
        name: b2,
        fromWireType: function(a3) {
          for (var b3 = B[a3 >> 2], d2 = Array(b3), l2 = 0; l2 < b3; ++l2)
            d2[l2] = String.fromCharCode(z[a3 + 4 + l2]);
          X(a3);
          return d2.join("");
        },
        toWireType: function(a3, b3) {
          function d2(a4, b4) {
            return a4[b4];
          }
          function e2(a4, b4) {
            return a4.charCodeAt(b4);
          }
          b3 instanceof ArrayBuffer && (b3 = new Uint8Array(b3));
          var h2;
          b3 instanceof Uint8Array ? h2 = d2 : b3 instanceof Uint8ClampedArray ? h2 = d2 : b3 instanceof Int8Array ? h2 = d2 : typeof b3 === "string" ? h2 = e2 : P("Cannot pass non-string to std::string");
          var k2 = b3.length, m2 = Kb(4 + k2);
          B[m2 >> 2] = k2;
          for (var p2 = 0; p2 < k2; ++p2) {
            var g2 = h2(b3, p2);
            255 < g2 && (X(m2), P("String has UTF-16 code units that do not fit in 8 bits"));
            z[m2 + 4 + p2] = g2;
          }
          a3 !== null && a3.push(X, m2);
          return m2;
        },
        argPackAdvance: 8,
        readValueFromPointer: lb,
        l: function(a3) {
          X(a3);
        }
      });
    },
    __embind_register_std_wstring: function(a2, b2, d2) {
      d2 = K(d2);
      if (b2 === 2) {
        var e2 = function() {
          return oa;
        };
        var f2 = 1;
      } else
        b2 === 4 && (e2 = function() {
          return B;
        }, f2 = 2);
      Q(a2, {
        name: d2,
        fromWireType: function(a3) {
          for (var b3 = e2(), d3 = B[a3 >> 2], l2 = Array(d3), p2 = a3 + 4 >> f2, g2 = 0; g2 < d3; ++g2)
            l2[g2] = String.fromCharCode(b3[p2 + g2]);
          X(a3);
          return l2.join("");
        },
        toWireType: function(a3, d3) {
          var k2 = e2(), h2 = d3.length, l2 = Kb(4 + h2 * b2);
          B[l2 >> 2] = h2;
          for (var g2 = l2 + 4 >> f2, q = 0; q < h2; ++q)
            k2[g2 + q] = d3.charCodeAt(q);
          a3 !== null && a3.push(X, l2);
          return l2;
        },
        argPackAdvance: 8,
        readValueFromPointer: lb,
        l: function(a3) {
          X(a3);
        }
      });
    },
    __embind_register_void: function(a2, b2) {
      b2 = K(b2);
      Q(a2, {
        da: true,
        name: b2,
        argPackAdvance: 0,
        fromWireType: function() {
        },
        toWireType: function() {
        }
      });
    },
    __emval_as: function(a2, b2, d2) {
      a2 = Z(a2);
      b2 = Fb(b2, "emval::as");
      var e2 = [], f2 = T(e2);
      A[d2 >> 2] = f2;
      return b2.toWireType(e2, a2);
    },
    __emval_decref: Cb,
    __emval_get_property: function(a2, b2) {
      a2 = Z(a2);
      b2 = Z(b2);
      return T(a2[b2]);
    },
    __emval_incref: function(a2) {
      4 < a2 && (Y[a2].H += 1);
    },
    __emval_new_array: function() {
      return T([]);
    },
    __emval_new_cstring: function(a2) {
      var b2 = Gb[a2];
      return T(b2 === void 0 ? K(a2) : b2);
    },
    __emval_new_object: function() {
      return T({});
    },
    __emval_run_destructors: function(a2) {
      zb(Y[a2].value);
      Cb(a2);
    },
    __emval_set_property: function(a2, b2, d2) {
      a2 = Z(a2);
      b2 = Z(b2);
      d2 = Z(d2);
      a2[b2] = d2;
    },
    __emval_take_value: function(a2, b2) {
      a2 = Fb(a2, "_emval_take_value");
      a2 = a2.readValueFromPointer(b2);
      return T(a2);
    },
    _abort: function() {
      c2.abort();
    },
    _emscripten_memcpy_big: function(a2, b2, d2) {
      z.set(z.subarray(b2, b2 + d2), a2);
      return a2;
    },
    _llvm_cos_f32: Ha,
    _llvm_log10_f32: function(a2) {
      return Math.log(a2) / Math.LN10;
    },
    _llvm_sin_f32: Ia,
    DYNAMICTOP_PTR: xa,
    STACKTOP: ua
  };
  var Lb = c2.asm(c2.N, c2.O, buffer);
  c2.asm = Lb;
  var Oa = c2.__GLOBAL__sub_I_bind_cpp = function() {
    return c2.asm.__GLOBAL__sub_I_bind_cpp.apply(null, arguments);
  }, La = c2.__GLOBAL__sub_I_fft_cc = function() {
    return c2.asm.__GLOBAL__sub_I_fft_cc.apply(null, arguments);
  }, Na = c2.__GLOBAL__sub_I_pitch_cc = function() {
    return c2.asm.__GLOBAL__sub_I_pitch_cc.apply(null, arguments);
  }, Ma = c2.__GLOBAL__sub_I_tempo_cc = function() {
    return c2.asm.__GLOBAL__sub_I_tempo_cc.apply(null, arguments);
  }, wb = c2.___getTypeName = function() {
    return c2.asm.___getTypeName.apply(null, arguments);
  }, X = c2._free = function() {
    return c2.asm._free.apply(null, arguments);
  }, Kb = c2._malloc = function() {
    return c2.asm._malloc.apply(null, arguments);
  };
  c2.dynCall_ffii = function() {
    return c2.asm.dynCall_ffii.apply(null, arguments);
  };
  c2.dynCall_fi = function() {
    return c2.asm.dynCall_fi.apply(null, arguments);
  };
  c2.dynCall_fii = function() {
    return c2.asm.dynCall_fii.apply(null, arguments);
  };
  c2.dynCall_fiii = function() {
    return c2.asm.dynCall_fiii.apply(null, arguments);
  };
  c2.dynCall_ii = function() {
    return c2.asm.dynCall_ii.apply(null, arguments);
  };
  c2.dynCall_iii = function() {
    return c2.asm.dynCall_iii.apply(null, arguments);
  };
  c2.dynCall_iiii = function() {
    return c2.asm.dynCall_iiii.apply(null, arguments);
  };
  c2.dynCall_iiiii = function() {
    return c2.asm.dynCall_iiiii.apply(null, arguments);
  };
  c2.dynCall_iiiiii = function() {
    return c2.asm.dynCall_iiiiii.apply(null, arguments);
  };
  c2.dynCall_v = function() {
    return c2.asm.dynCall_v.apply(null, arguments);
  };
  c2.dynCall_vi = function() {
    return c2.asm.dynCall_vi.apply(null, arguments);
  };
  c2.dynCall_viii = function() {
    return c2.asm.dynCall_viii.apply(null, arguments);
  };
  c2.asm = Lb;
  c2.then = function(a2) {
    if (c2.calledRun)
      a2(c2);
    else {
      var b2 = c2.onRuntimeInitialized;
      c2.onRuntimeInitialized = function() {
        b2 && b2();
        a2(c2);
      };
    }
    return c2;
  };
  G = function Mb() {
    c2.calledRun || Nb();
    c2.calledRun || (G = Mb);
  };
  function Nb() {
    function a2() {
      if (!c2.calledRun && (c2.calledRun = true, !ka)) {
        Fa || (Fa = true, Aa(Ca));
        Aa(Da);
        if (c2.onRuntimeInitialized)
          c2.onRuntimeInitialized();
        if (c2.postRun)
          for (typeof c2.postRun == "function" && (c2.postRun = [c2.postRun]); c2.postRun.length; ) {
            var a3 = c2.postRun.shift();
            Ea.unshift(a3);
          }
        Aa(Ea);
      }
    }
    if (!(0 < F)) {
      if (c2.preRun)
        for (typeof c2.preRun == "function" && (c2.preRun = [c2.preRun]); c2.preRun.length; )
          Ga();
      Aa(Ba);
      0 < F || c2.calledRun || (c2.setStatus ? (c2.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          c2.setStatus("");
        }, 1);
        a2();
      }, 1)) : a2());
    }
  }
  c2.run = Nb;
  function y2(a2) {
    if (c2.onAbort)
      c2.onAbort(a2);
    a2 !== void 0 ? (ha(a2), x2(a2), a2 = JSON.stringify(a2)) : a2 = "";
    ka = true;
    throw "abort(" + a2 + "). Build with -s ASSERTIONS=1 for more info.";
  }
  c2.abort = y2;
  if (c2.preInit)
    for (typeof c2.preInit == "function" && (c2.preInit = [c2.preInit]); 0 < c2.preInit.length; )
      c2.preInit.pop()();
  c2.noExitRuntime = true;
  Nb();
  return Aubio2;
};
var Aubio$1 = Aubio.bind({
  _currentScript: {
    src: "/aubio.js"
  }
});
var _a;
var isClient = typeof window !== "undefined";
var isFunction2 = (val) => typeof val === "function";
var isString2 = (val) => typeof val === "string";
var timestamp$1 = () => +Date.now();
var clamp2 = (n2, min, max) => Math.min(max, Math.max(min, n2));
var noop = () => {
};
isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    filter2(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
var bypassFilter = (invoke) => {
  return invoke();
};
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function identity(arg) {
  return arg;
}
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useIntervalFn(cb, interval2 = 1e3, options2 = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options2;
  let timer2 = null;
  const isActive = ref(false);
  function clean() {
    if (timer2) {
      clearInterval(timer2);
      timer2 = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    if (unref(interval2) <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer2 = setInterval(cb, resolveUnref(interval2));
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval2)) {
    const stopWatch = watch(interval2, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useLastChanged(source, options2 = {}) {
  var _a2;
  const ms = ref((_a2 = options2.initialValue) != null ? _a2 : null);
  watch(source, () => ms.value = timestamp$1(), options2);
  return ms;
}
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options2 = {}) {
  const _a2 = options2, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$5(_a2, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$2.call(b2, prop))
      __defNormalProp$2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b2)) {
      if (__propIsEnum$2.call(b2, prop))
        __defNormalProp$2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$2 = (a2, b2) => __defProps$2(a2, __getOwnPropDescs$2(b2));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchPausable(source, cb, options2 = {}) {
  const _a2 = options2, {
    eventFilter: filter2
  } = _a2, watchOptions = __objRest$1(_a2, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
    eventFilter
  }));
  return { stop, pause, resume, isActive };
}
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options2;
  if (isString2(args[0])) {
    [event, listener, options2] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options2] = args;
  }
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options2);
    cleanup = () => {
      el.removeEventListener(event, listener, options2);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
var __defProp$l = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
var __hasOwnProp$n = Object.prototype.hasOwnProperty;
var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$l = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$n.call(b2, prop))
      __defNormalProp$l(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(b2)) {
      if (__propIsEnum$n.call(b2, prop))
        __defNormalProp$l(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$8 = (a2, b2) => __defProps$8(a2, __getOwnPropDescs$8(b2));
var createKeyPredicate = (keyFilter) => {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  else if (keyFilter)
    return () => true;
  else
    return () => false;
};
function onKeyStroke(key, handler2, options2 = {}) {
  const { target = defaultWindow, eventName = "keydown", passive = false } = options2;
  const predicate = createKeyPredicate(key);
  const listener = (e2) => {
    if (predicate(e2))
      handler2(e2);
  };
  return useEventListener(target, eventName, listener, passive);
}
function onKeyDown(key, handler2, options2 = {}) {
  return onKeyStroke(key, handler2, __spreadProps$8(__spreadValues$l({}, options2), { eventName: "keydown" }));
}
function useSupported(callback, sync = false) {
  const isSupported = ref();
  const update = () => isSupported.value = Boolean(callback());
  update();
  tryOnMounted(update, sync);
  return isSupported;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
var handlers = _global[globalKey];
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
var __defProp$j = Object.defineProperty;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$j = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$l.call(b2, prop))
      __defNormalProp$j(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b2)) {
      if (__propIsEnum$l.call(b2, prop))
        __defNormalProp$j(a2, prop, b2[prop]);
    }
  return a2;
};
var StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2))
  },
  date: {
    read: (v2) => new Date(v2),
    write: (v2) => v2.toISOString()
  }
};
function useStorage(key, defaults, storage, options2 = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    }
  } = options2;
  const data = (shallow ? shallowRef : ref)(defaults);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e2) {
      onError(e2);
    }
  }
  if (!storage)
    return data;
  const rawInit = resolveUnref(defaults);
  const type = guessSerializerType(rawInit);
  const serializer = (_a2 = options2.serializer) != null ? _a2 : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(data, () => write(data.value), { flush, deep, eventFilter });
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", update);
  update();
  return data;
  function write(v2) {
    try {
      if (v2 == null)
        storage.removeItem(key);
      else
        storage.setItem(key, serializer.write(v2));
    } catch (e2) {
      onError(e2);
    }
  }
  function read2(event) {
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      const rawValue = event ? event.newValue : storage.getItem(key);
      if (rawValue == null) {
        if (writeDefaults && rawInit !== null)
          storage.setItem(key, serializer.write(rawInit));
        return rawInit;
      } else if (!event && mergeDefaults) {
        const value = serializer.read(rawValue);
        if (isFunction2(mergeDefaults))
          return mergeDefaults(value, rawInit);
        else if (type === "object" && !Array.isArray(value))
          return __spreadValues$j(__spreadValues$j({}, rawInit), value);
        return value;
      } else if (typeof rawValue !== "string") {
        return rawValue;
      } else {
        return serializer.read(rawValue);
      }
    } catch (e2) {
      onError(e2);
    } finally {
      resumeWatch();
    }
  }
  function update(event) {
    if (event && event.key !== key)
      return;
    data.value = read2(event);
  }
}
function useCycleList(list, options2) {
  var _a2;
  const state = shallowRef((_a2 = options2 == null ? void 0 : options2.initialValue) != null ? _a2 : list[0]);
  const index2 = computed({
    get() {
      var _a22;
      let index22 = (options2 == null ? void 0 : options2.getIndexOf) ? options2.getIndexOf(state.value, list) : list.indexOf(state.value);
      if (index22 < 0)
        index22 = (_a22 = options2 == null ? void 0 : options2.fallbackIndex) != null ? _a22 : 0;
      return index22;
    },
    set(v2) {
      set(v2);
    }
  });
  function set(i2) {
    const length = list.length;
    const index22 = (i2 % length + length) % length;
    const value = list[index22];
    state.value = value;
    return value;
  }
  function shift(delta = 1) {
    return set(index2.value + delta);
  }
  function next(n2 = 1) {
    return shift(n2);
  }
  function prev(n2 = 1) {
    return shift(-n2);
  }
  return {
    state,
    index: index2,
    next,
    prev
  };
}
function usePermission(permissionDesc, options2 = {}) {
  const {
    controls = false,
    navigator: navigator2 = defaultNavigator
  } = options2;
  const isSupported = useSupported(() => navigator2 && "permissions" in navigator2);
  let permissionStatus;
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const state = ref();
  const onChange = () => {
    if (permissionStatus)
      state.value = permissionStatus.state;
  };
  const query = createSingletonPromise(async () => {
    if (!isSupported.value)
      return;
    if (!permissionStatus) {
      try {
        permissionStatus = await navigator2.permissions.query(desc);
        useEventListener(permissionStatus, "change", onChange);
        onChange();
      } catch (e2) {
        state.value = "prompt";
      }
    }
    return permissionStatus;
  });
  query();
  if (controls) {
    return {
      state,
      isSupported,
      query
    };
  } else {
    return state;
  }
}
function useDevicesList(options2 = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    requestPermissions = false,
    constraints = { audio: true, video: true },
    onUpdated
  } = options2;
  const devices2 = ref([]);
  const videoInputs = computed(() => devices2.value.filter((i2) => i2.kind === "videoinput"));
  const audioInputs = computed(() => devices2.value.filter((i2) => i2.kind === "audioinput"));
  const audioOutputs = computed(() => devices2.value.filter((i2) => i2.kind === "audiooutput"));
  const isSupported = useSupported(() => navigator2 && navigator2.mediaDevices && navigator2.mediaDevices.enumerateDevices);
  const permissionGranted = ref(false);
  async function update() {
    if (!isSupported.value)
      return;
    devices2.value = await navigator2.mediaDevices.enumerateDevices();
    onUpdated == null ? void 0 : onUpdated(devices2.value);
  }
  async function ensurePermissions() {
    if (!isSupported.value)
      return false;
    if (permissionGranted.value)
      return true;
    const { state, query } = usePermission("camera", { controls: true });
    await query();
    if (state.value !== "granted") {
      const stream = await navigator2.mediaDevices.getUserMedia(constraints);
      stream.getTracks().forEach((t2) => t2.stop());
      update();
      permissionGranted.value = true;
    } else {
      permissionGranted.value = true;
    }
    return permissionGranted.value;
  }
  if (isSupported.value) {
    if (requestPermissions)
      ensurePermissions();
    useEventListener(navigator2.mediaDevices, "devicechange", update);
    update();
  }
  return {
    devices: devices2,
    ensurePermissions,
    permissionGranted,
    videoInputs,
    audioInputs,
    audioOutputs,
    isSupported
  };
}
function useRafFn(fn, options2 = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow
  } = options2;
  const isActive = ref(false);
  let rafId = null;
  function loop() {
    if (!isActive.value || !window2)
      return;
    fn();
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      loop();
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useMouse(options2 = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow,
    eventFilter
  } = options2;
  const x2 = ref(initialValue.x);
  const y2 = ref(initialValue.y);
  const sourceType = ref(null);
  const mouseHandler = (event) => {
    if (type === "page") {
      x2.value = event.pageX;
      y2.value = event.pageY;
    } else if (type === "client") {
      x2.value = event.clientX;
      y2.value = event.clientY;
    }
    sourceType.value = "mouse";
  };
  const reset = () => {
    x2.value = initialValue.x;
    y2.value = initialValue.y;
  };
  const touchHandler = (event) => {
    if (event.touches.length > 0) {
      const touch2 = event.touches[0];
      if (type === "page") {
        x2.value = touch2.pageX;
        y2.value = touch2.pageY;
      } else if (type === "client") {
        x2.value = touch2.clientX;
        y2.value = touch2.clientY;
      }
      sourceType.value = "touch";
    }
  };
  const mouseHandlerWrapper = (event) => {
    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});
  };
  const touchHandlerWrapper = (event) => {
    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});
  };
  if (window2) {
    useEventListener(window2, "mousemove", mouseHandlerWrapper, { passive: true });
    useEventListener(window2, "dragover", mouseHandlerWrapper, { passive: true });
    if (touch) {
      useEventListener(window2, "touchstart", touchHandlerWrapper, { passive: true });
      useEventListener(window2, "touchmove", touchHandlerWrapper, { passive: true });
      if (resetOnTouchEnds)
        useEventListener(window2, "touchend", reset, { passive: true });
    }
  }
  return {
    x: x2,
    y: y2,
    sourceType
  };
}
function useMouseInElement(target, options2 = {}) {
  const {
    handleOutside = true,
    window: window2 = defaultWindow
  } = options2;
  const { x: x2, y: y2, sourceType } = useMouse(options2);
  const targetRef = ref(target != null ? target : window2 == null ? void 0 : window2.document.body);
  const elementX = ref(0);
  const elementY = ref(0);
  const elementPositionX = ref(0);
  const elementPositionY = ref(0);
  const elementHeight = ref(0);
  const elementWidth = ref(0);
  const isOutside = ref(true);
  let stop = () => {
  };
  if (window2) {
    stop = watch([targetRef, x2, y2], () => {
      const el = unrefElement(targetRef);
      if (!el)
        return;
      const {
        left,
        top,
        width,
        height
      } = el.getBoundingClientRect();
      elementPositionX.value = left + window2.pageXOffset;
      elementPositionY.value = top + window2.pageYOffset;
      elementHeight.value = height;
      elementWidth.value = width;
      const elX = x2.value - elementPositionX.value;
      const elY = y2.value - elementPositionY.value;
      isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;
      if (handleOutside || !isOutside.value) {
        elementX.value = elX;
        elementY.value = elY;
      }
    }, { immediate: true });
  }
  return {
    x: x2,
    y: y2,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop
  };
}
function useMousePressed(options2 = {}) {
  const {
    touch = true,
    drag = true,
    initialValue = false,
    window: window2 = defaultWindow
  } = options2;
  const pressed = ref(initialValue);
  const sourceType = ref(null);
  if (!window2) {
    return {
      pressed,
      sourceType
    };
  }
  const onPressed = (srcType) => () => {
    pressed.value = true;
    sourceType.value = srcType;
  };
  const onReleased = () => {
    pressed.value = false;
    sourceType.value = null;
  };
  const target = computed(() => unrefElement(options2.target) || window2);
  useEventListener(target, "mousedown", onPressed("mouse"), { passive: true });
  useEventListener(window2, "mouseleave", onReleased, { passive: true });
  useEventListener(window2, "mouseup", onReleased, { passive: true });
  if (drag) {
    useEventListener(target, "dragstart", onPressed("mouse"), { passive: true });
    useEventListener(window2, "drop", onReleased, { passive: true });
    useEventListener(window2, "dragend", onReleased, { passive: true });
  }
  if (touch) {
    useEventListener(target, "touchstart", onPressed("touch"), { passive: true });
    useEventListener(window2, "touchend", onReleased, { passive: true });
    useEventListener(window2, "touchcancel", onReleased, { passive: true });
  }
  return {
    pressed,
    sourceType
  };
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop))
      __defNormalProp$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b2)) {
      if (__propIsEnum$1.call(b2, prop))
        __defNormalProp$1(a2, prop, b2[prop]);
    }
  return a2;
};
function useTimestamp(options2 = {}) {
  const {
    controls: exposeControls = false,
    offset = 0,
    immediate = true,
    interval: interval2 = "requestAnimationFrame"
  } = options2;
  const ts = ref(timestamp$1() + offset);
  const update = () => ts.value = timestamp$1() + offset;
  const controls = interval2 === "requestAnimationFrame" ? useRafFn(update, { immediate }) : useIntervalFn(update, interval2, { immediate });
  if (exposeControls) {
    return __spreadValues$1({
      timestamp: ts
    }, controls);
  } else {
    return ts;
  }
}
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
__spreadValues({
  linear: identity
}, _TransitionPresets);
function useClamp(value, min, max) {
  const _value = ref(value);
  return computed({
    get() {
      return _value.value = clamp2(_value.value, resolveUnref(min), resolveUnref(max));
    },
    set(value2) {
      _value.value = clamp2(value2, resolveUnref(min), resolveUnref(max));
    }
  });
}
var currentCamera = useStorage("cast-camera", "default");
var currentMic = useStorage("cast-mic", "default");
var showRecordingDialog = ref();
var recordingName = ref("");
var recordCamera = ref(true);
var mimeType = useStorage("slidev-record-mimetype", "video/webm");
var mimeExtMap = {
  "video/webm": "webm",
  "video/webm;codecs=h264": "mp4",
  "video/x-matroska;codecs=avc1": "mkv"
};
function getFilename(media, mimeType2) {
  const d2 = new Date();
  const pad = (v2) => `${v2}`.padStart(2, "0");
  const date = `${pad(d2.getMonth() + 1)}${pad(d2.getDate())}-${pad(d2.getHours())}${pad(d2.getMinutes())}`;
  const ext = mimeType2 ? mimeExtMap[mimeType2] : "webm";
  return `${[date, media, recordingName.value].filter((el) => !!el).join("-")}.${ext}`;
}
function getSupportedMimeTypes() {
  if (MediaRecorder && typeof (MediaRecorder == null ? void 0 : MediaRecorder.isTypeSupported) === "function") {
    return Object.keys(mimeExtMap).filter((mime) => MediaRecorder.isTypeSupported(mime));
  }
  return [];
}
var fileNames = reactive({
  screen: computed(() => getFilename("screen", mimeType.value)),
  camera: computed(() => getFilename("camera", mimeType.value))
});
var {
  devices,
  videoInputs: cameras,
  audioInputs: microphones,
  ensurePermissions: ensureDevicesListPermissions
} = useDevicesList({
  onUpdated: function() {
    var _a2, _b;
    if (currentCamera.value !== "none") {
      if (!cameras.value.find((i2) => i2.deviceId === currentCamera.value))
        currentCamera.value = ((_a2 = cameras.value[0]) == null ? void 0 : _a2.deviceId) || "default";
    }
    if (currentMic.value !== "none") {
      if (!microphones.value.find((i2) => i2.deviceId === currentMic.value))
        currentMic.value = ((_b = microphones.value[0]) == null ? void 0 : _b.deviceId) || "default";
    }
  }
});
function download(name2, url) {
  const a2 = document.createElement("a");
  a2.setAttribute("href", url);
  a2.setAttribute("download", name2);
  document.body.appendChild(a2);
  a2.click();
  document.body.removeChild(a2);
}
function useRecording() {
  const recording2 = ref(false);
  const recordingStartedAt = ref();
  const timestamp2 = useTimestamp();
  watch(recording2, (r2) => r2 ? recordingStartedAt.value = Date.now() : recordingStartedAt.value = null);
  const recordingTime = computed(() => {
    if (!recordingStartedAt.value)
      return 0;
    return timestamp2.value - recordingStartedAt.value;
  });
  const showAvatar = ref(false);
  const recorderCamera = shallowRef();
  const recorderSlides = shallowRef();
  const streamCamera = shallowRef();
  const streamCapture = shallowRef();
  const streamSlides = shallowRef();
  const config = {
    type: "video",
    bitsPerSecond: 4 * 256 * 8 * 1024,
    timeSlice: 24 * 60 * 60 * 1e3
  };
  async function toggleAvatar() {
    if (currentCamera.value === "none")
      return;
    if (showAvatar.value) {
      showAvatar.value = false;
      if (!recording2.value)
        closeStream(streamCamera);
    } else {
      await startCameraStream();
      if (streamCamera.value)
        showAvatar.value = !!streamCamera.value;
    }
  }
  async function startCameraStream() {
    await ensureDevicesListPermissions();
    await nextTick();
    if (!streamCamera.value) {
      if (currentCamera.value === "none" && currentMic.value === "none")
        return;
      streamCamera.value = await navigator.mediaDevices.getUserMedia({
        video: currentCamera.value === "none" || recordCamera.value !== true ? false : {
          deviceId: currentCamera.value
        },
        audio: currentMic.value === "none" ? false : {
          deviceId: currentMic.value
        }
      });
    }
  }
  watch(currentCamera, async (v2) => {
    if (v2 === "none") {
      closeStream(streamCamera);
    } else {
      if (recording2.value)
        return;
      if (streamCamera.value) {
        closeStream(streamCamera);
        await startCameraStream();
      }
    }
  });
  async function startRecording(customConfig) {
    var _a2;
    await ensureDevicesListPermissions();
    const { default: Recorder2 } = await import("./RecordRTC-6GKYO5H4.js").then(function(n2) {
      return n2.R;
    });
    await startCameraStream();
    streamCapture.value = await navigator.mediaDevices.getDisplayMedia({
      video: {
        frameRate: 30,
        width: 3840,
        height: 2160,
        cursor: "motion",
        resizeMode: "crop-and-scale"
      }
    });
    streamCapture.value.addEventListener("inactive", stopRecording);
    streamSlides.value = new MediaStream();
    streamCapture.value.getVideoTracks().forEach((videoTrack) => streamSlides.value.addTrack(videoTrack));
    Object.assign(config, customConfig);
    if (streamCamera.value) {
      streamSlides.value.addTrack((_a2 = master.stream.stream.getAudioTracks()) == null ? void 0 : _a2[0]);
      recorderCamera.value = new Recorder2(streamCamera.value, config);
      recorderCamera.value.startRecording();
    }
    recorderSlides.value = new Recorder2(streamSlides.value, config);
    recorderSlides.value.startRecording();
    recording2.value = true;
  }
  async function stopRecording() {
    var _a2, _b;
    recording2.value = false;
    (_a2 = recorderCamera.value) == null ? void 0 : _a2.stopRecording(() => {
      if (recordCamera.value) {
        const blob = recorderCamera.value.getBlob();
        const url = URL.createObjectURL(blob);
        download(getFilename("camera", config.mimeType), url);
        window.URL.revokeObjectURL(url);
      }
      recorderCamera.value = void 0;
      if (!showAvatar.value)
        closeStream(streamCamera);
    });
    (_b = recorderSlides.value) == null ? void 0 : _b.stopRecording(() => {
      const blob = recorderSlides.value.getBlob();
      const url = URL.createObjectURL(blob);
      download(getFilename("screen", config.mimeType), url);
      window.URL.revokeObjectURL(url);
      closeStream(streamCapture);
      closeStream(streamSlides);
      recorderSlides.value = void 0;
    });
  }
  function closeStream(stream) {
    const s2 = stream.value;
    if (!s2)
      return;
    s2.getTracks().forEach((i2) => {
      i2.stop();
      s2.removeTrack(i2);
    });
    stream.value = void 0;
  }
  function toggleRecording() {
    if (recording2.value)
      stopRecording();
    else
      startRecording();
  }
  useEventListener("beforeunload", (event) => {
    if (!recording2.value)
      return;
    if (confirm("Recording is not saved yet, do you want to leave?"))
      return;
    event.preventDefault();
    event.returnValue = "";
  });
  return {
    recording: recording2,
    recordingTime,
    showAvatar,
    toggleRecording,
    startRecording,
    stopRecording,
    toggleAvatar,
    recorderCamera,
    recorderSlides,
    streamCamera,
    streamCapture,
    streamSlides
  };
}
var cast = useRecording();
var recorder;
var recording = ref(false);
var toggled = useLastChanged(recording);
var timestamp = useTimestamp();
var duration = computed(() => timestamp.value - toggled.value);
var record = {
  start() {
    if (!recorder)
      useRecorder();
    recorder.start();
    recording.value = true;
  },
  async stop() {
    recording.value = false;
    const rec = await recorder.stop();
    const url = URL.createObjectURL(rec);
    const anchor = document.createElement("a");
    anchor.download = getFilename("rec");
    anchor.href = url;
    anchor.click();
  }
};
function useRecorder() {
  if (!recorder) {
    recorder = new Recorder();
  }
  return { recorder, record, recording, toggled, duration };
}
var audio = reactive({
  initiated: false,
  mute: useStorage("mute", false),
  volume: useClamp(useStorage("main-vol", 1), 0, 2),
  meter: 0
});
var master = shallowReactive({});
var channels = shallowReactive({});
function useAudio() {
  if (!audio.initiated) {
    start();
    const { recorder: recorder2 } = useRecorder();
    master.stream = context.createMediaStreamDestination();
    master.meter = new Meter().toDestination();
    master.meter.normalRange = true;
    master.meter.connect(master.stream);
    master.meter.connect(recorder2);
    useRafFn(() => {
      audio.meter = master.meter.getValue();
    });
    master.limiter = new Limiter(-18).connect(master.meter);
    master.reverb = new Reverb({
      decay: 1,
      wet: 0.5
    }).connect(master.meter);
    master.limiter.connect(master.reverb);
    watchEffect(() => {
      getDestination().mute = audio.mute;
    });
    watchEffect(() => {
      getDestination().volume.targetRampTo(gainToDb(audio.volume), 0.1);
    });
    audio.initiated = true;
  }
  return { audio, master, channels };
}
function createChannel$1(title = (Math.random() * 1e3).toFixed(0), options2) {
  const { master: master2 } = useAudio();
  const channel = new Limiter(options2).connect(master2.limiter);
  channels[title] = channel;
  return { channel };
}
function initGetUserMedia() {
  window.AudioContext = window.AudioContext || window.webkitAudioContext;
  if (!window.AudioContext) {
    return alert("AudioContext not supported");
  }
  if (navigator.mediaDevices === void 0) {
    navigator.mediaDevices = {};
  }
  if (navigator.mediaDevices.getUserMedia === void 0) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
      if (!getUserMedia) {
        alert("getUserMedia is not implemented in this browser");
      }
      return new Promise(function(resolve, reject) {
        getUserMedia.call(navigator, constraints, resolve, reject);
      });
    };
  }
}
var midiA = 69;
function pitchNoteOctave(pitch) {
  return {
    note: pitch > 0 ? pitch % 12 : 12 + pitch % 12,
    octave: Math.floor(pitch / 12) + 4
  };
}
function pitchFreq(pitch = 0, octave2 = 3, middleA = 440, tuning = "equal") {
  let hz = 0;
  const justCents = [0, 112, 204, 316, 386, 498, 590, 702, 814, 884, 1017, 1088];
  if (tuning == "equal") {
    hz = Number(middleA * Math.pow(2, octave2 - 3 + pitch / 12));
  }
  if (tuning == "just") {
    let diff = Number(Math.pow(Math.pow(2, 1 / 1200), justCents[pitch]));
    hz = Number(middleA * Math.pow(2, octave2 - 4) * diff);
  }
  return hz;
}
function pitchColor(pitch = 0, octave2, velocity = 1, alpha = 1) {
  octave2 = octave2 || Math.floor(pitch / 12) + 4;
  return `hsla(${pitch % 12 * 30},${velocity * 100}%,${Math.abs(octave2 + 2) * 8}%,${alpha})`;
}
function freqColor$1(freq2) {
  return pitchColor(freqPitch(freq2));
}
function freqPitch(freq2, middleA = 440) {
  return 12 * (Math.log(freq2 / middleA) / Math.log(2));
}
function isInChroma(chroma2, tonic, note2) {
  return chroma2.split("")[(24 + note2 - tonic) % 12] == "1";
}
function getCircleCoord(n2 = 0, total = 12, radius = 35, width = 100) {
  let angle = (n2 - total / 4) / (total / 2) * Math.PI;
  let x2 = radius * Math.cos(angle) + width / 2;
  let y2 = radius * Math.sin(angle) + width / 2;
  return { x: x2, y: y2 };
}
function rotateArray(arr, count = 1) {
  return [...arr.slice(count, arr.length), ...arr.slice(0, count)];
}
function clampNum(main, delta, min = 0, max = 100) {
  return Math.max(min, Math.min(Number(main) + Number(delta), max));
}
function getCents$1(frequency, pitch) {
  return Math.floor(1200 * Math.log(frequency / getStandardFrequency$1(pitch)) / Math.log(2));
}
function getStandardFrequency$1(pitch, middleA = 440) {
  return middleA * Math.pow(2, (pitch - 69) / 12);
}
var e$6 = class {
  constructor(e2 = false) {
    this.eventMap = {}, this.eventsSuspended = e2 == 1;
  }
  addListener(n2, s2, r2 = {}) {
    if (typeof n2 == "string" && n2.length < 1 || n2 instanceof String && n2.length < 1 || typeof n2 != "string" && !(n2 instanceof String) && n2 !== e$6.ANY_EVENT)
      throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
    if (typeof s2 != "function")
      throw new TypeError("The callback must be a function.");
    const a2 = new t$6(n2, this, s2, r2);
    return this.eventMap[n2] || (this.eventMap[n2] = []), r2.prepend ? this.eventMap[n2].unshift(a2) : this.eventMap[n2].push(a2), a2;
  }
  addOneTimeListener(e2, t2, n2 = {}) {
    n2.remaining = 1, this.addListener(e2, t2, n2);
  }
  static get ANY_EVENT() {
    return Symbol.for("Any event");
  }
  hasListener(n2, s2) {
    if (n2 === void 0)
      return !!(this.eventMap[e$6.ANY_EVENT] && this.eventMap[e$6.ANY_EVENT].length > 0) || Object.entries(this.eventMap).some(([, e2]) => e2.length > 0);
    if (this.eventMap[n2] && this.eventMap[n2].length > 0) {
      if (s2 instanceof t$6) {
        return this.eventMap[n2].filter((e2) => e2 === s2).length > 0;
      }
      if (typeof s2 == "function") {
        return this.eventMap[n2].filter((e2) => e2.callback === s2).length > 0;
      }
      return s2 == null;
    }
    return false;
  }
  get eventNames() {
    return Object.keys(this.eventMap);
  }
  getListeners(e2) {
    return this.eventMap[e2] || [];
  }
  suspendEvent(e2) {
    this.getListeners(e2).forEach((e3) => {
      e3.suspended = true;
    });
  }
  unsuspendEvent(e2) {
    this.getListeners(e2).forEach((e3) => {
      e3.suspended = false;
    });
  }
  getListenerCount(e2) {
    return this.getListeners(e2).length;
  }
  emit(t2, ...n2) {
    if (typeof t2 != "string" && !(t2 instanceof String))
      throw new TypeError("The 'event' parameter must be a string.");
    if (this.eventsSuspended)
      return;
    let s2 = [], r2 = this.eventMap[e$6.ANY_EVENT] || [];
    return this.eventMap[t2] && (r2 = r2.concat(this.eventMap[t2])), r2.forEach((e2) => {
      if (e2.suspended)
        return;
      let t3 = [...n2];
      Array.isArray(e2.arguments) && (t3 = t3.concat(e2.arguments)), e2.remaining > 0 && (s2.push(e2.callback.apply(e2.context, t3)), e2.count++), --e2.remaining < 1 && e2.remove();
    }), s2;
  }
  removeListener(e2, t2, n2 = {}) {
    if (e2 === void 0)
      return void (this.eventMap = {});
    if (!this.eventMap[e2])
      return;
    let s2 = this.eventMap[e2].filter((e3) => t2 && e3.callback !== t2 || n2.remaining && n2.remaining !== e3.remaining || n2.context && n2.context !== e3.context);
    s2.length ? this.eventMap[e2] = s2 : delete this.eventMap[e2];
  }
  async waitFor(e2, t2 = {}) {
    return t2.duration = parseInt(t2.duration), (isNaN(t2.duration) || t2.duration <= 0) && (t2.duration = 1 / 0), new Promise((n2, s2) => {
      let r2, a2 = this.addListener(e2, () => {
        clearTimeout(r2), n2();
      }, { remaining: 1 });
      t2.duration !== 1 / 0 && (r2 = setTimeout(() => {
        a2.remove(), s2("The duration expired before the event was emitted.");
      }, t2.duration));
    });
  }
  get eventCount() {
    return Object.keys(this.eventMap).length;
  }
};
var t$6 = class {
  constructor(t2, n2, s2, r2 = {}) {
    if (typeof t2 != "string" && !(t2 instanceof String) && t2 !== e$6.ANY_EVENT)
      throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
    if (!n2)
      throw new ReferenceError("The 'target' parameter is mandatory.");
    if (typeof s2 != "function")
      throw new TypeError("The 'callback' must be a function.");
    r2.arguments === void 0 || Array.isArray(r2.arguments) || (r2.arguments = [r2.arguments]), (r2 = Object.assign({ context: n2, remaining: 1 / 0, arguments: void 0, duration: 1 / 0 }, r2)).duration !== 1 / 0 && setTimeout(() => this.remove(), r2.duration), this.arguments = r2.arguments, this.callback = s2, this.context = r2.context, this.count = 0, this.event = t2, this.remaining = parseInt(r2.remaining) >= 1 ? parseInt(r2.remaining) : 1 / 0, this.suspended = false, this.target = n2;
  }
  remove() {
    this.target.removeListener(this.event, this.callback, { context: this.context, remaining: this.remaining });
  }
};
var n$6 = class {
  static get MIDI_CHANNEL_MESSAGES() {
    return { noteoff: 8, noteon: 9, keyaftertouch: 10, controlchange: 11, programchange: 12, channelaftertouch: 13, pitchbend: 14 };
  }
  static get MIDI_CHANNEL_NUMBERS() {
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
  }
  static get MIDI_CHANNEL_MODE_MESSAGES() {
    return { allsoundoff: 120, resetallcontrollers: 121, localcontrol: 122, allnotesoff: 123, omnimodeoff: 124, omnimodeon: 125, monomodeon: 126, polymodeon: 127 };
  }
  static get MIDI_CONTROL_CHANGE_MESSAGES() {
    return { bankselectcoarse: 0, modulationwheelcoarse: 1, breathcontrollercoarse: 2, controller3: 3, footcontrollercoarse: 4, portamentotimecoarse: 5, dataentrycoarse: 6, volumecoarse: 7, balancecoarse: 8, controller9: 9, pancoarse: 10, expressioncoarse: 11, effectcontrol1coarse: 12, effectcontrol2coarse: 13, controller14: 14, controller15: 15, generalpurposeslider1: 16, generalpurposeslider2: 17, generalpurposeslider3: 18, generalpurposeslider4: 19, controller20: 20, controller21: 21, controller22: 22, controller23: 23, controller24: 24, controller25: 25, controller26: 26, controller27: 27, controller28: 28, controller29: 29, controller30: 30, controller31: 31, bankselectfine: 32, modulationwheelfine: 33, breathcontrollerfine: 34, controller35: 35, footcontrollerfine: 36, portamentotimefine: 37, dataentryfine: 38, volumefine: 39, balancefine: 40, controller41: 41, panfine: 42, expressionfine: 43, effectcontrol1fine: 44, effectcontrol2fine: 45, controller46: 46, controller47: 47, controller48: 48, controller49: 49, controller50: 50, controller51: 51, controller52: 52, controller53: 53, controller54: 54, controller55: 55, controller56: 56, controller57: 57, controller58: 58, controller59: 59, controller60: 60, controller61: 61, controller62: 62, controller63: 63, holdpedal: 64, portamento: 65, sustenutopedal: 66, softpedal: 67, legatopedal: 68, hold2pedal: 69, soundvariation: 70, resonance: 71, soundreleasetime: 72, soundattacktime: 73, brightness: 74, soundcontrol6: 75, soundcontrol7: 76, soundcontrol8: 77, soundcontrol9: 78, soundcontrol10: 79, generalpurposebutton1: 80, generalpurposebutton2: 81, generalpurposebutton3: 82, generalpurposebutton4: 83, controller84: 84, controller85: 85, controller86: 86, controller87: 87, controller88: 88, controller89: 89, controller90: 90, reverblevel: 91, tremololevel: 92, choruslevel: 93, celestelevel: 94, phaserlevel: 95, databuttonincrement: 96, databuttondecrement: 97, nonregisteredparametercoarse: 98, nonregisteredparameterfine: 99, registeredparametercoarse: 100, registeredparameterfine: 101, controller102: 102, controller103: 103, controller104: 104, controller105: 105, controller106: 106, controller107: 107, controller108: 108, controller109: 109, controller110: 110, controller111: 111, controller112: 112, controller113: 113, controller114: 114, controller115: 115, controller116: 116, controller117: 117, controller118: 118, controller119: 119, allsoundoff: 120, resetallcontrollers: 121, localcontrol: 122, allnotesoff: 123, omnimodeoff: 124, omnimodeon: 125, monomodeon: 126, polymodeon: 127 };
  }
  static get MIDI_REGISTERED_PARAMETERS() {
    return { pitchbendrange: [0, 0], channelfinetuning: [0, 1], channelcoarsetuning: [0, 2], tuningprogram: [0, 3], tuningbank: [0, 4], modulationrange: [0, 5], azimuthangle: [61, 0], elevationangle: [61, 1], gain: [61, 2], distanceratio: [61, 3], maximumdistance: [61, 4], maximumdistancegain: [61, 5], referencedistanceratio: [61, 6], panspreadangle: [61, 7], rollangle: [61, 8] };
  }
  static get MIDI_SYSTEM_MESSAGES() {
    return { sysex: 240, timecode: 241, songposition: 242, songselect: 243, tunerequest: 246, tuningrequest: 246, sysexend: 247, clock: 248, start: 250, continue: 251, stop: 252, activesensing: 254, reset: 255, midimessage: 0, unknownsystemmessage: -1 };
  }
  static get CHANNEL_EVENTS() {
    return ["noteoff", "controlchange", "noteon", "keyaftertouch", "programchange", "channelaftertouch", "pitchbend", "allnotesoff", "allsoundoff", "localcontrol", "monomode", "omnimode", "resetallcontrollers", "nrpn", "nrpn-dataentrycoarse", "nrpn-dataentryfine", "nrpn-databuttonincrement", "nrpn-databuttondecrement", "rpn", "rpn-dataentrycoarse", "rpn-dataentryfine", "rpn-databuttonincrement", "rpn-databuttondecrement"];
  }
};
var s$2 = class {
  constructor(e2, t2 = {}) {
    this.duration = d$3.defaults.note.duration, this.attack = d$3.defaults.note.attack, this.release = d$3.defaults.note.release, t2.duration != null && (this.duration = t2.duration), t2.attack != null && (this.attack = t2.attack), t2.rawAttack != null && (this.attack = r$6.from7bitToFloat(t2.rawAttack)), t2.release != null && (this.release = t2.release), t2.rawRelease != null && (this.release = r$6.from7bitToFloat(t2.rawRelease)), Number.isInteger(e2) ? this.identifier = r$6.toNoteIdentifier(e2) : this.identifier = e2;
  }
  get identifier() {
    return this._name + (this._accidental || "") + this._octave;
  }
  set identifier(e2) {
    const t2 = r$6.getNoteDetails(e2);
    if (d$3.validation && !e2)
      throw new Error("Invalid note identifier");
    this._name = t2.name, this._accidental = t2.accidental, this._octave = t2.octave;
  }
  get name() {
    return this._name;
  }
  set name(e2) {
    if (d$3.validation && (e2 = e2.toUpperCase(), !["C", "D", "E", "F", "G", "A", "B"].includes(e2)))
      throw new Error("Invalid name value");
    this._name = e2;
  }
  get accidental() {
    return this._accidental;
  }
  set accidental(e2) {
    if (d$3.validation && (e2 = e2.toLowerCase(), !["#", "##", "b", "bb"].includes(e2)))
      throw new Error("Invalid accidental value");
    this._accidental = e2;
  }
  get octave() {
    return this._octave;
  }
  set octave(e2) {
    if (d$3.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new Error("Invalid octave value");
    this._octave = e2;
  }
  get duration() {
    return this._duration;
  }
  set duration(e2) {
    if (d$3.validation && (e2 = parseFloat(e2), isNaN(e2) || e2 === null || e2 < 0))
      throw new RangeError("Invalid duration value.");
    this._duration = e2;
  }
  get attack() {
    return this._attack;
  }
  set attack(e2) {
    if (d$3.validation && (e2 = parseFloat(e2), isNaN(e2) || !(e2 >= 0 && e2 <= 1)))
      throw new RangeError("Invalid attack value.");
    this._attack = e2;
  }
  get release() {
    return this._release;
  }
  set release(e2) {
    if (d$3.validation && (e2 = parseFloat(e2), isNaN(e2) || !(e2 >= 0 && e2 <= 1)))
      throw new RangeError("Invalid release value.");
    this._release = e2;
  }
  get rawAttack() {
    return r$6.fromFloatTo7Bit(this._attack);
  }
  set rawAttack(e2) {
    this._attack = r$6.from7bitToFloat(e2);
  }
  get rawRelease() {
    return r$6.fromFloatTo7Bit(this._release);
  }
  set rawRelease(e2) {
    this._release = r$6.from7bitToFloat(e2);
  }
  get number() {
    return r$6.toNoteNumber(this.identifier);
  }
  getOffsetNumber(e2 = 0, t2 = 0) {
    return d$3.validation && (e2 = parseInt(e2) || 0, t2 = parseInt(t2) || 0), Math.min(Math.max(this.number + 12 * e2 + t2, 0), 127);
  }
};
var r$6 = class {
  static toNoteNumber(e2, t2 = 0) {
    if (t2 = t2 == null ? 0 : parseInt(t2), isNaN(t2))
      throw new RangeError("Invalid 'octaveOffset' value");
    typeof e2 != "string" && (e2 = "");
    const n2 = this.getNoteDetails(e2);
    if (!n2)
      throw new TypeError("Invalid note identifier");
    let s2 = 12 * (n2.octave + 1 + t2);
    if (s2 += { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 }[n2.name], n2.accidental && (n2.accidental.startsWith("b") ? s2 -= n2.accidental.length : s2 += n2.accidental.length), s2 < 0 || s2 > 127)
      throw new RangeError("Invalid octaveOffset value");
    return s2;
  }
  static getNoteDetails(e2) {
    Number.isInteger(e2) && (e2 = this.toNoteIdentifier(e2));
    const t2 = e2.match(/^([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)$/i);
    if (!t2)
      throw new TypeError("Invalid note identifier");
    const n2 = t2[1].toUpperCase(), s2 = parseInt(t2[3]);
    let r2 = t2[2].toLowerCase();
    return r2 = r2 === "" ? void 0 : r2, { accidental: r2, identifier: n2 + (r2 || "") + s2, name: n2, octave: s2 };
  }
  static sanitizeChannels(e2) {
    let t2;
    if (this.validation) {
      if (e2 === "all")
        t2 = ["all"];
      else if (e2 === "none")
        return [];
    }
    return t2 = Array.isArray(e2) ? e2 : [e2], t2.indexOf("all") > -1 && (t2 = n$6.MIDI_CHANNEL_NUMBERS), t2.map(function(e3) {
      return parseInt(e3);
    }).filter(function(e3) {
      return e3 >= 1 && e3 <= 16;
    });
  }
  static toTimestamp(e2) {
    let t2 = false;
    const n2 = parseFloat(e2);
    return !isNaN(n2) && (typeof e2 == "string" && e2.substring(0, 1) === "+" ? n2 >= 0 && (t2 = d$3.time + n2) : n2 >= 0 && (t2 = n2), t2);
  }
  static guessNoteNumber(e2, t2) {
    t2 = parseInt(t2) || 0;
    let n2 = false;
    if (Number.isInteger(e2) && e2 >= 0 && e2 <= 127)
      n2 = parseInt(e2);
    else if (parseInt(e2) >= 0 && parseInt(e2) <= 127)
      n2 = parseInt(e2);
    else if (typeof e2 == "string" || e2 instanceof String)
      try {
        n2 = this.toNoteNumber(e2.trim(), t2);
      } catch (e3) {
        return false;
      }
    return n2;
  }
  static toNoteIdentifier(e2, t2) {
    if (e2 = parseInt(e2), isNaN(e2) || e2 < 0 || e2 > 127)
      throw new RangeError("Invalid note number");
    if (t2 = t2 == null ? 0 : parseInt(t2), isNaN(t2))
      throw new RangeError("Invalid octaveOffset value");
    const n2 = Math.floor(e2 / 12 - 1) + t2;
    return ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"][e2 % 12] + n2.toString();
  }
  static buildNote(e2, t2 = {}) {
    if (t2.octaveOffset = parseInt(t2.octaveOffset) || 0, e2 instanceof s$2)
      return e2;
    let n2 = this.guessNoteNumber(e2, t2.octaveOffset);
    if (n2 === false)
      throw new TypeError(`The input could not be parsed as a note (${e2})`);
    return t2.octaveOffset = void 0, new s$2(n2, t2);
  }
  static buildNoteArray(e2, t2 = {}) {
    let n2 = [];
    return Array.isArray(e2) || (e2 = [e2]), e2.forEach((e3) => {
      n2.push(this.buildNote(e3, t2));
    }), n2;
  }
  static from7bitToFloat(e2) {
    return e2 === 1 / 0 && (e2 = 127), e2 = parseInt(e2) || 0, Math.min(Math.max(e2 / 127, 0), 1);
  }
  static fromFloatTo7Bit(e2) {
    return e2 === 1 / 0 && (e2 = 1), e2 = parseFloat(e2) || 0, Math.min(Math.max(Math.round(127 * e2), 0), 127);
  }
  static fromMsbLsbToFloat(e2, t2 = 0) {
    d$3.validation && (e2 = Math.min(Math.max(parseInt(e2) || 0, 0), 127), t2 = Math.min(Math.max(parseInt(t2) || 0, 0), 127));
    const n2 = ((e2 << 7) + t2) / 16383;
    return Math.min(Math.max(n2, 0), 1);
  }
  static fromFloatToMsbLsb(e2) {
    d$3.validation && (e2 = Math.min(Math.max(parseFloat(e2) || 0, 0), 1));
    const t2 = Math.round(16383 * e2);
    return { msb: t2 >> 7, lsb: 127 & t2 };
  }
  static offsetNumber(e2, t2 = 0, n2 = 0) {
    if (d$3.validation) {
      if (e2 = parseInt(e2), isNaN(e2))
        throw new Error("Invalid note number");
      t2 = parseInt(t2) || 0, n2 = parseInt(n2) || 0;
    }
    return Math.min(Math.max(e2 + 12 * t2 + n2, 0), 127);
  }
  static getPropertyByValue(e2, t2) {
    return Object.keys(e2).find((n2) => e2[n2] === t2);
  }
  static getCcNameByNumber(e2) {
    return r$6.getPropertyByValue(n$6.MIDI_CONTROL_CHANGE_MESSAGES, e2);
  }
  static getChannelModeByNumber(e2) {
    if (!(e2 >= 120 && e2 <= 127))
      return false;
    for (let t2 in n$6.MIDI_CHANNEL_MODE_MESSAGES)
      if (n$6.MIDI_CHANNEL_MODE_MESSAGES.hasOwnProperty(t2) && e2 === n$6.MIDI_CHANNEL_MODE_MESSAGES[t2])
        return t2;
    return false;
  }
  static get isNode() {
    return typeof process != "undefined" && process.versions != null && process.versions.node != null;
  }
  static get isBrowser() {
    return typeof window != "undefined" && window.document !== void 0;
  }
};
var a$6 = class extends e$6 {
  constructor(e2, t2) {
    super(), this._output = e2, this._number = t2, this._octaveOffset = 0;
  }
  destroy() {
    this._output = null, this._number = null, this._octaveOffset = 0, this.removeListener();
  }
  send(e2, t2 = { time: 0 }) {
    return this.output.send(e2, t2), this;
  }
  sendKeyAftertouch(e2, t2, s2 = {}) {
    if (d$3.validation) {
      if (s2.useRawValue && (s2.rawValue = s2.useRawValue), isNaN(parseFloat(t2)))
        throw new RangeError("Invalid key aftertouch value.");
      if (s2.rawValue) {
        if (!(t2 >= 0 && t2 <= 127 && Number.isInteger(t2)))
          throw new RangeError("Key aftertouch raw value must be an integer between 0 and 127.");
      } else if (!(t2 >= 0 && t2 <= 1))
        throw new RangeError("Key aftertouch value must be a float between 0 and 1.");
    }
    s2.rawValue || (t2 = r$6.fromFloatTo7Bit(t2));
    const a2 = d$3.octaveOffset + this.output.octaveOffset + this.octaveOffset;
    return Array.isArray(e2) || (e2 = [e2]), r$6.buildNoteArray(e2).forEach((e3) => {
      this.send([(n$6.MIDI_CHANNEL_MESSAGES.keyaftertouch << 4) + (this.number - 1), e3.getOffsetNumber(a2), t2], { time: r$6.toTimestamp(s2.time) });
    }), this;
  }
  sendControlChange(e2, t2, s2 = {}) {
    if (typeof e2 == "string" && (e2 = n$6.MIDI_CONTROL_CHANGE_MESSAGES[e2]), Array.isArray(t2) || (t2 = [t2]), d$3.validation) {
      if (e2 === void 0)
        throw new TypeError("Control change must be identified with a valid name or an integer between 0 and 127.");
      if (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127))
        throw new TypeError("Control change number must be an integer between 0 and 127.");
      if ((t2 = t2.map((e3) => {
        const t3 = Math.min(Math.max(parseInt(e3), 0), 127);
        if (isNaN(t3))
          throw new TypeError("Values must be integers between 0 and 127");
        return t3;
      })).length === 2 && e2 >= 32)
        throw new TypeError("To use a value array, the controller must be between 0 and 31");
    }
    return t2.forEach((a2, i2) => {
      this.send([(n$6.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), e2 + 32 * i2, t2[i2]], { time: r$6.toTimestamp(s2.time) });
    }), this;
  }
  _selectNonRegisteredParameter(e2, t2 = {}) {
    return this.sendControlChange(99, e2[0], t2), this.sendControlChange(98, e2[1], t2), this;
  }
  _deselectRegisteredParameter(e2 = {}) {
    return this.sendControlChange(101, 127, e2), this.sendControlChange(100, 127, e2), this;
  }
  _deselectNonRegisteredParameter(e2 = {}) {
    return this.sendControlChange(101, 127, e2), this.sendControlChange(100, 127, e2), this;
  }
  _selectRegisteredParameter(e2, t2 = {}) {
    return this.sendControlChange(101, e2[0], t2), this.sendControlChange(100, e2[1], t2), this;
  }
  _setCurrentParameter(e2, t2 = {}) {
    return e2 = [].concat(e2), this.sendControlChange(6, e2[0], t2), e2.length < 2 || this.sendControlChange(38, e2[1], t2), this;
  }
  sendRpnDecrement(e2, t2 = {}) {
    if (Array.isArray(e2) || (e2 = n$6.MIDI_REGISTERED_PARAMETERS[e2]), d$3.validation) {
      if (e2 === void 0)
        throw new TypeError("The specified registered parameter is invalid.");
      let t3 = false;
      if (Object.getOwnPropertyNames(n$6.MIDI_REGISTERED_PARAMETERS).forEach((s2) => {
        n$6.MIDI_REGISTERED_PARAMETERS[s2][0] === e2[0] && n$6.MIDI_REGISTERED_PARAMETERS[s2][1] === e2[1] && (t3 = true);
      }), !t3)
        throw new TypeError("The specified registered parameter is invalid.");
    }
    return this._selectRegisteredParameter(e2, t2), this.sendControlChange(97, 0, t2), this._deselectRegisteredParameter(t2), this;
  }
  sendRpnIncrement(e2, t2 = {}) {
    if (Array.isArray(e2) || (e2 = n$6.MIDI_REGISTERED_PARAMETERS[e2]), d$3.validation) {
      if (e2 === void 0)
        throw new TypeError("The specified registered parameter is invalid.");
      let t3 = false;
      if (Object.getOwnPropertyNames(n$6.MIDI_REGISTERED_PARAMETERS).forEach((s2) => {
        n$6.MIDI_REGISTERED_PARAMETERS[s2][0] === e2[0] && n$6.MIDI_REGISTERED_PARAMETERS[s2][1] === e2[1] && (t3 = true);
      }), !t3)
        throw new TypeError("The specified registered parameter is invalid.");
    }
    return this._selectRegisteredParameter(e2, t2), this.sendControlChange(96, 0, t2), this._deselectRegisteredParameter(t2), this;
  }
  playNote(e2, t2 = {}) {
    if (this.sendNoteOn(e2, t2), t2.duration > 0 && isFinite(String(t2.duration).trim() || NaN)) {
      let n2 = { time: (r$6.toTimestamp(t2.time) || d$3.time) + t2.duration, release: t2.release, rawRelease: t2.rawRelease };
      this.sendNoteOff(e2, n2);
    }
    return this;
  }
  sendNoteOff(e2, t2 = {}) {
    if (d$3.validation) {
      if (t2.rawRelease != null && !(t2.rawRelease >= 0 && t2.rawRelease <= 127))
        throw new RangeError("The 'rawRelease' option must be an integer between 0 and 127");
      if (t2.release != null && !(t2.release >= 0 && t2.release <= 1))
        throw new RangeError("The 'release' option must be an number between 0 and 1");
      t2.rawVelocity && (t2.rawRelease = t2.velocity, console.warn("The 'rawVelocity' option is deprecated. Use 'rawRelease' instead.")), t2.velocity && (t2.release = t2.velocity, console.warn("The 'velocity' option is deprecated. Use 'attack' instead."));
    }
    let s2 = 64;
    t2.rawRelease != null ? s2 = t2.rawRelease : isNaN(t2.release) || (s2 = Math.round(127 * t2.release));
    const a2 = d$3.octaveOffset + this.output.octaveOffset + this.octaveOffset;
    return r$6.buildNoteArray(e2, { rawRelease: parseInt(s2) }).forEach((e3) => {
      this.send([(n$6.MIDI_CHANNEL_MESSAGES.noteoff << 4) + (this.number - 1), e3.getOffsetNumber(a2), e3.rawRelease], { time: r$6.toTimestamp(t2.time) });
    }), this;
  }
  stopNote(e2, t2 = {}) {
    return this.sendNoteOff(e2, t2);
  }
  sendNoteOn(e2, t2 = {}) {
    if (d$3.validation) {
      if (t2.rawAttack != null && !(t2.rawAttack >= 0 && t2.rawAttack <= 127))
        throw new RangeError("The 'rawAttack' option must be an integer between 0 and 127");
      if (t2.attack != null && !(t2.attack >= 0 && t2.attack <= 1))
        throw new RangeError("The 'attack' option must be an number between 0 and 1");
      t2.rawVelocity && (t2.rawAttack = t2.velocity, t2.rawRelease = t2.release, console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' or 'rawRelease'.")), t2.velocity && (t2.attack = t2.velocity, console.warn("The 'velocity' option is deprecated. Use 'attack' instead."));
    }
    let s2 = 64;
    t2.rawAttack != null ? s2 = t2.rawAttack : isNaN(t2.attack) || (s2 = Math.round(127 * t2.attack));
    const a2 = d$3.octaveOffset + this.output.octaveOffset + this.octaveOffset;
    return r$6.buildNoteArray(e2, { rawAttack: s2 }).forEach((e3) => {
      this.send([(n$6.MIDI_CHANNEL_MESSAGES.noteon << 4) + (this.number - 1), e3.getOffsetNumber(a2), e3.rawAttack], { time: r$6.toTimestamp(t2.time) });
    }), this;
  }
  sendChannelMode(e2, t2 = 0, s2 = {}) {
    if (typeof e2 == "string" && (e2 = n$6.MIDI_CHANNEL_MODE_MESSAGES[e2]), d$3.validation) {
      if (e2 === void 0)
        throw new TypeError("Invalid channel mode message name or number.");
      if (isNaN(e2) || !(e2 >= 120 && e2 <= 127))
        throw new TypeError("Invalid channel mode message number.");
      if (isNaN(parseInt(t2)) || t2 < 0 || t2 > 127)
        throw new RangeError("Value must be an integer between 0 and 127.");
    }
    return this.send([(n$6.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), e2, t2], { time: r$6.toTimestamp(s2.time) }), this;
  }
  sendOmniMode(e2, t2 = {}) {
    return e2 === void 0 || e2 ? this.sendChannelMode("omnimodeon", 0, t2) : this.sendChannelMode("omnimodeoff", 0, t2), this;
  }
  sendChannelAftertouch(e2, t2 = {}) {
    if (d$3.validation) {
      if (isNaN(parseFloat(e2)))
        throw new RangeError("Invalid channel aftertouch value.");
      if (t2.rawValue) {
        if (!(e2 >= 0 && e2 <= 127 && Number.isInteger(e2)))
          throw new RangeError("Channel aftertouch raw value must be an integer between 0 and 127.");
      } else if (!(e2 >= 0 && e2 <= 1))
        throw new RangeError("Channel aftertouch value must be a float between 0 and 1.");
    }
    return this.send([(n$6.MIDI_CHANNEL_MESSAGES.channelaftertouch << 4) + (this.number - 1), Math.round(127 * e2)], { time: r$6.toTimestamp(t2.time) }), this;
  }
  sendMasterTuning(e2, t2 = {}) {
    if (e2 = parseFloat(e2) || 0, d$3.validation && !(e2 > -65 && e2 < 64))
      throw new RangeError("The value must be a decimal number larger than -65 and smaller than 64.");
    let n2 = Math.floor(e2) + 64, s2 = e2 - Math.floor(e2);
    s2 = Math.round((s2 + 1) / 2 * 16383);
    let r2 = s2 >> 7 & 127, a2 = 127 & s2;
    return this.sendRpnValue("channelcoarsetuning", n2, t2), this.sendRpnValue("channelfinetuning", [r2, a2], t2), this;
  }
  sendModulationRange(e2, t2, n2 = {}) {
    if (d$3.validation) {
      if (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127))
        throw new RangeError("The semitones value must be an integer between 0 and 127.");
      if (!(t2 == null || Number.isInteger(t2) && t2 >= 0 && t2 <= 127))
        throw new RangeError("If specified, the cents value must be an integer between 0 and 127.");
    }
    return t2 >= 0 && t2 <= 127 || (t2 = 0), this.sendRpnValue("modulationrange", [e2, t2], n2), this;
  }
  sendNrpnValue(e2, t2, n2 = {}) {
    if (t2 = [].concat(t2), d$3.validation) {
      if (!Array.isArray(e2) || !Number.isInteger(e2[0]) || !Number.isInteger(e2[1]))
        throw new TypeError("The specified NRPN is invalid.");
      if (!(e2[0] >= 0 && e2[0] <= 127))
        throw new RangeError("The first byte of the NRPN must be between 0 and 127.");
      if (!(e2[1] >= 0 && e2[1] <= 127))
        throw new RangeError("The second byte of the NRPN must be between 0 and 127.");
      t2.forEach((e3) => {
        if (!(e3 >= 0 && e3 <= 127))
          throw new RangeError("The data bytes of the NRPN must be between 0 and 127.");
      });
    }
    return this._selectNonRegisteredParameter(e2, n2), this._setCurrentParameter(t2, n2), this._deselectNonRegisteredParameter(n2), this;
  }
  sendPitchBend(e2, t2 = {}) {
    if (d$3.validation)
      if (t2.rawValue && Array.isArray(e2)) {
        if (!(e2[0] >= 0 && e2[0] <= 127))
          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
        if (!(e2[1] >= 0 && e2[1] <= 127))
          throw new RangeError("The pitch bend LSB must be an integer between 0 and 127.");
      } else if (t2.rawValue && !Array.isArray(e2)) {
        if (!(e2 >= 0 && e2 <= 127))
          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
      } else {
        if (isNaN(e2) || e2 === null)
          throw new RangeError("Invalid pitch bend value.");
        if (!(e2 >= -1 && e2 <= 1))
          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
      }
    let s2 = 0, a2 = 0;
    if (t2.rawValue && Array.isArray(e2))
      s2 = e2[0], a2 = e2[1];
    else if (t2.rawValue && !Array.isArray(e2))
      s2 = e2;
    else {
      const t3 = r$6.fromFloatToMsbLsb((e2 + 1) / 2);
      s2 = t3.msb, a2 = t3.lsb;
    }
    return this.send([(n$6.MIDI_CHANNEL_MESSAGES.pitchbend << 4) + (this.number - 1), a2, s2], { time: r$6.toTimestamp(t2.time) }), this;
  }
  sendPitchBendRange(e2, t2, n2 = {}) {
    if (d$3.validation) {
      if (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127))
        throw new RangeError("The semitones value must be an integer between 0 and 127.");
      if (!Number.isInteger(t2) || !(t2 >= 0 && t2 <= 127))
        throw new RangeError("The cents value must be an integer between 0 and 127.");
    }
    return this.sendRpnValue("pitchbendrange", [e2, t2], n2), this;
  }
  sendProgramChange(e2, t2 = {}) {
    if (e2 = parseInt(e2) || 0, d$3.validation && !(e2 >= 0 && e2 <= 127))
      throw new RangeError("The program number must be between 0 and 127.");
    return this.send([(n$6.MIDI_CHANNEL_MESSAGES.programchange << 4) + (this.number - 1), e2], { time: r$6.toTimestamp(t2.time) }), this;
  }
  sendRpnValue(e2, t2, s2 = {}) {
    if (Array.isArray(e2) || (e2 = n$6.MIDI_REGISTERED_PARAMETERS[e2]), d$3.validation) {
      if (!Number.isInteger(e2[0]) || !Number.isInteger(e2[1]))
        throw new TypeError("The specified NRPN is invalid.");
      if (!(e2[0] >= 0 && e2[0] <= 127))
        throw new RangeError("The first byte of the RPN must be between 0 and 127.");
      if (!(e2[1] >= 0 && e2[1] <= 127))
        throw new RangeError("The second byte of the RPN must be between 0 and 127.");
      [].concat(t2).forEach((e3) => {
        if (!(e3 >= 0 && e3 <= 127))
          throw new RangeError("The data bytes of the RPN must be between 0 and 127.");
      });
    }
    return this._selectRegisteredParameter(e2, s2), this._setCurrentParameter(t2, s2), this._deselectRegisteredParameter(s2), this;
  }
  sendTuningBank(e2, t2 = {}) {
    if (d$3.validation && (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127)))
      throw new RangeError("The tuning bank number must be between 0 and 127.");
    return this.sendRpnValue("tuningbank", e2, t2), this;
  }
  sendTuningProgram(e2, t2 = {}) {
    if (d$3.validation && (!Number.isInteger(e2) || !(e2 >= 0 && e2 <= 127)))
      throw new RangeError("The tuning program number must be between 0 and 127.");
    return this.sendRpnValue("tuningprogram", e2, t2), this;
  }
  sendLocalControl(e2, t2 = {}) {
    return e2 ? this.sendChannelMode("localcontrol", 127, t2) : this.sendChannelMode("localcontrol", 0, t2);
  }
  sendAllNotesOff(e2 = {}) {
    return this.sendChannelMode("allnotesoff", 0, e2);
  }
  sendAllSoundOff(e2 = {}) {
    return this.sendChannelMode("allsoundoff", 0, e2);
  }
  sendResetAllControllers(e2 = {}) {
    return this.sendChannelMode("resetallcontrollers", 0, e2);
  }
  sendPolyphonicMode(e2, t2 = {}) {
    return e2 === "mono" ? this.sendChannelMode("monomodeon", 0, t2) : this.sendChannelMode("polymodeon", 0, t2);
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
  get output() {
    return this._output;
  }
  get number() {
    return this._number;
  }
};
var i$6 = class extends e$6 {
  constructor(e2) {
    super(), this._midiOutput = e2, this._octaveOffset = 0, this.channels = [];
    for (let e3 = 1; e3 <= 16; e3++)
      this.channels[e3] = new a$6(this, e3);
    this._midiOutput.onstatechange = this._onStateChange.bind(this);
  }
  async destroy() {
    this.removeListener(), this.channels.forEach((e2) => e2.destroy()), this.channels = [], this._midiOutput.onstatechange = null, await this.close(), this._midiOutput = null;
  }
  _onStateChange(e2) {
    let t2 = { timestamp: d$3.time };
    e2.port.connection === "open" ? (t2.type = "opened", t2.target = this, t2.port = t2.target, this.emit("opened", t2)) : e2.port.connection === "closed" && e2.port.state === "connected" ? (t2.type = "closed", t2.target = this, t2.port = t2.target, this.emit("closed", t2)) : e2.port.connection === "closed" && e2.port.state === "disconnected" ? (t2.type = "disconnected", t2.port = { connection: e2.port.connection, id: e2.port.id, manufacturer: e2.port.manufacturer, name: e2.port.name, state: e2.port.state, type: e2.port.type }, this.emit("disconnected", t2)) : e2.port.connection === "pending" && e2.port.state === "disconnected" || console.warn("This statechange event was not caught:", e2.port.connection, e2.port.state);
  }
  async open() {
    try {
      return await this._midiOutput.open(), Promise.resolve(this);
    } catch (e2) {
      return Promise.reject(e2);
    }
  }
  async close() {
    this._midiOutput ? await this._midiOutput.close() : await Promise.resolve();
  }
  send(e2, t2 = { time: 0 }, n2 = 0) {
    if (e2 instanceof h$5 && (e2 = r$6.isNode ? e2.data : e2.rawData), e2 instanceof Uint8Array && r$6.isNode && (e2 = Array.from(e2)), d$3.validation) {
      if (Array.isArray(e2) || e2 instanceof Uint8Array || (e2 = [e2], Array.isArray(t2) && (e2 = e2.concat(t2)), t2 = isNaN(n2) ? { time: 0 } : { time: n2 }), !(parseInt(e2[0]) >= 128 && parseInt(e2[0]) <= 255))
        throw new RangeError("The first byte (status) must be an integer between 128 and 255.");
      e2.slice(1).forEach((e3) => {
        if (!((e3 = parseInt(e3)) >= 0 && e3 <= 255))
          throw new RangeError("Data bytes must be integers between 0 and 255.");
      }), t2 || (t2 = { time: 0 });
    }
    return this._midiOutput.send(e2, r$6.toTimestamp(t2.time)), this;
  }
  sendSysex(e2, t2 = [], s2 = {}) {
    if (e2 = [].concat(e2), t2 instanceof Uint8Array) {
      const r2 = new Uint8Array(1 + e2.length + t2.length + 1);
      r2[0] = n$6.MIDI_SYSTEM_MESSAGES.sysex, r2.set(Uint8Array.from(e2), 1), r2.set(t2, 1 + e2.length), r2[r2.length - 1] = n$6.MIDI_SYSTEM_MESSAGES.sysexend, this.send(r2, { time: s2.time });
    } else {
      const r2 = e2.concat(t2, n$6.MIDI_SYSTEM_MESSAGES.sysexend);
      this.send([n$6.MIDI_SYSTEM_MESSAGES.sysex].concat(r2), { time: s2.time });
    }
    return this;
  }
  clear() {
    return this._midiOutput.clear ? this._midiOutput.clear() : d$3.validation && console.warn("The 'clear()' method has not yet been implemented in your environment."), this;
  }
  sendTimecodeQuarterFrame(e2, t2 = {}) {
    if (d$3.validation && (e2 = parseInt(e2), isNaN(e2) || !(e2 >= 0 && e2 <= 127)))
      throw new RangeError("The value must be an integer between 0 and 127.");
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.timecode, e2], { time: t2.time }), this;
  }
  sendSongPosition(e2 = 0, t2 = {}) {
    var s2 = (e2 = Math.floor(e2) || 0) >> 7 & 127, r2 = 127 & e2;
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.songposition, s2, r2], { time: t2.time }), this;
  }
  sendSongSelect(e2 = 0, t2 = {}) {
    if (d$3.validation && (e2 = parseInt(e2), isNaN(e2) || !(e2 >= 0 && e2 <= 127)))
      throw new RangeError("The program value must be between 0 and 127");
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.songselect, e2], { time: t2.time }), this;
  }
  sendTuneRequest(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.tunerequest], { time: e2.time }), this;
  }
  sendClock(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.clock], { time: e2.time }), this;
  }
  sendStart(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.start], { time: e2.time }), this;
  }
  sendContinue(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.continue], { time: e2.time }), this;
  }
  sendStop(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.stop], { time: e2.time }), this;
  }
  sendActiveSensing(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.activesensing], { time: e2.time }), this;
  }
  sendReset(e2 = {}) {
    return this.send([n$6.MIDI_SYSTEM_MESSAGES.reset], { time: e2.time }), this;
  }
  sendTuningRequest(e2 = {}) {
    return d$3.validation && console.warn("The sendTuningRequest() method has been deprecated. Use sendTuningRequest() instead."), this.sendTuneRequest(e2);
  }
  sendKeyAftertouch(e2, t2, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendKeyAftertouch(e2, t2, s2);
    }), this;
  }
  sendControlChange(e2, t2, s2 = {}, a2 = {}) {
    if (d$3.validation && (Array.isArray(s2) || Number.isInteger(s2) || s2 === "all")) {
      const e3 = s2;
      (s2 = a2).channels = e3, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendControlChange(e2, t2, s2);
    }), this;
  }
  sendPitchBendRange(e2 = 0, t2 = 0, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendPitchBendRange(e2, t2, s2);
    }), this;
  }
  setPitchBendRange(e2 = 0, t2 = 0, s2 = "all", r2 = {}) {
    return d$3.validation && (console.warn("The setPitchBendRange() method is deprecated. Use sendPitchBendRange() instead."), r2.channels = s2, r2.channels === "all" && (r2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendPitchBendRange(e2, t2, r2);
  }
  sendRpnValue(e2, t2, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendRpnValue(e2, t2, s2);
    }), this;
  }
  setRegisteredParameter(e2, t2 = [], s2 = "all", r2 = {}) {
    return d$3.validation && (console.warn("The setRegisteredParameter() method is deprecated. Use sendRpnValue() instead."), r2.channels = s2, r2.channels === "all" && (r2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendRpnValue(e2, t2, r2);
  }
  sendChannelAftertouch(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendChannelAftertouch(e2, t2);
    }), this;
  }
  sendPitchBend(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendPitchBend(e2, t2);
    }), this;
  }
  sendProgramChange(e2 = 0, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendProgramChange(e2, t2);
    }), this;
  }
  sendModulationRange(e2, t2, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendModulationRange(e2, t2, s2);
    }), this;
  }
  setModulationRange(e2 = 0, t2 = 0, s2 = "all", r2 = {}) {
    return d$3.validation && (console.warn("The setModulationRange() method is deprecated. Use sendModulationRange() instead."), r2.channels = s2, r2.channels === "all" && (r2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendModulationRange(e2, t2, r2);
  }
  sendMasterTuning(e2, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendMasterTuning(e2, t2);
    }), this;
  }
  setMasterTuning(e2, t2 = {}, s2 = {}) {
    return d$3.validation && (console.warn("The setMasterTuning() method is deprecated. Use sendMasterTuning() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendMasterTuning(e2, s2);
  }
  sendTuningProgram(e2, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendTuningProgram(e2, t2);
    }), this;
  }
  setTuningProgram(e2, t2 = "all", s2 = {}) {
    return d$3.validation && (console.warn("The setTuningProgram() method is deprecated. Use sendTuningProgram() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendTuningProgram(e2, s2);
  }
  sendTuningBank(e2 = 0, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendTuningBank(e2, t2);
    }), this;
  }
  setTuningBank(e2, t2 = "all", s2 = {}) {
    return d$3.validation && (console.warn("The setTuningBank() method is deprecated. Use sendTuningBank() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendTuningBank(e2, s2);
  }
  sendChannelMode(e2, t2 = 0, s2 = {}, a2 = {}) {
    if (d$3.validation && (Array.isArray(s2) || Number.isInteger(s2) || s2 === "all")) {
      const e3 = s2;
      (s2 = a2).channels = e3, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendChannelMode(e2, t2, s2);
    }), this;
  }
  sendAllSoundOff(e2 = {}) {
    return e2.channels == null && (e2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(e2.channels).forEach((t2) => {
      this.channels[t2].sendAllSoundOff(e2);
    }), this;
  }
  sendAllNotesOff(e2 = {}) {
    return e2.channels == null && (e2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(e2.channels).forEach((t2) => {
      this.channels[t2].sendAllNotesOff(e2);
    }), this;
  }
  sendResetAllControllers(e2 = {}, t2 = {}) {
    if (d$3.validation && (Array.isArray(e2) || Number.isInteger(e2) || e2 === "all")) {
      const s2 = e2;
      (e2 = t2).channels = s2, e2.channels === "all" && (e2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return e2.channels == null && (e2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(e2.channels).forEach((t3) => {
      this.channels[t3].sendResetAllControllers(e2);
    }), this;
  }
  sendPolyphonicMode(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendPolyphonicMode(e2, t2);
    }), this;
  }
  sendLocalControl(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendLocalControl(e2, t2);
    }), this;
  }
  sendOmniMode(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendOmniMode(e2, t2);
    }), this;
  }
  sendNrpnValue(e2, t2, s2 = {}) {
    return s2.channels == null && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].sendNrpnValue(e2, t2, s2);
    }), this;
  }
  setNonRegisteredParameter(e2, t2 = [], s2 = "all", r2 = {}) {
    return d$3.validation && (console.warn("The setNonRegisteredParameter() method is deprecated. Use sendNrpnValue() instead."), r2.channels = s2, r2.channels === "all" && (r2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendNrpnValue(e2, t2, r2);
  }
  sendRpnIncrement(e2, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendRpnIncrement(e2, t2);
    }), this;
  }
  incrementRegisteredParameter(e2, t2 = "all", s2 = {}) {
    return d$3.validation && (console.warn("The incrementRegisteredParameter() method is deprecated. Use sendRpnIncrement() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendRpnIncrement(e2, s2);
  }
  sendRpnDecrement(e2, t2 = {}) {
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendRpnDecrement(e2, t2);
    }), this;
  }
  decrementRegisteredParameter(e2, t2 = "all", s2 = {}) {
    return d$3.validation && (console.warn("The decrementRegisteredParameter() method is deprecated. Use sendRpnDecrement() instead."), s2.channels = t2, s2.channels === "all" && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS)), this.sendRpnDecrement(e2, s2);
  }
  sendNoteOff(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendNoteOff(e2, t2);
    }), this;
  }
  stopNote(e2, t2) {
    return this.sendNoteOff(e2, t2);
  }
  playNote(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (t2.rawVelocity && console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' instead."), t2.velocity && console.warn("The 'velocity' option is deprecated. Use 'velocity' instead."), Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].playNote(e2, t2);
    }), this;
  }
  sendNoteOn(e2, t2 = {}, s2 = {}) {
    if (d$3.validation && (Array.isArray(t2) || Number.isInteger(t2) || t2 === "all")) {
      const e3 = t2;
      (t2 = s2).channels = e3, t2.channels === "all" && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS);
    }
    return t2.channels == null && (t2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(t2.channels).forEach((n2) => {
      this.channels[n2].sendNoteOn(e2, t2);
    }), this;
  }
  get name() {
    return this._midiOutput.name;
  }
  get id() {
    return this._midiOutput.id;
  }
  get connection() {
    return this._midiOutput.connection;
  }
  get manufacturer() {
    return this._midiOutput.manufacturer;
  }
  get state() {
    return this._midiOutput.state;
  }
  get type() {
    return this._midiOutput.type;
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
};
var o$6 = class {
  constructor(e2 = [], t2 = {}) {
    this.destinations = [], this.types = [...Object.keys(n$6.MIDI_SYSTEM_MESSAGES), ...Object.keys(n$6.MIDI_CHANNEL_MESSAGES)], this.channels = n$6.MIDI_CHANNEL_NUMBERS, this.suspended = false, Array.isArray(e2) || (e2 = [e2]), t2.types && !Array.isArray(t2.types) && (t2.types = [t2.types]), t2.channels && !Array.isArray(t2.channels) && (t2.channels = [t2.channels]), d$3.validation && (e2.forEach((e3) => {
      if (!(e3 instanceof i$6))
        throw new TypeError("Destinations must be of type 'Output'.");
    }), t2.types !== void 0 && t2.types.forEach((e3) => {
      if (!n$6.MIDI_SYSTEM_MESSAGES.hasOwnProperty(e3) && !n$6.MIDI_CHANNEL_MESSAGES.hasOwnProperty(e3))
        throw new TypeError("Type must be a valid message type.");
    }), t2.channels !== void 0 && t2.channels.forEach((e3) => {
      if (!n$6.MIDI_CHANNEL_NUMBERS.includes(e3))
        throw new TypeError("MIDI channel must be between 1 and 16.");
    })), this.destinations = e2, t2.types && (this.types = t2.types), t2.channels && (this.channels = t2.channels);
  }
  forward(e2) {
    this.suspended || this.types.includes(e2.type) && (e2.channel && !this.channels.includes(e2.channel) || this.destinations.forEach((t2) => {
      (!d$3.validation || t2 instanceof i$6) && t2.send(e2);
    }));
  }
};
var l$3 = class extends e$6 {
  constructor(e2, t2) {
    super(), this._input = e2, this._number = t2, this._octaveOffset = 0, this._nrpnBuffer = [], this._rpnBuffer = [], this.parameterNumberEventsEnabled = true, this.notesState = new Array(128).fill(false);
  }
  destroy() {
    this._input = null, this._number = null, this._octaveOffset = 0, this._nrpnBuffer = [], this.notesState = new Array(128).fill(false), this.parameterNumberEventsEnabled = false, this.removeListener();
  }
  _processMidiMessageEvent(e2) {
    const t2 = Object.assign({}, e2);
    t2.port = this.input, t2.target = this, t2.type = "midimessage", this.emit(t2.type, t2), this._parseEventForStandardMessages(t2);
  }
  _parseEventForStandardMessages(e2) {
    const t2 = Object.assign({}, e2);
    t2.type = t2.message.type || "unknownmessage";
    const n2 = e2.message.dataBytes[0], a2 = e2.message.dataBytes[1];
    if (t2.type === "noteoff" || t2.type === "noteon" && a2 === 0)
      this.notesState[n2] = false, t2.type = "noteoff", t2.note = new s$2(r$6.offsetNumber(n2, this.octaveOffset + this.input.octaveOffset + d$3.octaveOffset), { rawAttack: 0, rawRelease: a2 }), t2.value = r$6.from7bitToFloat(a2), t2.rawValue = a2, t2.velocity = t2.note.release, t2.rawVelocity = t2.note.rawRelease;
    else if (t2.type === "noteon")
      this.notesState[n2] = true, t2.note = new s$2(r$6.offsetNumber(n2, this.octaveOffset + this.input.octaveOffset + d$3.octaveOffset), { rawAttack: a2 }), t2.value = r$6.from7bitToFloat(a2), t2.rawValue = a2, t2.velocity = t2.note.attack, t2.rawVelocity = t2.note.rawAttack;
    else if (t2.type === "keyaftertouch")
      t2.note = new s$2(r$6.offsetNumber(n2, this.octaveOffset + this.input.octaveOffset + d$3.octaveOffset)), t2.value = r$6.from7bitToFloat(a2), t2.rawValue = a2, t2.identifier = t2.note.identifier, t2.key = t2.note.number, t2.rawKey = n2;
    else if (t2.type === "controlchange") {
      t2.controller = { number: n2, name: r$6.getCcNameByNumber(n2) }, t2.subtype = t2.controller.name || "controller" + n2, t2.value = r$6.from7bitToFloat(a2), t2.rawValue = a2;
      const e3 = Object.assign({}, t2);
      e3.type = `${t2.type}-controller${n2}`, delete e3.subtype, this.emit(e3.type, e3), t2.message.dataBytes[0] >= 120 && this._parseChannelModeMessage(t2), this.parameterNumberEventsEnabled && this._isRpnOrNrpnController(t2.message.dataBytes[0]) && this._parseEventForParameterNumber(t2);
    } else
      t2.type === "programchange" ? (t2.value = n2, t2.rawValue = t2.value) : t2.type === "channelaftertouch" ? (t2.value = r$6.from7bitToFloat(n2), t2.rawValue = n2) : t2.type === "pitchbend" ? (t2.value = ((a2 << 7) + n2 - 8192) / 8192, t2.rawValue = (a2 << 7) + n2) : t2.type = "unknownmessage";
    this.emit(t2.type, t2);
  }
  _parseChannelModeMessage(e2) {
    const t2 = Object.assign({}, e2);
    t2.type = t2.controller.name, t2.type === "localcontrol" && (t2.value = t2.message.data[2] === 127, t2.rawValue = t2.message.data[2]), t2.type === "omnimodeon" ? (t2.type = "omnimode", t2.value = true, t2.rawValue = t2.message.data[2]) : t2.type === "omnimodeoff" && (t2.type = "omnimode", t2.value = false, t2.rawValue = t2.message.data[2]), t2.type === "monomodeon" ? (t2.type = "monomode", t2.value = true, t2.rawValue = t2.message.data[2]) : t2.type === "polymodeon" && (t2.type = "monomode", t2.value = false, t2.rawValue = t2.message.data[2]), this.emit(t2.type, t2);
  }
  _parseEventForParameterNumber(e2) {
    const t2 = e2.message.dataBytes[0], s2 = e2.message.dataBytes[1], r2 = n$6.MIDI_CONTROL_CHANGE_MESSAGES;
    t2 === r2.nonregisteredparameterfine || t2 === r2.registeredparameterfine ? (this._nrpnBuffer = [], this._rpnBuffer = [], t2 === r2.nonregisteredparameterfine ? this._nrpnBuffer = [e2.message] : s2 !== 127 && (this._rpnBuffer = [e2.message])) : t2 === r2.nonregisteredparametercoarse || t2 === r2.registeredparametercoarse ? t2 === r2.nonregisteredparametercoarse ? (this._rpnBuffer = [], this._nrpnBuffer.length === 1 ? this._nrpnBuffer.push(e2.message) : this._nrpnBuffer = []) : (this._nrpnBuffer = [], this._rpnBuffer.length === 1 && s2 !== 127 ? this._rpnBuffer.push(e2.message) : this._rpnBuffer = []) : t2 !== r2.dataentrycoarse && t2 !== r2.dataentryfine && t2 !== r2.databuttonincrement && t2 !== r2.databuttondecrement || (this._rpnBuffer.length === 2 ? this._dispatchParameterNumberEvent("rpn", this._rpnBuffer[0].dataBytes[1], this._rpnBuffer[1].dataBytes[1], e2) : this._nrpnBuffer.length === 2 ? this._dispatchParameterNumberEvent("nrpn", this._nrpnBuffer[0].dataBytes[1], this._nrpnBuffer[1].dataBytes[1], e2) : (this._nrpnBuffer = [], this._rpnBuffer = []));
  }
  _isRpnOrNrpnController(e2) {
    return e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.dataentrycoarse || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.dataentryfine || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.databuttonincrement || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.databuttondecrement || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparametercoarse || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparameterfine || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.registeredparametercoarse || e2 === n$6.MIDI_CONTROL_CHANGE_MESSAGES.registeredparameterfine;
  }
  _dispatchParameterNumberEvent(e2, t2, s2, a2) {
    e2 = e2 === "nrpn" ? "nrpn" : "rpn";
    const i2 = { target: a2.target, timestamp: a2.timestamp, message: a2.message, parameterMsb: t2, parameterLsb: s2, value: r$6.from7bitToFloat(a2.message.dataBytes[1]), rawValue: a2.message.dataBytes[1] };
    i2.parameter = e2 === "rpn" ? Object.keys(n$6.MIDI_REGISTERED_PARAMETERS).find((e3) => n$6.MIDI_REGISTERED_PARAMETERS[e3][0] === t2 && n$6.MIDI_REGISTERED_PARAMETERS[e3][1] === s2) : (t2 << 7) + s2;
    const o2 = r$6.getPropertyByValue(n$6.MIDI_CONTROL_CHANGE_MESSAGES, a2.message.dataBytes[0]);
    i2.type = `${e2}-${o2}`, this.emit(i2.type, i2), i2.type = e2, i2.subtype = o2, this.emit(i2.type, i2);
  }
  getChannelModeByNumber(e2) {
    return d$3.validation && (console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class."), e2 = Math.floor(e2)), r$6.getChannelModeByNumber(e2);
  }
  getCcNameByNumber(e2) {
    if (d$3.validation && (console.warn("The 'getCcNameByNumber()' method has been moved to the 'Utilities' class."), !((e2 = parseInt(e2)) >= 0 && e2 <= 127)))
      throw new RangeError("Invalid control change number.");
    return r$6.getCcNameByNumber(e2);
  }
  getNoteState(e2) {
    e2 instanceof s$2 && (e2 = e2.identifier);
    const t2 = r$6.guessNoteNumber(e2, d$3.octaveOffset + this.input.octaveOffset + this.octaveOffset);
    return this.notesState[t2];
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
  get input() {
    return this._input;
  }
  get number() {
    return this._number;
  }
  get nrpnEventsEnabled() {
    return this.parameterNumberEventsEnabled;
  }
  set nrpnEventsEnabled(e2) {
    this.validation && (e2 = !!e2), this.parameterNumberEventsEnabled = e2;
  }
};
var h$5 = class {
  constructor(e2) {
    this.rawData = e2, this.data = Array.from(this.rawData), this.statusByte = this.rawData[0], this.rawDataBytes = this.rawData.slice(1), this.dataBytes = this.data.slice(1), this.isChannelMessage = false, this.isSystemMessage = false, this.command = void 0, this.channel = void 0, this.manufacturerId = void 0, this.type = void 0, this.statusByte < 240 ? (this.isChannelMessage = true, this.command = this.statusByte >> 4, this.channel = 1 + (15 & this.statusByte)) : (this.isSystemMessage = true, this.command = this.statusByte), this.isChannelMessage ? this.type = r$6.getPropertyByValue(n$6.MIDI_CHANNEL_MESSAGES, this.command) : this.isSystemMessage && (this.type = r$6.getPropertyByValue(n$6.MIDI_SYSTEM_MESSAGES, this.command)), this.statusByte === n$6.MIDI_SYSTEM_MESSAGES.sysex && (this.dataBytes[0] === 0 ? (this.manufacturerId = this.dataBytes.slice(0, 3), this.dataBytes = this.dataBytes.slice(3, this.rawDataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(3, this.rawDataBytes.length - 1)) : (this.manufacturerId = [this.dataBytes[0]], this.dataBytes = this.dataBytes.slice(1, this.dataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(1, this.rawDataBytes.length - 1)));
  }
};
var c$4 = class extends e$6 {
  constructor(e2) {
    super(), this._midiInput = e2, this._octaveOffset = 0, this.channels = [];
    for (let e3 = 1; e3 <= 16; e3++)
      this.channels[e3] = new l$3(this, e3);
    this._forwarders = [], this._midiInput.onstatechange = this._onStateChange.bind(this), this._midiInput.onmidimessage = this._onMidiMessage.bind(this);
  }
  async destroy() {
    this.removeListener(), this.channels.forEach((e2) => e2.destroy()), this.channels = [], this._forwarders = [], this._midiInput && (this._midiInput.onstatechange = null, this._midiInput.onmidimessage = null), await this.close(), this._midiInput = null;
  }
  _onStateChange(e2) {
    let t2 = { timestamp: d$3.time, target: this, port: this };
    e2.port.connection === "open" ? (t2.type = "opened", this.emit("opened", t2)) : e2.port.connection === "closed" && e2.port.state === "connected" ? (t2.type = "closed", this.emit("closed", t2)) : e2.port.connection === "closed" && e2.port.state === "disconnected" ? (t2.type = "disconnected", t2.port = { connection: e2.port.connection, id: e2.port.id, manufacturer: e2.port.manufacturer, name: e2.port.name, state: e2.port.state, type: e2.port.type }, this.emit("disconnected", t2)) : e2.port.connection === "pending" && e2.port.state === "disconnected" || console.warn("This statechange event was not caught: ", e2.port.connection, e2.port.state);
  }
  _onMidiMessage(e2) {
    const t2 = new h$5(e2.data), n2 = { port: this, target: this, message: t2, timestamp: e2.timeStamp, type: "midimessage", data: t2.data, rawData: t2.data, statusByte: t2.data[0], dataBytes: t2.dataBytes };
    this.emit("midimessage", n2), t2.isSystemMessage ? this._parseEvent(n2) : t2.isChannelMessage && this.channels[t2.channel]._processMidiMessageEvent(n2), this._forwarders.forEach((e3) => e3.forward(t2));
  }
  _parseEvent(e2) {
    const t2 = Object.assign({}, e2);
    t2.type = t2.message.type || "unknownmidimessage", t2.type === "songselect" && (t2.song = e2.data[1] + 1, t2.value = e2.data[1], t2.rawValue = t2.value), this.emit(t2.type, t2);
  }
  async open() {
    try {
      await this._midiInput.open();
    } catch (e2) {
      return Promise.reject(e2);
    }
    return Promise.resolve(this);
  }
  async close() {
    if (!this._midiInput)
      return Promise.resolve(this);
    try {
      await this._midiInput.close();
    } catch (e2) {
      return Promise.reject(e2);
    }
    return Promise.resolve(this);
  }
  getChannelModeByNumber() {
    d$3.validation && console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class.");
  }
  addListener(e2, t2, s2 = {}) {
    if (d$3.validation && typeof s2 == "function") {
      let e3 = t2 != null ? [].concat(t2) : void 0;
      t2 = s2, s2 = { channels: e3 };
    }
    if (n$6.CHANNEL_EVENTS.includes(e2)) {
      s2.channels === void 0 && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS);
      let a2 = [];
      return r$6.sanitizeChannels(s2.channels).forEach((n2) => {
        a2.push(this.channels[n2].addListener(e2, t2, s2));
      }), a2;
    }
    return super.addListener(e2, t2, s2);
  }
  addOneTimeListener(e2, t2, n2 = {}) {
    return n2.remaining = 1, this.addListener(e2, t2, n2);
  }
  on(e2, t2, n2, s2) {
    return this.addListener(e2, t2, n2, s2);
  }
  hasListener(e2, t2, s2 = {}) {
    if (d$3.validation && typeof s2 == "function") {
      let e3 = [].concat(t2);
      t2 = s2, s2 = { channels: e3 };
    }
    return n$6.CHANNEL_EVENTS.includes(e2) ? (s2.channels === void 0 && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), r$6.sanitizeChannels(s2.channels).every((n2) => this.channels[n2].hasListener(e2, t2))) : super.hasListener(e2, t2);
  }
  removeListener(e2, t2, s2 = {}) {
    if (d$3.validation && typeof s2 == "function") {
      let e3 = [].concat(t2);
      t2 = s2, s2 = { channels: e3 };
    }
    if (s2.channels === void 0 && (s2.channels = n$6.MIDI_CHANNEL_NUMBERS), e2 == null)
      return r$6.sanitizeChannels(s2.channels).forEach((e3) => {
        this.channels[e3] && this.channels[e3].removeListener();
      }), super.removeListener();
    n$6.CHANNEL_EVENTS.includes(e2) ? r$6.sanitizeChannels(s2.channels).forEach((n2) => {
      this.channels[n2].removeListener(e2, t2, s2);
    }) : super.removeListener(e2, t2, s2);
  }
  addForwarder(e2, t2 = {}) {
    let n2;
    return n2 = e2 instanceof o$6 ? e2 : new o$6(e2, t2), this._forwarders.push(n2), n2;
  }
  removeForwarder(e2) {
    this._forwarders = this._forwarders.filter((t2) => t2 !== e2);
  }
  hasForwarder(e2) {
    return this._forwarders.includes(e2);
  }
  get name() {
    return this._midiInput.name;
  }
  get id() {
    return this._midiInput.id;
  }
  get connection() {
    return this._midiInput.connection;
  }
  get manufacturer() {
    return this._midiInput.manufacturer;
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
  get state() {
    return this._midiInput.state;
  }
  get type() {
    return this._midiInput.type;
  }
  get nrpnEventsEnabled() {
    return d$3.validation && console.warn("The 'nrpnEventsEnabled' property has been moved to the 'InputChannel' class."), false;
  }
};
var d$3 = new class extends e$6 {
  constructor() {
    super(), this.defaults = { note: { attack: r$6.from7bitToFloat(64), release: r$6.from7bitToFloat(64), duration: 1 / 0 } }, this.interface = null, this.validation = true, this._inputs = [], this._disconnectedInputs = [], this._outputs = [], this._disconnectedOutputs = [], this._stateChangeQueue = [], this._octaveOffset = 0;
  }
  async enable(e2 = {}, t2 = false) {
    if (r$6.isNode) {
      try {
        window.navigator;
      } catch (e3) {
        global.navigator = await Object.getPrototypeOf(async function() {
        }).constructor('\n        let jzz = await import("jzz");\n        return jzz.default;\n        ')();
      }
      try {
        performance;
      } catch (e3) {
        global.performance = await Object.getPrototypeOf(async function() {
        }).constructor('\n        let perf_hooks = await import("perf_hooks");\n        return perf_hooks.performance;\n        ')();
      }
    }
    if (this.validation = e2.validation !== false, this.validation && (typeof e2 == "function" && (e2 = { callback: e2, sysex: t2 }), t2 && (e2.sysex = true)), this.enabled)
      return typeof e2.callback == "function" && e2.callback(), Promise.resolve();
    const n2 = { timestamp: this.time, target: this, type: "error", error: void 0 }, s2 = { timestamp: this.time, target: this, type: "midiaccessgranted" }, a2 = { timestamp: this.time, target: this, type: "enabled" };
    try {
      typeof e2.requestMIDIAccessFunction == "function" ? this.interface = await e2.requestMIDIAccessFunction({ sysex: e2.sysex, software: e2.software }) : this.interface = await navigator.requestMIDIAccess({ sysex: e2.sysex, software: e2.software });
    } catch (t3) {
      return n2.error = t3, this.emit("error", n2), typeof e2.callback == "function" && e2.callback(t3), Promise.reject(t3);
    }
    this.emit("midiaccessgranted", s2), this.interface.onstatechange = this._onInterfaceStateChange.bind(this);
    try {
      await this._updateInputsAndOutputs();
    } catch (t3) {
      return n2.error = t3, this.emit("error", n2), typeof e2.callback == "function" && e2.callback(t3), Promise.reject(t3);
    }
    return this.emit("enabled", a2), typeof e2.callback == "function" && e2.callback(), Promise.resolve(this);
  }
  async disable() {
    return this._destroyInputsAndOutputs().then(() => {
      navigator && typeof navigator.close == "function" && navigator.close(), this.interface && (this.interface.onstatechange = void 0), this.interface = null;
      let e2 = { timestamp: this.time, target: this, type: "disabled" };
      this.emit("disabled", e2), this.removeListener();
    });
  }
  getInputById(e2, t2 = { disconnected: false }) {
    if (this.validation) {
      if (!this.enabled)
        throw new Error("WebMidi is not enabled.");
      if (!e2)
        return;
    }
    if (t2.disconnected) {
      for (let t3 = 0; t3 < this._disconnectedInputs.length; t3++)
        if (this._disconnectedInputs[t3].id === e2.toString())
          return this._disconnectedInputs[t3];
    } else
      for (let t3 = 0; t3 < this.inputs.length; t3++)
        if (this.inputs[t3].id === e2.toString())
          return this.inputs[t3];
  }
  getInputByName(e2, t2 = { disconnected: false }) {
    if (this.validation) {
      if (!this.enabled)
        throw new Error("WebMidi is not enabled.");
      if (!e2)
        return;
      e2 = e2.toString();
    }
    if (t2.disconnected) {
      for (let t3 = 0; t3 < this._disconnectedInputs.length; t3++)
        if (~this._disconnectedInputs[t3].name.indexOf(e2))
          return this._disconnectedInputs[t3];
    } else
      for (let t3 = 0; t3 < this.inputs.length; t3++)
        if (~this.inputs[t3].name.indexOf(e2))
          return this.inputs[t3];
  }
  getOutputByName(e2, t2 = { disconnected: false }) {
    if (this.validation) {
      if (!this.enabled)
        throw new Error("WebMidi is not enabled.");
      if (!e2)
        return;
      e2 = e2.toString();
    }
    if (t2.disconnected) {
      for (let t3 = 0; t3 < this._disconnectedOutputs.length; t3++)
        if (~this._disconnectedOutputs[t3].name.indexOf(e2))
          return this._disconnectedOutputs[t3];
    } else
      for (let t3 = 0; t3 < this.outputs.length; t3++)
        if (~this.outputs[t3].name.indexOf(e2))
          return this.outputs[t3];
  }
  getOutputById(e2, t2 = { disconnected: false }) {
    if (this.validation) {
      if (!this.enabled)
        throw new Error("WebMidi is not enabled.");
      if (!e2)
        return;
    }
    if (t2.disconnected) {
      for (let t3 = 0; t3 < this._disconnectedOutputs.length; t3++)
        if (this._disconnectedOutputs[t3].id === e2.toString())
          return this._disconnectedOutputs[t3];
    } else
      for (let t3 = 0; t3 < this.outputs.length; t3++)
        if (this.outputs[t3].id === e2.toString())
          return this.outputs[t3];
  }
  noteNameToNumber(e2) {
    return this.validation && console.warn("The noteNameToNumber() method is deprecated. Use Utilities.toNoteNumber() instead."), r$6.toNoteNumber(e2, this.octaveOffset);
  }
  getOctave(e2) {
    return this.validation && (console.warn("The getOctave()is deprecated. Use Utilities.getNoteDetails() instead"), e2 = parseInt(e2)), !isNaN(e2) && e2 >= 0 && e2 <= 127 && r$6.getNoteDetails(r$6.offsetNumber(e2, this.octaveOffset)).octave;
  }
  sanitizeChannels(e2) {
    return this.validation && console.warn("The sanitizeChannels() method has been moved to the utilities class."), r$6.sanitizeChannels(e2);
  }
  toMIDIChannels(e2) {
    return this.validation && console.warn("The toMIDIChannels() method has been deprecated. Use Utilities.sanitizeChannels() instead."), r$6.sanitizeChannels(e2);
  }
  guessNoteNumber(e2) {
    return this.validation && console.warn("The guessNoteNumber() method has been deprecated. Use Utilities.guessNoteNumber() instead."), r$6.guessNoteNumber(e2, this.octaveOffset);
  }
  getValidNoteArray(e2, t2 = {}) {
    return this.validation && console.warn("The getValidNoteArray() method has been moved to the Utilities.buildNoteArray()"), r$6.buildNoteArray(e2, t2);
  }
  convertToTimestamp(e2) {
    return this.validation && console.warn("The convertToTimestamp() method has been moved to Utilities.toTimestamp()."), r$6.toTimestamp(e2);
  }
  async _destroyInputsAndOutputs() {
    let e2 = [];
    return this.inputs.forEach((t2) => e2.push(t2.destroy())), this.outputs.forEach((t2) => e2.push(t2.destroy())), Promise.all(e2).then(() => {
      this._inputs = [], this._outputs = [];
    });
  }
  _onInterfaceStateChange(e2) {
    this._updateInputsAndOutputs();
    let t2 = { timestamp: e2.timeStamp, type: e2.port.state, target: this };
    if (e2.port.state === "connected" && e2.port.connection === "open") {
      e2.port.type === "output" ? t2.port = this.getOutputById(e2.port.id) : e2.port.type === "input" && (t2.port = this.getInputById(e2.port.id)), this.emit(e2.port.state, t2);
      const n2 = Object.assign({}, t2);
      n2.type = "portschanged", this.emit(n2.type, n2);
    } else if (e2.port.state === "disconnected" && e2.port.connection === "pending") {
      e2.port.type === "input" ? t2.port = this.getInputById(e2.port.id, { disconnected: true }) : e2.port.type === "output" && (t2.port = this.getOutputById(e2.port.id, { disconnected: true })), this.emit(e2.port.state, t2);
      const n2 = Object.assign({}, t2);
      n2.type = "portschanged", this.emit(n2.type, n2);
    }
  }
  async _updateInputsAndOutputs() {
    return Promise.all([this._updateInputs(), this._updateOutputs()]);
  }
  async _updateInputs() {
    if (!this.interface)
      return;
    for (let e3 = this._inputs.length - 1; e3 >= 0; e3--) {
      const t2 = this._inputs[e3];
      Array.from(this.interface.inputs.values()).find((e4) => e4 === t2._midiInput) || (this._disconnectedInputs.push(t2), this._inputs.splice(e3, 1));
    }
    let e2 = [];
    return this.interface.inputs.forEach((t2) => {
      if (!this._inputs.find((e3) => e3._midiInput === t2)) {
        let n2 = this._disconnectedInputs.find((e3) => e3._midiInput === t2);
        n2 || (n2 = new c$4(t2)), this._inputs.push(n2), e2.push(n2.open());
      }
    }), Promise.all(e2);
  }
  async _updateOutputs() {
    if (!this.interface)
      return;
    for (let e3 = this._outputs.length - 1; e3 >= 0; e3--) {
      const t2 = this._outputs[e3];
      Array.from(this.interface.outputs.values()).find((e4) => e4 === t2._midiOutput) || (this._disconnectedOutputs.push(t2), this._outputs.splice(e3, 1));
    }
    let e2 = [];
    return this.interface.outputs.forEach((t2) => {
      if (!this._outputs.find((e3) => e3._midiOutput === t2)) {
        let n2 = this._disconnectedOutputs.find((e3) => e3._midiOutput === t2);
        n2 || (n2 = new i$6(t2)), this._outputs.push(n2), e2.push(n2.open());
      }
    }), Promise.all(e2);
  }
  get enabled() {
    return this.interface !== null;
  }
  get inputs() {
    return this._inputs;
  }
  get isNode() {
    return this.validation && console.warn("WebMidi.isNode has been deprecated. Use Utilities.isNode instead."), r$6.isNode;
  }
  get isBrowser() {
    return this.validation && console.warn("WebMidi.isBrowser has been deprecated. Use Utilities.isBrowser instead."), r$6.isBrowser;
  }
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(e2) {
    if (this.validation && (e2 = parseInt(e2), isNaN(e2)))
      throw new TypeError("The 'octaveOffset' property must be an integer.");
    this._octaveOffset = e2;
  }
  get outputs() {
    return this._outputs;
  }
  get supported() {
    return typeof navigator != "undefined" && navigator.requestMIDIAccess;
  }
  get sysexEnabled() {
    return !(!this.interface || !this.interface.sysexEnabled);
  }
  get time() {
    return performance.now();
  }
  get version() {
    return "3.0.21";
  }
  get CHANNEL_EVENTS() {
    return this.validation && console.warn("The CHANNEL_EVENTS enum has been moved to Enumerations.CHANNEL_EVENTS."), n$6.CHANNEL_EVENTS;
  }
  get MIDI_SYSTEM_MESSAGES() {
    return this.validation && console.warn("The MIDI_SYSTEM_MESSAGES enum has been moved to Enumerations.MIDI_SYSTEM_MESSAGES."), n$6.MIDI_SYSTEM_MESSAGES;
  }
  get MIDI_CHANNEL_MODE_MESSAGES() {
    return this.validation && console.warn("The MIDI_CHANNEL_MODE_MESSAGES enum has been moved to Enumerations.MIDI_CHANNEL_MODE_MESSAGES."), n$6.MIDI_CHANNEL_MODE_MESSAGES;
  }
  get MIDI_CONTROL_CHANGE_MESSAGES() {
    return this.validation && console.warn("The MIDI_CONTROL_CHANGE_MESSAGES enum has been moved to Enumerations.MIDI_CONTROL_CHANGE_MESSAGES."), n$6.MIDI_CONTROL_CHANGE_MESSAGES;
  }
  get MIDI_REGISTERED_PARAMETER() {
    return this.validation && console.warn("The MIDI_REGISTERED_PARAMETER enum has been moved to Enumerations.MIDI_REGISTERED_PARAMETERS."), this.MIDI_REGISTERED_PARAMETERS;
  }
  get NOTES() {
    return this.validation && console.warn("The NOTES enum has been deprecated."), ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  }
}();
d$3.constructor = null;
var noteKeys = {
  "KeyQ": { note: "F", offset: 1 },
  "Digit2": { note: "F#", offset: 1 },
  "KeyW": { note: "G", offset: 1 },
  "Digit3": { note: "G#", offset: 1 },
  "KeyE": { note: "A", offset: 1 },
  "Digit4": { note: "A#", offset: 1 },
  "KeyR": { note: "B", offset: 1 },
  "KeyT": { note: "C", offset: 2 },
  "Digit6": { note: "C#", offset: 2 },
  "KeyY": { note: "D", offset: 2 },
  "Digit7": { note: "D#", offset: 2 },
  "KeyU": { note: "E", offset: 2 },
  "KeyI": { note: "F", offset: 2 },
  "Digit9": { note: "F#", offset: 2 },
  "KeyO": { note: "G", offset: 2 },
  "Digit0": { note: "G#", offset: 2 },
  "KeyP": { note: "A", offset: 2 },
  "Minus": { note: "A#", offset: 2 },
  "BracketLeft": { note: "B", offset: 2 },
  "BracketRIght": { note: "C", offset: 3 },
  "KeyZ": { note: "C", offset: 0 },
  "KeyS": { note: "C#", offset: 0 },
  "KeyX": { note: "D", offset: 0 },
  "KeyD": { note: "D#", offset: 0 },
  "KeyC": { note: "E", offset: 0 },
  "KeyV": { note: "F", offset: 0 },
  "KeyG": { note: "F#", offset: 0 },
  "KeyB": { note: "G", offset: 0 },
  "KeyH": { note: "G#", offset: 0 },
  "KeyN": { note: "A", offset: 0 },
  "KeyJ": { note: "A#", offset: 0 },
  "KeyM": { note: "B", offset: 0 },
  "Comma": { note: "C", offset: 1 },
  "KeyL": { note: "C#", offset: 1 },
  "Period": { note: "D", offset: 1 },
  "Semicolon": { note: "D#", offset: 1 },
  "Slash": { note: "E", offset: 1 }
};
function setupKeyboard() {
  document.addEventListener("keydown", (e2) => {
    if (e2.code == "Digit1")
      midi$1.offset--;
    if (e2.code == "Equal")
      midi$1.offset++;
    if (e2.repeat || !midi$1.keyboard || !noteKeys[e2.code])
      return;
    if (e2.ctrlKey || e2.altKey || e2.metaKey)
      return;
    if (e2.code == "Slash")
      e2.preventDefault();
    playKey(noteKeys[e2.code].note, noteKeys[e2.code].offset);
  });
  document.addEventListener("keyup", (e2) => {
    if (!noteKeys[e2.code])
      return;
    playKey(noteKeys[e2.code].note, noteKeys[e2.code].offset, true);
  });
}
var midi$1 = reactive({
  enabled: false,
  initiated: false,
  out: true,
  inputs: {},
  outputs: {},
  forwards: {},
  playing: false,
  channels: {},
  channel: useStorage("global-midi-channel", 1),
  note: {
    pitch: 0,
    channel: 1
  },
  offset: useClamp(0, -2, 2),
  keyboard: true,
  cc: {},
  ccLearn: {},
  message: null,
  log: [],
  clock: 0,
  filter: useStorage("global-midi-filter", {}),
  available: computed(() => Object.entries(midi$1.outputs).length > 0),
  activeNotes: computed(() => {
    let notes2 = {};
    for (let ch in midi$1.channels) {
      for (let num2 in midi$1.channels[ch].activeNotes) {
        notes2[num2] = midi$1.channels[ch].activeNotes[num2];
      }
    }
    return notes2;
  }),
  activeChroma: computed(() => {
    let chroma2 = new Array(12);
    for (let num2 in midi$1.activeNotes) {
      chroma2[(num2 - 9) % 12] = num2;
    }
    return chroma2;
  })
});
function learnCC({ param, number, channel } = {}) {
  const val = ref(0);
  watch(() => midi$1.cc, (cc) => {
    if (channel && cc.channel != channel)
      return;
    if (number == cc.number)
      val.value = cc.value;
  });
  return val;
}
function playKey(name2, offset = 0, off, velocity = 1) {
  let noteName = name2 + (4 + offset + midi$1.offset);
  const note2 = new s$2(noteName, {
    attack: off ? 0 : velocity,
    release: off ? 0 : velocity
  });
  const ev = {
    type: off ? "noteoff" : "noteon",
    note: note2,
    port: { id: "PC Keyboard" },
    timestamp: midi$1.time,
    target: { number: 0 }
  };
  noteInOn(ev);
}
function useMidi() {
  if (!midi$1.initiated) {
    setupKeyboard();
    onMounted(() => {
      if (d$3.supported) {
        setupMidi();
      }
    });
    watchEffect(() => {
      if (!midi$1.out)
        return;
      let outs = Object.values(d$3.outputs);
      if (midi$1.playing) {
        outs.forEach((output) => {
          output.sendContinue();
        });
      } else {
        outs.forEach((output) => {
          output.sendStop();
        });
      }
    });
    midi$1.initiated = true;
  }
  return {
    midi: midi$1,
    midiAttack,
    midiRelease,
    midiOnce: midiOnce$1,
    setCC,
    WebMidi: d$3
  };
}
function setupMidi() {
  d$3.enable();
  d$3.addListener("enabled", (e2) => {
    midi$1.enabled = true;
    initMidi();
  });
  d$3.addListener("connected", (e2) => {
    initMidi();
  });
  d$3.addListener("disconnected", (e2) => {
    delete midi$1[e2.port.type + "s"][e2.port.id];
  });
  midi$1.initiated = true;
}
function initMidi() {
  midi$1.inputs = reactive({});
  d$3.inputs.forEach((input2) => {
    midi$1.enabled = true;
    midi$1.inputs[input2.id] = {
      name: input2.name,
      manufacturer: input2.manufacturer,
      forwarder: input2.addForwarder(),
      event: null,
      note: null,
      cc: null
    };
    input2.removeListener();
    input2.addListener("start", () => {
      midi$1.playing = true;
    });
    input2.addListener("stop", () => {
      midi$1.playing = false;
      midi$1.channels = {};
    });
    input2.addListener("midimessage", (ev) => {
      var _a2;
      if (((_a2 = ev == null ? void 0 : ev.message) == null ? void 0 : _a2.type) == "clock")
        return;
      midi$1.inputs[input2.id].event = ev;
      midi$1.message = ev.message;
      midi$1.log.unshift(ev);
      if (midi$1.log.length > 100)
        midi$1.log.pop();
    });
    input2.addListener("noteon", (ev) => {
      midi$1.inputs[input2.id].note = noteInOn(ev);
    }, {
      channels: "all"
    });
    input2.addListener("noteoff", (ev) => {
      midi$1.inputs[input2.id].note = noteInOn(ev);
    }, { channels: "all" });
    input2.addListener("controlchange", (ev) => {
      const cc = ccIn(ev);
      if (!cc)
        return;
      midi$1.inputs[input2.id].cc = cc;
      midi$1.cc = cc;
    }, {
      channels: "all"
    });
    input2.addListener("clock", (ev) => {
      midi$1.clock = ev.timestamp;
    });
  });
  midi$1.outputs = reactive({});
  d$3.outputs.forEach((output) => {
    midi$1.outputs[output.id] = {
      name: output.name,
      manufacturer: output.manufacturer
    };
  });
}
function noteInOn(ev) {
  let note2 = ev.note;
  note2.port = ev.port.id;
  note2.type = ev.type;
  note2.timestamp = ev.timestamp;
  note2.channel = ev.target.number;
  if (midi$1.filter[note2.channel])
    return;
  createChannel(note2.channel);
  midi$1.channels[note2.channel].notes[note2.number] = note2;
  if (ev.type == "noteoff") {
    note2.velocity = 0;
    delete midi$1.channels[note2.channel].activeNotes[note2.number];
  } else {
    note2.velocity = 120 * (ev.note.attack || 1);
    midi$1.channels[note2.channel].activeNotes[note2.number] = true;
  }
  note2.pitch = (note2.number + 3) % 12;
  note2.octA = Math.floor((note2.number + 3) / 12) - 1;
  midi$1.note = note2;
  return note2;
}
function ccIn(ev) {
  if (midi$1.filter[ev.target.number])
    return;
  let cc = {
    channel: ev.target.number,
    timestamp: ev.timestamp,
    number: ev.controller.number,
    value: ev.value,
    raw: ev.rawValue,
    port: ev.port.id
  };
  createChannel(cc.channel);
  midi$1.channels[cc.channel].cc[cc.number] = cc;
  return cc;
}
function createChannel(ch) {
  if (!midi$1.channels[ch]) {
    midi$1.channels[ch] = reactive({ num: ch, activeNotes: {}, notes: {}, cc: {} });
  }
}
function setVelocity(channel, note2, velocity) {
  var _a2, _b, _c;
  if ((_c = (_b = (_a2 = midi$1.channels) == null ? void 0 : _a2[channel]) == null ? void 0 : _b.notes) == null ? void 0 : _c[note2]) {
    midi$1.channels[channel].notes[note2].velocity = velocity;
  }
}
function midiAttack(note2, options2) {
  if (!midi$1.out)
    return;
  let channel = (note2 == null ? void 0 : note2.channel) || midi$1.channel;
  setVelocity(channel, note2 == null ? void 0 : note2.number, 100);
  d$3.outputs.forEach((output) => {
    output.playNote(note2.number, {
      channels: channel,
      ...options2
    });
  });
}
function midiPlay(note2, options2) {
  if (!midi$1.out)
    return;
  d$3.outputs.forEach((output) => {
    output.playNote(note2, {
      channels: midi$1.channel,
      ...options2
    });
  });
}
function midiStop(note2, options2) {
  if (!midi$1.out)
    return;
  if (note2) {
    d$3.outputs.forEach((output) => {
      output.stopNote(note2, { channels: midi$1.channel, ...options2 });
    });
  } else {
    d$3.outputs.forEach((output) => {
      output.sendAllNotesOff();
      output.sendAllSoundOff({ time: "+1" });
    });
  }
}
function midiRelease(note2) {
  if (!midi$1.out)
    return;
  if (note2) {
    let channel = (note2 == null ? void 0 : note2.channel) || midi$1.channel;
    setVelocity(channel, note2 == null ? void 0 : note2.number, 0);
    d$3.outputs.forEach((output) => {
      output.stopNote(note2.number, { channels: channel });
    });
  } else {
    d$3.outputs.forEach((output) => {
      output.sendAllNotesOff();
      output.sendAllSoundOff({ time: "+1" });
    });
  }
}
function midiOnce$1(note2, options2) {
  if (!midi$1.out || midi$1.filter[midi$1.channel])
    return;
  midiPlay(note2, options2);
  setTimeout(() => {
    midiStop(note2, options2);
  }, 300);
}
function setCC(cc, value) {
  if (!midi$1.out)
    return;
  d$3.outputs.forEach((output) => {
    output.sendControlChange(Number(cc.number), value, cc.channel);
  });
}
function stopAll() {
  if (!midi$1.out)
    return;
  midi$1.channels = {};
  midi$1.playing = false;
  d$3.outputs.forEach((output) => {
    output.sendAllNotesOff();
    output.sendAllSoundOff({ time: "+1" });
    output.sendReset();
  });
}
function forwardMidi(iid, oid) {
  var _a2, _b;
  const output = d$3.outputs.find((out) => out.id == oid);
  const destinations = midi$1.inputs[iid].forwarder.destinations;
  const index2 = destinations.indexOf(output);
  if (index2 == -1) {
    destinations.push(output);
    midi$1.forwards[iid] = midi$1.forwards[iid] || {};
    midi$1.forwards[iid][oid] = true;
  } else {
    destinations.splice(index2, 1);
    (_b = (_a2 = midi$1.forwards) == null ? void 0 : _a2[iid]) == null ? true : delete _b[oid];
  }
}
var quantizeModes = ["+0", "@8n", "@16n", "@32n"];
var synth = {
  state: reactive({
    midi: useStorage("synth-midi", true),
    initiated: false,
    mute: false,
    quantize: useCycleList(quantizeModes, { initialValue: "+0" }),
    volume: useClamp(1, 0, 2)
  }),
  params: reactive({
    maxPolyphony: 50,
    oscillator: {
      type: useStorage("synth-osc", "sawtooth8")
    },
    volume: -30,
    envelope: {
      attack: 0.01,
      decay: 0.1,
      sustain: 0.6,
      release: 1
    },
    filterEnvelope: {
      attack: 1e-3,
      decay: 0.7,
      sustain: 0.5,
      release: 1,
      baseFrequency: 60,
      octaves: 5
    }
  })
};
function useSynth() {
  if (!synth.state.initiated) {
    onKeyDown("Escape", () => {
      synthReleaseAll();
    });
    watch(() => synth.state.volume, (vol) => synth.poly && synth.poly.volume.rampTo(gainToDb(vol)));
    watch(synth.params, (params) => {
      if (synth.poly) {
        synth.poly.set(params);
      }
    }, { deep: true, immediate: true });
    watch(() => midi$1.note, (note2) => {
      if (!synth.state.midi)
        return;
      if (note2.velocity > 0) {
        synthAttack(Midi(note2.number).toFrequency(), note2.velocity / 127);
      } else {
        synthRelease(Midi(note2.number).toFrequency());
      }
    });
    watch(() => midi$1.playing, (play) => {
      if (!play)
        synthReleaseAll();
    });
  }
  return { init: init$2, synth, synthOnce, synthAttack, synthRelease, synthReleaseAll };
}
function init$2() {
  start();
  if (synth == null ? void 0 : synth.poly)
    return;
  const { channel } = createChannel$1("synth");
  synth.widener = new StereoWidener(0.7).connect(channel);
  synth.reverb = new Reverb(3).connect(synth.widener);
  synth.delay = new PingPongDelay({ delayTime: "16n", feedback: 0.3, wet: 0.3, maxDelay: "4n" }).connect(synth.widener);
  synth.pan = new AutoPanner({ frequency: "4n", depth: 0.4 }).connect(synth.reverb).connect(synth.delay).connect(synth.widener);
  synth.compressor = new Compressor().connect(synth.pan);
  synth.poly = new PolySynth(MonoSynth, synth.params).connect(synth.compressor);
  synth.pan.start();
}
function synthOnce(note2 = "A4", duration2 = "8n", time) {
  if (!synth.poly || synth.state.mute)
    return init$2();
  synth.poly.triggerAttackRelease(note2, duration2, time);
}
function synthAttack(note2, velocity) {
  if (!synth.poly || synth.state.mute)
    return init$2();
  synth.poly.triggerAttack(note2, synth.state.quantize.state, velocity);
}
function synthRelease(note2) {
  if (!synth.poly || synth.state.mute)
    return init$2();
  synth.poly.triggerRelease(note2, synth.state.quantize.state);
}
function synthReleaseAll() {
  if (!synth.poly || synth.state.mute)
    return init$2();
  synth.poly.releaseAll();
}
var fillStr = (s2, n2) => Array(Math.abs(n2) + 1).join(s2);
function deprecate(original, alternative, fn) {
  return function(...args) {
    console.warn(`${original} is deprecated. Use ${alternative}.`);
    return fn.apply(this, args);
  };
}
function isNamed(src) {
  return src !== null && typeof src === "object" && typeof src.name === "string" ? true : false;
}
function isPitch(pitch) {
  return pitch !== null && typeof pitch === "object" && typeof pitch.step === "number" && typeof pitch.alt === "number" ? true : false;
}
var FIFTHS = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS = FIFTHS.map((fifths) => Math.floor(fifths * 7 / 12));
function encode$1(pitch) {
  const { step, alt, oct, dir = 1 } = pitch;
  const f2 = FIFTHS[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f2];
  }
  const o2 = oct - STEPS_TO_OCTS[step] - 4 * alt;
  return [dir * f2, dir * o2];
}
var FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];
function decode(coord) {
  const [f2, o2, dir] = coord;
  const step = FIFTHS_TO_STEPS[unaltered(f2)];
  const alt = Math.floor((f2 + 1) / 7);
  if (o2 === void 0) {
    return { step, alt, dir };
  }
  const oct = o2 + 4 * alt + STEPS_TO_OCTS[step];
  return { step, alt, oct, dir };
}
function unaltered(f2) {
  const i2 = (f2 + 1) % 7;
  return i2 < 0 ? 7 + i2 : i2;
}
var NoNote = { empty: true, name: "", pc: "", acc: "" };
var cache$1 = /* @__PURE__ */ new Map();
var stepToLetter = (step) => "CDEFGAB".charAt(step);
var altToAcc = (alt) => alt < 0 ? fillStr("b", -alt) : fillStr("#", alt);
var accToAlt = (acc) => acc[0] === "b" ? -acc.length : acc.length;
function note(src) {
  const cached = cache$1.get(src);
  if (cached) {
    return cached;
  }
  const value = typeof src === "string" ? parse$1(src) : isPitch(src) ? note(pitchName$1(src)) : isNamed(src) ? note(src.name) : NoNote;
  cache$1.set(src, value);
  return value;
}
var REGEX$1 = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function tokenizeNote(str) {
  const m2 = REGEX$1.exec(str);
  return [m2[1].toUpperCase(), m2[2].replace(/x/g, "##"), m2[3], m2[4]];
}
function coordToNote(noteCoord) {
  return note(decode(noteCoord));
}
var mod = (n2, m2) => (n2 % m2 + m2) % m2;
var SEMI = [0, 2, 4, 5, 7, 9, 11];
function parse$1(noteName) {
  const tokens = tokenizeNote(noteName);
  if (tokens[0] === "" || tokens[3] !== "") {
    return NoNote;
  }
  const letter = tokens[0];
  const acc = tokens[1];
  const octStr = tokens[2];
  const step = (letter.charCodeAt(0) + 3) % 7;
  const alt = accToAlt(acc);
  const oct = octStr.length ? +octStr : void 0;
  const coord = encode$1({ step, alt, oct });
  const name2 = letter + acc + octStr;
  const pc = letter + acc;
  const chroma2 = (SEMI[step] + alt + 120) % 12;
  const height = oct === void 0 ? mod(SEMI[step] + alt, 12) - 12 * 99 : SEMI[step] + alt + 12 * (oct + 1);
  const midi2 = height >= 0 && height <= 127 ? height : null;
  const freq2 = oct === void 0 ? null : Math.pow(2, (height - 69) / 12) * 440;
  return {
    empty: false,
    acc,
    alt,
    chroma: chroma2,
    coord,
    freq: freq2,
    height,
    letter,
    midi: midi2,
    name: name2,
    oct,
    pc,
    step
  };
}
function pitchName$1(props) {
  const { step, alt, oct } = props;
  const letter = stepToLetter(step);
  if (!letter) {
    return "";
  }
  const pc = letter + altToAcc(alt);
  return oct || oct === 0 ? pc + oct : pc;
}
var NoInterval = { empty: true, name: "", acc: "" };
var INTERVAL_TONAL_REGEX = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX$2 = new RegExp("^" + INTERVAL_TONAL_REGEX + "|" + INTERVAL_SHORTHAND_REGEX + "$");
function tokenizeInterval(str) {
  const m2 = REGEX$2.exec(`${str}`);
  if (m2 === null) {
    return ["", ""];
  }
  return m2[1] ? [m2[1], m2[2]] : [m2[4], m2[3]];
}
var cache$2 = {};
function interval(src) {
  return typeof src === "string" ? cache$2[src] || (cache$2[src] = parse(src)) : isPitch(src) ? interval(pitchName(src)) : isNamed(src) ? interval(src.name) : NoInterval;
}
var SIZES = [0, 2, 4, 5, 7, 9, 11];
var TYPES = "PMMPPMM";
function parse(str) {
  const tokens = tokenizeInterval(str);
  if (tokens[0] === "") {
    return NoInterval;
  }
  const num2 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num2) - 1) % 7;
  const t2 = TYPES[step];
  if (t2 === "M" && q === "P") {
    return NoInterval;
  }
  const type = t2 === "M" ? "majorable" : "perfectable";
  const name2 = "" + num2 + q;
  const dir = num2 < 0 ? -1 : 1;
  const simple = num2 === 8 || num2 === -8 ? num2 : dir * (step + 1);
  const alt = qToAlt(type, q);
  const oct = Math.floor((Math.abs(num2) - 1) / 7);
  const semitones = dir * (SIZES[step] + alt + 12 * oct);
  const chroma2 = (dir * (SIZES[step] + alt) % 12 + 12) % 12;
  const coord = encode$1({ step, alt, oct, dir });
  return {
    empty: false,
    name: name2,
    num: num2,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones,
    chroma: chroma2,
    coord,
    oct
  };
}
function qToAlt(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num2 = calcNum === 0 ? step + 1 : calcNum;
  const d2 = dir < 0 ? "-" : "";
  const type = TYPES[step] === "M" ? "majorable" : "perfectable";
  const name2 = d2 + num2 + altToQ(type, alt);
  return name2;
}
function altToQ(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr("A", alt);
  } else {
    return fillStr("d", type === "perfectable" ? alt : alt + 1);
  }
}
function transpose$1(noteName, intervalName) {
  const note$1 = note(noteName);
  const interval$1 = interval(intervalName);
  if (note$1.empty || interval$1.empty) {
    return "";
  }
  const noteCoord = note$1.coord;
  const intervalCoord = interval$1.coord;
  const tr2 = noteCoord.length === 1 ? [noteCoord[0] + intervalCoord[0]] : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];
  return coordToNote(tr2).name;
}
function ascR(b2, n2) {
  const a2 = [];
  for (; n2--; a2[n2] = n2 + b2)
    ;
  return a2;
}
function descR(b2, n2) {
  const a2 = [];
  for (; n2--; a2[n2] = b2 - n2)
    ;
  return a2;
}
function range2(from, to) {
  return from < to ? ascR(from, to - from + 1) : descR(from, from - to + 1);
}
function rotate(times, arr) {
  const len = arr.length;
  const n2 = (times % len + len) % len;
  return arr.slice(n2, len).concat(arr.slice(0, n2));
}
function compact(arr) {
  return arr.filter((n2) => n2 === 0 || n2);
}
var EmptyPcset = {
  empty: true,
  name: "",
  setNum: 0,
  chroma: "000000000000",
  normalized: "000000000000",
  intervals: []
};
var setNumToChroma = (num2) => Number(num2).toString(2);
var chromaToNumber = (chroma2) => parseInt(chroma2, 2);
var REGEX = /^[01]{12}$/;
function isChroma(set) {
  return REGEX.test(set);
}
var isPcsetNum = (set) => typeof set === "number" && set >= 0 && set <= 4095;
var isPcset = (set) => set && isChroma(set.chroma);
var cache = { [EmptyPcset.chroma]: EmptyPcset };
function get$5(src) {
  const chroma2 = isChroma(src) ? src : isPcsetNum(src) ? setNumToChroma(src) : Array.isArray(src) ? listToChroma(src) : isPcset(src) ? src.chroma : EmptyPcset.chroma;
  return cache[chroma2] = cache[chroma2] || chromaToPcset(chroma2);
}
var pcset = deprecate("Pcset.pcset", "Pcset.get", get$5);
var chroma$1 = (set) => get$5(set).chroma;
var intervals$1 = (set) => get$5(set).intervals;
var num = (set) => get$5(set).setNum;
var IVLS = [
  "1P",
  "2m",
  "2M",
  "3m",
  "3M",
  "4P",
  "5d",
  "5P",
  "6m",
  "6M",
  "7m",
  "7M"
];
function chromaToIntervals(chroma2) {
  const intervals2 = [];
  for (let i2 = 0; i2 < 12; i2++) {
    if (chroma2.charAt(i2) === "1")
      intervals2.push(IVLS[i2]);
  }
  return intervals2;
}
function chromas() {
  return range2(2048, 4095).map(setNumToChroma);
}
function modes$1(set, normalize = true) {
  const pcs = get$5(set);
  const binary = pcs.chroma.split("");
  return compact(binary.map((_, i2) => {
    const r2 = rotate(i2, binary);
    return normalize && r2[0] === "0" ? null : r2.join("");
  }));
}
function isEqual(s1, s2) {
  return get$5(s1).setNum === get$5(s2).setNum;
}
function isSubsetOf(set) {
  const s2 = get$5(set).setNum;
  return (notes2) => {
    const o2 = get$5(notes2).setNum;
    return s2 && s2 !== o2 && (o2 & s2) === o2;
  };
}
function isSupersetOf(set) {
  const s2 = get$5(set).setNum;
  return (notes2) => {
    const o2 = get$5(notes2).setNum;
    return s2 && s2 !== o2 && (o2 | s2) === o2;
  };
}
function isNoteIncludedIn(set) {
  const s2 = get$5(set);
  return (noteName) => {
    const n2 = note(noteName);
    return s2 && !n2.empty && s2.chroma.charAt(n2.chroma) === "1";
  };
}
function filter(set) {
  const isIncluded = isNoteIncludedIn(set);
  return (notes2) => {
    return notes2.filter(isIncluded);
  };
}
var index$5 = {
  get: get$5,
  chroma: chroma$1,
  num,
  intervals: intervals$1,
  chromas,
  isSupersetOf,
  isSubsetOf,
  isNoteIncludedIn,
  isEqual,
  filter,
  modes: modes$1,
  pcset
};
function chromaRotations(chroma2) {
  const binary = chroma2.split("");
  return binary.map((_, i2) => rotate(i2, binary).join(""));
}
function chromaToPcset(chroma2) {
  const setNum = chromaToNumber(chroma2);
  const normalizedNum = chromaRotations(chroma2).map(chromaToNumber).filter((n2) => n2 >= 2048).sort()[0];
  const normalized = setNumToChroma(normalizedNum);
  const intervals2 = chromaToIntervals(chroma2);
  return {
    empty: false,
    name: "",
    setNum,
    chroma: chroma2,
    normalized,
    intervals: intervals2
  };
}
function listToChroma(set) {
  if (set.length === 0) {
    return EmptyPcset.chroma;
  }
  let pitch;
  const binary = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (let i2 = 0; i2 < set.length; i2++) {
    pitch = note(set[i2]);
    if (pitch.empty)
      pitch = interval(set[i2]);
    if (!pitch.empty)
      binary[pitch.chroma] = 1;
  }
  return binary.join("");
}
var CHORDS = [
  ["1P 3M 5P", "major", "M ^ "],
  ["1P 3M 5P 7M", "major seventh", "maj7 \u0394 ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 \u03949 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth/ninth", "6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 \u0394#4 \u0394#11 M7#11 ^7#11 maj7#11"
  ],
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -\u03947 m\u0394 -^7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  ["1P 3m 5d", "diminished", "dim \xB0 o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 \xB07 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 \xF8 -7b5 h7 h"],
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 \u03949#11 ^9#11"
  ],
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
var NoChordType = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
var dictionary$1 = [];
var index$4 = {};
function get$4(type) {
  return index$4[type] || NoChordType;
}
var chordType$1 = deprecate("ChordType.chordType", "ChordType.get", get$4);
function names$3() {
  return dictionary$1.map((chord) => chord.name).filter((x2) => x2);
}
function symbols() {
  return dictionary$1.map((chord) => chord.aliases[0]).filter((x2) => x2);
}
function keys$1() {
  return Object.keys(index$4);
}
function all$1() {
  return dictionary$1.slice();
}
var entries$1 = deprecate("ChordType.entries", "ChordType.all", all$1);
function removeAll$1() {
  dictionary$1 = [];
  index$4 = {};
}
function add$1(intervals2, aliases, fullName) {
  const quality = getQuality(intervals2);
  const chord = {
    ...get$5(intervals2),
    name: fullName || "",
    quality,
    intervals: intervals2,
    aliases
  };
  dictionary$1.push(chord);
  if (chord.name) {
    index$4[chord.name] = chord;
  }
  index$4[chord.setNum] = chord;
  index$4[chord.chroma] = chord;
  chord.aliases.forEach((alias) => addAlias$1(chord, alias));
}
function addAlias$1(chord, alias) {
  index$4[alias] = chord;
}
function getQuality(intervals2) {
  const has = (interval2) => intervals2.indexOf(interval2) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
CHORDS.forEach(([ivls, fullName, names2]) => add$1(ivls.split(" "), names2.split(" "), fullName));
dictionary$1.sort((a2, b2) => a2.setNum - b2.setNum);
var index$1$2 = {
  names: names$3,
  symbols,
  get: get$4,
  all: all$1,
  add: add$1,
  removeAll: removeAll$1,
  keys: keys$1,
  entries: entries$1,
  chordType: chordType$1
};
var SCALES = [
  ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
  ["1P 3M 4P 5P 7M", "ionian pentatonic"],
  ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
  ["1P 2M 4P 5P 6M", "ritusen"],
  ["1P 2M 4P 5P 7m", "egyptian"],
  ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
  ["1P 3m 4P 5P 6m", "vietnamese 1"],
  ["1P 2m 3m 5P 6m", "pelog"],
  ["1P 2m 4P 5P 6m", "kumoijoshi"],
  ["1P 2M 3m 5P 6m", "hirajoshi"],
  ["1P 2m 4P 5d 7m", "iwato"],
  ["1P 2m 4P 5P 7m", "in-sen"],
  ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
  ["1P 3m 4P 6m 7m", "malkos raga"],
  ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
  ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
  ["1P 3m 4P 5P 6M", "minor six pentatonic"],
  ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
  ["1P 2M 3M 5P 6m", "flat six pentatonic"],
  ["1P 2m 3M 5P 6M", "scriabin"],
  ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
  ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
  ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
  ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
  ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
  ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
  ["1P 2A 3M 5P 5A 7M", "augmented"],
  ["1P 2M 3m 3M 5P 6M", "major blues"],
  ["1P 2M 4P 5P 6M 7m", "piongio"],
  ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
  ["1P 2M 3M 4A 6M 7m", "prometheus"],
  ["1P 2m 3M 5d 6m 7m", "mystery #1"],
  ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
  ["1P 2M 3M 4A 5A 7m", "whole tone", "messiaen's mode #1"],
  ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
  ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
  ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
  ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
  ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
  [
    "1P 2m 2A 3M 4A 6m 7m",
    "altered",
    "super locrian",
    "diminished whole tone",
    "pomeroy"
  ],
  ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
  [
    "1P 2M 3M 4P 5P 6m 7m",
    "mixolydian b6",
    "melodic minor fifth mode",
    "hindu"
  ],
  ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
  ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
  ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
  [
    "1P 2m 3m 4P 5P 6M 7m",
    "dorian b2",
    "phrygian #6",
    "melodic minor second mode"
  ],
  ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
  ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
  [
    "1P 2m 3m 4d 5d 6m 7d",
    "ultralocrian",
    "superlocrian bb7",
    "superlocrian diminished"
  ],
  ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
  ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
  [
    "1P 2M 3m 4A 5P 6M 7m",
    "dorian #4",
    "ukrainian dorian",
    "romanian minor",
    "altered dorian"
  ],
  ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
  ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
  ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
  ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
  ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
  ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
  ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
  ["1P 2M 3m 4P 5P 6m 7m", "aeolian", "minor"],
  ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
  ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
  ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
  ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
  ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
  ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
  ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
  ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
  ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
  ["1P 2m 3M 4P 5d 6m 7M", "persian"],
  ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
  ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
  [
    "1P 2M 3M 4P 5A 6M 7M",
    "major augmented",
    "major #5",
    "ionian augmented",
    "ionian #5"
  ],
  ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
  ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
  ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
  ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
  ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
  ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
  ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
  ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
  ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
  ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
  ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
  ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
  [
    "1P 2m 3m 3M 4A 5P 6M 7m",
    "half-whole diminished",
    "dominant diminished",
    "messiaen's mode #2"
  ],
  ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
  ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
  ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
  ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
  ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
  ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
];
var NoScaleType = {
  ...EmptyPcset,
  intervals: [],
  aliases: []
};
var dictionary = [];
var index$3 = {};
function names$2() {
  return dictionary.map((scale2) => scale2.name);
}
function get$3(type) {
  return index$3[type] || NoScaleType;
}
var scaleType$1 = deprecate("ScaleDictionary.scaleType", "ScaleType.get", get$3);
function all() {
  return dictionary.slice();
}
var entries = deprecate("ScaleDictionary.entries", "ScaleType.all", all);
function keys() {
  return Object.keys(index$3);
}
function removeAll() {
  dictionary = [];
  index$3 = {};
}
function add(intervals2, name2, aliases = []) {
  const scale2 = { ...get$5(intervals2), name: name2, intervals: intervals2, aliases };
  dictionary.push(scale2);
  index$3[scale2.name] = scale2;
  index$3[scale2.setNum] = scale2;
  index$3[scale2.chroma] = scale2;
  scale2.aliases.forEach((alias) => addAlias(scale2, alias));
  return scale2;
}
function addAlias(scale2, alias) {
  index$3[alias] = scale2;
}
SCALES.forEach(([ivls, name2, ...aliases]) => add(ivls.split(" "), name2, aliases));
var index$1$1 = {
  names: names$2,
  get: get$3,
  all,
  add,
  removeAll,
  keys,
  entries,
  scaleType: scaleType$1
};
var L2 = Math.log(2);
var L440 = Math.log(440);
function freqToMidi(freq2) {
  const v2 = 12 * (Math.log(freq2) - L440) / L2 + 69;
  return Math.round(v2 * 100) / 100;
}
var SHARPS = "C C# D D# E F F# G G# A A# B".split(" ");
var FLATS = "C Db D Eb E F Gb G Ab A Bb B".split(" ");
function midiToNoteName(midi2, options2 = {}) {
  if (isNaN(midi2) || midi2 === -Infinity || midi2 === Infinity)
    return "";
  midi2 = Math.round(midi2);
  const pcs = options2.sharps === true ? SHARPS : FLATS;
  const pc = pcs[midi2 % 12];
  if (options2.pitchClass) {
    return pc;
  }
  const o2 = Math.floor(midi2 / 12) - 1;
  return pc + o2;
}
var NAMES = ["C", "D", "E", "F", "G", "A", "B"];
var toName = (n2) => n2.name;
var onlyNotes = (array) => array.map(note).filter((n2) => !n2.empty);
function names$1(array) {
  if (array === void 0) {
    return NAMES.slice();
  } else if (!Array.isArray(array)) {
    return [];
  } else {
    return onlyNotes(array).map(toName);
  }
}
var get$2 = note;
var name = (note2) => get$2(note2).name;
var pitchClass = (note2) => get$2(note2).pc;
var accidentals = (note2) => get$2(note2).acc;
var octave = (note2) => get$2(note2).oct;
var midi = (note2) => get$2(note2).midi;
var freq = (note2) => get$2(note2).freq;
var chroma = (note2) => get$2(note2).chroma;
function fromMidi(midi2) {
  return midiToNoteName(midi2);
}
function fromFreq(freq2) {
  return midiToNoteName(freqToMidi(freq2));
}
function fromFreqSharps(freq2) {
  return midiToNoteName(freqToMidi(freq2), { sharps: true });
}
function fromMidiSharps(midi2) {
  return midiToNoteName(midi2, { sharps: true });
}
var transpose = transpose$1;
var tr = transpose$1;
var transposeBy = (interval2) => (note2) => transpose(note2, interval2);
var trBy = transposeBy;
var transposeFrom = (note2) => (interval2) => transpose(note2, interval2);
var trFrom = transposeFrom;
function transposeFifths(noteName, fifths) {
  const note2 = get$2(noteName);
  if (note2.empty) {
    return "";
  }
  const [nFifths, nOcts] = note2.coord;
  const transposed = nOcts === void 0 ? coordToNote([nFifths + fifths]) : coordToNote([nFifths + fifths, nOcts]);
  return transposed.name;
}
var trFifths = transposeFifths;
var ascending = (a2, b2) => a2.height - b2.height;
var descending = (a2, b2) => b2.height - a2.height;
function sortedNames(notes2, comparator) {
  comparator = comparator || ascending;
  return onlyNotes(notes2).sort(comparator).map(toName);
}
function sortedUniqNames(notes2) {
  return sortedNames(notes2, ascending).filter((n2, i2, a2) => i2 === 0 || n2 !== a2[i2 - 1]);
}
var simplify = (noteName) => {
  const note2 = get$2(noteName);
  if (note2.empty) {
    return "";
  }
  return midiToNoteName(note2.midi || note2.chroma, {
    sharps: note2.alt > 0,
    pitchClass: note2.midi === null
  });
};
function enharmonic(noteName, destName) {
  const src = get$2(noteName);
  if (src.empty) {
    return "";
  }
  const dest = get$2(destName || midiToNoteName(src.midi || src.chroma, {
    sharps: src.alt < 0,
    pitchClass: true
  }));
  if (dest.empty || dest.chroma !== src.chroma) {
    return "";
  }
  if (src.oct === void 0) {
    return dest.pc;
  }
  const srcChroma = src.chroma - src.alt;
  const destChroma = dest.chroma - dest.alt;
  const destOctOffset = srcChroma > 11 || destChroma < 0 ? -1 : srcChroma < 0 || destChroma > 11 ? 1 : 0;
  const destOct = src.oct + destOctOffset;
  return dest.pc + destOct;
}
var index$2 = {
  names: names$1,
  get: get$2,
  name,
  pitchClass,
  accidentals,
  octave,
  midi,
  ascending,
  descending,
  sortedNames,
  sortedUniqNames,
  fromMidi,
  fromMidiSharps,
  freq,
  fromFreq,
  fromFreqSharps,
  chroma,
  transpose,
  tr,
  transposeBy,
  trBy,
  transposeFrom,
  trFrom,
  transposeFifths,
  trFifths,
  simplify,
  enharmonic
};
Object.freeze([]);
var MODES = [
  [0, 2773, 0, "ionian", "", "Maj7", "major"],
  [1, 2902, 2, "dorian", "m", "m7"],
  [2, 3418, 4, "phrygian", "m", "m7"],
  [3, 2741, -1, "lydian", "", "Maj7"],
  [4, 2774, 1, "mixolydian", "", "7"],
  [5, 2906, 3, "aeolian", "m", "m7", "minor"],
  [6, 3434, 5, "locrian", "dim", "m7b5"]
];
var NoMode = {
  ...EmptyPcset,
  name: "",
  alt: 0,
  modeNum: NaN,
  triad: "",
  seventh: "",
  aliases: []
};
var modes = MODES.map(toMode);
var index$1 = {};
modes.forEach((mode) => {
  index$1[mode.name] = mode;
  mode.aliases.forEach((alias) => {
    index$1[alias] = mode;
  });
});
function get$1(name2) {
  return typeof name2 === "string" ? index$1[name2.toLowerCase()] || NoMode : name2 && name2.name ? get$1(name2.name) : NoMode;
}
function toMode(mode) {
  const [modeNum, setNum, alt, name2, triad, seventh, alias] = mode;
  const aliases = alias ? [alias] : [];
  const chroma2 = Number(setNum).toString(2);
  const intervals2 = get$3(name2).intervals;
  return {
    empty: false,
    intervals: intervals2,
    modeNum,
    chroma: chroma2,
    normalized: chroma2,
    name: name2,
    setNum,
    alt,
    triad,
    seventh,
    aliases
  };
}
function chords$1(chords2) {
  return (modeName, tonic) => {
    const mode = get$1(modeName);
    if (mode.empty)
      return [];
    const triads = rotate(mode.modeNum, chords2);
    const tonics = mode.intervals.map((i2) => transpose$1(tonic, i2));
    return triads.map((triad, i2) => tonics[i2] + triad);
  };
}
chords$1(MODES.map((x2) => x2[4]));
chords$1(MODES.map((x2) => x2[5]));
var NoScale = {
  empty: true,
  name: "",
  type: "",
  tonic: null,
  setNum: NaN,
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function tokenize(name2) {
  if (typeof name2 !== "string") {
    return ["", ""];
  }
  const i2 = name2.indexOf(" ");
  const tonic = note(name2.substring(0, i2));
  if (tonic.empty) {
    const n2 = note(name2);
    return n2.empty ? ["", name2] : [n2.name, ""];
  }
  const type = name2.substring(tonic.name.length + 1);
  return [tonic.name, type.length ? type : ""];
}
var names = names$2;
function get(src) {
  const tokens = Array.isArray(src) ? src : tokenize(src);
  const tonic = note(tokens[0]).name;
  const st = get$3(tokens[1]);
  if (st.empty) {
    return NoScale;
  }
  const type = st.name;
  const notes2 = tonic ? st.intervals.map((i2) => transpose$1(tonic, i2)) : [];
  const name2 = tonic ? tonic + " " + type : type;
  return { ...st, name: name2, type, tonic, notes: notes2 };
}
var scale = deprecate("Scale.scale", "Scale.get", get);
function scaleChords(name2) {
  const s2 = get(name2);
  const inScale = isSubsetOf(s2.chroma);
  return all$1().filter((chord) => inScale(chord.chroma)).map((chord) => chord.aliases[0]);
}
function extended(name2) {
  const s2 = get(name2);
  const isSuperset = isSupersetOf(s2.chroma);
  return all().filter((scale2) => isSuperset(scale2.chroma)).map((scale2) => scale2.name);
}
function reduced(name2) {
  const isSubset = isSubsetOf(get(name2).chroma);
  return all().filter((scale2) => isSubset(scale2.chroma)).map((scale2) => scale2.name);
}
function scaleNotes(notes2) {
  const pcset2 = notes2.map((n2) => note(n2).pc).filter((x2) => x2);
  const tonic = pcset2[0];
  const scale2 = sortedUniqNames(pcset2);
  return rotate(scale2.indexOf(tonic), scale2);
}
function modeNames(name2) {
  const s2 = get(name2);
  if (s2.empty) {
    return [];
  }
  const tonics = s2.tonic ? s2.notes : s2.intervals;
  return modes$1(s2.chroma).map((chroma2, i2) => {
    const modeName = get(chroma2).name;
    return modeName ? [tonics[i2], modeName] : ["", ""];
  }).filter((x2) => x2[0]);
}
function getNoteNameOf(scale2) {
  const names2 = Array.isArray(scale2) ? scaleNotes(scale2) : get(scale2).notes;
  const chromas2 = names2.map((name2) => note(name2).chroma);
  return (noteOrMidi) => {
    const currNote = typeof noteOrMidi === "number" ? note(fromMidi(noteOrMidi)) : note(noteOrMidi);
    const height = currNote.height;
    if (height === void 0)
      return void 0;
    const chroma2 = height % 12;
    const position = chromas2.indexOf(chroma2);
    if (position === -1)
      return void 0;
    return enharmonic(currNote.name, names2[position]);
  };
}
function rangeOf(scale2) {
  const getName = getNoteNameOf(scale2);
  return (fromNote, toNote) => {
    const from = note(fromNote).height;
    const to = note(toNote).height;
    if (from === void 0 || to === void 0)
      return [];
    return range2(from, to).map(getName).filter((x2) => x2);
  };
}
var index = {
  get,
  names,
  extended,
  modeNames,
  reduced,
  scaleChords,
  scaleNotes,
  tokenize,
  rangeOf,
  scale
};
index$1$2.add(["1P", "2m"], ["2m"], "minor second");
index$1$2.add(["1P", "2M"], ["2M"], "major second");
index$1$2.add(["1P", "3m"], ["3m"], "minor third");
index$1$2.add(["1P", "3M"], ["3M"], "major third");
index$1$2.add(["1P", "4P"], ["4P"], "perfect fourth");
index$1$2.add(["1P", "5d"], ["TT"], "tritone");
index$1$2.add(["1P", "5P"], ["5P"], "perfect fifth");
index$1$2.add(["1P", "6m"], ["6m"], "minor sixth");
index$1$2.add(["1P", "6M"], ["6M"], "major sixth");
index$1$2.add(["1P", "7m"], ["7m"], "minor seventh");
index$1$2.add(["1P", "7M"], ["7M"], "major seventh");
var chordType = index$1$2;
var scaleType = index$1$1;
var chordList = index$1$2.all();
var scaleList = index$1$1.all();
var intervals = ["1P", "2m", "2M", "3m", "3M", "4P", "TT", "5P", "6m", "6M", "7m", "7M"];
var noteNames = [];
var naturals = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
var sharps = ["G##", "A#", "A##", "B#", "C#", "C##", "D#", "D##", "E#", "F#", "F##", "G#"];
var flats = ["Bbb", "Bb", "Cb", "Dbb", "Db", "Ebb", "Eb", "Fb", "Gbb", "Gb", "Abb", "Ab"];
naturals.forEach((note2, n2) => {
  noteNames[note2] = n2;
});
sharps.forEach((note2, n2) => {
  noteNames[note2] = n2;
});
flats.forEach((note2, n2) => {
  noteNames[note2] = n2;
});
var notes = naturals;
var chords = {
  min: { handle: "min", name: "Minor", semitones: [0, 3, 7] },
  maj: { handle: "maj", name: "Major", semitones: [0, 4, 7] },
  aug: { handle: "aug", name: "Augmented", semitones: [0, 4, 8] },
  dim: { handle: "dim", name: "Diminished", semitones: [0, 3, 6] },
  M7: { handle: "M7", name: "Major 7th", semitones: [0, 4, 7, 11] },
  m7: { handle: "m7", name: "Minor 7th", semitones: [0, 3, 7, 10] },
  "7": { handle: "7", name: "Dominant 7th", semitones: [0, 4, 7, 10] },
  "+7": { handle: "+7", name: "Augmented 7th", semitones: [0, 4, 8, 10] },
  o7: { handle: "o7", name: "Diminished 7th", semitones: [0, 3, 6, 9] },
  "07": { handle: "07", name: "Half-diminished 7th", semitones: [0, 3, 6, 10] },
  "+M7": { handle: "+M7", name: "Augmented major 7th", semitones: [0, 3, 7, 11] },
  "6": { handle: "6", name: "Major 6th", semitones: [0, 4, 7, 9] },
  m6: { handle: "m6", name: "Minor 6th", semitones: [0, 3, 7, 9] },
  sus2: { handle: "sus2", name: "Suspended 2nd", semitones: [0, 2, 7] },
  sus4: { handle: "sus4", name: "Suspended 4th", semitones: [0, 5, 7] },
  "9": { handle: "9", name: "9th", semitones: [0, 3, 7, 13] }
};
var scales = {
  major: {
    handle: "major",
    name: "Major (Ionian)",
    chords: ["maj", "", "min", "", "min", "maj", "", "7", "", "min", "", "dim"],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]
  },
  minor: {
    handle: "minor",
    name: "Minor (Aeolian)",
    chords: ["min", "", "dim", "maj", "", "min", "", "min", "maj", "", "7", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]
  },
  dorian: {
    handle: "dorian",
    name: "Dorian",
    chords: ["min", "", "min", "maj", "", "7", "", "min", "", "dim", "maj", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0]
  },
  phrygian: {
    handle: "phrygian",
    name: "Phrygian",
    chords: ["min", "maj", "", "7", "", "min", "", "dim", "maj", "", "min", ""],
    steps: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0]
  },
  lydian: {
    handle: "lydian",
    name: "Lydian",
    chords: ["maj", "", "7", "", "min", "", "dim", "maj", "", "min", "", "min"],
    steps: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1]
  },
  mixolydian: {
    handle: "mixolydian",
    name: "Mixolydian",
    chords: ["7", "", "min", "", "dim", "maj", "", "min", "", "min", "maj", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0]
  },
  locrian: {
    handle: "locrian",
    name: "Locrian",
    chords: ["dim", "maj", "", "min", "", "min", "maj", "", "7", "", "min", ""],
    steps: [1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0]
  },
  majorPenta: {
    handle: "majorPenta",
    name: "Major pentatonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0]
  },
  minorPenta: {
    handle: "minorPenta",
    name: "Minor pentatonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0]
  },
  acoustic: {
    handle: "acoustic",
    name: "Acoustic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0]
  },
  adonai: {
    handle: "adonai",
    name: "Adonai malakh",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0]
  },
  algerian: {
    handle: "algerian",
    name: "Algerian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]
  },
  augmented: {
    handle: "augmented",
    name: "Augmented",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1]
  },
  bebopDom: {
    handle: "bebopDom",
    name: "Bebop dominant",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1]
  },
  bebopMaj: {
    handle: "bebopMaj",
    name: "Bebop major",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1]
  },
  bluesHexa: {
    handle: "bluesHexa",
    name: "Blues hexatonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0]
  },
  doubleHarmonic: {
    handle: "doubleHarmonic",
    name: "Double harmonic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1]
  },
  enigmatic: {
    handle: "enigmatic",
    name: "Enigmatic",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1]
  },
  gypsy: {
    handle: "gypsy",
    name: "Gypsy",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0]
  },
  halfDim: {
    handle: "halfDim",
    name: "Half diminished",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0]
  },
  harmonicMaj: {
    handle: "harmonicMaj",
    name: "Harmonic major",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1]
  },
  harmonicMin: {
    handle: "harmonicMin",
    name: "Harmonic minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1]
  },
  hungarianMin: {
    handle: "hungarianMin",
    name: "Hungarian minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]
  },
  istrian: {
    handle: "istrian",
    name: "Istrian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0]
  },
  lydianAug: {
    handle: "lydianAug",
    name: "Lydian augmented",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1]
  },
  majLocrian: {
    handle: "majLocrian",
    name: "Major locrian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0]
  },
  jazzMin: {
    handle: "jazzMin",
    name: "Jazz minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1]
  },
  neapolitanMaj: {
    handle: "neapolitanMaj",
    name: "Neapolitan major",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
  },
  neapolitanMin: {
    handle: "neapolitanMin",
    name: "Neapolitan minor",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1]
  },
  octatonic: {
    handle: "octatonic",
    name: "Octatonic (diminished)",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1]
  },
  persian: {
    handle: "persian",
    name: "Persian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1]
  },
  phrygianDom: {
    handle: "phrygianDom",
    name: "Phrygian dominant",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0]
  },
  prometheus: {
    handle: "prometheus",
    name: "Prometheus",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0]
  },
  tritone: {
    handle: "tritone",
    name: "Tritone",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0]
  },
  ukranianDorian: {
    handle: "ukranianDorian",
    name: "Ukranian dorian",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0]
  },
  wholeTone: {
    handle: "wholeTone",
    name: "Whole tone",
    chords: ["", "", "", "", "", "", "", "", "", "", "", ""],
    steps: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
  },
  chromatic: {
    handle: "chromatic",
    name: "Chromatic",
    chords: [
      "1/1",
      "25/24",
      "9/8",
      "6/5",
      "5/4",
      "4/3",
      "45/32",
      "3/2",
      "8/5",
      "5/3",
      "9/5",
      "15/8"
    ],
    steps: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  }
};
var allNotes = [...notes].map((n2, i2) => ({ name: n2, pitch: i2 }));
var globalScale = reactive({
  tonic: useClamp(useStorage("global-tonic", 0), 0, 11),
  note: computed(() => allNotes[globalScale.tonic]),
  chroma: useStorage("global-chroma", "101011010101"),
  set: computed(() => index$1$1.get(globalScale.chroma)),
  full: computed(() => {
    let sc = globalScale.note.name + "4 " + globalScale.set.name;
    return index.get(sc);
  }),
  pcs: computed(() => index.scaleNotes(globalScale.full.notes)),
  isIn: computed(() => index$5.isNoteIncludedIn(globalScale.pcs))
});
function getChromaNotes(chroma2 = "100010010000", tonic = globalScale.tonic) {
  let shiftChroma = rotateArray(chroma2.split(""), -tonic);
  let chOct = rotateArray(allNotes, -tonic).map((n2, i2) => {
    let noteName = Frequency(n2.pitch + tonic + 57, "midi").toNote();
    return noteName;
  });
  let filtered = chOct.filter((val, i2) => {
    if (shiftChroma[i2] == "1") {
      return true;
    }
  });
  return index$2.sortedNames(filtered);
}
function playChromaOnce(chroma2, tonic) {
  let notes2 = getChromaNotes(chroma2, tonic);
  notes2.forEach((name2, i2) => {
    midiOnce(name2);
  });
  synthOnce(notes2, "4n");
}
function playChroma(chroma2, tonic) {
  let notes2 = getChromaNotes(chroma2, tonic);
  notes2.forEach((name2) => {
    midiPlay(name2);
  });
  synthAttack(notes2);
}
function stopChroma(chroma2, tonic) {
  let notes2 = getChromaNotes(chroma2, tonic);
  notes2.forEach((name2) => {
    midiStop(name2);
  });
  synthRelease(notes2);
}
function playNote(name2) {
  midiPlay(name2);
  synthAttack(name2);
}
function stopNote(name2) {
  midiStop(name2);
  synthRelease(name2);
}
var r$5 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var t$5 = function(r2) {
  return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
};
var n$5 = function(r2, t2, n2) {
  return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
};
var e$5 = function(r2, t2, n2) {
  return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
};
var u$5 = function(r2) {
  return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
};
var a$5 = function(r2) {
  return { r: e$5(r2.r, 0, 255), g: e$5(r2.g, 0, 255), b: e$5(r2.b, 0, 255), a: e$5(r2.a) };
};
var o$5 = function(r2) {
  return { r: n$5(r2.r), g: n$5(r2.g), b: n$5(r2.b), a: n$5(r2.a, 3) };
};
var i$5 = /^#([0-9a-f]{3,8})$/i;
var s$1 = function(r2) {
  var t2 = r2.toString(16);
  return t2.length < 2 ? "0" + t2 : t2;
};
var h$4 = function(r2) {
  var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
  return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
};
var b$3 = function(r2) {
  var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
  t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
  var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
  return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
};
var g = function(r2) {
  return { h: u$5(r2.h), s: e$5(r2.s, 0, 100), l: e$5(r2.l, 0, 100), a: e$5(r2.a) };
};
var d$2 = function(r2) {
  return { h: n$5(r2.h), s: n$5(r2.s), l: n$5(r2.l), a: n$5(r2.a, 3) };
};
var f$2 = function(r2) {
  return b$3((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
  var t2, n2, e2;
};
var c$3 = function(r2) {
  return { h: (t2 = h$4(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
  var t2, n2, e2, u2;
};
var l$2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var p$3 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var v$1 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var m$1 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var y$1 = { string: [[function(r2) {
  var t2 = i$5.exec(r2);
  return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: r2.length === 4 ? n$5(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : r2.length === 6 || r2.length === 8 ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: r2.length === 8 ? n$5(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r2) {
  var t2 = v$1.exec(r2) || m$1.exec(r2);
  return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a$5({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: t2[7] === void 0 ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t2) {
  var n2 = l$2.exec(t2) || p$3.exec(t2);
  if (!n2)
    return null;
  var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], u2 === void 0 && (u2 = "deg"), Number(e2) * (r$5[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: n2[5] === void 0 ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return f$2(a2);
}, "hsl"]], object: [[function(r2) {
  var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = o2 === void 0 ? 1 : o2;
  return t$5(n2) && t$5(e2) && t$5(u2) ? a$5({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
}, "rgb"], [function(r2) {
  var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = a2 === void 0 ? 1 : a2;
  if (!t$5(n2) || !t$5(e2) || !t$5(u2))
    return null;
  var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
  return f$2(i2);
}, "hsl"], [function(r2) {
  var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = i2 === void 0 ? 1 : i2;
  if (!t$5(n2) || !t$5(a2) || !t$5(o2))
    return null;
  var h2 = function(r3) {
    return { h: u$5(r3.h), s: e$5(r3.s, 0, 100), v: e$5(r3.v, 0, 100), a: e$5(r3.a) };
  }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
  return b$3(h2);
}, "hsv"]] };
var N = function(r2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var e2 = t2[n2][0](r2);
    if (e2)
      return [e2, t2[n2][1]];
  }
  return [null, void 0];
};
var x$2 = function(r2) {
  return typeof r2 == "string" ? N(r2.trim(), y$1.string) : typeof r2 == "object" && r2 !== null ? N(r2, y$1.object) : [null, void 0];
};
var M$2 = function(r2, t2) {
  var n2 = c$3(r2);
  return { h: n2.h, s: e$5(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
};
var H = function(r2) {
  return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
};
var $ = function(r2, t2) {
  var n2 = c$3(r2);
  return { h: n2.h, s: n2.s, l: e$5(n2.l + 100 * t2, 0, 100), a: n2.a };
};
var j = function() {
  function r2(r3) {
    this.parsed = x$2(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r2.prototype.isValid = function() {
    return this.parsed !== null;
  }, r2.prototype.brightness = function() {
    return n$5(H(this.rgba), 2);
  }, r2.prototype.isDark = function() {
    return H(this.rgba) < 0.5;
  }, r2.prototype.isLight = function() {
    return H(this.rgba) >= 0.5;
  }, r2.prototype.toHex = function() {
    return r3 = o$5(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s$1(n$5(255 * a2)) : "", "#" + s$1(t2) + s$1(e2) + s$1(u2) + i2;
    var r3, t2, e2, u2, a2, i2;
  }, r2.prototype.toRgb = function() {
    return o$5(this.rgba);
  }, r2.prototype.toRgbString = function() {
    return r3 = o$5(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsl = function() {
    return d$2(c$3(this.rgba));
  }, r2.prototype.toHslString = function() {
    return r3 = d$2(c$3(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsv = function() {
    return r3 = h$4(this.rgba), { h: n$5(r3.h), s: n$5(r3.s), v: n$5(r3.v), a: n$5(r3.a, 3) };
    var r3;
  }, r2.prototype.invert = function() {
    return w$1({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
    var r3;
  }, r2.prototype.saturate = function(r3) {
    return r3 === void 0 && (r3 = 0.1), w$1(M$2(this.rgba, r3));
  }, r2.prototype.desaturate = function(r3) {
    return r3 === void 0 && (r3 = 0.1), w$1(M$2(this.rgba, -r3));
  }, r2.prototype.grayscale = function() {
    return w$1(M$2(this.rgba, -1));
  }, r2.prototype.lighten = function(r3) {
    return r3 === void 0 && (r3 = 0.1), w$1($(this.rgba, r3));
  }, r2.prototype.darken = function(r3) {
    return r3 === void 0 && (r3 = 0.1), w$1($(this.rgba, -r3));
  }, r2.prototype.rotate = function(r3) {
    return r3 === void 0 && (r3 = 15), this.hue(this.hue() + r3);
  }, r2.prototype.alpha = function(r3) {
    return typeof r3 == "number" ? w$1({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n$5(this.rgba.a, 3);
    var t2;
  }, r2.prototype.hue = function(r3) {
    var t2 = c$3(this.rgba);
    return typeof r3 == "number" ? w$1({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n$5(t2.h);
  }, r2.prototype.isEqual = function(r3) {
    return this.toHex() === w$1(r3).toHex();
  }, r2;
}();
var w$1 = function(r2) {
  return r2 instanceof j ? r2 : new j(r2);
};
var S = [];
var k = function(r2) {
  r2.forEach(function(r3) {
    S.indexOf(r3) < 0 && (r3(j, y$1), S.push(r3));
  });
};
var r$4 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var t$4 = function(r2) {
  return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
};
var a$4 = function(r2, t2, a2) {
  return t2 === void 0 && (t2 = 0), a2 === void 0 && (a2 = Math.pow(10, t2)), Math.round(a2 * r2) / a2 + 0;
};
var n$4 = function(r2, t2, a2) {
  return t2 === void 0 && (t2 = 0), a2 === void 0 && (a2 = 1), r2 > a2 ? a2 : r2 > t2 ? r2 : t2;
};
var u$4 = function(r2) {
  var t2 = r2 / 255;
  return t2 < 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
};
var h$3 = function(r2) {
  return 255 * (r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : 12.92 * r2);
};
var o$4 = 96.422;
var e$4 = 100;
var c$2 = 82.521;
var i$4 = function(r2) {
  var t2, a2, u2 = { x: 0.9555766 * (t2 = r2).x + -0.0230393 * t2.y + 0.0631636 * t2.z, y: -0.0282895 * t2.x + 1.0099416 * t2.y + 0.0210077 * t2.z, z: 0.0122982 * t2.x + -0.020483 * t2.y + 1.3299098 * t2.z };
  return a2 = { r: h$3(0.032404542 * u2.x - 0.015371385 * u2.y - 4985314e-9 * u2.z), g: h$3(-969266e-8 * u2.x + 0.018760108 * u2.y + 41556e-8 * u2.z), b: h$3(556434e-9 * u2.x - 2040259e-9 * u2.y + 0.010572252 * u2.z), a: r2.a }, { r: n$4(a2.r, 0, 255), g: n$4(a2.g, 0, 255), b: n$4(a2.b, 0, 255), a: n$4(a2.a) };
};
var l$1 = function(r2) {
  var t2 = u$4(r2.r), a2 = u$4(r2.g), h2 = u$4(r2.b);
  return function(r3) {
    return { x: n$4(r3.x, 0, o$4), y: n$4(r3.y, 0, e$4), z: n$4(r3.z, 0, c$2), a: n$4(r3.a) };
  }(function(r3) {
    return { x: 1.0478112 * r3.x + 0.0228866 * r3.y + -0.050127 * r3.z, y: 0.0295424 * r3.x + 0.9904844 * r3.y + -0.0170491 * r3.z, z: -92345e-7 * r3.x + 0.0150436 * r3.y + 0.7521316 * r3.z, a: r3.a };
  }({ x: 100 * (0.4124564 * t2 + 0.3575761 * a2 + 0.1804375 * h2), y: 100 * (0.2126729 * t2 + 0.7151522 * a2 + 0.072175 * h2), z: 100 * (0.0193339 * t2 + 0.119192 * a2 + 0.9503041 * h2), a: r2.a }));
};
var f$1 = 216 / 24389;
var b$2 = 24389 / 27;
var d$1 = function(r2) {
  return { l: n$4(r2.l, 0, 100), c: r2.c, h: (t2 = r2.h, (t2 = isFinite(t2) ? t2 % 360 : 0) > 0 ? t2 : t2 + 360), a: r2.a };
  var t2;
};
var p$2 = function(r2) {
  return { l: a$4(r2.l, 2), c: a$4(r2.c, 2), h: a$4(r2.h, 2), a: a$4(r2.a, 3) };
};
var v = function(r2) {
  var a2 = r2.l, n2 = r2.c, u2 = r2.h, h2 = r2.a, o2 = h2 === void 0 ? 1 : h2;
  if (!t$4(a2) || !t$4(n2) || !t$4(u2))
    return null;
  var e2 = d$1({ l: Number(a2), c: Number(n2), h: Number(u2), a: Number(o2) });
  return M$1(e2);
};
var y = function(r2) {
  var t2 = function(r3) {
    var t3 = l$1(r3), a2 = t3.x / o$4, n3 = t3.y / e$4, u3 = t3.z / c$2;
    return a2 = a2 > f$1 ? Math.cbrt(a2) : (b$2 * a2 + 16) / 116, { l: 116 * (n3 = n3 > f$1 ? Math.cbrt(n3) : (b$2 * n3 + 16) / 116) - 16, a: 500 * (a2 - n3), b: 200 * (n3 - (u3 = u3 > f$1 ? Math.cbrt(u3) : (b$2 * u3 + 16) / 116)), alpha: t3.a };
  }(r2), n2 = a$4(t2.a, 3), u2 = a$4(t2.b, 3), h2 = Math.atan2(u2, n2) / Math.PI * 180;
  return { l: t2.l, c: Math.sqrt(n2 * n2 + u2 * u2), h: h2 < 0 ? h2 + 360 : h2, a: t2.alpha };
};
var M$1 = function(r2) {
  return t2 = { l: r2.l, a: r2.c * Math.cos(r2.h * Math.PI / 180), b: r2.c * Math.sin(r2.h * Math.PI / 180), alpha: r2.a }, n2 = t2.a / 500 + (a2 = (t2.l + 16) / 116), u2 = a2 - t2.b / 200, i$4({ x: (Math.pow(n2, 3) > f$1 ? Math.pow(n2, 3) : (116 * n2 - 16) / b$2) * o$4, y: (t2.l > 8 ? Math.pow((t2.l + 16) / 116, 3) : t2.l / b$2) * e$4, z: (Math.pow(u2, 3) > f$1 ? Math.pow(u2, 3) : (116 * u2 - 16) / b$2) * c$2, a: t2.alpha });
  var t2, a2, n2, u2;
};
var x$1 = /^lch\(\s*([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var s = function(t2) {
  var a2 = x$1.exec(t2);
  if (!a2)
    return null;
  var n2, u2, h2 = d$1({ l: Number(a2[1]), c: Number(a2[2]), h: (n2 = a2[3], u2 = a2[4], u2 === void 0 && (u2 = "deg"), Number(n2) * (r$4[u2] || 1)), a: a2[5] === void 0 ? 1 : Number(a2[5]) / (a2[6] ? 100 : 1) });
  return M$1(h2);
};
function lchPlugin(r2, t2) {
  r2.prototype.toLch = function() {
    return p$2(y(this.rgba));
  }, r2.prototype.toLchString = function() {
    return r3 = p$2(y(this.rgba)), t3 = r3.l, a2 = r3.c, n2 = r3.h, (u2 = r3.a) < 1 ? "lch(" + t3 + "% " + a2 + " " + n2 + " / " + u2 + ")" : "lch(" + t3 + "% " + a2 + " " + n2 + ")";
    var r3, t3, a2, n2, u2;
  }, t2.string.push([s, "lch"]), t2.object.push([v, "lch"]);
}
var t$3 = function(t2, a2, n2) {
  return a2 === void 0 && (a2 = 0), n2 === void 0 && (n2 = 1), t2 > n2 ? n2 : t2 > a2 ? t2 : a2;
};
var a$3 = function(t2) {
  var a2 = t2 / 255;
  return a2 < 0.04045 ? a2 / 12.92 : Math.pow((a2 + 0.055) / 1.055, 2.4);
};
var n$3 = function(t2) {
  return 255 * (t2 > 31308e-7 ? 1.055 * Math.pow(t2, 1 / 2.4) - 0.055 : 12.92 * t2);
};
var r$3 = 96.422;
var o$3 = 100;
var u$3 = 82.521;
var e$3 = function(a2) {
  var r2, o2, u2 = { x: 0.9555766 * (r2 = a2).x + -0.0230393 * r2.y + 0.0631636 * r2.z, y: -0.0282895 * r2.x + 1.0099416 * r2.y + 0.0210077 * r2.z, z: 0.0122982 * r2.x + -0.020483 * r2.y + 1.3299098 * r2.z };
  return o2 = { r: n$3(0.032404542 * u2.x - 0.015371385 * u2.y - 4985314e-9 * u2.z), g: n$3(-969266e-8 * u2.x + 0.018760108 * u2.y + 41556e-8 * u2.z), b: n$3(556434e-9 * u2.x - 2040259e-9 * u2.y + 0.010572252 * u2.z), a: a2.a }, { r: t$3(o2.r, 0, 255), g: t$3(o2.g, 0, 255), b: t$3(o2.b, 0, 255), a: t$3(o2.a) };
};
var i$3 = function(n2) {
  var e2 = a$3(n2.r), i2 = a$3(n2.g), p2 = a$3(n2.b);
  return function(a2) {
    return { x: t$3(a2.x, 0, r$3), y: t$3(a2.y, 0, o$3), z: t$3(a2.z, 0, u$3), a: t$3(a2.a) };
  }(function(t2) {
    return { x: 1.0478112 * t2.x + 0.0228866 * t2.y + -0.050127 * t2.z, y: 0.0295424 * t2.x + 0.9904844 * t2.y + -0.0170491 * t2.z, z: -92345e-7 * t2.x + 0.0150436 * t2.y + 0.7521316 * t2.z, a: t2.a };
  }({ x: 100 * (0.4124564 * e2 + 0.3575761 * i2 + 0.1804375 * p2), y: 100 * (0.2126729 * e2 + 0.7151522 * i2 + 0.072175 * p2), z: 100 * (0.0193339 * e2 + 0.119192 * i2 + 0.9503041 * p2), a: n2.a }));
};
var p$1 = 216 / 24389;
var h$2 = 24389 / 27;
var f = function(t2) {
  var a2 = i$3(t2), n2 = a2.x / r$3, e2 = a2.y / o$3, f2 = a2.z / u$3;
  return n2 = n2 > p$1 ? Math.cbrt(n2) : (h$2 * n2 + 16) / 116, { l: 116 * (e2 = e2 > p$1 ? Math.cbrt(e2) : (h$2 * e2 + 16) / 116) - 16, a: 500 * (n2 - e2), b: 200 * (e2 - (f2 = f2 > p$1 ? Math.cbrt(f2) : (h$2 * f2 + 16) / 116)), alpha: a2.a };
};
var c$1 = function(a2, n2, i2) {
  var c2, y2 = f(a2), x2 = f(n2);
  return function(t2) {
    var a3 = (t2.l + 16) / 116, n3 = t2.a / 500 + a3, i3 = a3 - t2.b / 200;
    return e$3({ x: (Math.pow(n3, 3) > p$1 ? Math.pow(n3, 3) : (116 * n3 - 16) / h$2) * r$3, y: (t2.l > 8 ? Math.pow((t2.l + 16) / 116, 3) : t2.l / h$2) * o$3, z: (Math.pow(i3, 3) > p$1 ? Math.pow(i3, 3) : (116 * i3 - 16) / h$2) * u$3, a: t2.alpha });
  }({ l: t$3((c2 = { l: y2.l * (1 - i2) + x2.l * i2, a: y2.a * (1 - i2) + x2.a * i2, b: y2.b * (1 - i2) + x2.b * i2, alpha: y2.alpha * (1 - i2) + x2.alpha * i2 }).l, 0, 400), a: c2.a, b: c2.b, alpha: t$3(c2.alpha) });
};
function mixPlugin(t2) {
  function a2(t3, a3, n2) {
    n2 === void 0 && (n2 = 5);
    for (var r2 = [], o2 = 1 / (n2 - 1), u2 = 0; u2 <= n2 - 1; u2++)
      r2.push(t3.mix(a3, o2 * u2));
    return r2;
  }
  t2.prototype.mix = function(a3, n2) {
    n2 === void 0 && (n2 = 0.5);
    var r2 = a3 instanceof t2 ? a3 : new t2(a3), o2 = c$1(this.toRgb(), r2.toRgb(), n2);
    return new t2(o2);
  }, t2.prototype.tints = function(t3) {
    return a2(this, "#fff", t3);
  }, t2.prototype.shades = function(t3) {
    return a2(this, "#000", t3);
  }, t2.prototype.tones = function(t3) {
    return a2(this, "#808080", t3);
  };
}
function namesPlugin(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a2)
    r2[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2)
      return n2;
    if (f3 == null ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length)
        for (var c2 in a2)
          l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d3 = r3 === "transparent" ? "#0000" : a2[r3];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}
var a$2 = function(a2) {
  return typeof a2 == "string" ? a2.length > 0 : typeof a2 == "number";
};
var t$2 = function(a2, t2, o2) {
  return t2 === void 0 && (t2 = 0), o2 === void 0 && (o2 = Math.pow(10, t2)), Math.round(o2 * a2) / o2 + 0;
};
var o$2 = function(a2, t2, o2) {
  return t2 === void 0 && (t2 = 0), o2 === void 0 && (o2 = 1), a2 > o2 ? o2 : a2 > t2 ? a2 : t2;
};
var r$2 = function(a2) {
  var t2 = a2 / 255;
  return t2 < 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
};
var h$1 = function(a2) {
  return 255 * (a2 > 31308e-7 ? 1.055 * Math.pow(a2, 1 / 2.4) - 0.055 : 12.92 * a2);
};
var n$2 = 96.422;
var p = 100;
var M = 82.521;
var u$2 = function(a2) {
  var t2, r2, n2 = { x: 0.9555766 * (t2 = a2).x + -0.0230393 * t2.y + 0.0631636 * t2.z, y: -0.0282895 * t2.x + 1.0099416 * t2.y + 0.0210077 * t2.z, z: 0.0122982 * t2.x + -0.020483 * t2.y + 1.3299098 * t2.z };
  return r2 = { r: h$1(0.032404542 * n2.x - 0.015371385 * n2.y - 4985314e-9 * n2.z), g: h$1(-969266e-8 * n2.x + 0.018760108 * n2.y + 41556e-8 * n2.z), b: h$1(556434e-9 * n2.x - 2040259e-9 * n2.y + 0.010572252 * n2.z), a: a2.a }, { r: o$2(r2.r, 0, 255), g: o$2(r2.g, 0, 255), b: o$2(r2.b, 0, 255), a: o$2(r2.a) };
};
var e$2 = function(a2) {
  var t2 = r$2(a2.r), h2 = r$2(a2.g), u2 = r$2(a2.b);
  return function(a3) {
    return { x: o$2(a3.x, 0, n$2), y: o$2(a3.y, 0, p), z: o$2(a3.z, 0, M), a: o$2(a3.a) };
  }(function(a3) {
    return { x: 1.0478112 * a3.x + 0.0228866 * a3.y + -0.050127 * a3.z, y: 0.0295424 * a3.x + 0.9904844 * a3.y + -0.0170491 * a3.z, z: -92345e-7 * a3.x + 0.0150436 * a3.y + 0.7521316 * a3.z, a: a3.a };
  }({ x: 100 * (0.4124564 * t2 + 0.3575761 * h2 + 0.1804375 * u2), y: 100 * (0.2126729 * t2 + 0.7151522 * h2 + 0.072175 * u2), z: 100 * (0.0193339 * t2 + 0.119192 * h2 + 0.9503041 * u2), a: a2.a }));
};
var w = 216 / 24389;
var b$1 = 24389 / 27;
var i$2 = function(t2) {
  var r2 = t2.l, h2 = t2.a, n2 = t2.b, p2 = t2.alpha, M2 = p2 === void 0 ? 1 : p2;
  if (!a$2(r2) || !a$2(h2) || !a$2(n2))
    return null;
  var u2 = function(a2) {
    return { l: o$2(a2.l, 0, 400), a: a2.a, b: a2.b, alpha: o$2(a2.alpha) };
  }({ l: Number(r2), a: Number(h2), b: Number(n2), alpha: Number(M2) });
  return l(u2);
};
var l = function(a2) {
  var t2 = (a2.l + 16) / 116, o2 = a2.a / 500 + t2, r2 = t2 - a2.b / 200;
  return u$2({ x: (Math.pow(o2, 3) > w ? Math.pow(o2, 3) : (116 * o2 - 16) / b$1) * n$2, y: (a2.l > 8 ? Math.pow((a2.l + 16) / 116, 3) : a2.l / b$1) * p, z: (Math.pow(r2, 3) > w ? Math.pow(r2, 3) : (116 * r2 - 16) / b$1) * M, a: a2.alpha });
};
function labPlugin(a2, r2) {
  a2.prototype.toLab = function() {
    return o2 = e$2(this.rgba), h2 = o2.y / p, u2 = o2.z / M, r3 = (r3 = o2.x / n$2) > w ? Math.cbrt(r3) : (b$1 * r3 + 16) / 116, a3 = { l: 116 * (h2 = h2 > w ? Math.cbrt(h2) : (b$1 * h2 + 16) / 116) - 16, a: 500 * (r3 - h2), b: 200 * (h2 - (u2 = u2 > w ? Math.cbrt(u2) : (b$1 * u2 + 16) / 116)), alpha: o2.a }, { l: t$2(a3.l, 2), a: t$2(a3.a, 2), b: t$2(a3.b, 2), alpha: t$2(a3.alpha, 3) };
    var a3, o2, r3, h2, u2;
  }, a2.prototype.delta = function(r3) {
    r3 === void 0 && (r3 = "#FFF");
    var h2 = r3 instanceof a2 ? r3 : new a2(r3), n2 = function(a3, t2) {
      var o2 = a3.l, r4 = a3.a, h3 = a3.b, n3 = t2.l, p2 = t2.a, M2 = t2.b, u2 = 180 / Math.PI, e2 = Math.PI / 180, w2 = Math.pow(Math.pow(r4, 2) + Math.pow(h3, 2), 0.5), b2 = Math.pow(Math.pow(p2, 2) + Math.pow(M2, 2), 0.5), i2 = (o2 + n3) / 2, l2 = Math.pow((w2 + b2) / 2, 7), c2 = 0.5 * (1 - Math.pow(l2 / (l2 + Math.pow(25, 7)), 0.5)), f2 = r4 * (1 + c2), y2 = p2 * (1 + c2), v2 = Math.pow(Math.pow(f2, 2) + Math.pow(h3, 2), 0.5), x2 = Math.pow(Math.pow(y2, 2) + Math.pow(M2, 2), 0.5), z = (v2 + x2) / 2, s2 = f2 === 0 && h3 === 0 ? 0 : Math.atan2(h3, f2) * u2, d2 = y2 === 0 && M2 === 0 ? 0 : Math.atan2(M2, y2) * u2;
      s2 < 0 && (s2 += 360), d2 < 0 && (d2 += 360);
      var g2 = d2 - s2, m2 = Math.abs(d2 - s2);
      m2 > 180 && d2 <= s2 ? g2 += 360 : m2 > 180 && d2 > s2 && (g2 -= 360);
      var N2 = s2 + d2;
      m2 <= 180 ? N2 /= 2 : N2 = (s2 + d2 < 360 ? N2 + 360 : N2 - 360) / 2;
      var F = 1 - 0.17 * Math.cos(e2 * (N2 - 30)) + 0.24 * Math.cos(2 * e2 * N2) + 0.32 * Math.cos(e2 * (3 * N2 + 6)) - 0.2 * Math.cos(e2 * (4 * N2 - 63)), L = n3 - o2, I = x2 - v2, P = 2 * Math.sin(e2 * g2 / 2) * Math.pow(v2 * x2, 0.5), j2 = 1 + 0.015 * Math.pow(i2 - 50, 2) / Math.pow(20 + Math.pow(i2 - 50, 2), 0.5), k2 = 1 + 0.045 * z, q = 1 + 0.015 * z * F, A = 30 * Math.exp(-1 * Math.pow((N2 - 275) / 25, 2)), B = -2 * Math.pow(l2 / (l2 + Math.pow(25, 7)), 0.5) * Math.sin(2 * e2 * A);
      return Math.pow(Math.pow(L / 1 / j2, 2) + Math.pow(I / 1 / k2, 2) + Math.pow(P / 1 / q, 2) + B * I * P / (1 * k2 * 1 * q), 0.5);
    }(this.toLab(), h2.toLab()) / 100;
    return o$2(t$2(n2, 3));
  }, r2.object.push([i$2, "lab"]);
}
var r$1 = function(r2) {
  return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
};
var n$1 = function(r2, n2, t2) {
  return n2 === void 0 && (n2 = 0), t2 === void 0 && (t2 = Math.pow(10, n2)), Math.round(t2 * r2) / t2 + 0;
};
var t$1 = function(r2, n2, t2) {
  return n2 === void 0 && (n2 = 0), t2 === void 0 && (t2 = 1), r2 > t2 ? t2 : r2 > n2 ? r2 : n2;
};
var u$1 = function(r2) {
  return { c: t$1(r2.c, 0, 100), m: t$1(r2.m, 0, 100), y: t$1(r2.y, 0, 100), k: t$1(r2.k, 0, 100), a: t$1(r2.a) };
};
var e$1 = function(r2) {
  return { c: n$1(r2.c, 2), m: n$1(r2.m, 2), y: n$1(r2.y, 2), k: n$1(r2.k, 2), a: n$1(r2.a, 3) };
};
function c(r2) {
  return { r: n$1(255 * (1 - r2.c / 100) * (1 - r2.k / 100)), g: n$1(255 * (1 - r2.m / 100) * (1 - r2.k / 100)), b: n$1(255 * (1 - r2.y / 100) * (1 - r2.k / 100)), a: r2.a };
}
function i$1(r2) {
  var t2 = 1 - Math.max(r2.r / 255, r2.g / 255, r2.b / 255), u2 = (1 - r2.r / 255 - t2) / (1 - t2), e2 = (1 - r2.g / 255 - t2) / (1 - t2), c2 = (1 - r2.b / 255 - t2) / (1 - t2);
  return { c: isNaN(u2) ? 0 : n$1(100 * u2), m: isNaN(e2) ? 0 : n$1(100 * e2), y: isNaN(c2) ? 0 : n$1(100 * c2), k: n$1(100 * t2), a: r2.a };
}
function o$1(n2) {
  var t2 = n2.c, e2 = n2.m, i2 = n2.y, o2 = n2.k, m2 = n2.a, a2 = m2 === void 0 ? 1 : m2;
  return r$1(t2) && r$1(e2) && r$1(i2) && r$1(o2) ? c(u$1({ c: Number(t2), m: Number(e2), y: Number(i2), k: Number(o2), a: Number(a2) })) : null;
}
var m = /^device-cmyk\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var a$1 = function(r2) {
  var n2 = m.exec(r2);
  return n2 ? c(u$1({ c: Number(n2[1]) * (n2[2] ? 1 : 100), m: Number(n2[3]) * (n2[4] ? 1 : 100), y: Number(n2[5]) * (n2[6] ? 1 : 100), k: Number(n2[7]) * (n2[8] ? 1 : 100), a: n2[9] === void 0 ? 1 : Number(n2[9]) / (n2[10] ? 100 : 1) })) : null;
};
function cmykPlugin(r2, n2) {
  r2.prototype.toCmyk = function() {
    return e$1(i$1(this.rgba));
  }, r2.prototype.toCmykString = function() {
    return r3 = e$1(i$1(this.rgba)), n3 = r3.c, t2 = r3.m, u2 = r3.y, c2 = r3.k, (o2 = r3.a) < 1 ? "device-cmyk(" + n3 + "% " + t2 + "% " + u2 + "% " + c2 + "% / " + o2 + ")" : "device-cmyk(" + n3 + "% " + t2 + "% " + u2 + "% " + c2 + "%)";
    var r3, n3, t2, u2, c2, o2;
  }, n2.object.push([o$1, "cmyk"]), n2.string.push([a$1, "cmyk"]);
}
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var t = function(r2) {
  return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
};
var n = function(r2, t2, n2) {
  return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
};
var u = function(r2, t2, n2) {
  return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
};
var a = function(r2) {
  return { h: (t2 = r2.h, (t2 = isFinite(t2) ? t2 % 360 : 0) > 0 ? t2 : t2 + 360), w: u(r2.w, 0, 100), b: u(r2.b, 0, 100), a: u(r2.a) };
  var t2;
};
var e = function(r2) {
  return { h: n(r2.h), w: n(r2.w), b: n(r2.b), a: n(r2.a, 3) };
};
var b = function(r2) {
  return { h: function(r3) {
    var t2 = r3.r, n2 = r3.g, u2 = r3.b, a2 = r3.a, e2 = Math.max(t2, n2, u2), b2 = e2 - Math.min(t2, n2, u2), o2 = b2 ? e2 === t2 ? (n2 - u2) / b2 : e2 === n2 ? 2 + (u2 - t2) / b2 : 4 + (t2 - n2) / b2 : 0;
    return { h: 60 * (o2 < 0 ? o2 + 6 : o2), s: e2 ? b2 / e2 * 100 : 0, v: e2 / 255 * 100, a: a2 };
  }(r2).h, w: Math.min(r2.r, r2.g, r2.b) / 255 * 100, b: 100 - Math.max(r2.r, r2.g, r2.b) / 255 * 100, a: r2.a };
};
var o = function(r2) {
  return function(r3) {
    var t2 = r3.h, n2 = r3.s, u2 = r3.v, a2 = r3.a;
    t2 = t2 / 360 * 6, n2 /= 100, u2 /= 100;
    var e2 = Math.floor(t2), b2 = u2 * (1 - n2), o2 = u2 * (1 - (t2 - e2) * n2), i2 = u2 * (1 - (1 - t2 + e2) * n2), h2 = e2 % 6;
    return { r: 255 * [u2, o2, b2, b2, i2, u2][h2], g: 255 * [i2, u2, u2, o2, b2, b2][h2], b: 255 * [b2, b2, i2, u2, u2, o2][h2], a: a2 };
  }({ h: r2.h, s: r2.b === 100 ? 0 : 100 - r2.w / (100 - r2.b) * 100, v: 100 - r2.b, a: r2.a });
};
var i = function(r2) {
  var n2 = r2.h, u2 = r2.w, e2 = r2.b, b2 = r2.a, i2 = b2 === void 0 ? 1 : b2;
  if (!t(n2) || !t(u2) || !t(e2))
    return null;
  var h2 = a({ h: Number(n2), w: Number(u2), b: Number(e2), a: Number(i2) });
  return o(h2);
};
var h = /^hwb\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var d = function(t2) {
  var n2 = h.exec(t2);
  if (!n2)
    return null;
  var u2, e2, b2 = a({ h: (u2 = n2[1], e2 = n2[2], e2 === void 0 && (e2 = "deg"), Number(u2) * (r[e2] || 1)), w: Number(n2[3]), b: Number(n2[4]), a: n2[5] === void 0 ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return o(b2);
};
function hwbPlugin(r2, t2) {
  r2.prototype.toHwb = function() {
    return e(b(this.rgba));
  }, r2.prototype.toHwbString = function() {
    return r3 = e(b(this.rgba)), t3 = r3.h, n2 = r3.w, u2 = r3.b, (a2 = r3.a) < 1 ? "hwb(" + t3 + " " + n2 + "% " + u2 + "% / " + a2 + ")" : "hwb(" + t3 + " " + n2 + "% " + u2 + "%)";
    var r3, t3, n2, u2, a2;
  }, t2.string.push([d, "hwb"]), t2.object.push([i, "hwb"]);
}
k([mixPlugin, lchPlugin, namesPlugin, labPlugin, cmykPlugin, hwbPlugin]);
function lchToHsl(n2 = 0, total = 12, a2 = 1, s2 = 20, lightness = 60) {
  let lch = `lch(${lightness}% ${s2} ${n2 * (360 / total)} / ${a2})`;
  let hsl = w$1(lch).toHslString();
  return hsl;
}
function getColorInfo(color) {
  const cld = w$1(color);
  let info = {
    dark: cld.isDark(),
    hex: cld.toHex(),
    rgb: cld.toRgbString(),
    name: cld.toName({ closest: true }),
    cmyk: cld.toCmykString(),
    hsl: cld.toHslString(),
    lab: cld.toLab()
  };
  return info;
}
function levelColor(i2 = 0, n2 = 3, a2 = "0.5", s2 = "0.8", l2 = "0.5", reverse = false) {
  if (reverse) {
    i2 = n2 - i2 - 1;
  }
  return `hsla(${i2 * (360 / n2)}, ${s2 * 100}%, ${l2 * 100}%, ${a2})`;
}
function chromaColorMix(chroma2, tonic, part = 0.3) {
  let hsl = w$1(pitchColor(tonic));
  let lch = w$1(lchToHsl(tonic, 12, 1));
  chroma2.split("").forEach((bit, i2) => {
    if (isInChroma(chroma2, tonic, i2)) {
      hsl = hsl.mix(pitchColor(i2), part);
      lch = lch.mix(lchToHsl(i2, 12, 1), part);
    }
  });
  return {
    hsl: hsl.toHslString(),
    lch: lch.toHslString()
  };
}
var tempo = reactive({
  initialized: false,
  bpm: useClamp(useStorage("tempo-bpm", 100), 10, 500),
  blink: false,
  started: false,
  playing: false,
  stopped: false,
  mute: useStorage("tempo-mute", true),
  volume: useClamp(useStorage("tempo-volume", 0.5), 0, 1),
  progress: 0,
  position: 0,
  ticks: 0,
  metre: {
    over: 4,
    under: 4,
    num: computed(() => (tempo.metre.over / (tempo.metre.under / 4)).toFixed(2))
  },
  hz: computed(() => (tempo.bpm / 60).toFixed(2)),
  note: computed(() => index$2.pitchClass(Frequency(tempo.hz).toNote())),
  tune: computed(() => {
    return index$2.pitchClass(tempo.note) + 4;
  }),
  pitch: computed(() => freqPitch(tempo.hz)),
  digit: computed(() => (Frequency(tempo.hz).toMidi() + 12 * 10 + 3) % 12),
  color: computed(() => pitchColor(tempo.digit)),
  tap: {
    last: 0,
    diff: 0,
    timeout: 2e3,
    times: [],
    bpm: null
  },
  set(diff) {
    tempo.bpm = Math.round(diff + tempo.bpm);
  }
});
function useTempo() {
  if (tempo.initialized)
    return tempo;
  const metro = shallowReactive({
    counter: 0
  });
  onMounted(() => {
    const { channel } = createChannel$1("tempo-tick");
    metro.channel = channel;
    metro.pluck = new Sampler({
      urls: {
        E1: "/logic/high.wav",
        E2: "/logic/low.wav"
      },
      volume: -20,
      envelope: {
        attack: 1e-3,
        release: 2
      },
      baseUrl: "/audio/metronome/"
    }).connect(channel);
    metro.loop = new Loop((time) => {
      let even = metro.counter % 2 == 0;
      if (even)
        tempo.blink = true;
      if (!tempo.mute) {
        metro.pluck.triggerAttackRelease(even ? "E1" : "E2", "16n", time, even ? 1 : 0.2);
      }
      metro.counter++;
      setTimeout(() => {
        tempo.blink = false;
      }, 60);
    }, "8n").start(0);
    useRafFn(() => {
      tempo.position = Transport.position;
      tempo.ticks = Transport.ticks;
      tempo.progress = metro.loop.progress;
    });
  });
  watch(() => tempo.volume, (vol) => metro.pluck.volume.rampTo(gainToDb(tempo.volume)));
  watch(() => tempo.bpm, (bpm) => Transport.bpm.rampTo(bpm, "4n"), { immediate: true });
  watch(() => tempo.stopped, (stop) => {
    if (stop) {
      Transport.stop();
      tempo.playing = false;
    }
  });
  watch(() => tempo.playing, (playing) => {
    if (playing) {
      if (!tempo.started) {
        start();
        tempo.started = true;
      }
      tempo.stopped = false;
      Transport.start();
    } else {
      Transport.pause();
    }
  }, {
    immediate: true
  });
  tempo.initialized = true;
  return tempo;
}
function tap() {
  var time = performance.now();
  if (tempo.tap.last) {
    tempo.tap.diff = time - tempo.tap.last;
    tempo.tap.times.push(tempo.tap.diff);
    refresh();
  }
  tempo.tap.last = time;
  beginTimeout();
}
function refresh() {
  if (tempo.tap.times.length > 2) {
    var average = tempo.tap.times.reduce((result, t2) => result += t2) / tempo.tap.times.length;
    var bpm = 1 / (average / 1e3) * 60;
    tempo.tap.bpm = bpm;
  }
}
var timer = null;
function beginTimeout() {
  clearTimeout(timer);
  timer = setTimeout(function() {
    tempo.tap.times = [tempo.tap.diff];
    tempo.tap.last = null;
  }, tempo.tap.timeout);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var Midi2 = {};
var midiFile = {};
function parseMidi(data) {
  var p2 = new Parser(data);
  var headerChunk = p2.readChunk();
  if (headerChunk.id != "MThd")
    throw "Bad MIDI file.  Expected 'MHdr', got: '" + headerChunk.id + "'";
  var header = parseHeader(headerChunk.data);
  var tracks2 = [];
  for (var i2 = 0; !p2.eof() && i2 < header.numTracks; i2++) {
    var trackChunk = p2.readChunk();
    if (trackChunk.id != "MTrk")
      throw "Bad MIDI file.  Expected 'MTrk', got: '" + trackChunk.id + "'";
    var track = parseTrack(trackChunk.data);
    tracks2.push(track);
  }
  return {
    header,
    tracks: tracks2
  };
}
function parseHeader(data) {
  var p2 = new Parser(data);
  var format = p2.readUInt16();
  var numTracks = p2.readUInt16();
  var result = {
    format,
    numTracks
  };
  var timeDivision = p2.readUInt16();
  if (timeDivision & 32768) {
    result.framesPerSecond = 256 - (timeDivision >> 8);
    result.ticksPerFrame = timeDivision & 255;
  } else {
    result.ticksPerBeat = timeDivision;
  }
  return result;
}
function parseTrack(data) {
  var p2 = new Parser(data);
  var events = [];
  while (!p2.eof()) {
    var event = readEvent();
    events.push(event);
  }
  return events;
  var lastEventTypeByte = null;
  function readEvent() {
    var event2 = {};
    event2.deltaTime = p2.readVarInt();
    var eventTypeByte = p2.readUInt8();
    if ((eventTypeByte & 240) === 240) {
      if (eventTypeByte === 255) {
        event2.meta = true;
        var metatypeByte = p2.readUInt8();
        var length = p2.readVarInt();
        switch (metatypeByte) {
          case 0:
            event2.type = "sequenceNumber";
            if (length !== 2)
              throw "Expected length for sequenceNumber event is 2, got " + length;
            event2.number = p2.readUInt16();
            return event2;
          case 1:
            event2.type = "text";
            event2.text = p2.readString(length);
            return event2;
          case 2:
            event2.type = "copyrightNotice";
            event2.text = p2.readString(length);
            return event2;
          case 3:
            event2.type = "trackName";
            event2.text = p2.readString(length);
            return event2;
          case 4:
            event2.type = "instrumentName";
            event2.text = p2.readString(length);
            return event2;
          case 5:
            event2.type = "lyrics";
            event2.text = p2.readString(length);
            return event2;
          case 6:
            event2.type = "marker";
            event2.text = p2.readString(length);
            return event2;
          case 7:
            event2.type = "cuePoint";
            event2.text = p2.readString(length);
            return event2;
          case 32:
            event2.type = "channelPrefix";
            if (length != 1)
              throw "Expected length for channelPrefix event is 1, got " + length;
            event2.channel = p2.readUInt8();
            return event2;
          case 33:
            event2.type = "portPrefix";
            if (length != 1)
              throw "Expected length for portPrefix event is 1, got " + length;
            event2.port = p2.readUInt8();
            return event2;
          case 47:
            event2.type = "endOfTrack";
            if (length != 0)
              throw "Expected length for endOfTrack event is 0, got " + length;
            return event2;
          case 81:
            event2.type = "setTempo";
            if (length != 3)
              throw "Expected length for setTempo event is 3, got " + length;
            event2.microsecondsPerBeat = p2.readUInt24();
            return event2;
          case 84:
            event2.type = "smpteOffset";
            if (length != 5)
              throw "Expected length for smpteOffset event is 5, got " + length;
            var hourByte = p2.readUInt8();
            var FRAME_RATES = { 0: 24, 32: 25, 64: 29, 96: 30 };
            event2.frameRate = FRAME_RATES[hourByte & 96];
            event2.hour = hourByte & 31;
            event2.min = p2.readUInt8();
            event2.sec = p2.readUInt8();
            event2.frame = p2.readUInt8();
            event2.subFrame = p2.readUInt8();
            return event2;
          case 88:
            event2.type = "timeSignature";
            if (length != 2 && length != 4)
              throw "Expected length for timeSignature event is 4 or 2, got " + length;
            event2.numerator = p2.readUInt8();
            event2.denominator = 1 << p2.readUInt8();
            if (length === 4) {
              event2.metronome = p2.readUInt8();
              event2.thirtyseconds = p2.readUInt8();
            } else {
              event2.metronome = 36;
              event2.thirtyseconds = 8;
            }
            return event2;
          case 89:
            event2.type = "keySignature";
            if (length != 2)
              throw "Expected length for keySignature event is 2, got " + length;
            event2.key = p2.readInt8();
            event2.scale = p2.readUInt8();
            return event2;
          case 127:
            event2.type = "sequencerSpecific";
            event2.data = p2.readBytes(length);
            return event2;
          default:
            event2.type = "unknownMeta";
            event2.data = p2.readBytes(length);
            event2.metatypeByte = metatypeByte;
            return event2;
        }
      } else if (eventTypeByte == 240) {
        event2.type = "sysEx";
        var length = p2.readVarInt();
        event2.data = p2.readBytes(length);
        return event2;
      } else if (eventTypeByte == 247) {
        event2.type = "endSysEx";
        var length = p2.readVarInt();
        event2.data = p2.readBytes(length);
        return event2;
      } else {
        throw "Unrecognised MIDI event type byte: " + eventTypeByte;
      }
    } else {
      var param1;
      if ((eventTypeByte & 128) === 0) {
        if (lastEventTypeByte === null)
          throw "Running status byte encountered before status byte";
        param1 = eventTypeByte;
        eventTypeByte = lastEventTypeByte;
        event2.running = true;
      } else {
        param1 = p2.readUInt8();
        lastEventTypeByte = eventTypeByte;
      }
      var eventType = eventTypeByte >> 4;
      event2.channel = eventTypeByte & 15;
      switch (eventType) {
        case 8:
          event2.type = "noteOff";
          event2.noteNumber = param1;
          event2.velocity = p2.readUInt8();
          return event2;
        case 9:
          var velocity = p2.readUInt8();
          event2.type = velocity === 0 ? "noteOff" : "noteOn";
          event2.noteNumber = param1;
          event2.velocity = velocity;
          if (velocity === 0)
            event2.byte9 = true;
          return event2;
        case 10:
          event2.type = "noteAftertouch";
          event2.noteNumber = param1;
          event2.amount = p2.readUInt8();
          return event2;
        case 11:
          event2.type = "controller";
          event2.controllerType = param1;
          event2.value = p2.readUInt8();
          return event2;
        case 12:
          event2.type = "programChange";
          event2.programNumber = param1;
          return event2;
        case 13:
          event2.type = "channelAftertouch";
          event2.amount = param1;
          return event2;
        case 14:
          event2.type = "pitchBend";
          event2.value = param1 + (p2.readUInt8() << 7) - 8192;
          return event2;
        default:
          throw "Unrecognised MIDI event type: " + eventType;
      }
    }
  }
}
function Parser(data) {
  this.buffer = data;
  this.bufferLen = this.buffer.length;
  this.pos = 0;
}
Parser.prototype.eof = function() {
  return this.pos >= this.bufferLen;
};
Parser.prototype.readUInt8 = function() {
  var result = this.buffer[this.pos];
  this.pos += 1;
  return result;
};
Parser.prototype.readInt8 = function() {
  var u2 = this.readUInt8();
  if (u2 & 128)
    return u2 - 256;
  else
    return u2;
};
Parser.prototype.readUInt16 = function() {
  var b0 = this.readUInt8(), b1 = this.readUInt8();
  return (b0 << 8) + b1;
};
Parser.prototype.readInt16 = function() {
  var u2 = this.readUInt16();
  if (u2 & 32768)
    return u2 - 65536;
  else
    return u2;
};
Parser.prototype.readUInt24 = function() {
  var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8();
  return (b0 << 16) + (b1 << 8) + b2;
};
Parser.prototype.readInt24 = function() {
  var u2 = this.readUInt24();
  if (u2 & 8388608)
    return u2 - 16777216;
  else
    return u2;
};
Parser.prototype.readUInt32 = function() {
  var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8(), b3 = this.readUInt8();
  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
};
Parser.prototype.readBytes = function(len) {
  var bytes = this.buffer.slice(this.pos, this.pos + len);
  this.pos += len;
  return bytes;
};
Parser.prototype.readString = function(len) {
  var bytes = this.readBytes(len);
  return String.fromCharCode.apply(null, bytes);
};
Parser.prototype.readVarInt = function() {
  var result = 0;
  while (!this.eof()) {
    var b2 = this.readUInt8();
    if (b2 & 128) {
      result += b2 & 127;
      result <<= 7;
    } else {
      return result + b2;
    }
  }
  return result;
};
Parser.prototype.readChunk = function() {
  var id = this.readString(4);
  var length = this.readUInt32();
  var data = this.readBytes(length);
  return {
    id,
    length,
    data
  };
};
var midiParser = parseMidi;
function writeMidi(data, opts) {
  if (typeof data !== "object")
    throw "Invalid MIDI data";
  opts = opts || {};
  var header = data.header || {};
  var tracks2 = data.tracks || [];
  var i2, len = tracks2.length;
  var w2 = new Writer();
  writeHeader(w2, header, len);
  for (i2 = 0; i2 < len; i2++) {
    writeTrack(w2, tracks2[i2], opts);
  }
  return w2.buffer;
}
function writeHeader(w2, header, numTracks) {
  var format = header.format == null ? 1 : header.format;
  var timeDivision = 128;
  if (header.timeDivision) {
    timeDivision = header.timeDivision;
  } else if (header.ticksPerFrame && header.framesPerSecond) {
    timeDivision = -(header.framesPerSecond & 255) << 8 | header.ticksPerFrame & 255;
  } else if (header.ticksPerBeat) {
    timeDivision = header.ticksPerBeat & 32767;
  }
  var h2 = new Writer();
  h2.writeUInt16(format);
  h2.writeUInt16(numTracks);
  h2.writeUInt16(timeDivision);
  w2.writeChunk("MThd", h2.buffer);
}
function writeTrack(w2, track, opts) {
  var t2 = new Writer();
  var i2, len = track.length;
  var eventTypeByte = null;
  for (i2 = 0; i2 < len; i2++) {
    if (opts.running === false || !opts.running && !track[i2].running)
      eventTypeByte = null;
    eventTypeByte = writeEvent(t2, track[i2], eventTypeByte, opts.useByte9ForNoteOff);
  }
  w2.writeChunk("MTrk", t2.buffer);
}
function writeEvent(w2, event, lastEventTypeByte, useByte9ForNoteOff) {
  var type = event.type;
  var deltaTime = event.deltaTime;
  var text = event.text || "";
  var data = event.data || [];
  var eventTypeByte = null;
  w2.writeVarInt(deltaTime);
  switch (type) {
    case "sequenceNumber":
      w2.writeUInt8(255);
      w2.writeUInt8(0);
      w2.writeVarInt(2);
      w2.writeUInt16(event.number);
      break;
    case "text":
      w2.writeUInt8(255);
      w2.writeUInt8(1);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "copyrightNotice":
      w2.writeUInt8(255);
      w2.writeUInt8(2);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "trackName":
      w2.writeUInt8(255);
      w2.writeUInt8(3);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "instrumentName":
      w2.writeUInt8(255);
      w2.writeUInt8(4);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "lyrics":
      w2.writeUInt8(255);
      w2.writeUInt8(5);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "marker":
      w2.writeUInt8(255);
      w2.writeUInt8(6);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "cuePoint":
      w2.writeUInt8(255);
      w2.writeUInt8(7);
      w2.writeVarInt(text.length);
      w2.writeString(text);
      break;
    case "channelPrefix":
      w2.writeUInt8(255);
      w2.writeUInt8(32);
      w2.writeVarInt(1);
      w2.writeUInt8(event.channel);
      break;
    case "portPrefix":
      w2.writeUInt8(255);
      w2.writeUInt8(33);
      w2.writeVarInt(1);
      w2.writeUInt8(event.port);
      break;
    case "endOfTrack":
      w2.writeUInt8(255);
      w2.writeUInt8(47);
      w2.writeVarInt(0);
      break;
    case "setTempo":
      w2.writeUInt8(255);
      w2.writeUInt8(81);
      w2.writeVarInt(3);
      w2.writeUInt24(event.microsecondsPerBeat);
      break;
    case "smpteOffset":
      w2.writeUInt8(255);
      w2.writeUInt8(84);
      w2.writeVarInt(5);
      var FRAME_RATES = { 24: 0, 25: 32, 29: 64, 30: 96 };
      var hourByte = event.hour & 31 | FRAME_RATES[event.frameRate];
      w2.writeUInt8(hourByte);
      w2.writeUInt8(event.min);
      w2.writeUInt8(event.sec);
      w2.writeUInt8(event.frame);
      w2.writeUInt8(event.subFrame);
      break;
    case "timeSignature":
      w2.writeUInt8(255);
      w2.writeUInt8(88);
      w2.writeVarInt(4);
      w2.writeUInt8(event.numerator);
      var denominator = Math.floor(Math.log(event.denominator) / Math.LN2) & 255;
      w2.writeUInt8(denominator);
      w2.writeUInt8(event.metronome);
      w2.writeUInt8(event.thirtyseconds || 8);
      break;
    case "keySignature":
      w2.writeUInt8(255);
      w2.writeUInt8(89);
      w2.writeVarInt(2);
      w2.writeInt8(event.key);
      w2.writeUInt8(event.scale);
      break;
    case "sequencerSpecific":
      w2.writeUInt8(255);
      w2.writeUInt8(127);
      w2.writeVarInt(data.length);
      w2.writeBytes(data);
      break;
    case "unknownMeta":
      if (event.metatypeByte != null) {
        w2.writeUInt8(255);
        w2.writeUInt8(event.metatypeByte);
        w2.writeVarInt(data.length);
        w2.writeBytes(data);
      }
      break;
    case "sysEx":
      w2.writeUInt8(240);
      w2.writeVarInt(data.length);
      w2.writeBytes(data);
      break;
    case "endSysEx":
      w2.writeUInt8(247);
      w2.writeVarInt(data.length);
      w2.writeBytes(data);
      break;
    case "noteOff":
      var noteByte = useByte9ForNoteOff !== false && event.byte9 || useByte9ForNoteOff && event.velocity == 0 ? 144 : 128;
      eventTypeByte = noteByte | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.noteNumber);
      w2.writeUInt8(event.velocity);
      break;
    case "noteOn":
      eventTypeByte = 144 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.noteNumber);
      w2.writeUInt8(event.velocity);
      break;
    case "noteAftertouch":
      eventTypeByte = 160 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.noteNumber);
      w2.writeUInt8(event.amount);
      break;
    case "controller":
      eventTypeByte = 176 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.controllerType);
      w2.writeUInt8(event.value);
      break;
    case "programChange":
      eventTypeByte = 192 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.programNumber);
      break;
    case "channelAftertouch":
      eventTypeByte = 208 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      w2.writeUInt8(event.amount);
      break;
    case "pitchBend":
      eventTypeByte = 224 | event.channel;
      if (eventTypeByte !== lastEventTypeByte)
        w2.writeUInt8(eventTypeByte);
      var value14 = 8192 + event.value;
      var lsb14 = value14 & 127;
      var msb14 = value14 >> 7 & 127;
      w2.writeUInt8(lsb14);
      w2.writeUInt8(msb14);
      break;
    default:
      throw "Unrecognized event type: " + type;
  }
  return eventTypeByte;
}
function Writer() {
  this.buffer = [];
}
Writer.prototype.writeUInt8 = function(v2) {
  this.buffer.push(v2 & 255);
};
Writer.prototype.writeInt8 = Writer.prototype.writeUInt8;
Writer.prototype.writeUInt16 = function(v2) {
  var b0 = v2 >> 8 & 255, b1 = v2 & 255;
  this.writeUInt8(b0);
  this.writeUInt8(b1);
};
Writer.prototype.writeInt16 = Writer.prototype.writeUInt16;
Writer.prototype.writeUInt24 = function(v2) {
  var b0 = v2 >> 16 & 255, b1 = v2 >> 8 & 255, b2 = v2 & 255;
  this.writeUInt8(b0);
  this.writeUInt8(b1);
  this.writeUInt8(b2);
};
Writer.prototype.writeInt24 = Writer.prototype.writeUInt24;
Writer.prototype.writeUInt32 = function(v2) {
  var b0 = v2 >> 24 & 255, b1 = v2 >> 16 & 255, b2 = v2 >> 8 & 255, b3 = v2 & 255;
  this.writeUInt8(b0);
  this.writeUInt8(b1);
  this.writeUInt8(b2);
  this.writeUInt8(b3);
};
Writer.prototype.writeInt32 = Writer.prototype.writeUInt32;
Writer.prototype.writeBytes = function(arr) {
  this.buffer = this.buffer.concat(Array.prototype.slice.call(arr, 0));
};
Writer.prototype.writeString = function(str) {
  var i2, len = str.length, arr = [];
  for (i2 = 0; i2 < len; i2++) {
    arr.push(str.codePointAt(i2));
  }
  this.writeBytes(arr);
};
Writer.prototype.writeVarInt = function(v2) {
  if (v2 < 0)
    throw "Cannot write negative variable-length integer";
  if (v2 <= 127) {
    this.writeUInt8(v2);
  } else {
    var i2 = v2;
    var bytes = [];
    bytes.push(i2 & 127);
    i2 >>= 7;
    while (i2) {
      var b2 = i2 & 127 | 128;
      bytes.push(b2);
      i2 >>= 7;
    }
    this.writeBytes(bytes.reverse());
  }
};
Writer.prototype.writeChunk = function(id, data) {
  this.writeString(id);
  this.writeUInt32(data.length);
  this.writeBytes(data);
};
var midiWriter = writeMidi;
midiFile.parseMidi = midiParser;
midiFile.writeMidi = midiWriter;
var Header = {};
var BinarySearch = {};
Object.defineProperty(BinarySearch, "__esModule", { value: true });
BinarySearch.insert = BinarySearch.search = void 0;
function search(array, value, prop) {
  if (prop === void 0) {
    prop = "ticks";
  }
  var beginning = 0;
  var len = array.length;
  var end = len;
  if (len > 0 && array[len - 1][prop] <= value) {
    return len - 1;
  }
  while (beginning < end) {
    var midPoint = Math.floor(beginning + (end - beginning) / 2);
    var event_1 = array[midPoint];
    var nextEvent = array[midPoint + 1];
    if (event_1[prop] === value) {
      for (var i2 = midPoint; i2 < array.length; i2++) {
        var testEvent = array[i2];
        if (testEvent[prop] === value) {
          midPoint = i2;
        }
      }
      return midPoint;
    } else if (event_1[prop] < value && nextEvent[prop] > value) {
      return midPoint;
    } else if (event_1[prop] > value) {
      end = midPoint;
    } else if (event_1[prop] < value) {
      beginning = midPoint + 1;
    }
  }
  return -1;
}
BinarySearch.search = search;
function insert(array, event, prop) {
  if (prop === void 0) {
    prop = "ticks";
  }
  if (array.length) {
    var index2 = search(array, event[prop], prop);
    array.splice(index2 + 1, 0, event);
  } else {
    array.push(event);
  }
}
BinarySearch.insert = insert;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Header = exports.keySignatureKeys = void 0;
  var BinarySearch_12 = BinarySearch;
  var privatePPQMap = /* @__PURE__ */ new WeakMap();
  exports.keySignatureKeys = [
    "Cb",
    "Gb",
    "Db",
    "Ab",
    "Eb",
    "Bb",
    "F",
    "C",
    "G",
    "D",
    "A",
    "E",
    "B",
    "F#",
    "C#"
  ];
  var Header2 = function() {
    function Header3(midiData) {
      var _this = this;
      this.tempos = [];
      this.timeSignatures = [];
      this.keySignatures = [];
      this.meta = [];
      this.name = "";
      privatePPQMap.set(this, 480);
      if (midiData) {
        privatePPQMap.set(this, midiData.header.ticksPerBeat);
        midiData.tracks.forEach(function(track) {
          track.forEach(function(event) {
            if (event.meta) {
              if (event.type === "timeSignature") {
                _this.timeSignatures.push({
                  ticks: event.absoluteTime,
                  timeSignature: [
                    event.numerator,
                    event.denominator
                  ]
                });
              } else if (event.type === "setTempo") {
                _this.tempos.push({
                  bpm: 6e7 / event.microsecondsPerBeat,
                  ticks: event.absoluteTime
                });
              } else if (event.type === "keySignature") {
                _this.keySignatures.push({
                  key: exports.keySignatureKeys[event.key + 7],
                  scale: event.scale === 0 ? "major" : "minor",
                  ticks: event.absoluteTime
                });
              }
            }
          });
        });
        var firstTrackCurrentTicks_1 = 0;
        midiData.tracks[0].forEach(function(event) {
          firstTrackCurrentTicks_1 += event.deltaTime;
          if (event.meta) {
            if (event.type === "trackName") {
              _this.name = event.text;
            } else if (event.type === "text" || event.type === "cuePoint" || event.type === "marker" || event.type === "lyrics") {
              _this.meta.push({
                text: event.text,
                ticks: firstTrackCurrentTicks_1,
                type: event.type
              });
            }
          }
        });
        this.update();
      }
    }
    Header3.prototype.update = function() {
      var _this = this;
      var currentTime = 0;
      var lastEventBeats = 0;
      this.tempos.sort(function(a2, b2) {
        return a2.ticks - b2.ticks;
      });
      this.tempos.forEach(function(event, index2) {
        var lastBPM = index2 > 0 ? _this.tempos[index2 - 1].bpm : _this.tempos[0].bpm;
        var beats = event.ticks / _this.ppq - lastEventBeats;
        var elapsedSeconds = 60 / lastBPM * beats;
        event.time = elapsedSeconds + currentTime;
        currentTime = event.time;
        lastEventBeats += beats;
      });
      this.timeSignatures.sort(function(a2, b2) {
        return a2.ticks - b2.ticks;
      });
      this.timeSignatures.forEach(function(event, index2) {
        var lastEvent = index2 > 0 ? _this.timeSignatures[index2 - 1] : _this.timeSignatures[0];
        var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;
        var elapsedMeasures = elapsedBeats / lastEvent.timeSignature[0] / (lastEvent.timeSignature[1] / 4);
        lastEvent.measures = lastEvent.measures || 0;
        event.measures = elapsedMeasures + lastEvent.measures;
      });
    };
    Header3.prototype.ticksToSeconds = function(ticks) {
      var index2 = (0, BinarySearch_12.search)(this.tempos, ticks);
      if (index2 !== -1) {
        var tempo2 = this.tempos[index2];
        var tempoTime = tempo2.time;
        var elapsedBeats = (ticks - tempo2.ticks) / this.ppq;
        return tempoTime + 60 / tempo2.bpm * elapsedBeats;
      } else {
        var beats = ticks / this.ppq;
        return 60 / 120 * beats;
      }
    };
    Header3.prototype.ticksToMeasures = function(ticks) {
      var index2 = (0, BinarySearch_12.search)(this.timeSignatures, ticks);
      if (index2 !== -1) {
        var timeSigEvent = this.timeSignatures[index2];
        var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;
        return timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;
      } else {
        return ticks / this.ppq / 4;
      }
    };
    Object.defineProperty(Header3.prototype, "ppq", {
      get: function() {
        return privatePPQMap.get(this);
      },
      enumerable: false,
      configurable: true
    });
    Header3.prototype.secondsToTicks = function(seconds) {
      var index2 = (0, BinarySearch_12.search)(this.tempos, seconds, "time");
      if (index2 !== -1) {
        var tempo2 = this.tempos[index2];
        var tempoTime = tempo2.time;
        var elapsedTime = seconds - tempoTime;
        var elapsedBeats = elapsedTime / (60 / tempo2.bpm);
        return Math.round(tempo2.ticks + elapsedBeats * this.ppq);
      } else {
        var beats = seconds / (60 / 120);
        return Math.round(beats * this.ppq);
      }
    };
    Header3.prototype.toJSON = function() {
      return {
        keySignatures: this.keySignatures,
        meta: this.meta,
        name: this.name,
        ppq: this.ppq,
        tempos: this.tempos.map(function(t2) {
          return {
            bpm: t2.bpm,
            ticks: t2.ticks
          };
        }),
        timeSignatures: this.timeSignatures
      };
    };
    Header3.prototype.fromJSON = function(json) {
      this.name = json.name;
      this.tempos = json.tempos.map(function(t2) {
        return Object.assign({}, t2);
      });
      this.timeSignatures = json.timeSignatures.map(function(t2) {
        return Object.assign({}, t2);
      });
      this.keySignatures = json.keySignatures.map(function(t2) {
        return Object.assign({}, t2);
      });
      this.meta = json.meta.map(function(t2) {
        return Object.assign({}, t2);
      });
      privatePPQMap.set(this, json.ppq);
      this.update();
    };
    Header3.prototype.setTempo = function(bpm) {
      this.tempos = [
        {
          bpm,
          ticks: 0
        }
      ];
      this.update();
    };
    return Header3;
  }();
  exports.Header = Header2;
})(Header);
var Track$1 = {};
var ControlChange = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ControlChange = exports.controlChangeIds = exports.controlChangeNames = void 0;
  exports.controlChangeNames = {
    1: "modulationWheel",
    2: "breath",
    4: "footController",
    5: "portamentoTime",
    7: "volume",
    8: "balance",
    10: "pan",
    64: "sustain",
    65: "portamentoTime",
    66: "sostenuto",
    67: "softPedal",
    68: "legatoFootswitch",
    84: "portamentoControl"
  };
  exports.controlChangeIds = Object.keys(exports.controlChangeNames).reduce(function(obj, key) {
    obj[exports.controlChangeNames[key]] = key;
    return obj;
  }, {});
  var privateHeaderMap2 = /* @__PURE__ */ new WeakMap();
  var privateCCNumberMap = /* @__PURE__ */ new WeakMap();
  var ControlChange2 = function() {
    function ControlChange3(event, header) {
      privateHeaderMap2.set(this, header);
      privateCCNumberMap.set(this, event.controllerType);
      this.ticks = event.absoluteTime;
      this.value = event.value;
    }
    Object.defineProperty(ControlChange3.prototype, "number", {
      get: function() {
        return privateCCNumberMap.get(this);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ControlChange3.prototype, "name", {
      get: function() {
        if (exports.controlChangeNames[this.number]) {
          return exports.controlChangeNames[this.number];
        } else {
          return null;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ControlChange3.prototype, "time", {
      get: function() {
        var header = privateHeaderMap2.get(this);
        return header.ticksToSeconds(this.ticks);
      },
      set: function(t2) {
        var header = privateHeaderMap2.get(this);
        this.ticks = header.secondsToTicks(t2);
      },
      enumerable: false,
      configurable: true
    });
    ControlChange3.prototype.toJSON = function() {
      return {
        number: this.number,
        ticks: this.ticks,
        time: this.time,
        value: this.value
      };
    };
    return ControlChange3;
  }();
  exports.ControlChange = ControlChange2;
})(ControlChange);
var ControlChanges = {};
Object.defineProperty(ControlChanges, "__esModule", { value: true });
ControlChanges.createControlChanges = void 0;
var ControlChange_1$1 = ControlChange;
function createControlChanges() {
  return new Proxy({}, {
    get: function(target, handler2) {
      if (target[handler2]) {
        return target[handler2];
      } else if (ControlChange_1$1.controlChangeIds.hasOwnProperty(handler2)) {
        return target[ControlChange_1$1.controlChangeIds[handler2]];
      }
    },
    set: function(target, handler2, value) {
      if (ControlChange_1$1.controlChangeIds.hasOwnProperty(handler2)) {
        target[ControlChange_1$1.controlChangeIds[handler2]] = value;
      } else {
        target[handler2] = value;
      }
      return true;
    }
  });
}
ControlChanges.createControlChanges = createControlChanges;
var PitchBend$1 = {};
Object.defineProperty(PitchBend$1, "__esModule", { value: true });
PitchBend$1.PitchBend = void 0;
var privateHeaderMap$2 = /* @__PURE__ */ new WeakMap();
var PitchBend = function() {
  function PitchBend2(event, header) {
    privateHeaderMap$2.set(this, header);
    this.ticks = event.absoluteTime;
    this.value = event.value;
  }
  Object.defineProperty(PitchBend2.prototype, "time", {
    get: function() {
      var header = privateHeaderMap$2.get(this);
      return header.ticksToSeconds(this.ticks);
    },
    set: function(t2) {
      var header = privateHeaderMap$2.get(this);
      this.ticks = header.secondsToTicks(t2);
    },
    enumerable: false,
    configurable: true
  });
  PitchBend2.prototype.toJSON = function() {
    return {
      ticks: this.ticks,
      time: this.time,
      value: this.value
    };
  };
  return PitchBend2;
}();
PitchBend$1.PitchBend = PitchBend;
var Instrument$1 = {};
var InstrumentMaps = {};
Object.defineProperty(InstrumentMaps, "__esModule", { value: true });
InstrumentMaps.DrumKitByPatchID = InstrumentMaps.InstrumentFamilyByID = InstrumentMaps.instrumentByPatchID = void 0;
InstrumentMaps.instrumentByPatchID = [
  "acoustic grand piano",
  "bright acoustic piano",
  "electric grand piano",
  "honky-tonk piano",
  "electric piano 1",
  "electric piano 2",
  "harpsichord",
  "clavi",
  "celesta",
  "glockenspiel",
  "music box",
  "vibraphone",
  "marimba",
  "xylophone",
  "tubular bells",
  "dulcimer",
  "drawbar organ",
  "percussive organ",
  "rock organ",
  "church organ",
  "reed organ",
  "accordion",
  "harmonica",
  "tango accordion",
  "acoustic guitar (nylon)",
  "acoustic guitar (steel)",
  "electric guitar (jazz)",
  "electric guitar (clean)",
  "electric guitar (muted)",
  "overdriven guitar",
  "distortion guitar",
  "guitar harmonics",
  "acoustic bass",
  "electric bass (finger)",
  "electric bass (pick)",
  "fretless bass",
  "slap bass 1",
  "slap bass 2",
  "synth bass 1",
  "synth bass 2",
  "violin",
  "viola",
  "cello",
  "contrabass",
  "tremolo strings",
  "pizzicato strings",
  "orchestral harp",
  "timpani",
  "string ensemble 1",
  "string ensemble 2",
  "synthstrings 1",
  "synthstrings 2",
  "choir aahs",
  "voice oohs",
  "synth voice",
  "orchestra hit",
  "trumpet",
  "trombone",
  "tuba",
  "muted trumpet",
  "french horn",
  "brass section",
  "synthbrass 1",
  "synthbrass 2",
  "soprano sax",
  "alto sax",
  "tenor sax",
  "baritone sax",
  "oboe",
  "english horn",
  "bassoon",
  "clarinet",
  "piccolo",
  "flute",
  "recorder",
  "pan flute",
  "blown bottle",
  "shakuhachi",
  "whistle",
  "ocarina",
  "lead 1 (square)",
  "lead 2 (sawtooth)",
  "lead 3 (calliope)",
  "lead 4 (chiff)",
  "lead 5 (charang)",
  "lead 6 (voice)",
  "lead 7 (fifths)",
  "lead 8 (bass + lead)",
  "pad 1 (new age)",
  "pad 2 (warm)",
  "pad 3 (polysynth)",
  "pad 4 (choir)",
  "pad 5 (bowed)",
  "pad 6 (metallic)",
  "pad 7 (halo)",
  "pad 8 (sweep)",
  "fx 1 (rain)",
  "fx 2 (soundtrack)",
  "fx 3 (crystal)",
  "fx 4 (atmosphere)",
  "fx 5 (brightness)",
  "fx 6 (goblins)",
  "fx 7 (echoes)",
  "fx 8 (sci-fi)",
  "sitar",
  "banjo",
  "shamisen",
  "koto",
  "kalimba",
  "bag pipe",
  "fiddle",
  "shanai",
  "tinkle bell",
  "agogo",
  "steel drums",
  "woodblock",
  "taiko drum",
  "melodic tom",
  "synth drum",
  "reverse cymbal",
  "guitar fret noise",
  "breath noise",
  "seashore",
  "bird tweet",
  "telephone ring",
  "helicopter",
  "applause",
  "gunshot"
];
InstrumentMaps.InstrumentFamilyByID = [
  "piano",
  "chromatic percussion",
  "organ",
  "guitar",
  "bass",
  "strings",
  "ensemble",
  "brass",
  "reed",
  "pipe",
  "synth lead",
  "synth pad",
  "synth effects",
  "world",
  "percussive",
  "sound effects"
];
InstrumentMaps.DrumKitByPatchID = {
  0: "standard kit",
  8: "room kit",
  16: "power kit",
  24: "electronic kit",
  25: "tr-808 kit",
  32: "jazz kit",
  40: "brush kit",
  48: "orchestra kit",
  56: "sound fx kit"
};
Object.defineProperty(Instrument$1, "__esModule", { value: true });
Instrument$1.Instrument = void 0;
var InstrumentMaps_1 = InstrumentMaps;
var privateTrackMap = /* @__PURE__ */ new WeakMap();
var Instrument2 = function() {
  function Instrument22(trackData, track) {
    this.number = 0;
    privateTrackMap.set(this, track);
    this.number = 0;
    if (trackData) {
      var programChange = trackData.find(function(e2) {
        return e2.type === "programChange";
      });
      if (programChange) {
        this.number = programChange.programNumber;
      }
    }
  }
  Object.defineProperty(Instrument22.prototype, "name", {
    get: function() {
      if (this.percussion) {
        return InstrumentMaps_1.DrumKitByPatchID[this.number];
      } else {
        return InstrumentMaps_1.instrumentByPatchID[this.number];
      }
    },
    set: function(n2) {
      var patchNumber = InstrumentMaps_1.instrumentByPatchID.indexOf(n2);
      if (patchNumber !== -1) {
        this.number = patchNumber;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Instrument22.prototype, "family", {
    get: function() {
      if (this.percussion) {
        return "drums";
      } else {
        return InstrumentMaps_1.InstrumentFamilyByID[Math.floor(this.number / 8)];
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Instrument22.prototype, "percussion", {
    get: function() {
      var track = privateTrackMap.get(this);
      return track.channel === 9;
    },
    enumerable: false,
    configurable: true
  });
  Instrument22.prototype.toJSON = function() {
    return {
      family: this.family,
      number: this.number,
      name: this.name
    };
  };
  Instrument22.prototype.fromJSON = function(json) {
    this.number = json.number;
  };
  return Instrument22;
}();
Instrument$1.Instrument = Instrument2;
var Note$1 = {};
Object.defineProperty(Note$1, "__esModule", { value: true });
Note$1.Note = void 0;
function midiToPitch(midi2) {
  var octave2 = Math.floor(midi2 / 12) - 1;
  return midiToPitchClass(midi2) + octave2.toString();
}
function midiToPitchClass(midi2) {
  var scaleIndexToNote2 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  var note2 = midi2 % 12;
  return scaleIndexToNote2[note2];
}
function pitchClassToMidi(pitch) {
  var scaleIndexToNote2 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  return scaleIndexToNote2.indexOf(pitch);
}
var pitchToMidi = function() {
  var regexp = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;
  var noteToScaleIndex2 = {
    cbb: -2,
    cb: -1,
    c: 0,
    "c#": 1,
    cx: 2,
    dbb: 0,
    db: 1,
    d: 2,
    "d#": 3,
    dx: 4,
    ebb: 2,
    eb: 3,
    e: 4,
    "e#": 5,
    ex: 6,
    fbb: 3,
    fb: 4,
    f: 5,
    "f#": 6,
    fx: 7,
    gbb: 5,
    gb: 6,
    g: 7,
    "g#": 8,
    gx: 9,
    abb: 7,
    ab: 8,
    a: 9,
    "a#": 10,
    ax: 11,
    bbb: 9,
    bb: 10,
    b: 11,
    "b#": 12,
    bx: 13
  };
  return function(note2) {
    var split = regexp.exec(note2);
    var pitch = split[1];
    var octave2 = split[2];
    var index2 = noteToScaleIndex2[pitch.toLowerCase()];
    return index2 + (parseInt(octave2, 10) + 1) * 12;
  };
}();
var privateHeaderMap$1 = /* @__PURE__ */ new WeakMap();
var Note = function() {
  function Note2(noteOn, noteOff, header) {
    privateHeaderMap$1.set(this, header);
    this.midi = noteOn.midi;
    this.velocity = noteOn.velocity;
    this.noteOffVelocity = noteOff.velocity;
    this.ticks = noteOn.ticks;
    this.durationTicks = noteOff.ticks - noteOn.ticks;
  }
  Object.defineProperty(Note2.prototype, "name", {
    get: function() {
      return midiToPitch(this.midi);
    },
    set: function(n2) {
      this.midi = pitchToMidi(n2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "octave", {
    get: function() {
      return Math.floor(this.midi / 12) - 1;
    },
    set: function(o2) {
      var diff = o2 - this.octave;
      this.midi += diff * 12;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "pitch", {
    get: function() {
      return midiToPitchClass(this.midi);
    },
    set: function(p2) {
      this.midi = 12 * (this.octave + 1) + pitchClassToMidi(p2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "duration", {
    get: function() {
      var header = privateHeaderMap$1.get(this);
      return header.ticksToSeconds(this.ticks + this.durationTicks) - header.ticksToSeconds(this.ticks);
    },
    set: function(d2) {
      var header = privateHeaderMap$1.get(this);
      var noteEndTicks = header.secondsToTicks(this.time + d2);
      this.durationTicks = noteEndTicks - this.ticks;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "time", {
    get: function() {
      var header = privateHeaderMap$1.get(this);
      return header.ticksToSeconds(this.ticks);
    },
    set: function(t2) {
      var header = privateHeaderMap$1.get(this);
      this.ticks = header.secondsToTicks(t2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Note2.prototype, "bars", {
    get: function() {
      var header = privateHeaderMap$1.get(this);
      return header.ticksToMeasures(this.ticks);
    },
    enumerable: false,
    configurable: true
  });
  Note2.prototype.toJSON = function() {
    return {
      duration: this.duration,
      durationTicks: this.durationTicks,
      midi: this.midi,
      name: this.name,
      ticks: this.ticks,
      time: this.time,
      velocity: this.velocity
    };
  };
  return Note2;
}();
Note$1.Note = Note;
Object.defineProperty(Track$1, "__esModule", { value: true });
Track$1.Track = void 0;
var BinarySearch_1 = BinarySearch;
var ControlChange_1 = ControlChange;
var ControlChanges_1 = ControlChanges;
var PitchBend_1 = PitchBend$1;
var Instrument_1 = Instrument$1;
var Note_1 = Note$1;
var privateHeaderMap = /* @__PURE__ */ new WeakMap();
var Track = function() {
  function Track2(trackData, header) {
    var _this = this;
    this.name = "";
    this.notes = [];
    this.controlChanges = (0, ControlChanges_1.createControlChanges)();
    this.pitchBends = [];
    privateHeaderMap.set(this, header);
    if (trackData) {
      var nameEvent = trackData.find(function(e2) {
        return e2.type === "trackName";
      });
      this.name = nameEvent ? nameEvent.text : "";
    }
    this.instrument = new Instrument_1.Instrument(trackData, this);
    this.channel = 0;
    if (trackData) {
      var noteOns = trackData.filter(function(event) {
        return event.type === "noteOn";
      });
      var noteOffs = trackData.filter(function(event) {
        return event.type === "noteOff";
      });
      var _loop_1 = function() {
        var currentNote = noteOns.shift();
        this_1.channel = currentNote.channel;
        var offIndex = noteOffs.findIndex(function(note2) {
          return note2.noteNumber === currentNote.noteNumber && note2.absoluteTime >= currentNote.absoluteTime;
        });
        if (offIndex !== -1) {
          var noteOff = noteOffs.splice(offIndex, 1)[0];
          this_1.addNote({
            durationTicks: noteOff.absoluteTime - currentNote.absoluteTime,
            midi: currentNote.noteNumber,
            noteOffVelocity: noteOff.velocity / 127,
            ticks: currentNote.absoluteTime,
            velocity: currentNote.velocity / 127
          });
        }
      };
      var this_1 = this;
      while (noteOns.length) {
        _loop_1();
      }
      var controlChanges = trackData.filter(function(event) {
        return event.type === "controller";
      });
      controlChanges.forEach(function(event) {
        _this.addCC({
          number: event.controllerType,
          ticks: event.absoluteTime,
          value: event.value / 127
        });
      });
      var pitchBends = trackData.filter(function(event) {
        return event.type === "pitchBend";
      });
      pitchBends.forEach(function(event) {
        _this.addPitchBend({
          ticks: event.absoluteTime,
          value: event.value / Math.pow(2, 13)
        });
      });
      var endOfTrackEvent = trackData.find(function(event) {
        return event.type === "endOfTrack";
      });
      this.endOfTrackTicks = endOfTrackEvent !== void 0 ? endOfTrackEvent.absoluteTime : void 0;
    }
  }
  Track2.prototype.addNote = function(props) {
    var header = privateHeaderMap.get(this);
    var note2 = new Note_1.Note({
      midi: 0,
      ticks: 0,
      velocity: 1
    }, {
      ticks: 0,
      velocity: 0
    }, header);
    Object.assign(note2, props);
    (0, BinarySearch_1.insert)(this.notes, note2, "ticks");
    return this;
  };
  Track2.prototype.addCC = function(props) {
    var header = privateHeaderMap.get(this);
    var cc = new ControlChange_1.ControlChange({
      controllerType: props.number
    }, header);
    delete props.number;
    Object.assign(cc, props);
    if (!Array.isArray(this.controlChanges[cc.number])) {
      this.controlChanges[cc.number] = [];
    }
    (0, BinarySearch_1.insert)(this.controlChanges[cc.number], cc, "ticks");
    return this;
  };
  Track2.prototype.addPitchBend = function(props) {
    var header = privateHeaderMap.get(this);
    var pb = new PitchBend_1.PitchBend({}, header);
    Object.assign(pb, props);
    (0, BinarySearch_1.insert)(this.pitchBends, pb, "ticks");
    return this;
  };
  Object.defineProperty(Track2.prototype, "duration", {
    get: function() {
      if (!this.notes.length) {
        return 0;
      }
      var maxDuration = this.notes[this.notes.length - 1].time + this.notes[this.notes.length - 1].duration;
      for (var i2 = 0; i2 < this.notes.length - 1; i2++) {
        var duration2 = this.notes[i2].time + this.notes[i2].duration;
        if (maxDuration < duration2) {
          maxDuration = duration2;
        }
      }
      return maxDuration;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Track2.prototype, "durationTicks", {
    get: function() {
      if (!this.notes.length) {
        return 0;
      }
      var maxDuration = this.notes[this.notes.length - 1].ticks + this.notes[this.notes.length - 1].durationTicks;
      for (var i2 = 0; i2 < this.notes.length - 1; i2++) {
        var duration2 = this.notes[i2].ticks + this.notes[i2].durationTicks;
        if (maxDuration < duration2) {
          maxDuration = duration2;
        }
      }
      return maxDuration;
    },
    enumerable: false,
    configurable: true
  });
  Track2.prototype.fromJSON = function(json) {
    var _this = this;
    this.name = json.name;
    this.channel = json.channel;
    this.instrument = new Instrument_1.Instrument(void 0, this);
    this.instrument.fromJSON(json.instrument);
    if (json.endOfTrackTicks !== void 0) {
      this.endOfTrackTicks = json.endOfTrackTicks;
    }
    for (var number in json.controlChanges) {
      if (json.controlChanges[number]) {
        json.controlChanges[number].forEach(function(cc) {
          _this.addCC({
            number: cc.number,
            ticks: cc.ticks,
            value: cc.value
          });
        });
      }
    }
    json.notes.forEach(function(n2) {
      _this.addNote({
        durationTicks: n2.durationTicks,
        midi: n2.midi,
        ticks: n2.ticks,
        velocity: n2.velocity
      });
    });
  };
  Track2.prototype.toJSON = function() {
    var controlChanges = {};
    for (var i2 = 0; i2 < 127; i2++) {
      if (this.controlChanges.hasOwnProperty(i2)) {
        controlChanges[i2] = this.controlChanges[i2].map(function(c2) {
          return c2.toJSON();
        });
      }
    }
    var json = {
      channel: this.channel,
      controlChanges,
      pitchBends: this.pitchBends.map(function(pb) {
        return pb.toJSON();
      }),
      instrument: this.instrument.toJSON(),
      name: this.name,
      notes: this.notes.map(function(n2) {
        return n2.toJSON();
      })
    };
    if (this.endOfTrackTicks !== void 0) {
      json.endOfTrackTicks = this.endOfTrackTicks;
    }
    return json;
  };
  return Track2;
}();
Track$1.Track = Track;
var Encode = {};
function flatten(array) {
  var result = [];
  $flatten(array, result);
  return result;
}
function $flatten(array, result) {
  for (var i2 = 0; i2 < array.length; i2++) {
    var value = array[i2];
    if (Array.isArray(value)) {
      $flatten(value, result);
    } else {
      result.push(value);
    }
  }
}
var dist_es2015 = Object.freeze(Object.defineProperty({
  __proto__: null,
  flatten
}, Symbol.toStringTag, { value: "Module" }));
var require$$2 = getAugmentedNamespace(dist_es2015);
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(Encode, "__esModule", { value: true });
Encode.encode = void 0;
var midi_file_1 = midiFile;
var Header_1 = Header;
var array_flatten_1 = require$$2;
function encodeNote(note2, channel) {
  return [
    {
      absoluteTime: note2.ticks,
      channel,
      deltaTime: 0,
      noteNumber: note2.midi,
      type: "noteOn",
      velocity: Math.floor(note2.velocity * 127)
    },
    {
      absoluteTime: note2.ticks + note2.durationTicks,
      channel,
      deltaTime: 0,
      noteNumber: note2.midi,
      type: "noteOff",
      velocity: Math.floor(note2.noteOffVelocity * 127)
    }
  ];
}
function encodeNotes(track) {
  return (0, array_flatten_1.flatten)(track.notes.map(function(note2) {
    return encodeNote(note2, track.channel);
  }));
}
function encodeControlChange(cc, channel) {
  return {
    absoluteTime: cc.ticks,
    channel,
    controllerType: cc.number,
    deltaTime: 0,
    type: "controller",
    value: Math.floor(cc.value * 127)
  };
}
function encodeControlChanges(track) {
  var controlChanges = [];
  for (var i2 = 0; i2 < 127; i2++) {
    if (track.controlChanges.hasOwnProperty(i2)) {
      track.controlChanges[i2].forEach(function(cc) {
        controlChanges.push(encodeControlChange(cc, track.channel));
      });
    }
  }
  return controlChanges;
}
function encodePitchBend(pb, channel) {
  return {
    absoluteTime: pb.ticks,
    channel,
    deltaTime: 0,
    type: "pitchBend",
    value: pb.value
  };
}
function encodePitchBends(track) {
  var pitchBends = [];
  track.pitchBends.forEach(function(pb) {
    pitchBends.push(encodePitchBend(pb, track.channel));
  });
  return pitchBends;
}
function encodeInstrument(track) {
  return {
    absoluteTime: 0,
    channel: track.channel,
    deltaTime: 0,
    programNumber: track.instrument.number,
    type: "programChange"
  };
}
function encodeTrackName(name2) {
  return {
    absoluteTime: 0,
    deltaTime: 0,
    meta: true,
    text: name2,
    type: "trackName"
  };
}
function encodeTempo(tempo2) {
  return {
    absoluteTime: tempo2.ticks,
    deltaTime: 0,
    meta: true,
    microsecondsPerBeat: Math.floor(6e7 / tempo2.bpm),
    type: "setTempo"
  };
}
function encodeTimeSignature(timeSig) {
  return {
    absoluteTime: timeSig.ticks,
    deltaTime: 0,
    denominator: timeSig.timeSignature[1],
    meta: true,
    metronome: 24,
    numerator: timeSig.timeSignature[0],
    thirtyseconds: 8,
    type: "timeSignature"
  };
}
function encodeKeySignature(keySig) {
  var keyIndex = Header_1.keySignatureKeys.indexOf(keySig.key);
  return {
    absoluteTime: keySig.ticks,
    deltaTime: 0,
    key: keyIndex + 7,
    meta: true,
    scale: keySig.scale === "major" ? 0 : 1,
    type: "keySignature"
  };
}
function encodeText(textEvent) {
  return {
    absoluteTime: textEvent.ticks,
    deltaTime: 0,
    meta: true,
    text: textEvent.text,
    type: textEvent.type
  };
}
function encode(midi2) {
  var midiData = {
    header: {
      format: 1,
      numTracks: midi2.tracks.length + 1,
      ticksPerBeat: midi2.header.ppq
    },
    tracks: __spreadArray([
      __spreadArray(__spreadArray(__spreadArray(__spreadArray([
        {
          absoluteTime: 0,
          deltaTime: 0,
          meta: true,
          text: midi2.header.name,
          type: "trackName"
        }
      ], midi2.header.keySignatures.map(function(keySig) {
        return encodeKeySignature(keySig);
      }), true), midi2.header.meta.map(function(e2) {
        return encodeText(e2);
      }), true), midi2.header.tempos.map(function(tempo2) {
        return encodeTempo(tempo2);
      }), true), midi2.header.timeSignatures.map(function(timeSig) {
        return encodeTimeSignature(timeSig);
      }), true)
    ], midi2.tracks.map(function(track) {
      return __spreadArray(__spreadArray(__spreadArray([
        encodeTrackName(track.name),
        encodeInstrument(track)
      ], encodeNotes(track), true), encodeControlChanges(track), true), encodePitchBends(track), true);
    }), true)
  };
  midiData.tracks = midiData.tracks.map(function(track) {
    track = track.sort(function(a2, b2) {
      return a2.absoluteTime - b2.absoluteTime;
    });
    var lastTime = 0;
    track.forEach(function(note2) {
      note2.deltaTime = note2.absoluteTime - lastTime;
      lastTime = note2.absoluteTime;
      delete note2.absoluteTime;
    });
    track.push({
      deltaTime: 0,
      meta: true,
      type: "endOfTrack"
    });
    return track;
  });
  return new Uint8Array((0, midi_file_1.writeMidi)(midiData));
}
Encode.encode = encode;
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n2) {
      return function(v2) {
        return step([n2, v2]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Header = exports.Track = exports.Midi = void 0;
  var midi_file_12 = midiFile;
  var Header_12 = Header;
  var Track_1 = Track$1;
  var Encode_1 = Encode;
  var Midi22 = function() {
    function Midi3(midiArray) {
      var _this = this;
      var midiData = null;
      if (midiArray) {
        var midiArrayLike = midiArray instanceof ArrayBuffer ? new Uint8Array(midiArray) : midiArray;
        midiData = (0, midi_file_12.parseMidi)(midiArrayLike);
        midiData.tracks.forEach(function(track) {
          var currentTicks = 0;
          track.forEach(function(event) {
            currentTicks += event.deltaTime;
            event.absoluteTime = currentTicks;
          });
        });
        midiData.tracks = splitTracks(midiData.tracks);
      }
      this.header = new Header_12.Header(midiData);
      this.tracks = [];
      if (midiArray) {
        this.tracks = midiData.tracks.map(function(trackData) {
          return new Track_1.Track(trackData, _this.header);
        });
        if (midiData.header.format === 1 && this.tracks[0].duration === 0) {
          this.tracks.shift();
        }
      }
    }
    Midi3.fromUrl = function(url) {
      return __awaiter2(this, void 0, void 0, function() {
        var response, arrayBuffer;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, fetch(url)];
            case 1:
              response = _a2.sent();
              if (!response.ok)
                return [3, 3];
              return [4, response.arrayBuffer()];
            case 2:
              arrayBuffer = _a2.sent();
              return [2, new Midi3(arrayBuffer)];
            case 3:
              throw new Error("Could not load '".concat(url, "'"));
          }
        });
      });
    };
    Object.defineProperty(Midi3.prototype, "name", {
      get: function() {
        return this.header.name;
      },
      set: function(n2) {
        this.header.name = n2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Midi3.prototype, "duration", {
      get: function() {
        var durations = this.tracks.map(function(t2) {
          return t2.duration;
        });
        return Math.max.apply(Math, durations);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Midi3.prototype, "durationTicks", {
      get: function() {
        var durationTicks = this.tracks.map(function(t2) {
          return t2.durationTicks;
        });
        return Math.max.apply(Math, durationTicks);
      },
      enumerable: false,
      configurable: true
    });
    Midi3.prototype.addTrack = function() {
      var track = new Track_1.Track(void 0, this.header);
      this.tracks.push(track);
      return track;
    };
    Midi3.prototype.toArray = function() {
      return (0, Encode_1.encode)(this);
    };
    Midi3.prototype.toJSON = function() {
      return {
        header: this.header.toJSON(),
        tracks: this.tracks.map(function(track) {
          return track.toJSON();
        })
      };
    };
    Midi3.prototype.fromJSON = function(json) {
      var _this = this;
      this.header = new Header_12.Header();
      this.header.fromJSON(json.header);
      this.tracks = json.tracks.map(function(trackJSON) {
        var track = new Track_1.Track(void 0, _this.header);
        track.fromJSON(trackJSON);
        return track;
      });
    };
    Midi3.prototype.clone = function() {
      var midi2 = new Midi3();
      midi2.fromJSON(this.toJSON());
      return midi2;
    };
    return Midi3;
  }();
  exports.Midi = Midi22;
  var Track_2 = Track$1;
  Object.defineProperty(exports, "Track", { enumerable: true, get: function() {
    return Track_2.Track;
  } });
  var Header_2 = Header;
  Object.defineProperty(exports, "Header", { enumerable: true, get: function() {
    return Header_2.Header;
  } });
  function splitTracks(tracks2) {
    var newTracks = [];
    for (var i2 = 0; i2 < tracks2.length; i2++) {
      var defaultTrack = newTracks.length;
      var trackMap = /* @__PURE__ */ new Map();
      var currentProgram = Array(16).fill(0);
      for (var _i = 0, _a2 = tracks2[i2]; _i < _a2.length; _i++) {
        var event_1 = _a2[_i];
        var targetTrack = defaultTrack;
        var channel = event_1.channel;
        if (channel !== void 0) {
          if (event_1.type === "programChange") {
            currentProgram[channel] = event_1.programNumber;
          }
          var program = currentProgram[channel];
          var trackKey = "".concat(program, " ").concat(channel);
          if (trackMap.has(trackKey)) {
            targetTrack = trackMap.get(trackKey);
          } else {
            targetTrack = defaultTrack + trackMap.size;
            trackMap.set(trackKey, targetTrack);
          }
        }
        if (!newTracks[targetTrack]) {
          newTracks.push([]);
        }
        newTracks[targetTrack].push(event_1);
      }
    }
    return newTracks;
  }
})(Midi2);
function createAndDownloadBlobFile(body, filename, extension = "mid") {
  const blob = new Blob([body]);
  const fileName = `${filename}.${extension}`;
  if (navigator.msSaveBlob) {
    navigator.msSaveBlob(blob, fileName);
  } else {
    const link = document.createElement("a");
    if (link.download !== void 0) {
      const url = URL.createObjectURL(blob);
      link.setAttribute("href", url);
      link.setAttribute("download", fileName);
      link.style.visibility = "hidden";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }
}
var loops = reactive([]);
function useLoop(order = 0) {
  const loop = reactive({
    pitch: computed(() => globalScale.tonic),
    chroma: computed(() => globalScale.set.chroma),
    metre: {
      over: useStorage(`grid-${order}-over`, 4),
      under: useStorage(`grid-${order}-under`, 4)
    },
    octave: useStorage(`grid-${order}-octave`, 3),
    volume: useStorage(`grid-${order}-vol`, 1),
    pan: useStorage(`grid-${order}-pan`, order % 2 == 1 ? -0.5 : 0.5),
    probability: useStorage(`grid-${order}-probability`, 1),
    tonic: computed(() => {
      return loop.pitch + 12 * loop.octave - 3;
    }),
    steps: useStorage(`grid-${order}-steps`, []),
    current: [],
    progress: computed(() => {
      if (tempo.ticks) {
        return sequence == null ? void 0 : sequence.progress;
      } else {
        return 0;
      }
    }),
    clear() {
      loop.steps.forEach((step, s2) => {
        loop.steps[s2] = [{}];
      });
    },
    rotate(way = 1) {
      loop.steps = rotateArray(loop.steps, way);
    }
  });
  loops[order] = loop;
  const { channel } = createChannel$1(`grid-loop-${order}`);
  const panner = new PanVol(loop.pan, 0).connect(channel);
  const synth2 = new PolySynth({
    envelope: {
      attack: 0.5,
      release: 0.2
    },
    filterEnvelope: {
      attack: 0.1,
      release: 0.2
    }
  }).connect(panner);
  synth2.maxPolyphony = 100;
  let sequence = new Sequence((time, step) => {
    beatClick(step, time);
  }, loop.steps, loop.metre.under + "n").start(0);
  watch(() => loop.metre.under, () => {
    sequence.stop().dispose();
    sequence = new Sequence((time, step) => {
      beatClick(step, time);
    }, loop.steps, loop.metre.under + "n").start(0);
    sequence.probability = loop.probability;
  });
  watch(() => loop.metre.over, () => {
    if (loop.steps.length > loop.metre.over) {
      loop.steps.length = loop.metre.over;
    } else {
      for (let i2 = loop.steps.length; i2 < loop.metre.over; i2++) {
        loop.steps.push([{}]);
      }
    }
    sequence.events = loop.steps;
  }, { immediate: true });
  watchEffect(() => {
    sequence.events = loop.steps;
  });
  watchEffect(() => {
    if (tempo.stopped) {
      loop.current = null;
    }
  });
  watchEffect(() => {
    sequence.probability = loop.probability;
    panner.volume.targetRampTo(gainToDb(loop.volume), 1);
    panner.pan.targetRampTo(loop.pan, 1);
  });
  function beatClick(step, time) {
    if (context.state == "suspended") {
      start();
    }
    let notes2 = Object.entries(step).map((entry) => {
      if (entry[0] == "sub")
        return;
      return entry[1] ? Midi(Number(entry[0]) + loop.tonic) : null;
    }).filter(Number);
    synth2.triggerAttackRelease(notes2, { [loop.metre.under + "n"]: 1 / (step.sub || 1) }, time);
    Draw.schedule(() => {
      let dur = Time({
        [loop.metre.under + "n"]: 1 / (step.sub || 1)
      }).toMilliseconds();
      let midiNotes = notes2.map((n2) => n2.toMidi());
      midiPlay(midiNotes, { duration: dur, attack: loop.volume });
    }, time);
  }
  onBeforeUnmount(() => {
    loops.splice(order, 1);
    sequence.stop().dispose();
    panner.dispose();
    synth2.dispose();
  });
  return loop;
}
var mic = reactive({
  initiated: false,
  open: false,
  opened: false,
  monitor: false,
  meter: 0,
  volume: useClamp(useStorage("mic-vol", 1), 0, 2),
  gate: useClamp(useStorage("mic-gate", -60), -100, -40)
});
var meter;
var input;
var gate;
var compressor;
function useMic() {
  if (!mic.initiated) {
    meter = new Meter();
    meter.normalRange = true;
    input = new UserMedia();
    compressor = new Compressor({ threshold: -20, ratio: 2 }).connect(meter);
    gate = new Gate({ threshold: -60, smoothing: 1 });
    input.connect(gate);
    gate.connect(compressor);
    const { channel } = createChannel$1("mic");
    watch(() => mic.open, (o2) => {
      if (o2) {
        input.open().then(() => {
          mic.opened = true;
          useRafFn(() => {
            mic.meter = meter.getValue();
          });
        });
      } else {
        input.close();
        mic.opened = false;
      }
    });
    watch(() => mic.monitor, (mon) => mon ? meter.connect(channel) : meter.disconnect(channel));
    watch(() => mic.volume, (vol) => input.volume.rampTo(gainToDb(vol)), { immediate: true });
    watch(() => mic.gate, (g2) => gate.threshold = g2, { immediate: true });
  }
  return { mic, input };
}
function useSvgMouse() {
  const svg = ref(null);
  const area = ref(null);
  const { pressed } = useMousePressed();
  const mouse = reactive({
    x: 0,
    y: 0,
    normX: 0,
    normY: 0,
    pressed,
    inside: false
  });
  onMounted(() => {
    svg.value.addEventListener("mousemove", getCursorPosition);
    const { isOutside } = useMouseInElement(area);
    watch(isOutside, (out) => {
      mouse.inside = !out;
    });
  });
  function getCursorPosition(event, svgElement = svg.value, rect = area.value) {
    if (!svgElement)
      return;
    var svgPoint = svgElement.createSVGPoint();
    svgPoint.x = event.clientX;
    svgPoint.y = event.clientY;
    let correct = svgPoint.matrixTransform(svgElement.getScreenCTM().inverse());
    if (rect) {
      let bounds = rect.getBBox();
      mouse.x = correct.x < bounds.width ? correct.x < 0 ? 0 : correct.x : bounds.width;
      mouse.y = correct.y < bounds.height ? correct.y < 0 ? 0 : correct.y : bounds.height;
      mouse.normY = 1 - mouse.y / bounds.height;
      mouse.normX = mouse.x / bounds.width;
    } else {
      mouse.x = correct.x;
      mouse.y = correct.y;
    }
  }
  return {
    svg,
    area,
    mouse
  };
}
var types = { brown: "brown", pink: "pink", white: "white" };
var filterTypes = { lowpass: "LP", highpass: "HP", bandpass: "BP" };
var filterLFOTypes = {
  sine: "SIN",
  triangle: "TRI",
  square: "SQR",
  sawtooth: "SAW"
};
var options = useStorage("noise-options", {
  noise: {
    type: "pink"
  },
  envelope: {
    attack: 0.1,
    decay: 0.1,
    sustain: 0.9,
    release: 1
  },
  volume: 1
});
var filterOptions = useStorage("filter-options", {
  on: false,
  play: false,
  volume: 0.5,
  baseFrequency: 50,
  depth: 0.1,
  frequency: 1,
  octaves: 2,
  wet: 1,
  type: "sine",
  filter: {
    Q: 1,
    type: "lowpass"
  }
});
var pannerOptions = useStorage("panner-options", {
  on: false,
  play: false,
  wet: 1,
  frequency: 1,
  depth: 1,
  volume: 1
});
var crusherOptions = useStorage("bit-options", {
  on: false,
  bits: 16,
  wet: 1,
  volume: 1
});
function useNoise() {
  const active = ref(false);
  const fftData = ref([]);
  const fftFreq = ref([]);
  const { channel } = createChannel$1("noise");
  const fft = new FFT({ size: 512, smoothing: 0.2 }).connect(channel);
  for (let j2 = 0; j2 < 32; j2++) {
    fftFreq.value[j2] = fft.getFrequencyOfIndex(j2);
  }
  const gain = new Gain(options.value.volume).connect(fft);
  const filterGain = new Gain(filterOptions.value.volume).connect(fft);
  const pannerGain = new Gain(pannerOptions.value.volume).connect(fft);
  const crusherGain = new Gain(crusherOptions.value.volume).connect(fft);
  const panner = new AutoPanner(pannerOptions.value).connect(pannerGain);
  const crusher = new BitCrusher(crusherOptions.value).connect(crusherGain).connect(panner);
  const filter2 = new AutoFilter(filterOptions.value).connect(filterGain).connect(crusher);
  const synth2 = new NoiseSynth(options.value).connect(gain).connect(filter2);
  useRafFn(() => {
    let arr = fft.getValue();
    for (let j2 = 0; j2 < 32; j2++) {
      fftData.value[j2] = dbToGain(arr[j2]) * 10;
    }
  });
  onKeyStroke(" ", (e2) => {
    e2.preventDefault();
    active.value = true;
  }, { eventName: "keydown" });
  onKeyStroke(" ", (e2) => {
    active.value = false;
  }, { eventName: "keyup" });
  watch(active, (act) => {
    if (act) {
      synth2.triggerAttack();
    } else {
      synth2.triggerRelease();
    }
  });
  watch(options.value, () => {
    synth2.set(options.value);
  });
  watch(() => options.value.volume, (vol) => {
    gain.gain.rampTo(vol, 1);
  });
  onBeforeUnmount(() => {
    synth2.triggerRelease();
  });
  watch(filterOptions.value, (opt) => {
    opt.play ? filter2.start() : filter2.stop();
    if (opt.on) {
      filterGain.gain.rampTo(filterOptions.value.volume, 0.2);
    } else {
      filterGain.gain.rampTo(0, 0.2);
    }
    filter2.set(opt);
  });
  watch(pannerOptions.value, (opt) => {
    opt.play ? panner.start() : panner.stop();
    opt.on ? pannerGain.gain.rampTo(pannerOptions.value.volume, 0.2) : pannerGain.gain.rampTo(0, 0.2);
    panner.set(opt);
  });
  watch(crusherOptions.value, (opt) => {
    opt.on ? crusherGain.gain.rampTo(crusherOptions.value.volume, 0.2) : crusherGain.gain.rampTo(0, 0.2);
    crusher.set(opt);
  });
  return {
    options,
    filterOptions,
    pannerOptions,
    crusherOptions,
    active,
    fftData,
    fftFreq,
    types,
    filterTypes,
    filterLFOTypes
  };
}
var piano;
function usePiano() {
  init$1();
  return { init: init$1, piano, pianoOnce, pianoAttack, pianoRelease, pianoReleaseAll };
}
function init$1() {
  start();
  if (piano)
    return;
  const { channel } = createChannel$1("piano");
  piano = new Sampler({
    urls: {
      A0: "A0.mp3",
      C1: "C1.mp3",
      "D#1": "Ds1.mp3",
      "F#1": "Fs1.mp3",
      A1: "A1.mp3",
      C2: "C2.mp3",
      "D#2": "Ds2.mp3",
      "F#2": "Fs2.mp3",
      A2: "A2.mp3",
      C3: "C3.mp3",
      "D#3": "Ds3.mp3",
      "F#3": "Fs3.mp3",
      A3: "A3.mp3",
      C4: "C4.mp3",
      "D#4": "Ds4.mp3",
      "F#4": "Fs4.mp3",
      A4: "A4.mp3",
      C5: "C5.mp3",
      "D#5": "Ds5.mp3",
      "F#5": "Fs5.mp3",
      A5: "A5.mp3",
      C6: "C6.mp3",
      "D#6": "Ds6.mp3",
      "F#6": "Fs6.mp3",
      A6: "A6.mp3",
      C7: "C7.mp3",
      "D#7": "Ds7.mp3",
      "F#7": "Fs7.mp3",
      A7: "A7.mp3",
      C8: "C8.mp3"
    },
    release: 1,
    volume: -10,
    baseUrl: "/audio/piano/"
  }).connect(channel);
}
function pianoOnce(note2 = "A4", duration2 = "8n", time) {
  if (!piano)
    return init$1();
  piano.triggerAttackRelease(note2, duration2, time);
}
function pianoAttack(note2, velocity) {
  if (!piano)
    return init$1();
  piano.triggerAttack(note2, now(), velocity);
}
function pianoRelease(note2) {
  if (!piano)
    return init$1();
  piano.triggerRelease(note2);
}
function pianoReleaseAll() {
  if (!piano)
    return init$1();
  piano.releaseAll();
}
var tracks = reactive([]);
function useSequence(metre = {
  over: 4,
  under: 4,
  sound: "A",
  volume: 1
}, order = 0, mode = "bar") {
  let pan = order % 2 == 1 ? -0.5 : 0.5;
  const audio2 = {
    meter: null,
    mic: null,
    recorder: null,
    panner: null,
    synth: null
  };
  const { channel } = createChannel$1(`sequence-${mode}-${order}`);
  audio2.panner = new PanVol(pan, 0).connect(channel);
  audio2.synth = new Sampler({
    urls: {
      A1: "tongue/high.wav",
      A2: "tongue/low.wav",
      B1: "synth/high.wav",
      B2: "synth/low.wav",
      C1: "seiko/high.wav",
      C2: "seiko/low.wav",
      D1: "/ping/high.wav",
      D2: "/ping/low.wav",
      E1: "/logic/high.wav",
      E2: "/logic/low.wav"
    },
    volume: 1,
    envelope: {
      attack: 1e-3,
      release: 2
    },
    baseUrl: "/audio/metronome/"
  }).connect(audio2.panner);
  audio2.recorder = new Recorder();
  const recorder2 = reactive({
    recording: false,
    main: false,
    accent: false,
    both: computed(() => recorder2.main && recorder2.accent),
    async load(pos = "main", blob) {
      let arr = await blob.arrayBuffer();
      let buff = await audio2.recorder.context.decodeAudioData(arr);
      audio2.synth.add(pos == "main" ? "F1" : "F2", buff);
      recorder2[pos] = true;
      recorder2.recording = false;
    },
    async rec(pos = "main") {
      if (!recorder2.recording) {
        audio2.meter = new Meter().connect(audio2.recorder);
        audio2.mic = new UserMedia(1).connect(audio2.meter);
        audio2.mic.open().then(() => {
          recorder2.recording = pos;
          audio2.recorder.start();
        }).catch((e2) => {
          console.log("mic not open");
        });
      } else {
        let blob = await audio2.recorder.stop();
        let arr = await blob.arrayBuffer();
        let buff = await audio2.recorder.context.decodeAudioData(arr);
        audio2.synth.add(pos == "main" ? "F1" : "F2", buff);
        recorder2[pos] = true;
        recorder2.recording = false;
      }
    }
  });
  watch(() => metre.sound, (sound) => {
    if (sound != "F") {
      recorder2.main = false;
      recorder2.accent = false;
    }
  });
  const current = ref("0-0");
  const steps = reactive([["0-1"], ["1-1"], ["2-1"], ["3-1"]]);
  const mutes = useStorage(`metro-${mode}-mutes-${order}`, []);
  const accents = useStorage(`metro-${mode}-accents-${order}`, [true]);
  const volume = useClamp(useStorage(`metro-${mode}-vol-${order}`, metre.volume || 1), 0, 1);
  const panning = useClamp(useStorage(`metro-${mode}-pan-${order}`, pan), -1, 1);
  const mutesCount = computed(() => mutes.value.reduce((acc, val) => {
    if (!val) {
      acc++;
    }
    return acc;
  }, 0));
  const euclidSeq = computed(() => mutesCount.value > 0 && mutesCount.value < steps.length ? getEuclideanRhythm(mutesCount.value, steps.length) : new Array(steps.length).fill("1").join(""));
  const currentSeq = computed(() => mutes.value.reduce((acc, val) => val ? acc + "0" : acc + "1", ""));
  const isEuclidean = computed(() => euclidSeq.value == currentSeq.value);
  function reset() {
    let arr = [];
    euclidSeq.value.split("").forEach((e2, i2) => {
      arr[i2] = e2 != false && e2 != null ? false : true;
    });
    mutes.value = arr;
  }
  let sequence = new Sequence((time, step) => {
    beatClick(step, time);
  }, steps, metre.under + "n").start(0);
  watch(() => metre.under, () => {
    sequence.stop().dispose();
    sequence = new Sequence((time, step) => {
      beatClick(step, time);
    }, steps, metre.under + "n").start(0);
  });
  watch(() => metre.over, () => {
    steps.length = 0;
    for (let i2 = 0; i2 < metre.over; i2++) {
      steps.push([`${i2}-1`]);
    }
    sequence.events = steps;
  }, { immediate: true });
  watchEffect(() => {
    sequence.events = steps;
    accents.value.length = steps.length;
    mutes.value.length = steps.length;
  });
  watchEffect(() => {
    if (tempo.stopped) {
      current.value = "1000-1";
    }
  });
  watch(volume, (vol) => {
    audio2.panner.volume.targetRampTo(gainToDb(vol), 1);
  }, { immediate: true });
  watch(panning, (p2) => {
    audio2.panner.pan.targetRampTo(p2, 1);
  }, { immediate: true });
  const progress = computed(() => {
    if (tempo.ticks) {
      return sequence.progress;
    } else {
      return 0;
    }
  });
  function beatClick(step, time) {
    if (context.state == "suspended") {
      start();
    }
    let mainStep = typeof step == "string" ? +step.split("-")[0] : step;
    Draw.schedule(() => {
      current.value = step;
    }, time);
    let accented = accents.value[mainStep] && step.split("-")[1] == "1";
    if (mutes.value[mainStep])
      return;
    if (mutes.value[step])
      return;
    if (metre.sound == "F" && !accented && !recorder2.main)
      return;
    if (metre.sound == "F" && accented && !recorder2.accent)
      return;
    let note2 = `${metre.sound}${accented ? 2 : 1}`;
    audio2.synth.triggerAttackRelease(note2, metre.under + "n", time);
  }
  const lastHit = ref(0);
  onKeyStroke("Shift", () => {
    lastHit.value = progress.value;
  });
  onBeforeUnmount(() => {
    sequence.stop().dispose();
    audio2.panner.dispose();
    audio2.synth.dispose();
  });
  tracks[order] = reactive({
    metre: computed(() => metre),
    steps,
    mutes,
    accents,
    mutesCount,
    isEuclidean,
    reset
  });
  return {
    progress,
    current,
    steps,
    mutes,
    accents,
    volume,
    panning,
    recorder: recorder2,
    lastHit,
    reset,
    isEuclidean
  };
}
function _getEuclideanRhythm(m2, k2, input2) {
  input2 = input2 || new Array(m2).fill("1").concat(new Array(k2).fill("0"));
  const output = [];
  for (let i2 = 0; i2 < Math.min(m2, k2); i2++) {
    output.push(input2.shift() + input2.pop());
  }
  if (input2.length > 1) {
    return _getEuclideanRhythm(output.length, input2.length, output.concat(input2));
  }
  return output.concat(input2);
}
function getEuclideanRhythm(x2, total) {
  return _getEuclideanRhythm(x2, total - x2).join("");
}
var meyda_min = { exports: {} };
(function(module, exports) {
  !function(r2, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    function r2(r3, t3, e3) {
      if (e3 || arguments.length === 2)
        for (var a3, n3 = 0, o3 = t3.length; n3 < o3; n3++)
          !a3 && n3 in t3 || (a3 || (a3 = Array.prototype.slice.call(t3, 0, n3)), a3[n3] = t3[n3]);
      return r3.concat(a3 || Array.prototype.slice.call(t3));
    }
    var t2 = Object.freeze({ __proto__: null, blackman: function(r3) {
      for (var t3 = new Float32Array(r3), e3 = 2 * Math.PI / (r3 - 1), a3 = 2 * e3, n3 = 0; n3 < r3 / 2; n3++)
        t3[n3] = 0.42 - 0.5 * Math.cos(n3 * e3) + 0.08 * Math.cos(n3 * a3);
      for (n3 = Math.ceil(r3 / 2); n3 > 0; n3--)
        t3[r3 - n3] = t3[n3 - 1];
      return t3;
    }, sine: function(r3) {
      for (var t3 = Math.PI / (r3 - 1), e3 = new Float32Array(r3), a3 = 0; a3 < r3; a3++)
        e3[a3] = Math.sin(t3 * a3);
      return e3;
    }, hanning: function(r3) {
      for (var t3 = new Float32Array(r3), e3 = 0; e3 < r3; e3++)
        t3[e3] = 0.5 - 0.5 * Math.cos(2 * Math.PI * e3 / (r3 - 1));
      return t3;
    }, hamming: function(r3) {
      for (var t3 = new Float32Array(r3), e3 = 0; e3 < r3; e3++)
        t3[e3] = 0.54 - 0.46 * Math.cos(2 * Math.PI * (e3 / r3 - 1));
      return t3;
    } }), e2 = {};
    function a2(r3) {
      for (; r3 % 2 == 0 && r3 > 1; )
        r3 /= 2;
      return r3 === 1;
    }
    function n2(r3, a3) {
      if (a3 !== "rect") {
        if (a3 !== "" && a3 || (a3 = "hanning"), e2[a3] || (e2[a3] = {}), !e2[a3][r3.length])
          try {
            e2[a3][r3.length] = t2[a3](r3.length);
          } catch (r4) {
            throw new Error("Invalid windowing function");
          }
        r3 = function(r4, t3) {
          for (var e3 = [], a4 = 0; a4 < Math.min(r4.length, t3.length); a4++)
            e3[a4] = r4[a4] * t3[a4];
          return e3;
        }(r3, e2[a3][r3.length]);
      }
      return r3;
    }
    function o2(r3, t3, e3) {
      for (var a3 = new Float32Array(r3), n3 = 0; n3 < a3.length; n3++)
        a3[n3] = n3 * t3 / e3, a3[n3] = 13 * Math.atan(a3[n3] / 1315.8) + 3.5 * Math.atan(Math.pow(a3[n3] / 7518, 2));
      return a3;
    }
    function i2(r3) {
      return Float32Array.from(r3);
    }
    function u2(r3) {
      return 1125 * Math.log(1 + r3 / 700);
    }
    function f2(r3, t3, e3) {
      for (var a3, n3 = new Float32Array(r3 + 2), o3 = new Float32Array(r3 + 2), i3 = t3 / 2, f3 = u2(0), c3 = (u2(i3) - f3) / (r3 + 1), l3 = new Array(r3 + 2), s3 = 0; s3 < n3.length; s3++)
        n3[s3] = s3 * c3, o3[s3] = (a3 = n3[s3], 700 * (Math.exp(a3 / 1125) - 1)), l3[s3] = Math.floor((e3 + 1) * o3[s3] / t3);
      for (var m3 = new Array(r3), p3 = 0; p3 < m3.length; p3++) {
        m3[p3] = new Array(e3 / 2 + 1).fill(0);
        for (s3 = l3[p3]; s3 < l3[p3 + 1]; s3++)
          m3[p3][s3] = (s3 - l3[p3]) / (l3[p3 + 1] - l3[p3]);
        for (s3 = l3[p3 + 1]; s3 < l3[p3 + 2]; s3++)
          m3[p3][s3] = (l3[p3 + 2] - s3) / (l3[p3 + 2] - l3[p3 + 1]);
      }
      return m3;
    }
    function c2(t3, e3, a3, n3, o3, i3, u3) {
      n3 === void 0 && (n3 = 5), o3 === void 0 && (o3 = 2), i3 === void 0 && (i3 = true), u3 === void 0 && (u3 = 440);
      var f3 = Math.floor(a3 / 2) + 1, c3 = new Array(a3).fill(0).map(function(r3, n4) {
        return t3 * function(r4, t4) {
          return Math.log2(16 * r4 / t4);
        }(e3 * n4 / a3, u3);
      });
      c3[0] = c3[1] - 1.5 * t3;
      var l3, s3, m3, p3 = c3.slice(1).map(function(r3, t4) {
        return Math.max(r3 - c3[t4]);
      }, 1).concat([1]), h3 = Math.round(t3 / 2), g3 = new Array(t3).fill(0).map(function(r3, e4) {
        return c3.map(function(r4) {
          return (10 * t3 + h3 + r4 - e4) % t3 - h3;
        });
      }), w3 = g3.map(function(r3, t4) {
        return r3.map(function(r4, e4) {
          return Math.exp(-0.5 * Math.pow(2 * g3[t4][e4] / p3[e4], 2));
        });
      });
      if (s3 = (l3 = w3)[0].map(function() {
        return 0;
      }), m3 = l3.reduce(function(r3, t4) {
        return t4.forEach(function(t5, e4) {
          r3[e4] += Math.pow(t5, 2);
        }), r3;
      }, s3).map(Math.sqrt), w3 = l3.map(function(r3, t4) {
        return r3.map(function(r4, t5) {
          return r4 / (m3[t5] || 1);
        });
      }), o3) {
        var v3 = c3.map(function(r3) {
          return Math.exp(-0.5 * Math.pow((r3 / t3 - n3) / o3, 2));
        });
        w3 = w3.map(function(r3) {
          return r3.map(function(r4, t4) {
            return r4 * v3[t4];
          });
        });
      }
      return i3 && (w3 = r2(r2([], w3.slice(3), true), w3.slice(0, 3), true)), w3.map(function(r3) {
        return r3.slice(0, f3);
      });
    }
    function l2(r3, t3) {
      for (var e3 = 0, a3 = 0, n3 = 0; n3 < t3.length; n3++)
        e3 += Math.pow(n3, r3) * Math.abs(t3[n3]), a3 += t3[n3];
      return e3 / a3;
    }
    function s2(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.barkScale, a3 = r3.numberOfBarkBands, n3 = a3 === void 0 ? 24 : a3;
      if (typeof t3 != "object" || typeof e3 != "object")
        throw new TypeError();
      var o3 = n3, i3 = new Float32Array(o3), u3 = 0, f3 = t3, c3 = new Int32Array(o3 + 1);
      c3[0] = 0;
      for (var l3 = e3[f3.length - 1] / o3, s3 = 1, m3 = 0; m3 < f3.length; m3++)
        for (; e3[m3] > l3; )
          c3[s3++] = m3, l3 = s3 * e3[f3.length - 1] / o3;
      c3[o3] = f3.length - 1;
      for (m3 = 0; m3 < o3; m3++) {
        for (var p3 = 0, h3 = c3[m3]; h3 < c3[m3 + 1]; h3++)
          p3 += f3[h3];
        i3[m3] = Math.pow(p3, 0.23);
      }
      for (m3 = 0; m3 < i3.length; m3++)
        u3 += i3[m3];
      return { specific: i3, total: u3 };
    }
    function m2(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = new Float32Array(t3.length), a3 = 0; a3 < e3.length; a3++)
        e3[a3] = Math.pow(t3[a3], 2);
      return e3;
    }
    function p2(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.melFilterBank, a3 = r3.bufferSize;
      if (typeof t3 != "object")
        throw new TypeError("Valid ampSpectrum is required to generate melBands");
      if (typeof e3 != "object")
        throw new TypeError("Valid melFilterBank is required to generate melBands");
      for (var n3 = m2({ ampSpectrum: t3 }), o3 = e3.length, i3 = Array(o3), u3 = new Float32Array(o3), f3 = 0; f3 < u3.length; f3++) {
        i3[f3] = new Float32Array(a3 / 2), u3[f3] = 0;
        for (var c3 = 0; c3 < a3 / 2; c3++)
          i3[f3][c3] = e3[f3][c3] * n3[c3], u3[f3] += i3[f3][c3];
        u3[f3] = Math.log(u3[f3] + 1);
      }
      return Array.prototype.slice.call(u3);
    }
    function h2(r3) {
      return r3 && r3.__esModule && Object.prototype.hasOwnProperty.call(r3, "default") ? r3.default : r3;
    }
    var g2 = { exports: {} }, w2 = null;
    var v2 = function(r3, t3) {
      var e3 = r3.length;
      return t3 = t3 || 2, w2 && w2[e3] || function(r4) {
        (w2 = w2 || {})[r4] = new Array(r4 * r4);
        for (var t4 = Math.PI / r4, e4 = 0; e4 < r4; e4++)
          for (var a3 = 0; a3 < r4; a3++)
            w2[r4][a3 + e4 * r4] = Math.cos(t4 * (a3 + 0.5) * e4);
      }(e3), r3.map(function() {
        return 0;
      }).map(function(a3, n3) {
        return t3 * r3.reduce(function(r4, t4, a4, o3) {
          return r4 + t4 * w2[e3][a4 + n3 * e3];
        }, 0);
      });
    };
    !function(r3) {
      r3.exports = v2;
    }(g2);
    var d2 = h2(g2.exports);
    var y2 = Object.freeze({ __proto__: null, buffer: function(r3) {
      return r3.signal;
    }, rms: function(r3) {
      var t3 = r3.signal;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = 0, a3 = 0; a3 < t3.length; a3++)
        e3 += Math.pow(t3[a3], 2);
      return e3 /= t3.length, e3 = Math.sqrt(e3);
    }, energy: function(r3) {
      var t3 = r3.signal;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = 0, a3 = 0; a3 < t3.length; a3++)
        e3 += Math.pow(Math.abs(t3[a3]), 2);
      return e3;
    }, complexSpectrum: function(r3) {
      return r3.complexSpectrum;
    }, spectralSlope: function(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.sampleRate, a3 = r3.bufferSize;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var n3 = 0, o3 = 0, i3 = new Float32Array(t3.length), u3 = 0, f3 = 0, c3 = 0; c3 < t3.length; c3++) {
        n3 += t3[c3];
        var l3 = c3 * e3 / a3;
        i3[c3] = l3, u3 += l3 * l3, o3 += l3, f3 += l3 * t3[c3];
      }
      return (t3.length * f3 - o3 * n3) / (n3 * (u3 - Math.pow(o3, 2)));
    }, spectralCentroid: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      return l2(1, t3);
    }, spectralRolloff: function(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.sampleRate;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var a3 = t3, n3 = e3 / (2 * (a3.length - 1)), o3 = 0, i3 = 0; i3 < a3.length; i3++)
        o3 += a3[i3];
      for (var u3 = 0.99 * o3, f3 = a3.length - 1; o3 > u3 && f3 >= 0; )
        o3 -= a3[f3], --f3;
      return (f3 + 1) * n3;
    }, spectralFlatness: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = 0, a3 = 0, n3 = 0; n3 < t3.length; n3++)
        e3 += Math.log(t3[n3]), a3 += t3[n3];
      return Math.exp(e3 / t3.length) * t3.length / a3;
    }, spectralSpread: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      return Math.sqrt(l2(2, t3) - Math.pow(l2(1, t3), 2));
    }, spectralSkewness: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      var e3 = l2(1, t3), a3 = l2(2, t3), n3 = l2(3, t3);
      return (2 * Math.pow(e3, 3) - 3 * e3 * a3 + n3) / Math.pow(Math.sqrt(a3 - Math.pow(e3, 2)), 3);
    }, spectralKurtosis: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      var e3 = t3, a3 = l2(1, e3), n3 = l2(2, e3), o3 = l2(3, e3), i3 = l2(4, e3);
      return (-3 * Math.pow(a3, 4) + 6 * a3 * n3 - 4 * a3 * o3 + i3) / Math.pow(Math.sqrt(n3 - Math.pow(a3, 2)), 4);
    }, amplitudeSpectrum: function(r3) {
      return r3.ampSpectrum;
    }, zcr: function(r3) {
      var t3 = r3.signal;
      if (typeof t3 != "object")
        throw new TypeError();
      for (var e3 = 0, a3 = 1; a3 < t3.length; a3++)
        (t3[a3 - 1] >= 0 && t3[a3] < 0 || t3[a3 - 1] < 0 && t3[a3] >= 0) && e3++;
      return e3;
    }, loudness: s2, perceptualSpread: function(r3) {
      for (var t3 = s2({ ampSpectrum: r3.ampSpectrum, barkScale: r3.barkScale }), e3 = 0, a3 = 0; a3 < t3.specific.length; a3++)
        t3.specific[a3] > e3 && (e3 = t3.specific[a3]);
      return Math.pow((t3.total - e3) / t3.total, 2);
    }, perceptualSharpness: function(r3) {
      for (var t3 = s2({ ampSpectrum: r3.ampSpectrum, barkScale: r3.barkScale }), e3 = t3.specific, a3 = 0, n3 = 0; n3 < e3.length; n3++)
        a3 += n3 < 15 ? (n3 + 1) * e3[n3 + 1] : 0.066 * Math.exp(0.171 * (n3 + 1));
      return a3 *= 0.11 / t3.total;
    }, powerSpectrum: m2, mfcc: function(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.melFilterBank, a3 = r3.numberOfMFCCCoefficients, n3 = r3.bufferSize, o3 = Math.min(40, Math.max(1, a3 || 13));
      if (e3.length < o3)
        throw new Error("Insufficient filter bank for requested number of coefficients");
      var i3 = p2({ ampSpectrum: t3, melFilterBank: e3, bufferSize: n3 });
      return d2(i3).slice(0, o3);
    }, chroma: function(r3) {
      var t3 = r3.ampSpectrum, e3 = r3.chromaFilterBank;
      if (typeof t3 != "object")
        throw new TypeError("Valid ampSpectrum is required to generate chroma");
      if (typeof e3 != "object")
        throw new TypeError("Valid chromaFilterBank is required to generate chroma");
      var a3 = e3.map(function(r4, e4) {
        return t3.reduce(function(t4, e5, a4) {
          return t4 + e5 * r4[a4];
        }, 0);
      }), n3 = Math.max.apply(Math, a3);
      return n3 ? a3.map(function(r4) {
        return r4 / n3;
      }) : a3;
    }, spectralFlux: function(r3) {
      var t3 = r3.signal, e3 = r3.previousSignal, a3 = r3.bufferSize;
      if (typeof t3 != "object" || typeof e3 != "object")
        throw new TypeError();
      for (var n3 = 0, o3 = -a3 / 2; o3 < t3.length / 2 - 1; o3++)
        x = Math.abs(t3[o3]) - Math.abs(e3[o3]), n3 += (x + Math.abs(x)) / 2;
      return n3;
    }, spectralCrest: function(r3) {
      var t3 = r3.ampSpectrum;
      if (typeof t3 != "object")
        throw new TypeError();
      var e3 = 0, a3 = -1 / 0;
      return t3.forEach(function(r4) {
        e3 += Math.pow(r4, 2), a3 = r4 > a3 ? r4 : a3;
      }), e3 /= t3.length, e3 = Math.sqrt(e3), a3 / e3;
    }, melBands: p2 });
    function S2(r3) {
      if (Array.isArray(r3)) {
        for (var t3 = 0, e3 = Array(r3.length); t3 < r3.length; t3++)
          e3[t3] = r3[t3];
        return e3;
      }
      return Array.from(r3);
    }
    var _ = {}, b2 = {}, M2 = { bitReverseArray: function(r3) {
      if (_[r3] === void 0) {
        for (var t3 = (r3 - 1).toString(2).length, e3 = "0".repeat(t3), a3 = {}, n3 = 0; n3 < r3; n3++) {
          var o3 = n3.toString(2);
          o3 = e3.substr(o3.length) + o3, o3 = [].concat(S2(o3)).reverse().join(""), a3[n3] = parseInt(o3, 2);
        }
        _[r3] = a3;
      }
      return _[r3];
    }, multiply: function(r3, t3) {
      return { real: r3.real * t3.real - r3.imag * t3.imag, imag: r3.real * t3.imag + r3.imag * t3.real };
    }, add: function(r3, t3) {
      return { real: r3.real + t3.real, imag: r3.imag + t3.imag };
    }, subtract: function(r3, t3) {
      return { real: r3.real - t3.real, imag: r3.imag - t3.imag };
    }, euler: function(r3, t3) {
      var e3 = -2 * Math.PI * r3 / t3;
      return { real: Math.cos(e3), imag: Math.sin(e3) };
    }, conj: function(r3) {
      return r3.imag *= -1, r3;
    }, constructComplexArray: function(r3) {
      var t3 = {};
      t3.real = r3.real === void 0 ? r3.slice() : r3.real.slice();
      var e3 = t3.real.length;
      return b2[e3] === void 0 && (b2[e3] = Array.apply(null, Array(e3)).map(Number.prototype.valueOf, 0)), t3.imag = b2[e3].slice(), t3;
    } }, F = function(r3) {
      var t3 = {};
      r3.real === void 0 || r3.imag === void 0 ? t3 = M2.constructComplexArray(r3) : (t3.real = r3.real.slice(), t3.imag = r3.imag.slice());
      var e3 = t3.real.length, a3 = Math.log2(e3);
      if (Math.round(a3) != a3)
        throw new Error("Input size must be a power of 2.");
      if (t3.real.length != t3.imag.length)
        throw new Error("Real and imaginary components must have the same length.");
      for (var n3 = M2.bitReverseArray(e3), o3 = { real: [], imag: [] }, i3 = 0; i3 < e3; i3++)
        o3.real[n3[i3]] = t3.real[i3], o3.imag[n3[i3]] = t3.imag[i3];
      for (var u3 = 0; u3 < e3; u3++)
        t3.real[u3] = o3.real[u3], t3.imag[u3] = o3.imag[u3];
      for (var f3 = 1; f3 <= a3; f3++)
        for (var c3 = Math.pow(2, f3), l3 = 0; l3 < c3 / 2; l3++)
          for (var s3 = M2.euler(l3, c3), m3 = 0; m3 < e3 / c3; m3++) {
            var p3 = c3 * m3 + l3, h3 = c3 * m3 + l3 + c3 / 2, g3 = { real: t3.real[p3], imag: t3.imag[p3] }, w3 = { real: t3.real[h3], imag: t3.imag[h3] }, v3 = M2.multiply(s3, w3), d3 = M2.subtract(g3, v3);
            t3.real[h3] = d3.real, t3.imag[h3] = d3.imag;
            var y3 = M2.add(v3, g3);
            t3.real[p3] = y3.real, t3.imag[p3] = y3.imag;
          }
      return t3;
    }, A = F, E = function() {
      function r3(r4, t3) {
        var e3 = this;
        if (this._m = t3, !r4.audioContext)
          throw this._m.errors.noAC;
        if (r4.bufferSize && !a2(r4.bufferSize))
          throw this._m._errors.notPow2;
        if (!r4.source)
          throw this._m._errors.noSource;
        this._m.audioContext = r4.audioContext, this._m.bufferSize = r4.bufferSize || this._m.bufferSize || 256, this._m.hopSize = r4.hopSize || this._m.hopSize || this._m.bufferSize, this._m.sampleRate = r4.sampleRate || this._m.audioContext.sampleRate || 44100, this._m.callback = r4.callback, this._m.windowingFunction = r4.windowingFunction || "hanning", this._m.featureExtractors = y2, this._m.EXTRACTION_STARTED = r4.startImmediately || false, this._m.channel = typeof r4.channel == "number" ? r4.channel : 0, this._m.inputs = r4.inputs || 1, this._m.outputs = r4.outputs || 1, this._m.numberOfMFCCCoefficients = r4.numberOfMFCCCoefficients || this._m.numberOfMFCCCoefficients || 13, this._m.numberOfBarkBands = r4.numberOfBarkBands || this._m.numberOfBarkBands || 24, this._m.spn = this._m.audioContext.createScriptProcessor(this._m.bufferSize, this._m.inputs, this._m.outputs), this._m.spn.connect(this._m.audioContext.destination), this._m._featuresToExtract = r4.featureExtractors || [], this._m.barkScale = o2(this._m.bufferSize, this._m.sampleRate, this._m.bufferSize), this._m.melFilterBank = f2(Math.max(this._m.melBands, this._m.numberOfMFCCCoefficients), this._m.sampleRate, this._m.bufferSize), this._m.inputData = null, this._m.previousInputData = null, this._m.frame = null, this._m.previousFrame = null, this.setSource(r4.source), this._m.spn.onaudioprocess = function(r5) {
          var t4;
          e3._m.inputData !== null && (e3._m.previousInputData = e3._m.inputData), e3._m.inputData = r5.inputBuffer.getChannelData(e3._m.channel), e3._m.previousInputData ? ((t4 = new Float32Array(e3._m.previousInputData.length + e3._m.inputData.length - e3._m.hopSize)).set(e3._m.previousInputData.slice(e3._m.hopSize)), t4.set(e3._m.inputData, e3._m.previousInputData.length - e3._m.hopSize)) : t4 = e3._m.inputData, function(r6, t5, e4) {
            if (r6.length < t5)
              throw new Error("Buffer is too short for frame length");
            if (e4 < 1)
              throw new Error("Hop length cannot be less that 1");
            if (t5 < 1)
              throw new Error("Frame length cannot be less that 1");
            var a3 = 1 + Math.floor((r6.length - t5) / e4);
            return new Array(a3).fill(0).map(function(a4, n3) {
              return r6.slice(n3 * e4, n3 * e4 + t5);
            });
          }(t4, e3._m.bufferSize, e3._m.hopSize).forEach(function(r6) {
            e3._m.frame = r6;
            var t5 = e3._m.extract(e3._m._featuresToExtract, e3._m.frame, e3._m.previousFrame);
            typeof e3._m.callback == "function" && e3._m.EXTRACTION_STARTED && e3._m.callback(t5), e3._m.previousFrame = e3._m.frame;
          });
        };
      }
      return r3.prototype.start = function(r4) {
        this._m._featuresToExtract = r4 || this._m._featuresToExtract, this._m.EXTRACTION_STARTED = true;
      }, r3.prototype.stop = function() {
        this._m.EXTRACTION_STARTED = false;
      }, r3.prototype.setSource = function(r4) {
        this._m.source && this._m.source.disconnect(this._m.spn), this._m.source = r4, this._m.source.connect(this._m.spn);
      }, r3.prototype.setChannel = function(r4) {
        r4 <= this._m.inputs ? this._m.channel = r4 : console.error("Channel ".concat(r4, " does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(r4, " when instantiating the MeydaAnalyzer"));
      }, r3.prototype.get = function(r4) {
        return this._m.inputData ? this._m.extract(r4 || this._m._featuresToExtract, this._m.inputData, this._m.previousInputData) : null;
      }, r3;
    }(), C = { audioContext: null, spn: null, bufferSize: 512, sampleRate: 44100, melBands: 26, chromaBands: 12, callback: null, windowingFunction: "hanning", featureExtractors: y2, EXTRACTION_STARTED: false, numberOfMFCCCoefficients: 13, numberOfBarkBands: 24, _featuresToExtract: [], windowing: n2, _errors: { notPow2: new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"), featureUndef: new Error("Meyda: No features defined."), invalidFeatureFmt: new Error("Meyda: Invalid feature format"), invalidInput: new Error("Meyda: Invalid input."), noAC: new Error("Meyda: No AudioContext specified."), noSource: new Error("Meyda: No source node specified.") }, createMeydaAnalyzer: function(r3) {
      return new E(r3, Object.assign({}, C));
    }, listAvailableFeatureExtractors: function() {
      return Object.keys(this.featureExtractors);
    }, extract: function(r3, t3, e3) {
      var n3 = this;
      if (!t3)
        throw this._errors.invalidInput;
      if (typeof t3 != "object")
        throw this._errors.invalidInput;
      if (!r3)
        throw this._errors.featureUndef;
      if (!a2(t3.length))
        throw this._errors.notPow2;
      this.barkScale !== void 0 && this.barkScale.length == this.bufferSize || (this.barkScale = o2(this.bufferSize, this.sampleRate, this.bufferSize)), this.melFilterBank !== void 0 && this.barkScale.length == this.bufferSize && this.melFilterBank.length == this.melBands || (this.melFilterBank = f2(Math.max(this.melBands, this.numberOfMFCCCoefficients), this.sampleRate, this.bufferSize)), this.chromaFilterBank !== void 0 && this.chromaFilterBank.length == this.chromaBands || (this.chromaFilterBank = c2(this.chromaBands, this.sampleRate, this.bufferSize)), "buffer" in t3 && t3.buffer === void 0 ? this.signal = i2(t3) : this.signal = t3;
      var u3 = k2(t3, this.windowingFunction, this.bufferSize);
      if (this.signal = u3.windowedSignal, this.complexSpectrum = u3.complexSpectrum, this.ampSpectrum = u3.ampSpectrum, e3) {
        var l3 = k2(e3, this.windowingFunction, this.bufferSize);
        this.previousSignal = l3.windowedSignal, this.previousComplexSpectrum = l3.complexSpectrum, this.previousAmpSpectrum = l3.ampSpectrum;
      }
      var s3 = function(r4) {
        return n3.featureExtractors[r4]({ ampSpectrum: n3.ampSpectrum, chromaFilterBank: n3.chromaFilterBank, complexSpectrum: n3.complexSpectrum, signal: n3.signal, bufferSize: n3.bufferSize, sampleRate: n3.sampleRate, barkScale: n3.barkScale, melFilterBank: n3.melFilterBank, previousSignal: n3.previousSignal, previousAmpSpectrum: n3.previousAmpSpectrum, previousComplexSpectrum: n3.previousComplexSpectrum, numberOfMFCCCoefficients: n3.numberOfMFCCCoefficients, numberOfBarkBands: n3.numberOfBarkBands });
      };
      if (typeof r3 == "object")
        return r3.reduce(function(r4, t4) {
          var e4;
          return Object.assign({}, r4, ((e4 = {})[t4] = s3(t4), e4));
        }, {});
      if (typeof r3 == "string")
        return s3(r3);
      throw this._errors.invalidFeatureFmt;
    } }, k2 = function(r3, t3, e3) {
      var a3 = {};
      r3.buffer === void 0 ? a3.signal = i2(r3) : a3.signal = r3, a3.windowedSignal = n2(a3.signal, t3), a3.complexSpectrum = A(a3.windowedSignal), a3.ampSpectrum = new Float32Array(e3 / 2);
      for (var o3 = 0; o3 < e3 / 2; o3++)
        a3.ampSpectrum[o3] = Math.sqrt(Math.pow(a3.complexSpectrum.real[o3], 2) + Math.pow(a3.complexSpectrum.imag[o3], 2));
      return a3;
    };
    return typeof window != "undefined" && (window.Meyda = C), C;
  });
})(meyda_min);
var Meyda = getDefaultExportFromCjs(meyda_min.exports);
var noteStrings = [
  "C",
  "C\u266F",
  "D",
  "D\u266F",
  "E",
  "F",
  "F\u266F",
  "G",
  "G\u266F",
  "A",
  "A\u266F",
  "B"
];
var settings = {
  middleA: 440,
  semitone: 69
};
var tuner = reactive({
  initiated: false,
  stream: null,
  middleA: settings.middleA,
  semitone: settings.semitone,
  note: {
    name: "A",
    value: 69,
    cents: 0,
    octave: 4,
    frequency: 440,
    color: freqColor(440),
    silent: false
  },
  span: 64,
  bufferSize: 4096,
  tempoBufferSize: 512,
  frequencyData: null,
  running: false,
  frame: 0,
  beat: 0,
  bpm: 0,
  confidence: 0,
  listenBeat: false,
  prevBeat: 0,
  blink: false,
  chroma: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  spec: [],
  rms: 0
});
var chain = {};
function useTuner() {
  initGetUserMedia();
  return {
    init,
    tuner,
    chain
  };
}
function init() {
  tuner.initiated = true;
  chain.audioContext = new window.AudioContext();
  chain.analyser = chain.audioContext.createAnalyser();
  chain.scriptProcessor = chain.audioContext.createScriptProcessor(tuner.bufferSize, 1, 1);
  chain.beatProcessor = chain.audioContext.createScriptProcessor(tuner.tempoBufferSize, 1, 1);
  watch(() => tuner.frame, () => {
    if (!tuner.listen)
      return;
    if (tuner.beat > tuner.prevBeat) {
      tuner.prevBeat = tuner.beat;
      tuner.blink = true;
      setTimeout(() => {
        tuner.blink = false;
      }, 60);
    }
  });
  chain.meyda = Meyda.createMeydaAnalyzer({
    audioContext: chain.audioContext,
    source: chain.analyser,
    bufferSize: 4096,
    featureExtractors: ["chroma", "amplitudeSpectrum", "rms"],
    callback: (features) => {
      tuner.rms = features.rms;
      tuner.chroma = features.chroma;
      tuner.spec = features.amplitudeSpectrum;
    }
  });
  chain.meyda.start();
  tuner.frequencyData = new Uint8Array(chain.analyser.frequencyBinCount);
  Aubio$1().then(function(aubio) {
    chain.pitchDetector = new aubio.Pitch("default", tuner.bufferSize, 1, chain.audioContext.sampleRate);
    chain.tempoAnalyzer = new aubio.Tempo(tuner.tempoBufferSize * 4, tuner.tempoBufferSize, chain.audioContext.sampleRate);
    tuner.running = true;
    start2();
  });
}
function start2() {
  navigator.mediaDevices.getUserMedia({ audio: true }).then(function(stream) {
    tuner.stream = stream;
    chain.audioContext.createMediaStreamSource(stream).connect(chain.analyser);
    chain.analyser.connect(chain.scriptProcessor);
    chain.analyser.connect(chain.beatProcessor);
    chain.scriptProcessor.connect(chain.audioContext.destination);
    chain.beatProcessor.connect(chain.audioContext.destination);
    chain.beatProcessor.addEventListener("audioprocess", (e2) => {
      const tempo2 = chain.tempoAnalyzer.do(e2.inputBuffer.getChannelData(0));
      if (tempo2) {
        tuner.beat++;
        tuner.confidence = chain.tempoAnalyzer.getConfidence();
        tuner.bpm = chain.tempoAnalyzer.getBpm();
      }
    });
    chain.scriptProcessor.addEventListener("audioprocess", function(event) {
      const frequency = chain.pitchDetector.do(event.inputBuffer.getChannelData(0));
      tuner.frame++;
      if (frequency) {
        const note2 = getNote(frequency);
        tuner.note = {
          name: noteStrings[note2 % 12],
          value: note2,
          cents: getCents(frequency, note2),
          octave: parseInt(note2 / 12) - 1,
          frequency,
          color: freqColor(frequency),
          silent: false
        };
      } else {
        tuner.note.silent = true;
      }
    });
  }).catch(function(error) {
    console.log(error.name + ": " + error.message);
  });
}
function getNote(frequency) {
  const note2 = 12 * (Math.log(frequency / tuner.middleA) / Math.log(2));
  return Math.round(note2) + tuner.semitone;
}
function getStandardFrequency(note2) {
  return tuner.middleA * Math.pow(2, (note2 - tuner.semitone) / 12);
}
function getCents(frequency, note2) {
  return Math.floor(1200 * Math.log(frequency / getStandardFrequency(note2)) / Math.log(2));
}
function freqColor(frequency) {
  const note2 = getRawNote(frequency);
  if (!note2)
    return "#333";
  const octave2 = parseInt(note2 / 12) + 2;
  const color = pitchColor(note2, octave2);
  return color;
}
function getRawNote(frequency) {
  return 12 * (Math.log(frequency / settings.middleA) / Math.log(2)) % 12;
}

export {
  currentCamera,
  currentMic,
  showRecordingDialog,
  recordingName,
  recordCamera,
  mimeType,
  mimeExtMap,
  getFilename,
  getSupportedMimeTypes,
  fileNames,
  devices,
  cameras,
  microphones,
  ensureDevicesListPermissions,
  download,
  useRecording,
  cast,
  recorder,
  recording,
  record,
  useRecorder,
  master,
  channels,
  useAudio,
  createChannel$1,
  initGetUserMedia,
  midiA,
  pitchNoteOctave,
  pitchFreq,
  pitchColor,
  freqColor$1,
  freqPitch,
  isInChroma,
  getCircleCoord,
  rotateArray,
  clampNum,
  getCents$1,
  getStandardFrequency$1,
  setupKeyboard,
  midi$1,
  learnCC,
  playKey,
  useMidi,
  midiAttack,
  midiPlay,
  midiStop,
  midiRelease,
  midiOnce$1,
  setCC,
  stopAll,
  forwardMidi,
  quantizeModes,
  synth,
  useSynth,
  synthOnce,
  synthAttack,
  synthRelease,
  synthReleaseAll,
  chordType,
  scaleType,
  chordList,
  scaleList,
  intervals,
  noteNames,
  notes,
  chords,
  scales,
  globalScale,
  playChromaOnce,
  playChroma,
  stopChroma,
  playNote,
  stopNote,
  lchToHsl,
  getColorInfo,
  levelColor,
  chromaColorMix,
  tempo,
  useTempo,
  tap,
  commonjsGlobal,
  createAndDownloadBlobFile,
  useLoop,
  mic,
  useMic,
  useSvgMouse,
  useNoise,
  usePiano,
  pianoOnce,
  pianoAttack,
  pianoRelease,
  pianoReleaseAll,
  tracks,
  useSequence,
  getEuclideanRhythm,
  tuner,
  useTuner
};
/**
 * The `Enumerations` class contains enumerations and arrays of elements used throughout the
 * library. All properties are static and should be referenced using the class name. For example:
 * `Enumerations.MIDI_CHANNEL_MESSAGES`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `Forwarder` class allows the forwarding of MIDI messages to predetermined outputs. When you
 * call its [`forward()`](#forward) method, it will send the specified [`Message`](Message) object
 * to all the outputs listed in its [`destinations`](#destinations) property.
 *
 * If specific channels or message types have been defined in the [`channels`](#channels) or
 * [`types`](#types) properties, only messages matching the channels/types will be forwarded.
 *
 * While it can be manually instantiated, you are more likely to come across a `Forwarder` object as
 * the return value of the [`Input.addForwarder()`](Input#addForwarder) method.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `InputChannel` class represents a single MIDI input channel (1-16) from a single input
 * device. This object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `InputChannel` objects can be found inside the input's [`channels`](Input#channels)
 * property.
 *
 * @fires InputChannel#midimessage
 * @fires InputChannel#unknownmessage
 *
 * @fires InputChannel#noteoff
 * @fires InputChannel#noteon
 * @fires InputChannel#keyaftertouch
 * @fires InputChannel#programchange
 * @fires InputChannel#event:controlchange-controllerxxx
 * @fires InputChannel#channelaftertouch
 * @fires InputChannel#pitchbend
 * @fires InputChannel#controlchange
 *
 * @fires InputChannel#allnotesoff
 * @fires InputChannel#allsoundoff
 * @fires InputChannel#localcontrol
 * @fires InputChannel#monomode
 * @fires InputChannel#omnimode
 * @fires InputChannel#resetallcontrollers
 *
 * @fires InputChannel#event:nrpn
 * @fires InputChannel#event:nrpn-dataentrycoarse
 * @fires InputChannel#event:nrpn-dataentryfine
 * @fires InputChannel#event:nrpn-databuttonincrement
 * @fires InputChannel#event:nrpn-databuttondecrement
 * @fires InputChannel#event:rpn
 * @fires InputChannel#event:rpn-dataentrycoarse
 * @fires InputChannel#event:rpn-dataentryfine
 * @fires InputChannel#event:rpn-databuttonincrement
 * @fires InputChannel#event:rpn-databuttondecrement
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `Input` class represents a single MIDI input port. This object is automatically instantiated
 * by the library according to the host's MIDI subsystem and does not need to be directly
 * instantiated. Instead, you can access all `Input` objects by referring to the
 * [`WebMidi.inputs`](WebMidi#inputs) array. You can also retrieve inputs by using methods such as
 * [`WebMidi.getInputByName()`](WebMidi#getInputByName) and
 * [`WebMidi.getInputById()`](WebMidi#getInputById).
 *
 * Note that a single MIDI device may expose several inputs and/or outputs.
 *
 * **Important**: the `Input` class does not directly fire channel-specific MIDI messages
 * (such as [`noteon`](InputChannel#event:noteon) or
 * [`controlchange`](InputChannel#event:controlchange), etc.). The [`InputChannel`](InputChannel)
 * object does that. However, you can still use the
 * [`Input.addListener()`](#addListener) method to listen to channel-specific events on multiple
 * [`InputChannel`](InputChannel) objects at once.
 *
 * @fires Input#opened
 * @fires Input#disconnected
 * @fires Input#closed
 * @fires Input#midimessage
 *
 * @fires Input#sysex
 * @fires Input#timecode
 * @fires Input#songposition
 * @fires Input#songselect
 * @fires Input#tunerequest
 * @fires Input#clock
 * @fires Input#start
 * @fires Input#continue
 * @fires Input#stop
 * @fires Input#activesensing
 * @fires Input#reset
 *
 * @fires Input#unknownmidimessage
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
/**
 * The `Message` class represents a single MIDI message. It has several properties that make it
 * easy to make sense of the binary data it contains.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `Note` class represents a single musical note such as `"D3"`, `"G#4"`, `"F-1"`, `"Gb7"`, etc.
 *
 * `Note` objects can be played back on a single channel by calling
 * [`OutputChannel.playNote()`]{@link OutputChannel#playNote} or, on multiple channels of the same
 * output, by calling [`Output.playNote()`]{@link Output#playNote}.
 *
 * The note has [`attack`](#attack) and [`release`](#release) velocities set at `0.5` by default.
 * These can be changed by passing in the appropriate option. It is also possible to set a
 * system-wide default for attack and release velocities by using the
 * [`WebMidi.defaults`](WebMidi#defaults) property.
 *
 * If you prefer to work with raw MIDI values (`0` to `127`), you can use [`rawAttack`](#rawAttack) and
 * [`rawRelease`](#rawRelease) to both get and set the values.
 *
 * The note may have a [`duration`](#duration). If it does, playback will be automatically stopped
 * when the duration has elapsed by sending a `"noteoff"` event. By default, the duration is set to
 * `Infinity`. In this case, it will never stop playing unless explicitly stopped by calling a
 * method such as [`OutputChannel.stopNote()`]{@link OutputChannel#stopNote},
 * [`Output.stopNote()`]{@link Output#stopNote} or similar.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `OutputChannel` class represents a single output MIDI channel. `OutputChannel` objects are
 * provided by an [`Output`](Output) port which, itself, is made available by a device. The
 * `OutputChannel` object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `OutputChannel` objects can be found inside the parent output's
 * [`channels`]{@link Output#channels} property.
 *
 * @param {Output} output The [`Output`](Output) this channel belongs to.
 * @param {number} number The MIDI channel number (`1` - `16`).
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `Output` class represents a single MIDI output port (not to be confused with a MIDI channel).
 * A port is made available by a MIDI device. A MIDI device can advertise several input and output
 * ports. Each port has 16 MIDI channels which can be accessed via the [`channels`](#channels)
 * property.
 *
 * The `Output` object is automatically instantiated by the library according to the host's MIDI
 * subsystem and should not be directly instantiated.
 *
 * You can access all available `Output` objects by referring to the
 * [`WebMidi.outputs`](WebMidi#outputs) array or by using methods such as
 * [`WebMidi.getOutputByName()`](WebMidi#getOutputByName) or
 * [`WebMidi.getOutputById()`](WebMidi#getOutputById).
 *
 * @fires Output#opened
 * @fires Output#disconnected
 * @fires Output#closed
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
/**
 * The `Utilities` class contains general-purpose utility methods. All methods are static and
 * should be called using the class name. For example: `Utilities.getNoteDetails("C4")`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
/**
 * The `WebMidi` object makes it easier to work with the low-level Web MIDI API. Basically, it
 * simplifies sending outgoing MIDI messages and reacting to incoming MIDI messages.
 *
 * When using the WebMidi.js library, you should know that the `WebMidi` class has already been
 * instantiated. You cannot instantiate it yourself. If you use the **IIFE** version, you should
 * simply use the global object called `WebMidi`. If you use the **CJS** (CommonJS) or **ESM** (ES6
 * module) version, you get an already-instantiated object when you import the module.
 *
 * @fires WebMidi#connected
 * @fires WebMidi#disabled
 * @fires WebMidi#disconnected
 * @fires WebMidi#enabled
 * @fires WebMidi#error
 * @fires WebMidi#midiaccessgranted
 * @fires WebMidi#portschanged
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */
//# sourceMappingURL=chunk-O4E3YSSV.js.map
